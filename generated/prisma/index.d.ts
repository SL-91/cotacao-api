
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SequelizeMeta
 * 
 */
export type SequelizeMeta = $Result.DefaultSelection<Prisma.$SequelizeMetaPayload>
/**
 * Model accommodation_quotations
 * 
 */
export type accommodation_quotations = $Result.DefaultSelection<Prisma.$accommodation_quotationsPayload>
/**
 * Model attendant
 * 
 */
export type attendant = $Result.DefaultSelection<Prisma.$attendantPayload>
/**
 * Model attendant_calls
 * 
 */
export type attendant_calls = $Result.DefaultSelection<Prisma.$attendant_callsPayload>
/**
 * Model attendants
 * 
 */
export type attendants = $Result.DefaultSelection<Prisma.$attendantsPayload>
/**
 * Model budget_consults_aut
 * 
 */
export type budget_consults_aut = $Result.DefaultSelection<Prisma.$budget_consults_autPayload>
/**
 * Model budget_consults_clt
 * 
 */
export type budget_consults_clt = $Result.DefaultSelection<Prisma.$budget_consults_cltPayload>
/**
 * Model budget_consults_goi
 * 
 */
export type budget_consults_goi = $Result.DefaultSelection<Prisma.$budget_consults_goiPayload>
/**
 * Model budget_consults_spa
 * 
 */
export type budget_consults_spa = $Result.DefaultSelection<Prisma.$budget_consults_spaPayload>
/**
 * Model calls
 * 
 */
export type calls = $Result.DefaultSelection<Prisma.$callsPayload>
/**
 * Model cities_quotations
 * 
 */
export type cities_quotations = $Result.DefaultSelection<Prisma.$cities_quotationsPayload>
/**
 * Model configs_bot_aut
 * 
 */
export type configs_bot_aut = $Result.DefaultSelection<Prisma.$configs_bot_autPayload>
/**
 * Model configs_bot_clt
 * 
 */
export type configs_bot_clt = $Result.DefaultSelection<Prisma.$configs_bot_cltPayload>
/**
 * Model configs_bot_goi
 * 
 */
export type configs_bot_goi = $Result.DefaultSelection<Prisma.$configs_bot_goiPayload>
/**
 * Model configs_bot_spa
 * 
 */
export type configs_bot_spa = $Result.DefaultSelection<Prisma.$configs_bot_spaPayload>
/**
 * Model coparticipation_type_quotations
 * 
 */
export type coparticipation_type_quotations = $Result.DefaultSelection<Prisma.$coparticipation_type_quotationsPayload>
/**
 * Model cpf_consults_aut
 * 
 */
export type cpf_consults_aut = $Result.DefaultSelection<Prisma.$cpf_consults_autPayload>
/**
 * Model cpf_consults_clt
 * 
 */
export type cpf_consults_clt = $Result.DefaultSelection<Prisma.$cpf_consults_cltPayload>
/**
 * Model cpf_consults_goi
 * 
 */
export type cpf_consults_goi = $Result.DefaultSelection<Prisma.$cpf_consults_goiPayload>
/**
 * Model cpf_consults_spa
 * 
 */
export type cpf_consults_spa = $Result.DefaultSelection<Prisma.$cpf_consults_spaPayload>
/**
 * Model files
 * 
 */
export type files = $Result.DefaultSelection<Prisma.$filesPayload>
/**
 * Model maintenance_commands
 * 
 */
export type maintenance_commands = $Result.DefaultSelection<Prisma.$maintenance_commandsPayload>
/**
 * Model messages_log
 * 
 */
export type messages_log = $Result.DefaultSelection<Prisma.$messages_logPayload>
/**
 * Model modality_assistance_quotations
 * 
 */
export type modality_assistance_quotations = $Result.DefaultSelection<Prisma.$modality_assistance_quotationsPayload>
/**
 * Model plan_group_quotations
 * 
 */
export type plan_group_quotations = $Result.DefaultSelection<Prisma.$plan_group_quotationsPayload>
/**
 * Model plan_type_quotations
 * 
 */
export type plan_type_quotations = $Result.DefaultSelection<Prisma.$plan_type_quotationsPayload>
/**
 * Model problems_clt
 * 
 */
export type problems_clt = $Result.DefaultSelection<Prisma.$problems_cltPayload>
/**
 * Model Quotation
 * 
 */
export type Quotation = $Result.DefaultSelection<Prisma.$QuotationPayload>
/**
 * Model quote_calculations_aut
 * 
 */
export type quote_calculations_aut = $Result.DefaultSelection<Prisma.$quote_calculations_autPayload>
/**
 * Model quote_calculations_clt
 * 
 */
export type quote_calculations_clt = $Result.DefaultSelection<Prisma.$quote_calculations_cltPayload>
/**
 * Model quote_calculations_goi
 * 
 */
export type quote_calculations_goi = $Result.DefaultSelection<Prisma.$quote_calculations_goiPayload>
/**
 * Model quote_calculations_spa
 * 
 */
export type quote_calculations_spa = $Result.DefaultSelection<Prisma.$quote_calculations_spaPayload>
/**
 * Model register_partners_aut
 * 
 */
export type register_partners_aut = $Result.DefaultSelection<Prisma.$register_partners_autPayload>
/**
 * Model register_partners_spa
 * 
 */
export type register_partners_spa = $Result.DefaultSelection<Prisma.$register_partners_spaPayload>
/**
 * Model rh_calls
 * 
 */
export type rh_calls = $Result.DefaultSelection<Prisma.$rh_callsPayload>
/**
 * Model rh_numbers
 * 
 */
export type rh_numbers = $Result.DefaultSelection<Prisma.$rh_numbersPayload>
/**
 * Model seller_codes
 * 
 */
export type seller_codes = $Result.DefaultSelection<Prisma.$seller_codesPayload>
/**
 * Model sessions_aut
 * 
 */
export type sessions_aut = $Result.DefaultSelection<Prisma.$sessions_autPayload>
/**
 * Model sessions_clt
 * 
 */
export type sessions_clt = $Result.DefaultSelection<Prisma.$sessions_cltPayload>
/**
 * Model sessions_goi
 * 
 */
export type sessions_goi = $Result.DefaultSelection<Prisma.$sessions_goiPayload>
/**
 * Model sessions_spa
 * 
 */
export type sessions_spa = $Result.DefaultSelection<Prisma.$sessions_spaPayload>
/**
 * Model supervisor_register_partners
 * 
 */
export type supervisor_register_partners = $Result.DefaultSelection<Prisma.$supervisor_register_partnersPayload>
/**
 * Model testers_aut
 * 
 */
export type testers_aut = $Result.DefaultSelection<Prisma.$testers_autPayload>
/**
 * Model testers_clt
 * 
 */
export type testers_clt = $Result.DefaultSelection<Prisma.$testers_cltPayload>
/**
 * Model testers_goi
 * 
 */
export type testers_goi = $Result.DefaultSelection<Prisma.$testers_goiPayload>
/**
 * Model testers_spa
 * 
 */
export type testers_spa = $Result.DefaultSelection<Prisma.$testers_spaPayload>
/**
 * Model threads_aut
 * 
 */
export type threads_aut = $Result.DefaultSelection<Prisma.$threads_autPayload>
/**
 * Model threads_clt
 * 
 */
export type threads_clt = $Result.DefaultSelection<Prisma.$threads_cltPayload>
/**
 * Model threads_goi
 * 
 */
export type threads_goi = $Result.DefaultSelection<Prisma.$threads_goiPayload>
/**
 * Model threads_spa
 * 
 */
export type threads_spa = $Result.DefaultSelection<Prisma.$threads_spaPayload>
/**
 * Model tokens_generated_aut
 * 
 */
export type tokens_generated_aut = $Result.DefaultSelection<Prisma.$tokens_generated_autPayload>
/**
 * Model tokens_generated_clt
 * 
 */
export type tokens_generated_clt = $Result.DefaultSelection<Prisma.$tokens_generated_cltPayload>
/**
 * Model tokens_generated_goi
 * 
 */
export type tokens_generated_goi = $Result.DefaultSelection<Prisma.$tokens_generated_goiPayload>
/**
 * Model tokens_generated_spa
 * 
 */
export type tokens_generated_spa = $Result.DefaultSelection<Prisma.$tokens_generated_spaPayload>
/**
 * Model trainings_links_aut
 * 
 */
export type trainings_links_aut = $Result.DefaultSelection<Prisma.$trainings_links_autPayload>
/**
 * Model trainings_links_clt
 * 
 */
export type trainings_links_clt = $Result.DefaultSelection<Prisma.$trainings_links_cltPayload>
/**
 * Model trainings_links_goi
 * 
 */
export type trainings_links_goi = $Result.DefaultSelection<Prisma.$trainings_links_goiPayload>
/**
 * Model trainings_links_spa
 * 
 */
export type trainings_links_spa = $Result.DefaultSelection<Prisma.$trainings_links_spaPayload>
/**
 * Model users_aut
 * 
 */
export type users_aut = $Result.DefaultSelection<Prisma.$users_autPayload>
/**
 * Model users_clt
 * 
 */
export type users_clt = $Result.DefaultSelection<Prisma.$users_cltPayload>
/**
 * Model users_goi
 * 
 */
export type users_goi = $Result.DefaultSelection<Prisma.$users_goiPayload>
/**
 * Model users_spa
 * 
 */
export type users_spa = $Result.DefaultSelection<Prisma.$users_spaPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SequelizeMetas
 * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SequelizeMetas
   * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.sequelizeMeta`: Exposes CRUD operations for the **SequelizeMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SequelizeMetas
    * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
    * ```
    */
  get sequelizeMeta(): Prisma.SequelizeMetaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accommodation_quotations`: Exposes CRUD operations for the **accommodation_quotations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accommodation_quotations
    * const accommodation_quotations = await prisma.accommodation_quotations.findMany()
    * ```
    */
  get accommodation_quotations(): Prisma.accommodation_quotationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendant`: Exposes CRUD operations for the **attendant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendants
    * const attendants = await prisma.attendant.findMany()
    * ```
    */
  get attendant(): Prisma.attendantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendant_calls`: Exposes CRUD operations for the **attendant_calls** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendant_calls
    * const attendant_calls = await prisma.attendant_calls.findMany()
    * ```
    */
  get attendant_calls(): Prisma.attendant_callsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendants`: Exposes CRUD operations for the **attendants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendants
    * const attendants = await prisma.attendants.findMany()
    * ```
    */
  get attendants(): Prisma.attendantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget_consults_aut`: Exposes CRUD operations for the **budget_consults_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budget_consults_auts
    * const budget_consults_auts = await prisma.budget_consults_aut.findMany()
    * ```
    */
  get budget_consults_aut(): Prisma.budget_consults_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget_consults_clt`: Exposes CRUD operations for the **budget_consults_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budget_consults_clts
    * const budget_consults_clts = await prisma.budget_consults_clt.findMany()
    * ```
    */
  get budget_consults_clt(): Prisma.budget_consults_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget_consults_goi`: Exposes CRUD operations for the **budget_consults_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budget_consults_gois
    * const budget_consults_gois = await prisma.budget_consults_goi.findMany()
    * ```
    */
  get budget_consults_goi(): Prisma.budget_consults_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget_consults_spa`: Exposes CRUD operations for the **budget_consults_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budget_consults_spas
    * const budget_consults_spas = await prisma.budget_consults_spa.findMany()
    * ```
    */
  get budget_consults_spa(): Prisma.budget_consults_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calls`: Exposes CRUD operations for the **calls** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calls
    * const calls = await prisma.calls.findMany()
    * ```
    */
  get calls(): Prisma.callsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cities_quotations`: Exposes CRUD operations for the **cities_quotations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities_quotations
    * const cities_quotations = await prisma.cities_quotations.findMany()
    * ```
    */
  get cities_quotations(): Prisma.cities_quotationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configs_bot_aut`: Exposes CRUD operations for the **configs_bot_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs_bot_auts
    * const configs_bot_auts = await prisma.configs_bot_aut.findMany()
    * ```
    */
  get configs_bot_aut(): Prisma.configs_bot_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configs_bot_clt`: Exposes CRUD operations for the **configs_bot_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs_bot_clts
    * const configs_bot_clts = await prisma.configs_bot_clt.findMany()
    * ```
    */
  get configs_bot_clt(): Prisma.configs_bot_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configs_bot_goi`: Exposes CRUD operations for the **configs_bot_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs_bot_gois
    * const configs_bot_gois = await prisma.configs_bot_goi.findMany()
    * ```
    */
  get configs_bot_goi(): Prisma.configs_bot_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configs_bot_spa`: Exposes CRUD operations for the **configs_bot_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs_bot_spas
    * const configs_bot_spas = await prisma.configs_bot_spa.findMany()
    * ```
    */
  get configs_bot_spa(): Prisma.configs_bot_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coparticipation_type_quotations`: Exposes CRUD operations for the **coparticipation_type_quotations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coparticipation_type_quotations
    * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.findMany()
    * ```
    */
  get coparticipation_type_quotations(): Prisma.coparticipation_type_quotationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cpf_consults_aut`: Exposes CRUD operations for the **cpf_consults_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cpf_consults_auts
    * const cpf_consults_auts = await prisma.cpf_consults_aut.findMany()
    * ```
    */
  get cpf_consults_aut(): Prisma.cpf_consults_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cpf_consults_clt`: Exposes CRUD operations for the **cpf_consults_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cpf_consults_clts
    * const cpf_consults_clts = await prisma.cpf_consults_clt.findMany()
    * ```
    */
  get cpf_consults_clt(): Prisma.cpf_consults_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cpf_consults_goi`: Exposes CRUD operations for the **cpf_consults_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cpf_consults_gois
    * const cpf_consults_gois = await prisma.cpf_consults_goi.findMany()
    * ```
    */
  get cpf_consults_goi(): Prisma.cpf_consults_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cpf_consults_spa`: Exposes CRUD operations for the **cpf_consults_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cpf_consults_spas
    * const cpf_consults_spas = await prisma.cpf_consults_spa.findMany()
    * ```
    */
  get cpf_consults_spa(): Prisma.cpf_consults_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.files`: Exposes CRUD operations for the **files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.files.findMany()
    * ```
    */
  get files(): Prisma.filesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenance_commands`: Exposes CRUD operations for the **maintenance_commands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenance_commands
    * const maintenance_commands = await prisma.maintenance_commands.findMany()
    * ```
    */
  get maintenance_commands(): Prisma.maintenance_commandsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages_log`: Exposes CRUD operations for the **messages_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages_logs
    * const messages_logs = await prisma.messages_log.findMany()
    * ```
    */
  get messages_log(): Prisma.messages_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modality_assistance_quotations`: Exposes CRUD operations for the **modality_assistance_quotations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modality_assistance_quotations
    * const modality_assistance_quotations = await prisma.modality_assistance_quotations.findMany()
    * ```
    */
  get modality_assistance_quotations(): Prisma.modality_assistance_quotationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan_group_quotations`: Exposes CRUD operations for the **plan_group_quotations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_group_quotations
    * const plan_group_quotations = await prisma.plan_group_quotations.findMany()
    * ```
    */
  get plan_group_quotations(): Prisma.plan_group_quotationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan_type_quotations`: Exposes CRUD operations for the **plan_type_quotations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_type_quotations
    * const plan_type_quotations = await prisma.plan_type_quotations.findMany()
    * ```
    */
  get plan_type_quotations(): Prisma.plan_type_quotationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.problems_clt`: Exposes CRUD operations for the **problems_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problems_clts
    * const problems_clts = await prisma.problems_clt.findMany()
    * ```
    */
  get problems_clt(): Prisma.problems_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotation`: Exposes CRUD operations for the **Quotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotations
    * const quotations = await prisma.quotation.findMany()
    * ```
    */
  get quotation(): Prisma.QuotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote_calculations_aut`: Exposes CRUD operations for the **quote_calculations_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quote_calculations_auts
    * const quote_calculations_auts = await prisma.quote_calculations_aut.findMany()
    * ```
    */
  get quote_calculations_aut(): Prisma.quote_calculations_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote_calculations_clt`: Exposes CRUD operations for the **quote_calculations_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quote_calculations_clts
    * const quote_calculations_clts = await prisma.quote_calculations_clt.findMany()
    * ```
    */
  get quote_calculations_clt(): Prisma.quote_calculations_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote_calculations_goi`: Exposes CRUD operations for the **quote_calculations_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quote_calculations_gois
    * const quote_calculations_gois = await prisma.quote_calculations_goi.findMany()
    * ```
    */
  get quote_calculations_goi(): Prisma.quote_calculations_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote_calculations_spa`: Exposes CRUD operations for the **quote_calculations_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quote_calculations_spas
    * const quote_calculations_spas = await prisma.quote_calculations_spa.findMany()
    * ```
    */
  get quote_calculations_spa(): Prisma.quote_calculations_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.register_partners_aut`: Exposes CRUD operations for the **register_partners_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Register_partners_auts
    * const register_partners_auts = await prisma.register_partners_aut.findMany()
    * ```
    */
  get register_partners_aut(): Prisma.register_partners_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.register_partners_spa`: Exposes CRUD operations for the **register_partners_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Register_partners_spas
    * const register_partners_spas = await prisma.register_partners_spa.findMany()
    * ```
    */
  get register_partners_spa(): Prisma.register_partners_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rh_calls`: Exposes CRUD operations for the **rh_calls** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rh_calls
    * const rh_calls = await prisma.rh_calls.findMany()
    * ```
    */
  get rh_calls(): Prisma.rh_callsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rh_numbers`: Exposes CRUD operations for the **rh_numbers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rh_numbers
    * const rh_numbers = await prisma.rh_numbers.findMany()
    * ```
    */
  get rh_numbers(): Prisma.rh_numbersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seller_codes`: Exposes CRUD operations for the **seller_codes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seller_codes
    * const seller_codes = await prisma.seller_codes.findMany()
    * ```
    */
  get seller_codes(): Prisma.seller_codesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions_aut`: Exposes CRUD operations for the **sessions_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions_auts
    * const sessions_auts = await prisma.sessions_aut.findMany()
    * ```
    */
  get sessions_aut(): Prisma.sessions_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions_clt`: Exposes CRUD operations for the **sessions_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions_clts
    * const sessions_clts = await prisma.sessions_clt.findMany()
    * ```
    */
  get sessions_clt(): Prisma.sessions_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions_goi`: Exposes CRUD operations for the **sessions_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions_gois
    * const sessions_gois = await prisma.sessions_goi.findMany()
    * ```
    */
  get sessions_goi(): Prisma.sessions_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions_spa`: Exposes CRUD operations for the **sessions_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions_spas
    * const sessions_spas = await prisma.sessions_spa.findMany()
    * ```
    */
  get sessions_spa(): Prisma.sessions_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supervisor_register_partners`: Exposes CRUD operations for the **supervisor_register_partners** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supervisor_register_partners
    * const supervisor_register_partners = await prisma.supervisor_register_partners.findMany()
    * ```
    */
  get supervisor_register_partners(): Prisma.supervisor_register_partnersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testers_aut`: Exposes CRUD operations for the **testers_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testers_auts
    * const testers_auts = await prisma.testers_aut.findMany()
    * ```
    */
  get testers_aut(): Prisma.testers_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testers_clt`: Exposes CRUD operations for the **testers_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testers_clts
    * const testers_clts = await prisma.testers_clt.findMany()
    * ```
    */
  get testers_clt(): Prisma.testers_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testers_goi`: Exposes CRUD operations for the **testers_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testers_gois
    * const testers_gois = await prisma.testers_goi.findMany()
    * ```
    */
  get testers_goi(): Prisma.testers_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testers_spa`: Exposes CRUD operations for the **testers_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testers_spas
    * const testers_spas = await prisma.testers_spa.findMany()
    * ```
    */
  get testers_spa(): Prisma.testers_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threads_aut`: Exposes CRUD operations for the **threads_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads_auts
    * const threads_auts = await prisma.threads_aut.findMany()
    * ```
    */
  get threads_aut(): Prisma.threads_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threads_clt`: Exposes CRUD operations for the **threads_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads_clts
    * const threads_clts = await prisma.threads_clt.findMany()
    * ```
    */
  get threads_clt(): Prisma.threads_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threads_goi`: Exposes CRUD operations for the **threads_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads_gois
    * const threads_gois = await prisma.threads_goi.findMany()
    * ```
    */
  get threads_goi(): Prisma.threads_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threads_spa`: Exposes CRUD operations for the **threads_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads_spas
    * const threads_spas = await prisma.threads_spa.findMany()
    * ```
    */
  get threads_spa(): Prisma.threads_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokens_generated_aut`: Exposes CRUD operations for the **tokens_generated_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens_generated_auts
    * const tokens_generated_auts = await prisma.tokens_generated_aut.findMany()
    * ```
    */
  get tokens_generated_aut(): Prisma.tokens_generated_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokens_generated_clt`: Exposes CRUD operations for the **tokens_generated_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens_generated_clts
    * const tokens_generated_clts = await prisma.tokens_generated_clt.findMany()
    * ```
    */
  get tokens_generated_clt(): Prisma.tokens_generated_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokens_generated_goi`: Exposes CRUD operations for the **tokens_generated_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens_generated_gois
    * const tokens_generated_gois = await prisma.tokens_generated_goi.findMany()
    * ```
    */
  get tokens_generated_goi(): Prisma.tokens_generated_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokens_generated_spa`: Exposes CRUD operations for the **tokens_generated_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens_generated_spas
    * const tokens_generated_spas = await prisma.tokens_generated_spa.findMany()
    * ```
    */
  get tokens_generated_spa(): Prisma.tokens_generated_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainings_links_aut`: Exposes CRUD operations for the **trainings_links_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings_links_auts
    * const trainings_links_auts = await prisma.trainings_links_aut.findMany()
    * ```
    */
  get trainings_links_aut(): Prisma.trainings_links_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainings_links_clt`: Exposes CRUD operations for the **trainings_links_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings_links_clts
    * const trainings_links_clts = await prisma.trainings_links_clt.findMany()
    * ```
    */
  get trainings_links_clt(): Prisma.trainings_links_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainings_links_goi`: Exposes CRUD operations for the **trainings_links_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings_links_gois
    * const trainings_links_gois = await prisma.trainings_links_goi.findMany()
    * ```
    */
  get trainings_links_goi(): Prisma.trainings_links_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainings_links_spa`: Exposes CRUD operations for the **trainings_links_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings_links_spas
    * const trainings_links_spas = await prisma.trainings_links_spa.findMany()
    * ```
    */
  get trainings_links_spa(): Prisma.trainings_links_spaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users_aut`: Exposes CRUD operations for the **users_aut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_auts
    * const users_auts = await prisma.users_aut.findMany()
    * ```
    */
  get users_aut(): Prisma.users_autDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users_clt`: Exposes CRUD operations for the **users_clt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_clts
    * const users_clts = await prisma.users_clt.findMany()
    * ```
    */
  get users_clt(): Prisma.users_cltDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users_goi`: Exposes CRUD operations for the **users_goi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_gois
    * const users_gois = await prisma.users_goi.findMany()
    * ```
    */
  get users_goi(): Prisma.users_goiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users_spa`: Exposes CRUD operations for the **users_spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_spas
    * const users_spas = await prisma.users_spa.findMany()
    * ```
    */
  get users_spa(): Prisma.users_spaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SequelizeMeta: 'SequelizeMeta',
    accommodation_quotations: 'accommodation_quotations',
    attendant: 'attendant',
    attendant_calls: 'attendant_calls',
    attendants: 'attendants',
    budget_consults_aut: 'budget_consults_aut',
    budget_consults_clt: 'budget_consults_clt',
    budget_consults_goi: 'budget_consults_goi',
    budget_consults_spa: 'budget_consults_spa',
    calls: 'calls',
    cities_quotations: 'cities_quotations',
    configs_bot_aut: 'configs_bot_aut',
    configs_bot_clt: 'configs_bot_clt',
    configs_bot_goi: 'configs_bot_goi',
    configs_bot_spa: 'configs_bot_spa',
    coparticipation_type_quotations: 'coparticipation_type_quotations',
    cpf_consults_aut: 'cpf_consults_aut',
    cpf_consults_clt: 'cpf_consults_clt',
    cpf_consults_goi: 'cpf_consults_goi',
    cpf_consults_spa: 'cpf_consults_spa',
    files: 'files',
    maintenance_commands: 'maintenance_commands',
    messages_log: 'messages_log',
    modality_assistance_quotations: 'modality_assistance_quotations',
    plan_group_quotations: 'plan_group_quotations',
    plan_type_quotations: 'plan_type_quotations',
    problems_clt: 'problems_clt',
    Quotation: 'Quotation',
    quote_calculations_aut: 'quote_calculations_aut',
    quote_calculations_clt: 'quote_calculations_clt',
    quote_calculations_goi: 'quote_calculations_goi',
    quote_calculations_spa: 'quote_calculations_spa',
    register_partners_aut: 'register_partners_aut',
    register_partners_spa: 'register_partners_spa',
    rh_calls: 'rh_calls',
    rh_numbers: 'rh_numbers',
    seller_codes: 'seller_codes',
    sessions_aut: 'sessions_aut',
    sessions_clt: 'sessions_clt',
    sessions_goi: 'sessions_goi',
    sessions_spa: 'sessions_spa',
    supervisor_register_partners: 'supervisor_register_partners',
    testers_aut: 'testers_aut',
    testers_clt: 'testers_clt',
    testers_goi: 'testers_goi',
    testers_spa: 'testers_spa',
    threads_aut: 'threads_aut',
    threads_clt: 'threads_clt',
    threads_goi: 'threads_goi',
    threads_spa: 'threads_spa',
    tokens_generated_aut: 'tokens_generated_aut',
    tokens_generated_clt: 'tokens_generated_clt',
    tokens_generated_goi: 'tokens_generated_goi',
    tokens_generated_spa: 'tokens_generated_spa',
    trainings_links_aut: 'trainings_links_aut',
    trainings_links_clt: 'trainings_links_clt',
    trainings_links_goi: 'trainings_links_goi',
    trainings_links_spa: 'trainings_links_spa',
    users_aut: 'users_aut',
    users_clt: 'users_clt',
    users_goi: 'users_goi',
    users_spa: 'users_spa'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "sequelizeMeta" | "accommodation_quotations" | "attendant" | "attendant_calls" | "attendants" | "budget_consults_aut" | "budget_consults_clt" | "budget_consults_goi" | "budget_consults_spa" | "calls" | "cities_quotations" | "configs_bot_aut" | "configs_bot_clt" | "configs_bot_goi" | "configs_bot_spa" | "coparticipation_type_quotations" | "cpf_consults_aut" | "cpf_consults_clt" | "cpf_consults_goi" | "cpf_consults_spa" | "files" | "maintenance_commands" | "messages_log" | "modality_assistance_quotations" | "plan_group_quotations" | "plan_type_quotations" | "problems_clt" | "quotation" | "quote_calculations_aut" | "quote_calculations_clt" | "quote_calculations_goi" | "quote_calculations_spa" | "register_partners_aut" | "register_partners_spa" | "rh_calls" | "rh_numbers" | "seller_codes" | "sessions_aut" | "sessions_clt" | "sessions_goi" | "sessions_spa" | "supervisor_register_partners" | "testers_aut" | "testers_clt" | "testers_goi" | "testers_spa" | "threads_aut" | "threads_clt" | "threads_goi" | "threads_spa" | "tokens_generated_aut" | "tokens_generated_clt" | "tokens_generated_goi" | "tokens_generated_spa" | "trainings_links_aut" | "trainings_links_clt" | "trainings_links_goi" | "trainings_links_spa" | "users_aut" | "users_clt" | "users_goi" | "users_spa"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SequelizeMeta: {
        payload: Prisma.$SequelizeMetaPayload<ExtArgs>
        fields: Prisma.SequelizeMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SequelizeMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SequelizeMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload>
          }
          findFirst: {
            args: Prisma.SequelizeMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SequelizeMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload>
          }
          findMany: {
            args: Prisma.SequelizeMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload>[]
          }
          create: {
            args: Prisma.SequelizeMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload>
          }
          createMany: {
            args: Prisma.SequelizeMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SequelizeMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload>
          }
          update: {
            args: Prisma.SequelizeMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload>
          }
          deleteMany: {
            args: Prisma.SequelizeMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SequelizeMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SequelizeMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SequelizeMetaPayload>
          }
          aggregate: {
            args: Prisma.SequelizeMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSequelizeMeta>
          }
          groupBy: {
            args: Prisma.SequelizeMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SequelizeMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SequelizeMetaCountArgs<ExtArgs>
            result: $Utils.Optional<SequelizeMetaCountAggregateOutputType> | number
          }
        }
      }
      accommodation_quotations: {
        payload: Prisma.$accommodation_quotationsPayload<ExtArgs>
        fields: Prisma.accommodation_quotationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accommodation_quotationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accommodation_quotationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload>
          }
          findFirst: {
            args: Prisma.accommodation_quotationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accommodation_quotationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload>
          }
          findMany: {
            args: Prisma.accommodation_quotationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload>[]
          }
          create: {
            args: Prisma.accommodation_quotationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload>
          }
          createMany: {
            args: Prisma.accommodation_quotationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accommodation_quotationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload>
          }
          update: {
            args: Prisma.accommodation_quotationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload>
          }
          deleteMany: {
            args: Prisma.accommodation_quotationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accommodation_quotationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accommodation_quotationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accommodation_quotationsPayload>
          }
          aggregate: {
            args: Prisma.Accommodation_quotationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccommodation_quotations>
          }
          groupBy: {
            args: Prisma.accommodation_quotationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Accommodation_quotationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accommodation_quotationsCountArgs<ExtArgs>
            result: $Utils.Optional<Accommodation_quotationsCountAggregateOutputType> | number
          }
        }
      }
      attendant: {
        payload: Prisma.$attendantPayload<ExtArgs>
        fields: Prisma.attendantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload>
          }
          findFirst: {
            args: Prisma.attendantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload>
          }
          findMany: {
            args: Prisma.attendantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload>[]
          }
          create: {
            args: Prisma.attendantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload>
          }
          createMany: {
            args: Prisma.attendantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attendantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload>
          }
          update: {
            args: Prisma.attendantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload>
          }
          deleteMany: {
            args: Prisma.attendantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attendantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantPayload>
          }
          aggregate: {
            args: Prisma.AttendantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendant>
          }
          groupBy: {
            args: Prisma.attendantGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendantGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendantCountArgs<ExtArgs>
            result: $Utils.Optional<AttendantCountAggregateOutputType> | number
          }
        }
      }
      attendant_calls: {
        payload: Prisma.$attendant_callsPayload<ExtArgs>
        fields: Prisma.attendant_callsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendant_callsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendant_callsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload>
          }
          findFirst: {
            args: Prisma.attendant_callsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendant_callsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload>
          }
          findMany: {
            args: Prisma.attendant_callsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload>[]
          }
          create: {
            args: Prisma.attendant_callsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload>
          }
          createMany: {
            args: Prisma.attendant_callsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attendant_callsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload>
          }
          update: {
            args: Prisma.attendant_callsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload>
          }
          deleteMany: {
            args: Prisma.attendant_callsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendant_callsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attendant_callsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendant_callsPayload>
          }
          aggregate: {
            args: Prisma.Attendant_callsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendant_calls>
          }
          groupBy: {
            args: Prisma.attendant_callsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Attendant_callsGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendant_callsCountArgs<ExtArgs>
            result: $Utils.Optional<Attendant_callsCountAggregateOutputType> | number
          }
        }
      }
      attendants: {
        payload: Prisma.$attendantsPayload<ExtArgs>
        fields: Prisma.attendantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload>
          }
          findFirst: {
            args: Prisma.attendantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload>
          }
          findMany: {
            args: Prisma.attendantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload>[]
          }
          create: {
            args: Prisma.attendantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload>
          }
          createMany: {
            args: Prisma.attendantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attendantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload>
          }
          update: {
            args: Prisma.attendantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload>
          }
          deleteMany: {
            args: Prisma.attendantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attendantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendantsPayload>
          }
          aggregate: {
            args: Prisma.AttendantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendants>
          }
          groupBy: {
            args: Prisma.attendantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendantsCountArgs<ExtArgs>
            result: $Utils.Optional<AttendantsCountAggregateOutputType> | number
          }
        }
      }
      budget_consults_aut: {
        payload: Prisma.$budget_consults_autPayload<ExtArgs>
        fields: Prisma.budget_consults_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.budget_consults_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.budget_consults_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload>
          }
          findFirst: {
            args: Prisma.budget_consults_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.budget_consults_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload>
          }
          findMany: {
            args: Prisma.budget_consults_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload>[]
          }
          create: {
            args: Prisma.budget_consults_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload>
          }
          createMany: {
            args: Prisma.budget_consults_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.budget_consults_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload>
          }
          update: {
            args: Prisma.budget_consults_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload>
          }
          deleteMany: {
            args: Prisma.budget_consults_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.budget_consults_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.budget_consults_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_autPayload>
          }
          aggregate: {
            args: Prisma.Budget_consults_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget_consults_aut>
          }
          groupBy: {
            args: Prisma.budget_consults_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Budget_consults_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.budget_consults_autCountArgs<ExtArgs>
            result: $Utils.Optional<Budget_consults_autCountAggregateOutputType> | number
          }
        }
      }
      budget_consults_clt: {
        payload: Prisma.$budget_consults_cltPayload<ExtArgs>
        fields: Prisma.budget_consults_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.budget_consults_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.budget_consults_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload>
          }
          findFirst: {
            args: Prisma.budget_consults_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.budget_consults_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload>
          }
          findMany: {
            args: Prisma.budget_consults_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload>[]
          }
          create: {
            args: Prisma.budget_consults_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload>
          }
          createMany: {
            args: Prisma.budget_consults_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.budget_consults_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload>
          }
          update: {
            args: Prisma.budget_consults_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload>
          }
          deleteMany: {
            args: Prisma.budget_consults_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.budget_consults_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.budget_consults_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_cltPayload>
          }
          aggregate: {
            args: Prisma.Budget_consults_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget_consults_clt>
          }
          groupBy: {
            args: Prisma.budget_consults_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Budget_consults_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.budget_consults_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Budget_consults_cltCountAggregateOutputType> | number
          }
        }
      }
      budget_consults_goi: {
        payload: Prisma.$budget_consults_goiPayload<ExtArgs>
        fields: Prisma.budget_consults_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.budget_consults_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.budget_consults_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload>
          }
          findFirst: {
            args: Prisma.budget_consults_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.budget_consults_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload>
          }
          findMany: {
            args: Prisma.budget_consults_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload>[]
          }
          create: {
            args: Prisma.budget_consults_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload>
          }
          createMany: {
            args: Prisma.budget_consults_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.budget_consults_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload>
          }
          update: {
            args: Prisma.budget_consults_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload>
          }
          deleteMany: {
            args: Prisma.budget_consults_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.budget_consults_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.budget_consults_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_goiPayload>
          }
          aggregate: {
            args: Prisma.Budget_consults_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget_consults_goi>
          }
          groupBy: {
            args: Prisma.budget_consults_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Budget_consults_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.budget_consults_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Budget_consults_goiCountAggregateOutputType> | number
          }
        }
      }
      budget_consults_spa: {
        payload: Prisma.$budget_consults_spaPayload<ExtArgs>
        fields: Prisma.budget_consults_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.budget_consults_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.budget_consults_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload>
          }
          findFirst: {
            args: Prisma.budget_consults_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.budget_consults_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload>
          }
          findMany: {
            args: Prisma.budget_consults_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload>[]
          }
          create: {
            args: Prisma.budget_consults_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload>
          }
          createMany: {
            args: Prisma.budget_consults_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.budget_consults_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload>
          }
          update: {
            args: Prisma.budget_consults_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload>
          }
          deleteMany: {
            args: Prisma.budget_consults_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.budget_consults_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.budget_consults_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_consults_spaPayload>
          }
          aggregate: {
            args: Prisma.Budget_consults_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget_consults_spa>
          }
          groupBy: {
            args: Prisma.budget_consults_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Budget_consults_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.budget_consults_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Budget_consults_spaCountAggregateOutputType> | number
          }
        }
      }
      calls: {
        payload: Prisma.$callsPayload<ExtArgs>
        fields: Prisma.callsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.callsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.callsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload>
          }
          findFirst: {
            args: Prisma.callsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.callsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload>
          }
          findMany: {
            args: Prisma.callsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload>[]
          }
          create: {
            args: Prisma.callsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload>
          }
          createMany: {
            args: Prisma.callsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.callsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload>
          }
          update: {
            args: Prisma.callsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload>
          }
          deleteMany: {
            args: Prisma.callsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.callsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.callsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$callsPayload>
          }
          aggregate: {
            args: Prisma.CallsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalls>
          }
          groupBy: {
            args: Prisma.callsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallsGroupByOutputType>[]
          }
          count: {
            args: Prisma.callsCountArgs<ExtArgs>
            result: $Utils.Optional<CallsCountAggregateOutputType> | number
          }
        }
      }
      cities_quotations: {
        payload: Prisma.$cities_quotationsPayload<ExtArgs>
        fields: Prisma.cities_quotationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cities_quotationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cities_quotationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload>
          }
          findFirst: {
            args: Prisma.cities_quotationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cities_quotationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload>
          }
          findMany: {
            args: Prisma.cities_quotationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload>[]
          }
          create: {
            args: Prisma.cities_quotationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload>
          }
          createMany: {
            args: Prisma.cities_quotationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cities_quotationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload>
          }
          update: {
            args: Prisma.cities_quotationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload>
          }
          deleteMany: {
            args: Prisma.cities_quotationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cities_quotationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cities_quotationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cities_quotationsPayload>
          }
          aggregate: {
            args: Prisma.Cities_quotationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCities_quotations>
          }
          groupBy: {
            args: Prisma.cities_quotationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cities_quotationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cities_quotationsCountArgs<ExtArgs>
            result: $Utils.Optional<Cities_quotationsCountAggregateOutputType> | number
          }
        }
      }
      configs_bot_aut: {
        payload: Prisma.$configs_bot_autPayload<ExtArgs>
        fields: Prisma.configs_bot_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configs_bot_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configs_bot_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload>
          }
          findFirst: {
            args: Prisma.configs_bot_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configs_bot_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload>
          }
          findMany: {
            args: Prisma.configs_bot_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload>[]
          }
          create: {
            args: Prisma.configs_bot_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload>
          }
          createMany: {
            args: Prisma.configs_bot_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.configs_bot_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload>
          }
          update: {
            args: Prisma.configs_bot_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload>
          }
          deleteMany: {
            args: Prisma.configs_bot_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configs_bot_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.configs_bot_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_autPayload>
          }
          aggregate: {
            args: Prisma.Configs_bot_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigs_bot_aut>
          }
          groupBy: {
            args: Prisma.configs_bot_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Configs_bot_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.configs_bot_autCountArgs<ExtArgs>
            result: $Utils.Optional<Configs_bot_autCountAggregateOutputType> | number
          }
        }
      }
      configs_bot_clt: {
        payload: Prisma.$configs_bot_cltPayload<ExtArgs>
        fields: Prisma.configs_bot_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configs_bot_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configs_bot_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload>
          }
          findFirst: {
            args: Prisma.configs_bot_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configs_bot_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload>
          }
          findMany: {
            args: Prisma.configs_bot_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload>[]
          }
          create: {
            args: Prisma.configs_bot_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload>
          }
          createMany: {
            args: Prisma.configs_bot_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.configs_bot_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload>
          }
          update: {
            args: Prisma.configs_bot_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload>
          }
          deleteMany: {
            args: Prisma.configs_bot_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configs_bot_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.configs_bot_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_cltPayload>
          }
          aggregate: {
            args: Prisma.Configs_bot_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigs_bot_clt>
          }
          groupBy: {
            args: Prisma.configs_bot_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Configs_bot_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.configs_bot_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Configs_bot_cltCountAggregateOutputType> | number
          }
        }
      }
      configs_bot_goi: {
        payload: Prisma.$configs_bot_goiPayload<ExtArgs>
        fields: Prisma.configs_bot_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configs_bot_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configs_bot_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload>
          }
          findFirst: {
            args: Prisma.configs_bot_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configs_bot_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload>
          }
          findMany: {
            args: Prisma.configs_bot_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload>[]
          }
          create: {
            args: Prisma.configs_bot_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload>
          }
          createMany: {
            args: Prisma.configs_bot_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.configs_bot_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload>
          }
          update: {
            args: Prisma.configs_bot_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload>
          }
          deleteMany: {
            args: Prisma.configs_bot_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configs_bot_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.configs_bot_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_goiPayload>
          }
          aggregate: {
            args: Prisma.Configs_bot_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigs_bot_goi>
          }
          groupBy: {
            args: Prisma.configs_bot_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Configs_bot_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.configs_bot_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Configs_bot_goiCountAggregateOutputType> | number
          }
        }
      }
      configs_bot_spa: {
        payload: Prisma.$configs_bot_spaPayload<ExtArgs>
        fields: Prisma.configs_bot_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configs_bot_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configs_bot_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload>
          }
          findFirst: {
            args: Prisma.configs_bot_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configs_bot_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload>
          }
          findMany: {
            args: Prisma.configs_bot_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload>[]
          }
          create: {
            args: Prisma.configs_bot_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload>
          }
          createMany: {
            args: Prisma.configs_bot_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.configs_bot_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload>
          }
          update: {
            args: Prisma.configs_bot_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload>
          }
          deleteMany: {
            args: Prisma.configs_bot_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configs_bot_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.configs_bot_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configs_bot_spaPayload>
          }
          aggregate: {
            args: Prisma.Configs_bot_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigs_bot_spa>
          }
          groupBy: {
            args: Prisma.configs_bot_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Configs_bot_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.configs_bot_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Configs_bot_spaCountAggregateOutputType> | number
          }
        }
      }
      coparticipation_type_quotations: {
        payload: Prisma.$coparticipation_type_quotationsPayload<ExtArgs>
        fields: Prisma.coparticipation_type_quotationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coparticipation_type_quotationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coparticipation_type_quotationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload>
          }
          findFirst: {
            args: Prisma.coparticipation_type_quotationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coparticipation_type_quotationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload>
          }
          findMany: {
            args: Prisma.coparticipation_type_quotationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload>[]
          }
          create: {
            args: Prisma.coparticipation_type_quotationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload>
          }
          createMany: {
            args: Prisma.coparticipation_type_quotationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.coparticipation_type_quotationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload>
          }
          update: {
            args: Prisma.coparticipation_type_quotationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload>
          }
          deleteMany: {
            args: Prisma.coparticipation_type_quotationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coparticipation_type_quotationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.coparticipation_type_quotationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coparticipation_type_quotationsPayload>
          }
          aggregate: {
            args: Prisma.Coparticipation_type_quotationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoparticipation_type_quotations>
          }
          groupBy: {
            args: Prisma.coparticipation_type_quotationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Coparticipation_type_quotationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.coparticipation_type_quotationsCountArgs<ExtArgs>
            result: $Utils.Optional<Coparticipation_type_quotationsCountAggregateOutputType> | number
          }
        }
      }
      cpf_consults_aut: {
        payload: Prisma.$cpf_consults_autPayload<ExtArgs>
        fields: Prisma.cpf_consults_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cpf_consults_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cpf_consults_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload>
          }
          findFirst: {
            args: Prisma.cpf_consults_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cpf_consults_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload>
          }
          findMany: {
            args: Prisma.cpf_consults_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload>[]
          }
          create: {
            args: Prisma.cpf_consults_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload>
          }
          createMany: {
            args: Prisma.cpf_consults_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cpf_consults_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload>
          }
          update: {
            args: Prisma.cpf_consults_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload>
          }
          deleteMany: {
            args: Prisma.cpf_consults_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cpf_consults_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cpf_consults_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_autPayload>
          }
          aggregate: {
            args: Prisma.Cpf_consults_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCpf_consults_aut>
          }
          groupBy: {
            args: Prisma.cpf_consults_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cpf_consults_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.cpf_consults_autCountArgs<ExtArgs>
            result: $Utils.Optional<Cpf_consults_autCountAggregateOutputType> | number
          }
        }
      }
      cpf_consults_clt: {
        payload: Prisma.$cpf_consults_cltPayload<ExtArgs>
        fields: Prisma.cpf_consults_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cpf_consults_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cpf_consults_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload>
          }
          findFirst: {
            args: Prisma.cpf_consults_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cpf_consults_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload>
          }
          findMany: {
            args: Prisma.cpf_consults_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload>[]
          }
          create: {
            args: Prisma.cpf_consults_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload>
          }
          createMany: {
            args: Prisma.cpf_consults_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cpf_consults_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload>
          }
          update: {
            args: Prisma.cpf_consults_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload>
          }
          deleteMany: {
            args: Prisma.cpf_consults_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cpf_consults_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cpf_consults_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_cltPayload>
          }
          aggregate: {
            args: Prisma.Cpf_consults_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCpf_consults_clt>
          }
          groupBy: {
            args: Prisma.cpf_consults_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cpf_consults_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.cpf_consults_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Cpf_consults_cltCountAggregateOutputType> | number
          }
        }
      }
      cpf_consults_goi: {
        payload: Prisma.$cpf_consults_goiPayload<ExtArgs>
        fields: Prisma.cpf_consults_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cpf_consults_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cpf_consults_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload>
          }
          findFirst: {
            args: Prisma.cpf_consults_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cpf_consults_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload>
          }
          findMany: {
            args: Prisma.cpf_consults_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload>[]
          }
          create: {
            args: Prisma.cpf_consults_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload>
          }
          createMany: {
            args: Prisma.cpf_consults_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cpf_consults_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload>
          }
          update: {
            args: Prisma.cpf_consults_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload>
          }
          deleteMany: {
            args: Prisma.cpf_consults_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cpf_consults_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cpf_consults_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_goiPayload>
          }
          aggregate: {
            args: Prisma.Cpf_consults_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCpf_consults_goi>
          }
          groupBy: {
            args: Prisma.cpf_consults_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cpf_consults_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.cpf_consults_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Cpf_consults_goiCountAggregateOutputType> | number
          }
        }
      }
      cpf_consults_spa: {
        payload: Prisma.$cpf_consults_spaPayload<ExtArgs>
        fields: Prisma.cpf_consults_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cpf_consults_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cpf_consults_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload>
          }
          findFirst: {
            args: Prisma.cpf_consults_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cpf_consults_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload>
          }
          findMany: {
            args: Prisma.cpf_consults_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload>[]
          }
          create: {
            args: Prisma.cpf_consults_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload>
          }
          createMany: {
            args: Prisma.cpf_consults_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cpf_consults_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload>
          }
          update: {
            args: Prisma.cpf_consults_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload>
          }
          deleteMany: {
            args: Prisma.cpf_consults_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cpf_consults_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cpf_consults_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cpf_consults_spaPayload>
          }
          aggregate: {
            args: Prisma.Cpf_consults_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCpf_consults_spa>
          }
          groupBy: {
            args: Prisma.cpf_consults_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cpf_consults_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.cpf_consults_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Cpf_consults_spaCountAggregateOutputType> | number
          }
        }
      }
      files: {
        payload: Prisma.$filesPayload<ExtArgs>
        fields: Prisma.filesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.filesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.filesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          findFirst: {
            args: Prisma.filesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.filesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          findMany: {
            args: Prisma.filesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>[]
          }
          create: {
            args: Prisma.filesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          createMany: {
            args: Prisma.filesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.filesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          update: {
            args: Prisma.filesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          deleteMany: {
            args: Prisma.filesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.filesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.filesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          aggregate: {
            args: Prisma.FilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiles>
          }
          groupBy: {
            args: Prisma.filesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.filesCountArgs<ExtArgs>
            result: $Utils.Optional<FilesCountAggregateOutputType> | number
          }
        }
      }
      maintenance_commands: {
        payload: Prisma.$maintenance_commandsPayload<ExtArgs>
        fields: Prisma.maintenance_commandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.maintenance_commandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.maintenance_commandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload>
          }
          findFirst: {
            args: Prisma.maintenance_commandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.maintenance_commandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload>
          }
          findMany: {
            args: Prisma.maintenance_commandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload>[]
          }
          create: {
            args: Prisma.maintenance_commandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload>
          }
          createMany: {
            args: Prisma.maintenance_commandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.maintenance_commandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload>
          }
          update: {
            args: Prisma.maintenance_commandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload>
          }
          deleteMany: {
            args: Prisma.maintenance_commandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.maintenance_commandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.maintenance_commandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_commandsPayload>
          }
          aggregate: {
            args: Prisma.Maintenance_commandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance_commands>
          }
          groupBy: {
            args: Prisma.maintenance_commandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Maintenance_commandsGroupByOutputType>[]
          }
          count: {
            args: Prisma.maintenance_commandsCountArgs<ExtArgs>
            result: $Utils.Optional<Maintenance_commandsCountAggregateOutputType> | number
          }
        }
      }
      messages_log: {
        payload: Prisma.$messages_logPayload<ExtArgs>
        fields: Prisma.messages_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messages_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messages_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload>
          }
          findFirst: {
            args: Prisma.messages_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messages_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload>
          }
          findMany: {
            args: Prisma.messages_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload>[]
          }
          create: {
            args: Prisma.messages_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload>
          }
          createMany: {
            args: Prisma.messages_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.messages_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload>
          }
          update: {
            args: Prisma.messages_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload>
          }
          deleteMany: {
            args: Prisma.messages_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messages_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.messages_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messages_logPayload>
          }
          aggregate: {
            args: Prisma.Messages_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages_log>
          }
          groupBy: {
            args: Prisma.messages_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Messages_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.messages_logCountArgs<ExtArgs>
            result: $Utils.Optional<Messages_logCountAggregateOutputType> | number
          }
        }
      }
      modality_assistance_quotations: {
        payload: Prisma.$modality_assistance_quotationsPayload<ExtArgs>
        fields: Prisma.modality_assistance_quotationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.modality_assistance_quotationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.modality_assistance_quotationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload>
          }
          findFirst: {
            args: Prisma.modality_assistance_quotationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.modality_assistance_quotationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload>
          }
          findMany: {
            args: Prisma.modality_assistance_quotationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload>[]
          }
          create: {
            args: Prisma.modality_assistance_quotationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload>
          }
          createMany: {
            args: Prisma.modality_assistance_quotationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.modality_assistance_quotationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload>
          }
          update: {
            args: Prisma.modality_assistance_quotationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload>
          }
          deleteMany: {
            args: Prisma.modality_assistance_quotationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.modality_assistance_quotationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.modality_assistance_quotationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modality_assistance_quotationsPayload>
          }
          aggregate: {
            args: Prisma.Modality_assistance_quotationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModality_assistance_quotations>
          }
          groupBy: {
            args: Prisma.modality_assistance_quotationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Modality_assistance_quotationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.modality_assistance_quotationsCountArgs<ExtArgs>
            result: $Utils.Optional<Modality_assistance_quotationsCountAggregateOutputType> | number
          }
        }
      }
      plan_group_quotations: {
        payload: Prisma.$plan_group_quotationsPayload<ExtArgs>
        fields: Prisma.plan_group_quotationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plan_group_quotationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plan_group_quotationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload>
          }
          findFirst: {
            args: Prisma.plan_group_quotationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plan_group_quotationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload>
          }
          findMany: {
            args: Prisma.plan_group_quotationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload>[]
          }
          create: {
            args: Prisma.plan_group_quotationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload>
          }
          createMany: {
            args: Prisma.plan_group_quotationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.plan_group_quotationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload>
          }
          update: {
            args: Prisma.plan_group_quotationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload>
          }
          deleteMany: {
            args: Prisma.plan_group_quotationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plan_group_quotationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.plan_group_quotationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_group_quotationsPayload>
          }
          aggregate: {
            args: Prisma.Plan_group_quotationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan_group_quotations>
          }
          groupBy: {
            args: Prisma.plan_group_quotationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plan_group_quotationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.plan_group_quotationsCountArgs<ExtArgs>
            result: $Utils.Optional<Plan_group_quotationsCountAggregateOutputType> | number
          }
        }
      }
      plan_type_quotations: {
        payload: Prisma.$plan_type_quotationsPayload<ExtArgs>
        fields: Prisma.plan_type_quotationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plan_type_quotationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plan_type_quotationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload>
          }
          findFirst: {
            args: Prisma.plan_type_quotationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plan_type_quotationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload>
          }
          findMany: {
            args: Prisma.plan_type_quotationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload>[]
          }
          create: {
            args: Prisma.plan_type_quotationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload>
          }
          createMany: {
            args: Prisma.plan_type_quotationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.plan_type_quotationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload>
          }
          update: {
            args: Prisma.plan_type_quotationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload>
          }
          deleteMany: {
            args: Prisma.plan_type_quotationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plan_type_quotationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.plan_type_quotationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_type_quotationsPayload>
          }
          aggregate: {
            args: Prisma.Plan_type_quotationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan_type_quotations>
          }
          groupBy: {
            args: Prisma.plan_type_quotationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plan_type_quotationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.plan_type_quotationsCountArgs<ExtArgs>
            result: $Utils.Optional<Plan_type_quotationsCountAggregateOutputType> | number
          }
        }
      }
      problems_clt: {
        payload: Prisma.$problems_cltPayload<ExtArgs>
        fields: Prisma.problems_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.problems_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.problems_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload>
          }
          findFirst: {
            args: Prisma.problems_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.problems_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload>
          }
          findMany: {
            args: Prisma.problems_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload>[]
          }
          create: {
            args: Prisma.problems_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload>
          }
          createMany: {
            args: Prisma.problems_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.problems_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload>
          }
          update: {
            args: Prisma.problems_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload>
          }
          deleteMany: {
            args: Prisma.problems_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.problems_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.problems_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_cltPayload>
          }
          aggregate: {
            args: Prisma.Problems_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProblems_clt>
          }
          groupBy: {
            args: Prisma.problems_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Problems_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.problems_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Problems_cltCountAggregateOutputType> | number
          }
        }
      }
      Quotation: {
        payload: Prisma.$QuotationPayload<ExtArgs>
        fields: Prisma.QuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findFirst: {
            args: Prisma.QuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findMany: {
            args: Prisma.QuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          create: {
            args: Prisma.QuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          createMany: {
            args: Prisma.QuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          update: {
            args: Prisma.QuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          deleteMany: {
            args: Prisma.QuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          aggregate: {
            args: Prisma.QuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotation>
          }
          groupBy: {
            args: Prisma.QuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationCountAggregateOutputType> | number
          }
        }
      }
      quote_calculations_aut: {
        payload: Prisma.$quote_calculations_autPayload<ExtArgs>
        fields: Prisma.quote_calculations_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quote_calculations_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quote_calculations_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload>
          }
          findFirst: {
            args: Prisma.quote_calculations_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quote_calculations_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload>
          }
          findMany: {
            args: Prisma.quote_calculations_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload>[]
          }
          create: {
            args: Prisma.quote_calculations_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload>
          }
          createMany: {
            args: Prisma.quote_calculations_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.quote_calculations_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload>
          }
          update: {
            args: Prisma.quote_calculations_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload>
          }
          deleteMany: {
            args: Prisma.quote_calculations_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quote_calculations_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.quote_calculations_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_autPayload>
          }
          aggregate: {
            args: Prisma.Quote_calculations_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote_calculations_aut>
          }
          groupBy: {
            args: Prisma.quote_calculations_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Quote_calculations_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.quote_calculations_autCountArgs<ExtArgs>
            result: $Utils.Optional<Quote_calculations_autCountAggregateOutputType> | number
          }
        }
      }
      quote_calculations_clt: {
        payload: Prisma.$quote_calculations_cltPayload<ExtArgs>
        fields: Prisma.quote_calculations_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quote_calculations_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quote_calculations_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload>
          }
          findFirst: {
            args: Prisma.quote_calculations_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quote_calculations_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload>
          }
          findMany: {
            args: Prisma.quote_calculations_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload>[]
          }
          create: {
            args: Prisma.quote_calculations_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload>
          }
          createMany: {
            args: Prisma.quote_calculations_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.quote_calculations_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload>
          }
          update: {
            args: Prisma.quote_calculations_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload>
          }
          deleteMany: {
            args: Prisma.quote_calculations_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quote_calculations_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.quote_calculations_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_cltPayload>
          }
          aggregate: {
            args: Prisma.Quote_calculations_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote_calculations_clt>
          }
          groupBy: {
            args: Prisma.quote_calculations_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Quote_calculations_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.quote_calculations_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Quote_calculations_cltCountAggregateOutputType> | number
          }
        }
      }
      quote_calculations_goi: {
        payload: Prisma.$quote_calculations_goiPayload<ExtArgs>
        fields: Prisma.quote_calculations_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quote_calculations_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quote_calculations_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload>
          }
          findFirst: {
            args: Prisma.quote_calculations_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quote_calculations_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload>
          }
          findMany: {
            args: Prisma.quote_calculations_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload>[]
          }
          create: {
            args: Prisma.quote_calculations_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload>
          }
          createMany: {
            args: Prisma.quote_calculations_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.quote_calculations_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload>
          }
          update: {
            args: Prisma.quote_calculations_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload>
          }
          deleteMany: {
            args: Prisma.quote_calculations_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quote_calculations_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.quote_calculations_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_goiPayload>
          }
          aggregate: {
            args: Prisma.Quote_calculations_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote_calculations_goi>
          }
          groupBy: {
            args: Prisma.quote_calculations_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Quote_calculations_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.quote_calculations_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Quote_calculations_goiCountAggregateOutputType> | number
          }
        }
      }
      quote_calculations_spa: {
        payload: Prisma.$quote_calculations_spaPayload<ExtArgs>
        fields: Prisma.quote_calculations_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quote_calculations_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quote_calculations_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload>
          }
          findFirst: {
            args: Prisma.quote_calculations_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quote_calculations_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload>
          }
          findMany: {
            args: Prisma.quote_calculations_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload>[]
          }
          create: {
            args: Prisma.quote_calculations_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload>
          }
          createMany: {
            args: Prisma.quote_calculations_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.quote_calculations_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload>
          }
          update: {
            args: Prisma.quote_calculations_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload>
          }
          deleteMany: {
            args: Prisma.quote_calculations_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quote_calculations_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.quote_calculations_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quote_calculations_spaPayload>
          }
          aggregate: {
            args: Prisma.Quote_calculations_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote_calculations_spa>
          }
          groupBy: {
            args: Prisma.quote_calculations_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Quote_calculations_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.quote_calculations_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Quote_calculations_spaCountAggregateOutputType> | number
          }
        }
      }
      register_partners_aut: {
        payload: Prisma.$register_partners_autPayload<ExtArgs>
        fields: Prisma.register_partners_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.register_partners_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.register_partners_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload>
          }
          findFirst: {
            args: Prisma.register_partners_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.register_partners_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload>
          }
          findMany: {
            args: Prisma.register_partners_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload>[]
          }
          create: {
            args: Prisma.register_partners_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload>
          }
          createMany: {
            args: Prisma.register_partners_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.register_partners_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload>
          }
          update: {
            args: Prisma.register_partners_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload>
          }
          deleteMany: {
            args: Prisma.register_partners_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.register_partners_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.register_partners_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_autPayload>
          }
          aggregate: {
            args: Prisma.Register_partners_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegister_partners_aut>
          }
          groupBy: {
            args: Prisma.register_partners_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Register_partners_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.register_partners_autCountArgs<ExtArgs>
            result: $Utils.Optional<Register_partners_autCountAggregateOutputType> | number
          }
        }
      }
      register_partners_spa: {
        payload: Prisma.$register_partners_spaPayload<ExtArgs>
        fields: Prisma.register_partners_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.register_partners_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.register_partners_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload>
          }
          findFirst: {
            args: Prisma.register_partners_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.register_partners_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload>
          }
          findMany: {
            args: Prisma.register_partners_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload>[]
          }
          create: {
            args: Prisma.register_partners_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload>
          }
          createMany: {
            args: Prisma.register_partners_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.register_partners_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload>
          }
          update: {
            args: Prisma.register_partners_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload>
          }
          deleteMany: {
            args: Prisma.register_partners_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.register_partners_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.register_partners_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$register_partners_spaPayload>
          }
          aggregate: {
            args: Prisma.Register_partners_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegister_partners_spa>
          }
          groupBy: {
            args: Prisma.register_partners_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Register_partners_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.register_partners_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Register_partners_spaCountAggregateOutputType> | number
          }
        }
      }
      rh_calls: {
        payload: Prisma.$rh_callsPayload<ExtArgs>
        fields: Prisma.rh_callsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rh_callsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rh_callsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload>
          }
          findFirst: {
            args: Prisma.rh_callsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rh_callsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload>
          }
          findMany: {
            args: Prisma.rh_callsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload>[]
          }
          create: {
            args: Prisma.rh_callsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload>
          }
          createMany: {
            args: Prisma.rh_callsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rh_callsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload>
          }
          update: {
            args: Prisma.rh_callsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload>
          }
          deleteMany: {
            args: Prisma.rh_callsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rh_callsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rh_callsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_callsPayload>
          }
          aggregate: {
            args: Prisma.Rh_callsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRh_calls>
          }
          groupBy: {
            args: Prisma.rh_callsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rh_callsGroupByOutputType>[]
          }
          count: {
            args: Prisma.rh_callsCountArgs<ExtArgs>
            result: $Utils.Optional<Rh_callsCountAggregateOutputType> | number
          }
        }
      }
      rh_numbers: {
        payload: Prisma.$rh_numbersPayload<ExtArgs>
        fields: Prisma.rh_numbersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rh_numbersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rh_numbersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload>
          }
          findFirst: {
            args: Prisma.rh_numbersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rh_numbersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload>
          }
          findMany: {
            args: Prisma.rh_numbersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload>[]
          }
          create: {
            args: Prisma.rh_numbersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload>
          }
          createMany: {
            args: Prisma.rh_numbersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rh_numbersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload>
          }
          update: {
            args: Prisma.rh_numbersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload>
          }
          deleteMany: {
            args: Prisma.rh_numbersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rh_numbersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rh_numbersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rh_numbersPayload>
          }
          aggregate: {
            args: Prisma.Rh_numbersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRh_numbers>
          }
          groupBy: {
            args: Prisma.rh_numbersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rh_numbersGroupByOutputType>[]
          }
          count: {
            args: Prisma.rh_numbersCountArgs<ExtArgs>
            result: $Utils.Optional<Rh_numbersCountAggregateOutputType> | number
          }
        }
      }
      seller_codes: {
        payload: Prisma.$seller_codesPayload<ExtArgs>
        fields: Prisma.seller_codesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.seller_codesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seller_codesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload>
          }
          findFirst: {
            args: Prisma.seller_codesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seller_codesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload>
          }
          findMany: {
            args: Prisma.seller_codesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload>[]
          }
          create: {
            args: Prisma.seller_codesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload>
          }
          createMany: {
            args: Prisma.seller_codesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.seller_codesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload>
          }
          update: {
            args: Prisma.seller_codesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload>
          }
          deleteMany: {
            args: Prisma.seller_codesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.seller_codesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.seller_codesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seller_codesPayload>
          }
          aggregate: {
            args: Prisma.Seller_codesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeller_codes>
          }
          groupBy: {
            args: Prisma.seller_codesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Seller_codesGroupByOutputType>[]
          }
          count: {
            args: Prisma.seller_codesCountArgs<ExtArgs>
            result: $Utils.Optional<Seller_codesCountAggregateOutputType> | number
          }
        }
      }
      sessions_aut: {
        payload: Prisma.$sessions_autPayload<ExtArgs>
        fields: Prisma.sessions_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessions_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessions_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload>
          }
          findFirst: {
            args: Prisma.sessions_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessions_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload>
          }
          findMany: {
            args: Prisma.sessions_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload>[]
          }
          create: {
            args: Prisma.sessions_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload>
          }
          createMany: {
            args: Prisma.sessions_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessions_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload>
          }
          update: {
            args: Prisma.sessions_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload>
          }
          deleteMany: {
            args: Prisma.sessions_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessions_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessions_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_autPayload>
          }
          aggregate: {
            args: Prisma.Sessions_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions_aut>
          }
          groupBy: {
            args: Prisma.sessions_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sessions_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessions_autCountArgs<ExtArgs>
            result: $Utils.Optional<Sessions_autCountAggregateOutputType> | number
          }
        }
      }
      sessions_clt: {
        payload: Prisma.$sessions_cltPayload<ExtArgs>
        fields: Prisma.sessions_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessions_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessions_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload>
          }
          findFirst: {
            args: Prisma.sessions_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessions_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload>
          }
          findMany: {
            args: Prisma.sessions_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload>[]
          }
          create: {
            args: Prisma.sessions_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload>
          }
          createMany: {
            args: Prisma.sessions_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessions_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload>
          }
          update: {
            args: Prisma.sessions_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload>
          }
          deleteMany: {
            args: Prisma.sessions_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessions_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessions_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_cltPayload>
          }
          aggregate: {
            args: Prisma.Sessions_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions_clt>
          }
          groupBy: {
            args: Prisma.sessions_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sessions_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessions_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Sessions_cltCountAggregateOutputType> | number
          }
        }
      }
      sessions_goi: {
        payload: Prisma.$sessions_goiPayload<ExtArgs>
        fields: Prisma.sessions_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessions_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessions_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload>
          }
          findFirst: {
            args: Prisma.sessions_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessions_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload>
          }
          findMany: {
            args: Prisma.sessions_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload>[]
          }
          create: {
            args: Prisma.sessions_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload>
          }
          createMany: {
            args: Prisma.sessions_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessions_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload>
          }
          update: {
            args: Prisma.sessions_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload>
          }
          deleteMany: {
            args: Prisma.sessions_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessions_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessions_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_goiPayload>
          }
          aggregate: {
            args: Prisma.Sessions_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions_goi>
          }
          groupBy: {
            args: Prisma.sessions_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sessions_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessions_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Sessions_goiCountAggregateOutputType> | number
          }
        }
      }
      sessions_spa: {
        payload: Prisma.$sessions_spaPayload<ExtArgs>
        fields: Prisma.sessions_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessions_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessions_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload>
          }
          findFirst: {
            args: Prisma.sessions_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessions_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload>
          }
          findMany: {
            args: Prisma.sessions_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload>[]
          }
          create: {
            args: Prisma.sessions_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload>
          }
          createMany: {
            args: Prisma.sessions_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessions_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload>
          }
          update: {
            args: Prisma.sessions_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload>
          }
          deleteMany: {
            args: Prisma.sessions_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessions_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessions_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessions_spaPayload>
          }
          aggregate: {
            args: Prisma.Sessions_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions_spa>
          }
          groupBy: {
            args: Prisma.sessions_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sessions_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessions_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Sessions_spaCountAggregateOutputType> | number
          }
        }
      }
      supervisor_register_partners: {
        payload: Prisma.$supervisor_register_partnersPayload<ExtArgs>
        fields: Prisma.supervisor_register_partnersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supervisor_register_partnersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supervisor_register_partnersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload>
          }
          findFirst: {
            args: Prisma.supervisor_register_partnersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supervisor_register_partnersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload>
          }
          findMany: {
            args: Prisma.supervisor_register_partnersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload>[]
          }
          create: {
            args: Prisma.supervisor_register_partnersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload>
          }
          createMany: {
            args: Prisma.supervisor_register_partnersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.supervisor_register_partnersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload>
          }
          update: {
            args: Prisma.supervisor_register_partnersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload>
          }
          deleteMany: {
            args: Prisma.supervisor_register_partnersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.supervisor_register_partnersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.supervisor_register_partnersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisor_register_partnersPayload>
          }
          aggregate: {
            args: Prisma.Supervisor_register_partnersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupervisor_register_partners>
          }
          groupBy: {
            args: Prisma.supervisor_register_partnersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Supervisor_register_partnersGroupByOutputType>[]
          }
          count: {
            args: Prisma.supervisor_register_partnersCountArgs<ExtArgs>
            result: $Utils.Optional<Supervisor_register_partnersCountAggregateOutputType> | number
          }
        }
      }
      testers_aut: {
        payload: Prisma.$testers_autPayload<ExtArgs>
        fields: Prisma.testers_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testers_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testers_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload>
          }
          findFirst: {
            args: Prisma.testers_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testers_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload>
          }
          findMany: {
            args: Prisma.testers_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload>[]
          }
          create: {
            args: Prisma.testers_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload>
          }
          createMany: {
            args: Prisma.testers_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testers_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload>
          }
          update: {
            args: Prisma.testers_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload>
          }
          deleteMany: {
            args: Prisma.testers_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testers_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testers_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_autPayload>
          }
          aggregate: {
            args: Prisma.Testers_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTesters_aut>
          }
          groupBy: {
            args: Prisma.testers_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Testers_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.testers_autCountArgs<ExtArgs>
            result: $Utils.Optional<Testers_autCountAggregateOutputType> | number
          }
        }
      }
      testers_clt: {
        payload: Prisma.$testers_cltPayload<ExtArgs>
        fields: Prisma.testers_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testers_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testers_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload>
          }
          findFirst: {
            args: Prisma.testers_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testers_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload>
          }
          findMany: {
            args: Prisma.testers_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload>[]
          }
          create: {
            args: Prisma.testers_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload>
          }
          createMany: {
            args: Prisma.testers_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testers_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload>
          }
          update: {
            args: Prisma.testers_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload>
          }
          deleteMany: {
            args: Prisma.testers_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testers_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testers_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_cltPayload>
          }
          aggregate: {
            args: Prisma.Testers_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTesters_clt>
          }
          groupBy: {
            args: Prisma.testers_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Testers_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.testers_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Testers_cltCountAggregateOutputType> | number
          }
        }
      }
      testers_goi: {
        payload: Prisma.$testers_goiPayload<ExtArgs>
        fields: Prisma.testers_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testers_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testers_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload>
          }
          findFirst: {
            args: Prisma.testers_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testers_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload>
          }
          findMany: {
            args: Prisma.testers_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload>[]
          }
          create: {
            args: Prisma.testers_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload>
          }
          createMany: {
            args: Prisma.testers_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testers_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload>
          }
          update: {
            args: Prisma.testers_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload>
          }
          deleteMany: {
            args: Prisma.testers_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testers_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testers_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_goiPayload>
          }
          aggregate: {
            args: Prisma.Testers_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTesters_goi>
          }
          groupBy: {
            args: Prisma.testers_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Testers_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.testers_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Testers_goiCountAggregateOutputType> | number
          }
        }
      }
      testers_spa: {
        payload: Prisma.$testers_spaPayload<ExtArgs>
        fields: Prisma.testers_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testers_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testers_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload>
          }
          findFirst: {
            args: Prisma.testers_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testers_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload>
          }
          findMany: {
            args: Prisma.testers_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload>[]
          }
          create: {
            args: Prisma.testers_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload>
          }
          createMany: {
            args: Prisma.testers_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testers_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload>
          }
          update: {
            args: Prisma.testers_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload>
          }
          deleteMany: {
            args: Prisma.testers_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testers_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testers_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testers_spaPayload>
          }
          aggregate: {
            args: Prisma.Testers_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTesters_spa>
          }
          groupBy: {
            args: Prisma.testers_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Testers_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.testers_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Testers_spaCountAggregateOutputType> | number
          }
        }
      }
      threads_aut: {
        payload: Prisma.$threads_autPayload<ExtArgs>
        fields: Prisma.threads_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.threads_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.threads_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload>
          }
          findFirst: {
            args: Prisma.threads_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.threads_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload>
          }
          findMany: {
            args: Prisma.threads_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload>[]
          }
          create: {
            args: Prisma.threads_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload>
          }
          createMany: {
            args: Prisma.threads_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.threads_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload>
          }
          update: {
            args: Prisma.threads_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload>
          }
          deleteMany: {
            args: Prisma.threads_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.threads_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.threads_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_autPayload>
          }
          aggregate: {
            args: Prisma.Threads_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThreads_aut>
          }
          groupBy: {
            args: Prisma.threads_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Threads_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.threads_autCountArgs<ExtArgs>
            result: $Utils.Optional<Threads_autCountAggregateOutputType> | number
          }
        }
      }
      threads_clt: {
        payload: Prisma.$threads_cltPayload<ExtArgs>
        fields: Prisma.threads_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.threads_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.threads_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload>
          }
          findFirst: {
            args: Prisma.threads_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.threads_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload>
          }
          findMany: {
            args: Prisma.threads_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload>[]
          }
          create: {
            args: Prisma.threads_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload>
          }
          createMany: {
            args: Prisma.threads_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.threads_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload>
          }
          update: {
            args: Prisma.threads_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload>
          }
          deleteMany: {
            args: Prisma.threads_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.threads_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.threads_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_cltPayload>
          }
          aggregate: {
            args: Prisma.Threads_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThreads_clt>
          }
          groupBy: {
            args: Prisma.threads_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Threads_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.threads_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Threads_cltCountAggregateOutputType> | number
          }
        }
      }
      threads_goi: {
        payload: Prisma.$threads_goiPayload<ExtArgs>
        fields: Prisma.threads_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.threads_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.threads_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload>
          }
          findFirst: {
            args: Prisma.threads_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.threads_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload>
          }
          findMany: {
            args: Prisma.threads_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload>[]
          }
          create: {
            args: Prisma.threads_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload>
          }
          createMany: {
            args: Prisma.threads_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.threads_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload>
          }
          update: {
            args: Prisma.threads_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload>
          }
          deleteMany: {
            args: Prisma.threads_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.threads_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.threads_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_goiPayload>
          }
          aggregate: {
            args: Prisma.Threads_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThreads_goi>
          }
          groupBy: {
            args: Prisma.threads_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Threads_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.threads_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Threads_goiCountAggregateOutputType> | number
          }
        }
      }
      threads_spa: {
        payload: Prisma.$threads_spaPayload<ExtArgs>
        fields: Prisma.threads_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.threads_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.threads_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload>
          }
          findFirst: {
            args: Prisma.threads_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.threads_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload>
          }
          findMany: {
            args: Prisma.threads_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload>[]
          }
          create: {
            args: Prisma.threads_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload>
          }
          createMany: {
            args: Prisma.threads_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.threads_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload>
          }
          update: {
            args: Prisma.threads_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload>
          }
          deleteMany: {
            args: Prisma.threads_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.threads_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.threads_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$threads_spaPayload>
          }
          aggregate: {
            args: Prisma.Threads_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThreads_spa>
          }
          groupBy: {
            args: Prisma.threads_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Threads_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.threads_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Threads_spaCountAggregateOutputType> | number
          }
        }
      }
      tokens_generated_aut: {
        payload: Prisma.$tokens_generated_autPayload<ExtArgs>
        fields: Prisma.tokens_generated_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tokens_generated_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tokens_generated_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload>
          }
          findFirst: {
            args: Prisma.tokens_generated_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tokens_generated_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload>
          }
          findMany: {
            args: Prisma.tokens_generated_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload>[]
          }
          create: {
            args: Prisma.tokens_generated_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload>
          }
          createMany: {
            args: Prisma.tokens_generated_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tokens_generated_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload>
          }
          update: {
            args: Prisma.tokens_generated_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload>
          }
          deleteMany: {
            args: Prisma.tokens_generated_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tokens_generated_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tokens_generated_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_autPayload>
          }
          aggregate: {
            args: Prisma.Tokens_generated_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokens_generated_aut>
          }
          groupBy: {
            args: Prisma.tokens_generated_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tokens_generated_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.tokens_generated_autCountArgs<ExtArgs>
            result: $Utils.Optional<Tokens_generated_autCountAggregateOutputType> | number
          }
        }
      }
      tokens_generated_clt: {
        payload: Prisma.$tokens_generated_cltPayload<ExtArgs>
        fields: Prisma.tokens_generated_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tokens_generated_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tokens_generated_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload>
          }
          findFirst: {
            args: Prisma.tokens_generated_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tokens_generated_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload>
          }
          findMany: {
            args: Prisma.tokens_generated_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload>[]
          }
          create: {
            args: Prisma.tokens_generated_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload>
          }
          createMany: {
            args: Prisma.tokens_generated_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tokens_generated_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload>
          }
          update: {
            args: Prisma.tokens_generated_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload>
          }
          deleteMany: {
            args: Prisma.tokens_generated_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tokens_generated_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tokens_generated_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_cltPayload>
          }
          aggregate: {
            args: Prisma.Tokens_generated_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokens_generated_clt>
          }
          groupBy: {
            args: Prisma.tokens_generated_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tokens_generated_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.tokens_generated_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Tokens_generated_cltCountAggregateOutputType> | number
          }
        }
      }
      tokens_generated_goi: {
        payload: Prisma.$tokens_generated_goiPayload<ExtArgs>
        fields: Prisma.tokens_generated_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tokens_generated_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tokens_generated_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload>
          }
          findFirst: {
            args: Prisma.tokens_generated_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tokens_generated_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload>
          }
          findMany: {
            args: Prisma.tokens_generated_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload>[]
          }
          create: {
            args: Prisma.tokens_generated_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload>
          }
          createMany: {
            args: Prisma.tokens_generated_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tokens_generated_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload>
          }
          update: {
            args: Prisma.tokens_generated_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload>
          }
          deleteMany: {
            args: Prisma.tokens_generated_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tokens_generated_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tokens_generated_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_goiPayload>
          }
          aggregate: {
            args: Prisma.Tokens_generated_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokens_generated_goi>
          }
          groupBy: {
            args: Prisma.tokens_generated_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tokens_generated_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.tokens_generated_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Tokens_generated_goiCountAggregateOutputType> | number
          }
        }
      }
      tokens_generated_spa: {
        payload: Prisma.$tokens_generated_spaPayload<ExtArgs>
        fields: Prisma.tokens_generated_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tokens_generated_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tokens_generated_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload>
          }
          findFirst: {
            args: Prisma.tokens_generated_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tokens_generated_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload>
          }
          findMany: {
            args: Prisma.tokens_generated_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload>[]
          }
          create: {
            args: Prisma.tokens_generated_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload>
          }
          createMany: {
            args: Prisma.tokens_generated_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tokens_generated_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload>
          }
          update: {
            args: Prisma.tokens_generated_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload>
          }
          deleteMany: {
            args: Prisma.tokens_generated_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tokens_generated_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tokens_generated_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokens_generated_spaPayload>
          }
          aggregate: {
            args: Prisma.Tokens_generated_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokens_generated_spa>
          }
          groupBy: {
            args: Prisma.tokens_generated_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tokens_generated_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.tokens_generated_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Tokens_generated_spaCountAggregateOutputType> | number
          }
        }
      }
      trainings_links_aut: {
        payload: Prisma.$trainings_links_autPayload<ExtArgs>
        fields: Prisma.trainings_links_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trainings_links_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trainings_links_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload>
          }
          findFirst: {
            args: Prisma.trainings_links_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trainings_links_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload>
          }
          findMany: {
            args: Prisma.trainings_links_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload>[]
          }
          create: {
            args: Prisma.trainings_links_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload>
          }
          createMany: {
            args: Prisma.trainings_links_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trainings_links_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload>
          }
          update: {
            args: Prisma.trainings_links_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload>
          }
          deleteMany: {
            args: Prisma.trainings_links_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trainings_links_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trainings_links_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_autPayload>
          }
          aggregate: {
            args: Prisma.Trainings_links_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainings_links_aut>
          }
          groupBy: {
            args: Prisma.trainings_links_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trainings_links_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.trainings_links_autCountArgs<ExtArgs>
            result: $Utils.Optional<Trainings_links_autCountAggregateOutputType> | number
          }
        }
      }
      trainings_links_clt: {
        payload: Prisma.$trainings_links_cltPayload<ExtArgs>
        fields: Prisma.trainings_links_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trainings_links_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trainings_links_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload>
          }
          findFirst: {
            args: Prisma.trainings_links_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trainings_links_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload>
          }
          findMany: {
            args: Prisma.trainings_links_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload>[]
          }
          create: {
            args: Prisma.trainings_links_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload>
          }
          createMany: {
            args: Prisma.trainings_links_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trainings_links_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload>
          }
          update: {
            args: Prisma.trainings_links_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload>
          }
          deleteMany: {
            args: Prisma.trainings_links_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trainings_links_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trainings_links_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_cltPayload>
          }
          aggregate: {
            args: Prisma.Trainings_links_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainings_links_clt>
          }
          groupBy: {
            args: Prisma.trainings_links_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trainings_links_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.trainings_links_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Trainings_links_cltCountAggregateOutputType> | number
          }
        }
      }
      trainings_links_goi: {
        payload: Prisma.$trainings_links_goiPayload<ExtArgs>
        fields: Prisma.trainings_links_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trainings_links_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trainings_links_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload>
          }
          findFirst: {
            args: Prisma.trainings_links_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trainings_links_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload>
          }
          findMany: {
            args: Prisma.trainings_links_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload>[]
          }
          create: {
            args: Prisma.trainings_links_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload>
          }
          createMany: {
            args: Prisma.trainings_links_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trainings_links_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload>
          }
          update: {
            args: Prisma.trainings_links_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload>
          }
          deleteMany: {
            args: Prisma.trainings_links_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trainings_links_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trainings_links_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_goiPayload>
          }
          aggregate: {
            args: Prisma.Trainings_links_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainings_links_goi>
          }
          groupBy: {
            args: Prisma.trainings_links_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trainings_links_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.trainings_links_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Trainings_links_goiCountAggregateOutputType> | number
          }
        }
      }
      trainings_links_spa: {
        payload: Prisma.$trainings_links_spaPayload<ExtArgs>
        fields: Prisma.trainings_links_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trainings_links_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trainings_links_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload>
          }
          findFirst: {
            args: Prisma.trainings_links_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trainings_links_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload>
          }
          findMany: {
            args: Prisma.trainings_links_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload>[]
          }
          create: {
            args: Prisma.trainings_links_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload>
          }
          createMany: {
            args: Prisma.trainings_links_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trainings_links_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload>
          }
          update: {
            args: Prisma.trainings_links_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload>
          }
          deleteMany: {
            args: Prisma.trainings_links_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trainings_links_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trainings_links_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainings_links_spaPayload>
          }
          aggregate: {
            args: Prisma.Trainings_links_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainings_links_spa>
          }
          groupBy: {
            args: Prisma.trainings_links_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trainings_links_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.trainings_links_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Trainings_links_spaCountAggregateOutputType> | number
          }
        }
      }
      users_aut: {
        payload: Prisma.$users_autPayload<ExtArgs>
        fields: Prisma.users_autFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_autFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_autFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload>
          }
          findFirst: {
            args: Prisma.users_autFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_autFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload>
          }
          findMany: {
            args: Prisma.users_autFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload>[]
          }
          create: {
            args: Prisma.users_autCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload>
          }
          createMany: {
            args: Prisma.users_autCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.users_autDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload>
          }
          update: {
            args: Prisma.users_autUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload>
          }
          deleteMany: {
            args: Prisma.users_autDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.users_autUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.users_autUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_autPayload>
          }
          aggregate: {
            args: Prisma.Users_autAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_aut>
          }
          groupBy: {
            args: Prisma.users_autGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_autGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_autCountArgs<ExtArgs>
            result: $Utils.Optional<Users_autCountAggregateOutputType> | number
          }
        }
      }
      users_clt: {
        payload: Prisma.$users_cltPayload<ExtArgs>
        fields: Prisma.users_cltFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_cltFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_cltFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload>
          }
          findFirst: {
            args: Prisma.users_cltFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_cltFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload>
          }
          findMany: {
            args: Prisma.users_cltFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload>[]
          }
          create: {
            args: Prisma.users_cltCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload>
          }
          createMany: {
            args: Prisma.users_cltCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.users_cltDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload>
          }
          update: {
            args: Prisma.users_cltUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload>
          }
          deleteMany: {
            args: Prisma.users_cltDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.users_cltUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.users_cltUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_cltPayload>
          }
          aggregate: {
            args: Prisma.Users_cltAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_clt>
          }
          groupBy: {
            args: Prisma.users_cltGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_cltGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_cltCountArgs<ExtArgs>
            result: $Utils.Optional<Users_cltCountAggregateOutputType> | number
          }
        }
      }
      users_goi: {
        payload: Prisma.$users_goiPayload<ExtArgs>
        fields: Prisma.users_goiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_goiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_goiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload>
          }
          findFirst: {
            args: Prisma.users_goiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_goiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload>
          }
          findMany: {
            args: Prisma.users_goiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload>[]
          }
          create: {
            args: Prisma.users_goiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload>
          }
          createMany: {
            args: Prisma.users_goiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.users_goiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload>
          }
          update: {
            args: Prisma.users_goiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload>
          }
          deleteMany: {
            args: Prisma.users_goiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.users_goiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.users_goiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_goiPayload>
          }
          aggregate: {
            args: Prisma.Users_goiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_goi>
          }
          groupBy: {
            args: Prisma.users_goiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_goiGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_goiCountArgs<ExtArgs>
            result: $Utils.Optional<Users_goiCountAggregateOutputType> | number
          }
        }
      }
      users_spa: {
        payload: Prisma.$users_spaPayload<ExtArgs>
        fields: Prisma.users_spaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_spaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_spaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload>
          }
          findFirst: {
            args: Prisma.users_spaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_spaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload>
          }
          findMany: {
            args: Prisma.users_spaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload>[]
          }
          create: {
            args: Prisma.users_spaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload>
          }
          createMany: {
            args: Prisma.users_spaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.users_spaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload>
          }
          update: {
            args: Prisma.users_spaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload>
          }
          deleteMany: {
            args: Prisma.users_spaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.users_spaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.users_spaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_spaPayload>
          }
          aggregate: {
            args: Prisma.Users_spaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_spa>
          }
          groupBy: {
            args: Prisma.users_spaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_spaGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_spaCountArgs<ExtArgs>
            result: $Utils.Optional<Users_spaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    sequelizeMeta?: SequelizeMetaOmit
    accommodation_quotations?: accommodation_quotationsOmit
    attendant?: attendantOmit
    attendant_calls?: attendant_callsOmit
    attendants?: attendantsOmit
    budget_consults_aut?: budget_consults_autOmit
    budget_consults_clt?: budget_consults_cltOmit
    budget_consults_goi?: budget_consults_goiOmit
    budget_consults_spa?: budget_consults_spaOmit
    calls?: callsOmit
    cities_quotations?: cities_quotationsOmit
    configs_bot_aut?: configs_bot_autOmit
    configs_bot_clt?: configs_bot_cltOmit
    configs_bot_goi?: configs_bot_goiOmit
    configs_bot_spa?: configs_bot_spaOmit
    coparticipation_type_quotations?: coparticipation_type_quotationsOmit
    cpf_consults_aut?: cpf_consults_autOmit
    cpf_consults_clt?: cpf_consults_cltOmit
    cpf_consults_goi?: cpf_consults_goiOmit
    cpf_consults_spa?: cpf_consults_spaOmit
    files?: filesOmit
    maintenance_commands?: maintenance_commandsOmit
    messages_log?: messages_logOmit
    modality_assistance_quotations?: modality_assistance_quotationsOmit
    plan_group_quotations?: plan_group_quotationsOmit
    plan_type_quotations?: plan_type_quotationsOmit
    problems_clt?: problems_cltOmit
    quotation?: QuotationOmit
    quote_calculations_aut?: quote_calculations_autOmit
    quote_calculations_clt?: quote_calculations_cltOmit
    quote_calculations_goi?: quote_calculations_goiOmit
    quote_calculations_spa?: quote_calculations_spaOmit
    register_partners_aut?: register_partners_autOmit
    register_partners_spa?: register_partners_spaOmit
    rh_calls?: rh_callsOmit
    rh_numbers?: rh_numbersOmit
    seller_codes?: seller_codesOmit
    sessions_aut?: sessions_autOmit
    sessions_clt?: sessions_cltOmit
    sessions_goi?: sessions_goiOmit
    sessions_spa?: sessions_spaOmit
    supervisor_register_partners?: supervisor_register_partnersOmit
    testers_aut?: testers_autOmit
    testers_clt?: testers_cltOmit
    testers_goi?: testers_goiOmit
    testers_spa?: testers_spaOmit
    threads_aut?: threads_autOmit
    threads_clt?: threads_cltOmit
    threads_goi?: threads_goiOmit
    threads_spa?: threads_spaOmit
    tokens_generated_aut?: tokens_generated_autOmit
    tokens_generated_clt?: tokens_generated_cltOmit
    tokens_generated_goi?: tokens_generated_goiOmit
    tokens_generated_spa?: tokens_generated_spaOmit
    trainings_links_aut?: trainings_links_autOmit
    trainings_links_clt?: trainings_links_cltOmit
    trainings_links_goi?: trainings_links_goiOmit
    trainings_links_spa?: trainings_links_spaOmit
    users_aut?: users_autOmit
    users_clt?: users_cltOmit
    users_goi?: users_goiOmit
    users_spa?: users_spaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AttendantCountOutputType
   */

  export type AttendantCountOutputType = {
    calls: number
  }

  export type AttendantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calls?: boolean | AttendantCountOutputTypeCountCallsArgs
  }

  // Custom InputTypes
  /**
   * AttendantCountOutputType without action
   */
  export type AttendantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendantCountOutputType
     */
    select?: AttendantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttendantCountOutputType without action
   */
  export type AttendantCountOutputTypeCountCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: callsWhereInput
  }


  /**
   * Count Type AttendantsCountOutputType
   */

  export type AttendantsCountOutputType = {
    attendant_calls: number
  }

  export type AttendantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendant_calls?: boolean | AttendantsCountOutputTypeCountAttendant_callsArgs
  }

  // Custom InputTypes
  /**
   * AttendantsCountOutputType without action
   */
  export type AttendantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendantsCountOutputType
     */
    select?: AttendantsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttendantsCountOutputType without action
   */
  export type AttendantsCountOutputTypeCountAttendant_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendant_callsWhereInput
  }


  /**
   * Count Type Rh_numbersCountOutputType
   */

  export type Rh_numbersCountOutputType = {
    rh_calls: number
  }

  export type Rh_numbersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rh_calls?: boolean | Rh_numbersCountOutputTypeCountRh_callsArgs
  }

  // Custom InputTypes
  /**
   * Rh_numbersCountOutputType without action
   */
  export type Rh_numbersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rh_numbersCountOutputType
     */
    select?: Rh_numbersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Rh_numbersCountOutputType without action
   */
  export type Rh_numbersCountOutputTypeCountRh_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rh_callsWhereInput
  }


  /**
   * Count Type Users_autCountOutputType
   */

  export type Users_autCountOutputType = {
    budget_consults_aut: number
    cpf_consults_aut: number
    quote_calculations_aut: number
    sessions_aut: number
    threads_aut: number
    tokens_generated_aut: number
    trainings_links_aut: number
  }

  export type Users_autCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_consults_aut?: boolean | Users_autCountOutputTypeCountBudget_consults_autArgs
    cpf_consults_aut?: boolean | Users_autCountOutputTypeCountCpf_consults_autArgs
    quote_calculations_aut?: boolean | Users_autCountOutputTypeCountQuote_calculations_autArgs
    sessions_aut?: boolean | Users_autCountOutputTypeCountSessions_autArgs
    threads_aut?: boolean | Users_autCountOutputTypeCountThreads_autArgs
    tokens_generated_aut?: boolean | Users_autCountOutputTypeCountTokens_generated_autArgs
    trainings_links_aut?: boolean | Users_autCountOutputTypeCountTrainings_links_autArgs
  }

  // Custom InputTypes
  /**
   * Users_autCountOutputType without action
   */
  export type Users_autCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_autCountOutputType
     */
    select?: Users_autCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Users_autCountOutputType without action
   */
  export type Users_autCountOutputTypeCountBudget_consults_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_consults_autWhereInput
  }

  /**
   * Users_autCountOutputType without action
   */
  export type Users_autCountOutputTypeCountCpf_consults_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cpf_consults_autWhereInput
  }

  /**
   * Users_autCountOutputType without action
   */
  export type Users_autCountOutputTypeCountQuote_calculations_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_calculations_autWhereInput
  }

  /**
   * Users_autCountOutputType without action
   */
  export type Users_autCountOutputTypeCountSessions_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessions_autWhereInput
  }

  /**
   * Users_autCountOutputType without action
   */
  export type Users_autCountOutputTypeCountThreads_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: threads_autWhereInput
  }

  /**
   * Users_autCountOutputType without action
   */
  export type Users_autCountOutputTypeCountTokens_generated_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokens_generated_autWhereInput
  }

  /**
   * Users_autCountOutputType without action
   */
  export type Users_autCountOutputTypeCountTrainings_links_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainings_links_autWhereInput
  }


  /**
   * Count Type Users_cltCountOutputType
   */

  export type Users_cltCountOutputType = {
    budget_consults_clt: number
    cpf_consults_clt: number
    quote_calculations_clt: number
    sessions_clt: number
    threads_clt: number
    tokens_generated_clt: number
    trainings_links_clt: number
  }

  export type Users_cltCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_consults_clt?: boolean | Users_cltCountOutputTypeCountBudget_consults_cltArgs
    cpf_consults_clt?: boolean | Users_cltCountOutputTypeCountCpf_consults_cltArgs
    quote_calculations_clt?: boolean | Users_cltCountOutputTypeCountQuote_calculations_cltArgs
    sessions_clt?: boolean | Users_cltCountOutputTypeCountSessions_cltArgs
    threads_clt?: boolean | Users_cltCountOutputTypeCountThreads_cltArgs
    tokens_generated_clt?: boolean | Users_cltCountOutputTypeCountTokens_generated_cltArgs
    trainings_links_clt?: boolean | Users_cltCountOutputTypeCountTrainings_links_cltArgs
  }

  // Custom InputTypes
  /**
   * Users_cltCountOutputType without action
   */
  export type Users_cltCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_cltCountOutputType
     */
    select?: Users_cltCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Users_cltCountOutputType without action
   */
  export type Users_cltCountOutputTypeCountBudget_consults_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_consults_cltWhereInput
  }

  /**
   * Users_cltCountOutputType without action
   */
  export type Users_cltCountOutputTypeCountCpf_consults_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cpf_consults_cltWhereInput
  }

  /**
   * Users_cltCountOutputType without action
   */
  export type Users_cltCountOutputTypeCountQuote_calculations_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_calculations_cltWhereInput
  }

  /**
   * Users_cltCountOutputType without action
   */
  export type Users_cltCountOutputTypeCountSessions_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessions_cltWhereInput
  }

  /**
   * Users_cltCountOutputType without action
   */
  export type Users_cltCountOutputTypeCountThreads_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: threads_cltWhereInput
  }

  /**
   * Users_cltCountOutputType without action
   */
  export type Users_cltCountOutputTypeCountTokens_generated_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokens_generated_cltWhereInput
  }

  /**
   * Users_cltCountOutputType without action
   */
  export type Users_cltCountOutputTypeCountTrainings_links_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainings_links_cltWhereInput
  }


  /**
   * Count Type Users_goiCountOutputType
   */

  export type Users_goiCountOutputType = {
    budget_consults_goi: number
    cpf_consults_goi: number
    quote_calculations_goi: number
    sessions_goi: number
    threads_goi: number
    tokens_generated_goi: number
    trainings_links_goi: number
  }

  export type Users_goiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_consults_goi?: boolean | Users_goiCountOutputTypeCountBudget_consults_goiArgs
    cpf_consults_goi?: boolean | Users_goiCountOutputTypeCountCpf_consults_goiArgs
    quote_calculations_goi?: boolean | Users_goiCountOutputTypeCountQuote_calculations_goiArgs
    sessions_goi?: boolean | Users_goiCountOutputTypeCountSessions_goiArgs
    threads_goi?: boolean | Users_goiCountOutputTypeCountThreads_goiArgs
    tokens_generated_goi?: boolean | Users_goiCountOutputTypeCountTokens_generated_goiArgs
    trainings_links_goi?: boolean | Users_goiCountOutputTypeCountTrainings_links_goiArgs
  }

  // Custom InputTypes
  /**
   * Users_goiCountOutputType without action
   */
  export type Users_goiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_goiCountOutputType
     */
    select?: Users_goiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Users_goiCountOutputType without action
   */
  export type Users_goiCountOutputTypeCountBudget_consults_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_consults_goiWhereInput
  }

  /**
   * Users_goiCountOutputType without action
   */
  export type Users_goiCountOutputTypeCountCpf_consults_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cpf_consults_goiWhereInput
  }

  /**
   * Users_goiCountOutputType without action
   */
  export type Users_goiCountOutputTypeCountQuote_calculations_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_calculations_goiWhereInput
  }

  /**
   * Users_goiCountOutputType without action
   */
  export type Users_goiCountOutputTypeCountSessions_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessions_goiWhereInput
  }

  /**
   * Users_goiCountOutputType without action
   */
  export type Users_goiCountOutputTypeCountThreads_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: threads_goiWhereInput
  }

  /**
   * Users_goiCountOutputType without action
   */
  export type Users_goiCountOutputTypeCountTokens_generated_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokens_generated_goiWhereInput
  }

  /**
   * Users_goiCountOutputType without action
   */
  export type Users_goiCountOutputTypeCountTrainings_links_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainings_links_goiWhereInput
  }


  /**
   * Count Type Users_spaCountOutputType
   */

  export type Users_spaCountOutputType = {
    budget_consults_spa: number
    cpf_consults_spa: number
    quote_calculations_spa: number
    sessions_spa: number
    threads_spa: number
    tokens_generated_spa: number
    trainings_links_spa: number
  }

  export type Users_spaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_consults_spa?: boolean | Users_spaCountOutputTypeCountBudget_consults_spaArgs
    cpf_consults_spa?: boolean | Users_spaCountOutputTypeCountCpf_consults_spaArgs
    quote_calculations_spa?: boolean | Users_spaCountOutputTypeCountQuote_calculations_spaArgs
    sessions_spa?: boolean | Users_spaCountOutputTypeCountSessions_spaArgs
    threads_spa?: boolean | Users_spaCountOutputTypeCountThreads_spaArgs
    tokens_generated_spa?: boolean | Users_spaCountOutputTypeCountTokens_generated_spaArgs
    trainings_links_spa?: boolean | Users_spaCountOutputTypeCountTrainings_links_spaArgs
  }

  // Custom InputTypes
  /**
   * Users_spaCountOutputType without action
   */
  export type Users_spaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_spaCountOutputType
     */
    select?: Users_spaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Users_spaCountOutputType without action
   */
  export type Users_spaCountOutputTypeCountBudget_consults_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_consults_spaWhereInput
  }

  /**
   * Users_spaCountOutputType without action
   */
  export type Users_spaCountOutputTypeCountCpf_consults_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cpf_consults_spaWhereInput
  }

  /**
   * Users_spaCountOutputType without action
   */
  export type Users_spaCountOutputTypeCountQuote_calculations_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_calculations_spaWhereInput
  }

  /**
   * Users_spaCountOutputType without action
   */
  export type Users_spaCountOutputTypeCountSessions_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessions_spaWhereInput
  }

  /**
   * Users_spaCountOutputType without action
   */
  export type Users_spaCountOutputTypeCountThreads_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: threads_spaWhereInput
  }

  /**
   * Users_spaCountOutputType without action
   */
  export type Users_spaCountOutputTypeCountTokens_generated_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokens_generated_spaWhereInput
  }

  /**
   * Users_spaCountOutputType without action
   */
  export type Users_spaCountOutputTypeCountTrainings_links_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainings_links_spaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SequelizeMeta
   */

  export type AggregateSequelizeMeta = {
    _count: SequelizeMetaCountAggregateOutputType | null
    _min: SequelizeMetaMinAggregateOutputType | null
    _max: SequelizeMetaMaxAggregateOutputType | null
  }

  export type SequelizeMetaMinAggregateOutputType = {
    name: string | null
  }

  export type SequelizeMetaMaxAggregateOutputType = {
    name: string | null
  }

  export type SequelizeMetaCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type SequelizeMetaMinAggregateInputType = {
    name?: true
  }

  export type SequelizeMetaMaxAggregateInputType = {
    name?: true
  }

  export type SequelizeMetaCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type SequelizeMetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SequelizeMeta to aggregate.
     */
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     */
    orderBy?: SequelizeMetaOrderByWithRelationInput | SequelizeMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SequelizeMetas
    **/
    _count?: true | SequelizeMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SequelizeMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SequelizeMetaMaxAggregateInputType
  }

  export type GetSequelizeMetaAggregateType<T extends SequelizeMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateSequelizeMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSequelizeMeta[P]>
      : GetScalarType<T[P], AggregateSequelizeMeta[P]>
  }




  export type SequelizeMetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SequelizeMetaWhereInput
    orderBy?: SequelizeMetaOrderByWithAggregationInput | SequelizeMetaOrderByWithAggregationInput[]
    by: SequelizeMetaScalarFieldEnum[] | SequelizeMetaScalarFieldEnum
    having?: SequelizeMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SequelizeMetaCountAggregateInputType | true
    _min?: SequelizeMetaMinAggregateInputType
    _max?: SequelizeMetaMaxAggregateInputType
  }

  export type SequelizeMetaGroupByOutputType = {
    name: string
    _count: SequelizeMetaCountAggregateOutputType | null
    _min: SequelizeMetaMinAggregateOutputType | null
    _max: SequelizeMetaMaxAggregateOutputType | null
  }

  type GetSequelizeMetaGroupByPayload<T extends SequelizeMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SequelizeMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SequelizeMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SequelizeMetaGroupByOutputType[P]>
            : GetScalarType<T[P], SequelizeMetaGroupByOutputType[P]>
        }
      >
    >


  export type SequelizeMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
  }, ExtArgs["result"]["sequelizeMeta"]>



  export type SequelizeMetaSelectScalar = {
    name?: boolean
  }

  export type SequelizeMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name", ExtArgs["result"]["sequelizeMeta"]>

  export type $SequelizeMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SequelizeMeta"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
    }, ExtArgs["result"]["sequelizeMeta"]>
    composites: {}
  }

  type SequelizeMetaGetPayload<S extends boolean | null | undefined | SequelizeMetaDefaultArgs> = $Result.GetResult<Prisma.$SequelizeMetaPayload, S>

  type SequelizeMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SequelizeMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SequelizeMetaCountAggregateInputType | true
    }

  export interface SequelizeMetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SequelizeMeta'], meta: { name: 'SequelizeMeta' } }
    /**
     * Find zero or one SequelizeMeta that matches the filter.
     * @param {SequelizeMetaFindUniqueArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SequelizeMetaFindUniqueArgs>(args: SelectSubset<T, SequelizeMetaFindUniqueArgs<ExtArgs>>): Prisma__SequelizeMetaClient<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SequelizeMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SequelizeMetaFindUniqueOrThrowArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SequelizeMetaFindUniqueOrThrowArgs>(args: SelectSubset<T, SequelizeMetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SequelizeMetaClient<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SequelizeMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindFirstArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SequelizeMetaFindFirstArgs>(args?: SelectSubset<T, SequelizeMetaFindFirstArgs<ExtArgs>>): Prisma__SequelizeMetaClient<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SequelizeMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindFirstOrThrowArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SequelizeMetaFindFirstOrThrowArgs>(args?: SelectSubset<T, SequelizeMetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__SequelizeMetaClient<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SequelizeMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SequelizeMetas
     * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
     * 
     * // Get first 10 SequelizeMetas
     * const sequelizeMetas = await prisma.sequelizeMeta.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sequelizeMetaWithNameOnly = await prisma.sequelizeMeta.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends SequelizeMetaFindManyArgs>(args?: SelectSubset<T, SequelizeMetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SequelizeMeta.
     * @param {SequelizeMetaCreateArgs} args - Arguments to create a SequelizeMeta.
     * @example
     * // Create one SequelizeMeta
     * const SequelizeMeta = await prisma.sequelizeMeta.create({
     *   data: {
     *     // ... data to create a SequelizeMeta
     *   }
     * })
     * 
     */
    create<T extends SequelizeMetaCreateArgs>(args: SelectSubset<T, SequelizeMetaCreateArgs<ExtArgs>>): Prisma__SequelizeMetaClient<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SequelizeMetas.
     * @param {SequelizeMetaCreateManyArgs} args - Arguments to create many SequelizeMetas.
     * @example
     * // Create many SequelizeMetas
     * const sequelizeMeta = await prisma.sequelizeMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SequelizeMetaCreateManyArgs>(args?: SelectSubset<T, SequelizeMetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SequelizeMeta.
     * @param {SequelizeMetaDeleteArgs} args - Arguments to delete one SequelizeMeta.
     * @example
     * // Delete one SequelizeMeta
     * const SequelizeMeta = await prisma.sequelizeMeta.delete({
     *   where: {
     *     // ... filter to delete one SequelizeMeta
     *   }
     * })
     * 
     */
    delete<T extends SequelizeMetaDeleteArgs>(args: SelectSubset<T, SequelizeMetaDeleteArgs<ExtArgs>>): Prisma__SequelizeMetaClient<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SequelizeMeta.
     * @param {SequelizeMetaUpdateArgs} args - Arguments to update one SequelizeMeta.
     * @example
     * // Update one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SequelizeMetaUpdateArgs>(args: SelectSubset<T, SequelizeMetaUpdateArgs<ExtArgs>>): Prisma__SequelizeMetaClient<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SequelizeMetas.
     * @param {SequelizeMetaDeleteManyArgs} args - Arguments to filter SequelizeMetas to delete.
     * @example
     * // Delete a few SequelizeMetas
     * const { count } = await prisma.sequelizeMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SequelizeMetaDeleteManyArgs>(args?: SelectSubset<T, SequelizeMetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SequelizeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SequelizeMetas
     * const sequelizeMeta = await prisma.sequelizeMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SequelizeMetaUpdateManyArgs>(args: SelectSubset<T, SequelizeMetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SequelizeMeta.
     * @param {SequelizeMetaUpsertArgs} args - Arguments to update or create a SequelizeMeta.
     * @example
     * // Update or create a SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.upsert({
     *   create: {
     *     // ... data to create a SequelizeMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SequelizeMeta we want to update
     *   }
     * })
     */
    upsert<T extends SequelizeMetaUpsertArgs>(args: SelectSubset<T, SequelizeMetaUpsertArgs<ExtArgs>>): Prisma__SequelizeMetaClient<$Result.GetResult<Prisma.$SequelizeMetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SequelizeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaCountArgs} args - Arguments to filter SequelizeMetas to count.
     * @example
     * // Count the number of SequelizeMetas
     * const count = await prisma.sequelizeMeta.count({
     *   where: {
     *     // ... the filter for the SequelizeMetas we want to count
     *   }
     * })
    **/
    count<T extends SequelizeMetaCountArgs>(
      args?: Subset<T, SequelizeMetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SequelizeMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SequelizeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SequelizeMetaAggregateArgs>(args: Subset<T, SequelizeMetaAggregateArgs>): Prisma.PrismaPromise<GetSequelizeMetaAggregateType<T>>

    /**
     * Group by SequelizeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SequelizeMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SequelizeMetaGroupByArgs['orderBy'] }
        : { orderBy?: SequelizeMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SequelizeMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSequelizeMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SequelizeMeta model
   */
  readonly fields: SequelizeMetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SequelizeMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SequelizeMetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SequelizeMeta model
   */
  interface SequelizeMetaFieldRefs {
    readonly name: FieldRef<"SequelizeMeta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SequelizeMeta findUnique
   */
  export type SequelizeMetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * Filter, which SequelizeMeta to fetch.
     */
    where: SequelizeMetaWhereUniqueInput
  }

  /**
   * SequelizeMeta findUniqueOrThrow
   */
  export type SequelizeMetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * Filter, which SequelizeMeta to fetch.
     */
    where: SequelizeMetaWhereUniqueInput
  }

  /**
   * SequelizeMeta findFirst
   */
  export type SequelizeMetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * Filter, which SequelizeMeta to fetch.
     */
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     */
    orderBy?: SequelizeMetaOrderByWithRelationInput | SequelizeMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequelizeMetas.
     */
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequelizeMetas.
     */
    distinct?: SequelizeMetaScalarFieldEnum | SequelizeMetaScalarFieldEnum[]
  }

  /**
   * SequelizeMeta findFirstOrThrow
   */
  export type SequelizeMetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * Filter, which SequelizeMeta to fetch.
     */
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     */
    orderBy?: SequelizeMetaOrderByWithRelationInput | SequelizeMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequelizeMetas.
     */
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequelizeMetas.
     */
    distinct?: SequelizeMetaScalarFieldEnum | SequelizeMetaScalarFieldEnum[]
  }

  /**
   * SequelizeMeta findMany
   */
  export type SequelizeMetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * Filter, which SequelizeMetas to fetch.
     */
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     */
    orderBy?: SequelizeMetaOrderByWithRelationInput | SequelizeMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SequelizeMetas.
     */
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     */
    skip?: number
    distinct?: SequelizeMetaScalarFieldEnum | SequelizeMetaScalarFieldEnum[]
  }

  /**
   * SequelizeMeta create
   */
  export type SequelizeMetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * The data needed to create a SequelizeMeta.
     */
    data: XOR<SequelizeMetaCreateInput, SequelizeMetaUncheckedCreateInput>
  }

  /**
   * SequelizeMeta createMany
   */
  export type SequelizeMetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SequelizeMetas.
     */
    data: SequelizeMetaCreateManyInput | SequelizeMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SequelizeMeta update
   */
  export type SequelizeMetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * The data needed to update a SequelizeMeta.
     */
    data: XOR<SequelizeMetaUpdateInput, SequelizeMetaUncheckedUpdateInput>
    /**
     * Choose, which SequelizeMeta to update.
     */
    where: SequelizeMetaWhereUniqueInput
  }

  /**
   * SequelizeMeta updateMany
   */
  export type SequelizeMetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SequelizeMetas.
     */
    data: XOR<SequelizeMetaUpdateManyMutationInput, SequelizeMetaUncheckedUpdateManyInput>
    /**
     * Filter which SequelizeMetas to update
     */
    where?: SequelizeMetaWhereInput
    /**
     * Limit how many SequelizeMetas to update.
     */
    limit?: number
  }

  /**
   * SequelizeMeta upsert
   */
  export type SequelizeMetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * The filter to search for the SequelizeMeta to update in case it exists.
     */
    where: SequelizeMetaWhereUniqueInput
    /**
     * In case the SequelizeMeta found by the `where` argument doesn't exist, create a new SequelizeMeta with this data.
     */
    create: XOR<SequelizeMetaCreateInput, SequelizeMetaUncheckedCreateInput>
    /**
     * In case the SequelizeMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SequelizeMetaUpdateInput, SequelizeMetaUncheckedUpdateInput>
  }

  /**
   * SequelizeMeta delete
   */
  export type SequelizeMetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
    /**
     * Filter which SequelizeMeta to delete.
     */
    where: SequelizeMetaWhereUniqueInput
  }

  /**
   * SequelizeMeta deleteMany
   */
  export type SequelizeMetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SequelizeMetas to delete
     */
    where?: SequelizeMetaWhereInput
    /**
     * Limit how many SequelizeMetas to delete.
     */
    limit?: number
  }

  /**
   * SequelizeMeta without action
   */
  export type SequelizeMetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SequelizeMeta
     */
    omit?: SequelizeMetaOmit<ExtArgs> | null
  }


  /**
   * Model accommodation_quotations
   */

  export type AggregateAccommodation_quotations = {
    _count: Accommodation_quotationsCountAggregateOutputType | null
    _avg: Accommodation_quotationsAvgAggregateOutputType | null
    _sum: Accommodation_quotationsSumAggregateOutputType | null
    _min: Accommodation_quotationsMinAggregateOutputType | null
    _max: Accommodation_quotationsMaxAggregateOutputType | null
  }

  export type Accommodation_quotationsAvgAggregateOutputType = {
    id: number | null
  }

  export type Accommodation_quotationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Accommodation_quotationsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Accommodation_quotationsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Accommodation_quotationsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Accommodation_quotationsAvgAggregateInputType = {
    id?: true
  }

  export type Accommodation_quotationsSumAggregateInputType = {
    id?: true
  }

  export type Accommodation_quotationsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Accommodation_quotationsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Accommodation_quotationsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Accommodation_quotationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accommodation_quotations to aggregate.
     */
    where?: accommodation_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accommodation_quotations to fetch.
     */
    orderBy?: accommodation_quotationsOrderByWithRelationInput | accommodation_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accommodation_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accommodation_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accommodation_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accommodation_quotations
    **/
    _count?: true | Accommodation_quotationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Accommodation_quotationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Accommodation_quotationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Accommodation_quotationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Accommodation_quotationsMaxAggregateInputType
  }

  export type GetAccommodation_quotationsAggregateType<T extends Accommodation_quotationsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccommodation_quotations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccommodation_quotations[P]>
      : GetScalarType<T[P], AggregateAccommodation_quotations[P]>
  }




  export type accommodation_quotationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accommodation_quotationsWhereInput
    orderBy?: accommodation_quotationsOrderByWithAggregationInput | accommodation_quotationsOrderByWithAggregationInput[]
    by: Accommodation_quotationsScalarFieldEnum[] | Accommodation_quotationsScalarFieldEnum
    having?: accommodation_quotationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Accommodation_quotationsCountAggregateInputType | true
    _avg?: Accommodation_quotationsAvgAggregateInputType
    _sum?: Accommodation_quotationsSumAggregateInputType
    _min?: Accommodation_quotationsMinAggregateInputType
    _max?: Accommodation_quotationsMaxAggregateInputType
  }

  export type Accommodation_quotationsGroupByOutputType = {
    id: bigint
    name: string
    _count: Accommodation_quotationsCountAggregateOutputType | null
    _avg: Accommodation_quotationsAvgAggregateOutputType | null
    _sum: Accommodation_quotationsSumAggregateOutputType | null
    _min: Accommodation_quotationsMinAggregateOutputType | null
    _max: Accommodation_quotationsMaxAggregateOutputType | null
  }

  type GetAccommodation_quotationsGroupByPayload<T extends accommodation_quotationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Accommodation_quotationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Accommodation_quotationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Accommodation_quotationsGroupByOutputType[P]>
            : GetScalarType<T[P], Accommodation_quotationsGroupByOutputType[P]>
        }
      >
    >


  export type accommodation_quotationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["accommodation_quotations"]>



  export type accommodation_quotationsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type accommodation_quotationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["accommodation_quotations"]>

  export type $accommodation_quotationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accommodation_quotations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["accommodation_quotations"]>
    composites: {}
  }

  type accommodation_quotationsGetPayload<S extends boolean | null | undefined | accommodation_quotationsDefaultArgs> = $Result.GetResult<Prisma.$accommodation_quotationsPayload, S>

  type accommodation_quotationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accommodation_quotationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Accommodation_quotationsCountAggregateInputType | true
    }

  export interface accommodation_quotationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accommodation_quotations'], meta: { name: 'accommodation_quotations' } }
    /**
     * Find zero or one Accommodation_quotations that matches the filter.
     * @param {accommodation_quotationsFindUniqueArgs} args - Arguments to find a Accommodation_quotations
     * @example
     * // Get one Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accommodation_quotationsFindUniqueArgs>(args: SelectSubset<T, accommodation_quotationsFindUniqueArgs<ExtArgs>>): Prisma__accommodation_quotationsClient<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accommodation_quotations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accommodation_quotationsFindUniqueOrThrowArgs} args - Arguments to find a Accommodation_quotations
     * @example
     * // Get one Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accommodation_quotationsFindUniqueOrThrowArgs>(args: SelectSubset<T, accommodation_quotationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accommodation_quotationsClient<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accommodation_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accommodation_quotationsFindFirstArgs} args - Arguments to find a Accommodation_quotations
     * @example
     * // Get one Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accommodation_quotationsFindFirstArgs>(args?: SelectSubset<T, accommodation_quotationsFindFirstArgs<ExtArgs>>): Prisma__accommodation_quotationsClient<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accommodation_quotations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accommodation_quotationsFindFirstOrThrowArgs} args - Arguments to find a Accommodation_quotations
     * @example
     * // Get one Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accommodation_quotationsFindFirstOrThrowArgs>(args?: SelectSubset<T, accommodation_quotationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accommodation_quotationsClient<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accommodation_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accommodation_quotationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.findMany()
     * 
     * // Get first 10 Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accommodation_quotationsWithIdOnly = await prisma.accommodation_quotations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accommodation_quotationsFindManyArgs>(args?: SelectSubset<T, accommodation_quotationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accommodation_quotations.
     * @param {accommodation_quotationsCreateArgs} args - Arguments to create a Accommodation_quotations.
     * @example
     * // Create one Accommodation_quotations
     * const Accommodation_quotations = await prisma.accommodation_quotations.create({
     *   data: {
     *     // ... data to create a Accommodation_quotations
     *   }
     * })
     * 
     */
    create<T extends accommodation_quotationsCreateArgs>(args: SelectSubset<T, accommodation_quotationsCreateArgs<ExtArgs>>): Prisma__accommodation_quotationsClient<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accommodation_quotations.
     * @param {accommodation_quotationsCreateManyArgs} args - Arguments to create many Accommodation_quotations.
     * @example
     * // Create many Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accommodation_quotationsCreateManyArgs>(args?: SelectSubset<T, accommodation_quotationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accommodation_quotations.
     * @param {accommodation_quotationsDeleteArgs} args - Arguments to delete one Accommodation_quotations.
     * @example
     * // Delete one Accommodation_quotations
     * const Accommodation_quotations = await prisma.accommodation_quotations.delete({
     *   where: {
     *     // ... filter to delete one Accommodation_quotations
     *   }
     * })
     * 
     */
    delete<T extends accommodation_quotationsDeleteArgs>(args: SelectSubset<T, accommodation_quotationsDeleteArgs<ExtArgs>>): Prisma__accommodation_quotationsClient<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accommodation_quotations.
     * @param {accommodation_quotationsUpdateArgs} args - Arguments to update one Accommodation_quotations.
     * @example
     * // Update one Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accommodation_quotationsUpdateArgs>(args: SelectSubset<T, accommodation_quotationsUpdateArgs<ExtArgs>>): Prisma__accommodation_quotationsClient<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accommodation_quotations.
     * @param {accommodation_quotationsDeleteManyArgs} args - Arguments to filter Accommodation_quotations to delete.
     * @example
     * // Delete a few Accommodation_quotations
     * const { count } = await prisma.accommodation_quotations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accommodation_quotationsDeleteManyArgs>(args?: SelectSubset<T, accommodation_quotationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accommodation_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accommodation_quotationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accommodation_quotationsUpdateManyArgs>(args: SelectSubset<T, accommodation_quotationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accommodation_quotations.
     * @param {accommodation_quotationsUpsertArgs} args - Arguments to update or create a Accommodation_quotations.
     * @example
     * // Update or create a Accommodation_quotations
     * const accommodation_quotations = await prisma.accommodation_quotations.upsert({
     *   create: {
     *     // ... data to create a Accommodation_quotations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accommodation_quotations we want to update
     *   }
     * })
     */
    upsert<T extends accommodation_quotationsUpsertArgs>(args: SelectSubset<T, accommodation_quotationsUpsertArgs<ExtArgs>>): Prisma__accommodation_quotationsClient<$Result.GetResult<Prisma.$accommodation_quotationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accommodation_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accommodation_quotationsCountArgs} args - Arguments to filter Accommodation_quotations to count.
     * @example
     * // Count the number of Accommodation_quotations
     * const count = await prisma.accommodation_quotations.count({
     *   where: {
     *     // ... the filter for the Accommodation_quotations we want to count
     *   }
     * })
    **/
    count<T extends accommodation_quotationsCountArgs>(
      args?: Subset<T, accommodation_quotationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Accommodation_quotationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accommodation_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Accommodation_quotationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Accommodation_quotationsAggregateArgs>(args: Subset<T, Accommodation_quotationsAggregateArgs>): Prisma.PrismaPromise<GetAccommodation_quotationsAggregateType<T>>

    /**
     * Group by Accommodation_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accommodation_quotationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accommodation_quotationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accommodation_quotationsGroupByArgs['orderBy'] }
        : { orderBy?: accommodation_quotationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accommodation_quotationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccommodation_quotationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accommodation_quotations model
   */
  readonly fields: accommodation_quotationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accommodation_quotations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accommodation_quotationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accommodation_quotations model
   */
  interface accommodation_quotationsFieldRefs {
    readonly id: FieldRef<"accommodation_quotations", 'BigInt'>
    readonly name: FieldRef<"accommodation_quotations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * accommodation_quotations findUnique
   */
  export type accommodation_quotationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which accommodation_quotations to fetch.
     */
    where: accommodation_quotationsWhereUniqueInput
  }

  /**
   * accommodation_quotations findUniqueOrThrow
   */
  export type accommodation_quotationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which accommodation_quotations to fetch.
     */
    where: accommodation_quotationsWhereUniqueInput
  }

  /**
   * accommodation_quotations findFirst
   */
  export type accommodation_quotationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which accommodation_quotations to fetch.
     */
    where?: accommodation_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accommodation_quotations to fetch.
     */
    orderBy?: accommodation_quotationsOrderByWithRelationInput | accommodation_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accommodation_quotations.
     */
    cursor?: accommodation_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accommodation_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accommodation_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accommodation_quotations.
     */
    distinct?: Accommodation_quotationsScalarFieldEnum | Accommodation_quotationsScalarFieldEnum[]
  }

  /**
   * accommodation_quotations findFirstOrThrow
   */
  export type accommodation_quotationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which accommodation_quotations to fetch.
     */
    where?: accommodation_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accommodation_quotations to fetch.
     */
    orderBy?: accommodation_quotationsOrderByWithRelationInput | accommodation_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accommodation_quotations.
     */
    cursor?: accommodation_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accommodation_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accommodation_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accommodation_quotations.
     */
    distinct?: Accommodation_quotationsScalarFieldEnum | Accommodation_quotationsScalarFieldEnum[]
  }

  /**
   * accommodation_quotations findMany
   */
  export type accommodation_quotationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which accommodation_quotations to fetch.
     */
    where?: accommodation_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accommodation_quotations to fetch.
     */
    orderBy?: accommodation_quotationsOrderByWithRelationInput | accommodation_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accommodation_quotations.
     */
    cursor?: accommodation_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accommodation_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accommodation_quotations.
     */
    skip?: number
    distinct?: Accommodation_quotationsScalarFieldEnum | Accommodation_quotationsScalarFieldEnum[]
  }

  /**
   * accommodation_quotations create
   */
  export type accommodation_quotationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to create a accommodation_quotations.
     */
    data: XOR<accommodation_quotationsCreateInput, accommodation_quotationsUncheckedCreateInput>
  }

  /**
   * accommodation_quotations createMany
   */
  export type accommodation_quotationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accommodation_quotations.
     */
    data: accommodation_quotationsCreateManyInput | accommodation_quotationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accommodation_quotations update
   */
  export type accommodation_quotationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to update a accommodation_quotations.
     */
    data: XOR<accommodation_quotationsUpdateInput, accommodation_quotationsUncheckedUpdateInput>
    /**
     * Choose, which accommodation_quotations to update.
     */
    where: accommodation_quotationsWhereUniqueInput
  }

  /**
   * accommodation_quotations updateMany
   */
  export type accommodation_quotationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accommodation_quotations.
     */
    data: XOR<accommodation_quotationsUpdateManyMutationInput, accommodation_quotationsUncheckedUpdateManyInput>
    /**
     * Filter which accommodation_quotations to update
     */
    where?: accommodation_quotationsWhereInput
    /**
     * Limit how many accommodation_quotations to update.
     */
    limit?: number
  }

  /**
   * accommodation_quotations upsert
   */
  export type accommodation_quotationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * The filter to search for the accommodation_quotations to update in case it exists.
     */
    where: accommodation_quotationsWhereUniqueInput
    /**
     * In case the accommodation_quotations found by the `where` argument doesn't exist, create a new accommodation_quotations with this data.
     */
    create: XOR<accommodation_quotationsCreateInput, accommodation_quotationsUncheckedCreateInput>
    /**
     * In case the accommodation_quotations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accommodation_quotationsUpdateInput, accommodation_quotationsUncheckedUpdateInput>
  }

  /**
   * accommodation_quotations delete
   */
  export type accommodation_quotationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
    /**
     * Filter which accommodation_quotations to delete.
     */
    where: accommodation_quotationsWhereUniqueInput
  }

  /**
   * accommodation_quotations deleteMany
   */
  export type accommodation_quotationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accommodation_quotations to delete
     */
    where?: accommodation_quotationsWhereInput
    /**
     * Limit how many accommodation_quotations to delete.
     */
    limit?: number
  }

  /**
   * accommodation_quotations without action
   */
  export type accommodation_quotationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accommodation_quotations
     */
    select?: accommodation_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accommodation_quotations
     */
    omit?: accommodation_quotationsOmit<ExtArgs> | null
  }


  /**
   * Model attendant
   */

  export type AggregateAttendant = {
    _count: AttendantCountAggregateOutputType | null
    _min: AttendantMinAggregateOutputType | null
    _max: AttendantMaxAggregateOutputType | null
  }

  export type AttendantMinAggregateOutputType = {
    id: string | null
    jid: string | null
    name: string | null
    password: string | null
    token: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendantMaxAggregateOutputType = {
    id: string | null
    jid: string | null
    name: string | null
    password: string | null
    token: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendantCountAggregateOutputType = {
    id: number
    jid: number
    name: number
    password: number
    token: number
    isAdmin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendantMinAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    password?: true
    token?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendantMaxAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    password?: true
    token?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendantCountAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    password?: true
    token?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendant to aggregate.
     */
    where?: attendantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendants to fetch.
     */
    orderBy?: attendantOrderByWithRelationInput | attendantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendants
    **/
    _count?: true | AttendantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendantMaxAggregateInputType
  }

  export type GetAttendantAggregateType<T extends AttendantAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendant[P]>
      : GetScalarType<T[P], AggregateAttendant[P]>
  }




  export type attendantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendantWhereInput
    orderBy?: attendantOrderByWithAggregationInput | attendantOrderByWithAggregationInput[]
    by: AttendantScalarFieldEnum[] | AttendantScalarFieldEnum
    having?: attendantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendantCountAggregateInputType | true
    _min?: AttendantMinAggregateInputType
    _max?: AttendantMaxAggregateInputType
  }

  export type AttendantGroupByOutputType = {
    id: string
    jid: string
    name: string
    password: string
    token: string | null
    isAdmin: boolean
    createdAt: Date
    updatedAt: Date
    _count: AttendantCountAggregateOutputType | null
    _min: AttendantMinAggregateOutputType | null
    _max: AttendantMaxAggregateOutputType | null
  }

  type GetAttendantGroupByPayload<T extends attendantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendantGroupByOutputType[P]>
            : GetScalarType<T[P], AttendantGroupByOutputType[P]>
        }
      >
    >


  export type attendantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jid?: boolean
    name?: boolean
    password?: boolean
    token?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calls?: boolean | attendant$callsArgs<ExtArgs>
    _count?: boolean | AttendantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendant"]>



  export type attendantSelectScalar = {
    id?: boolean
    jid?: boolean
    name?: boolean
    password?: boolean
    token?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type attendantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jid" | "name" | "password" | "token" | "isAdmin" | "createdAt" | "updatedAt", ExtArgs["result"]["attendant"]>
  export type attendantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calls?: boolean | attendant$callsArgs<ExtArgs>
    _count?: boolean | AttendantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $attendantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendant"
    objects: {
      calls: Prisma.$callsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jid: string
      name: string
      password: string
      token: string | null
      isAdmin: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendant"]>
    composites: {}
  }

  type attendantGetPayload<S extends boolean | null | undefined | attendantDefaultArgs> = $Result.GetResult<Prisma.$attendantPayload, S>

  type attendantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendantCountAggregateInputType | true
    }

  export interface attendantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendant'], meta: { name: 'attendant' } }
    /**
     * Find zero or one Attendant that matches the filter.
     * @param {attendantFindUniqueArgs} args - Arguments to find a Attendant
     * @example
     * // Get one Attendant
     * const attendant = await prisma.attendant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendantFindUniqueArgs>(args: SelectSubset<T, attendantFindUniqueArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendantFindUniqueOrThrowArgs} args - Arguments to find a Attendant
     * @example
     * // Get one Attendant
     * const attendant = await prisma.attendant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendantFindUniqueOrThrowArgs>(args: SelectSubset<T, attendantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantFindFirstArgs} args - Arguments to find a Attendant
     * @example
     * // Get one Attendant
     * const attendant = await prisma.attendant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendantFindFirstArgs>(args?: SelectSubset<T, attendantFindFirstArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantFindFirstOrThrowArgs} args - Arguments to find a Attendant
     * @example
     * // Get one Attendant
     * const attendant = await prisma.attendant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendantFindFirstOrThrowArgs>(args?: SelectSubset<T, attendantFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendants
     * const attendants = await prisma.attendant.findMany()
     * 
     * // Get first 10 Attendants
     * const attendants = await prisma.attendant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendantWithIdOnly = await prisma.attendant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendantFindManyArgs>(args?: SelectSubset<T, attendantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendant.
     * @param {attendantCreateArgs} args - Arguments to create a Attendant.
     * @example
     * // Create one Attendant
     * const Attendant = await prisma.attendant.create({
     *   data: {
     *     // ... data to create a Attendant
     *   }
     * })
     * 
     */
    create<T extends attendantCreateArgs>(args: SelectSubset<T, attendantCreateArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendants.
     * @param {attendantCreateManyArgs} args - Arguments to create many Attendants.
     * @example
     * // Create many Attendants
     * const attendant = await prisma.attendant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendantCreateManyArgs>(args?: SelectSubset<T, attendantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendant.
     * @param {attendantDeleteArgs} args - Arguments to delete one Attendant.
     * @example
     * // Delete one Attendant
     * const Attendant = await prisma.attendant.delete({
     *   where: {
     *     // ... filter to delete one Attendant
     *   }
     * })
     * 
     */
    delete<T extends attendantDeleteArgs>(args: SelectSubset<T, attendantDeleteArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendant.
     * @param {attendantUpdateArgs} args - Arguments to update one Attendant.
     * @example
     * // Update one Attendant
     * const attendant = await prisma.attendant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendantUpdateArgs>(args: SelectSubset<T, attendantUpdateArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendants.
     * @param {attendantDeleteManyArgs} args - Arguments to filter Attendants to delete.
     * @example
     * // Delete a few Attendants
     * const { count } = await prisma.attendant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendantDeleteManyArgs>(args?: SelectSubset<T, attendantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendants
     * const attendant = await prisma.attendant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendantUpdateManyArgs>(args: SelectSubset<T, attendantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendant.
     * @param {attendantUpsertArgs} args - Arguments to update or create a Attendant.
     * @example
     * // Update or create a Attendant
     * const attendant = await prisma.attendant.upsert({
     *   create: {
     *     // ... data to create a Attendant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendant we want to update
     *   }
     * })
     */
    upsert<T extends attendantUpsertArgs>(args: SelectSubset<T, attendantUpsertArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantCountArgs} args - Arguments to filter Attendants to count.
     * @example
     * // Count the number of Attendants
     * const count = await prisma.attendant.count({
     *   where: {
     *     // ... the filter for the Attendants we want to count
     *   }
     * })
    **/
    count<T extends attendantCountArgs>(
      args?: Subset<T, attendantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendantAggregateArgs>(args: Subset<T, AttendantAggregateArgs>): Prisma.PrismaPromise<GetAttendantAggregateType<T>>

    /**
     * Group by Attendant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendantGroupByArgs['orderBy'] }
        : { orderBy?: attendantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendant model
   */
  readonly fields: attendantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calls<T extends attendant$callsArgs<ExtArgs> = {}>(args?: Subset<T, attendant$callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendant model
   */
  interface attendantFieldRefs {
    readonly id: FieldRef<"attendant", 'String'>
    readonly jid: FieldRef<"attendant", 'String'>
    readonly name: FieldRef<"attendant", 'String'>
    readonly password: FieldRef<"attendant", 'String'>
    readonly token: FieldRef<"attendant", 'String'>
    readonly isAdmin: FieldRef<"attendant", 'Boolean'>
    readonly createdAt: FieldRef<"attendant", 'DateTime'>
    readonly updatedAt: FieldRef<"attendant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attendant findUnique
   */
  export type attendantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * Filter, which attendant to fetch.
     */
    where: attendantWhereUniqueInput
  }

  /**
   * attendant findUniqueOrThrow
   */
  export type attendantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * Filter, which attendant to fetch.
     */
    where: attendantWhereUniqueInput
  }

  /**
   * attendant findFirst
   */
  export type attendantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * Filter, which attendant to fetch.
     */
    where?: attendantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendants to fetch.
     */
    orderBy?: attendantOrderByWithRelationInput | attendantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendants.
     */
    cursor?: attendantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendants.
     */
    distinct?: AttendantScalarFieldEnum | AttendantScalarFieldEnum[]
  }

  /**
   * attendant findFirstOrThrow
   */
  export type attendantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * Filter, which attendant to fetch.
     */
    where?: attendantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendants to fetch.
     */
    orderBy?: attendantOrderByWithRelationInput | attendantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendants.
     */
    cursor?: attendantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendants.
     */
    distinct?: AttendantScalarFieldEnum | AttendantScalarFieldEnum[]
  }

  /**
   * attendant findMany
   */
  export type attendantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * Filter, which attendants to fetch.
     */
    where?: attendantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendants to fetch.
     */
    orderBy?: attendantOrderByWithRelationInput | attendantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendants.
     */
    cursor?: attendantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendants.
     */
    skip?: number
    distinct?: AttendantScalarFieldEnum | AttendantScalarFieldEnum[]
  }

  /**
   * attendant create
   */
  export type attendantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * The data needed to create a attendant.
     */
    data: XOR<attendantCreateInput, attendantUncheckedCreateInput>
  }

  /**
   * attendant createMany
   */
  export type attendantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendants.
     */
    data: attendantCreateManyInput | attendantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendant update
   */
  export type attendantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * The data needed to update a attendant.
     */
    data: XOR<attendantUpdateInput, attendantUncheckedUpdateInput>
    /**
     * Choose, which attendant to update.
     */
    where: attendantWhereUniqueInput
  }

  /**
   * attendant updateMany
   */
  export type attendantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendants.
     */
    data: XOR<attendantUpdateManyMutationInput, attendantUncheckedUpdateManyInput>
    /**
     * Filter which attendants to update
     */
    where?: attendantWhereInput
    /**
     * Limit how many attendants to update.
     */
    limit?: number
  }

  /**
   * attendant upsert
   */
  export type attendantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * The filter to search for the attendant to update in case it exists.
     */
    where: attendantWhereUniqueInput
    /**
     * In case the attendant found by the `where` argument doesn't exist, create a new attendant with this data.
     */
    create: XOR<attendantCreateInput, attendantUncheckedCreateInput>
    /**
     * In case the attendant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendantUpdateInput, attendantUncheckedUpdateInput>
  }

  /**
   * attendant delete
   */
  export type attendantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    /**
     * Filter which attendant to delete.
     */
    where: attendantWhereUniqueInput
  }

  /**
   * attendant deleteMany
   */
  export type attendantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendants to delete
     */
    where?: attendantWhereInput
    /**
     * Limit how many attendants to delete.
     */
    limit?: number
  }

  /**
   * attendant.calls
   */
  export type attendant$callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    where?: callsWhereInput
    orderBy?: callsOrderByWithRelationInput | callsOrderByWithRelationInput[]
    cursor?: callsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallsScalarFieldEnum | CallsScalarFieldEnum[]
  }

  /**
   * attendant without action
   */
  export type attendantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
  }


  /**
   * Model attendant_calls
   */

  export type AggregateAttendant_calls = {
    _count: Attendant_callsCountAggregateOutputType | null
    _min: Attendant_callsMinAggregateOutputType | null
    _max: Attendant_callsMaxAggregateOutputType | null
  }

  export type Attendant_callsMinAggregateOutputType = {
    id: string | null
    jid: string | null
    mainProblem: string | null
    detailsProblem: string | null
    pushName: string | null
    attendantId: string | null
    isResolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Attendant_callsMaxAggregateOutputType = {
    id: string | null
    jid: string | null
    mainProblem: string | null
    detailsProblem: string | null
    pushName: string | null
    attendantId: string | null
    isResolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Attendant_callsCountAggregateOutputType = {
    id: number
    jid: number
    mainProblem: number
    detailsProblem: number
    pushName: number
    attendantId: number
    isResolved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Attendant_callsMinAggregateInputType = {
    id?: true
    jid?: true
    mainProblem?: true
    detailsProblem?: true
    pushName?: true
    attendantId?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Attendant_callsMaxAggregateInputType = {
    id?: true
    jid?: true
    mainProblem?: true
    detailsProblem?: true
    pushName?: true
    attendantId?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Attendant_callsCountAggregateInputType = {
    id?: true
    jid?: true
    mainProblem?: true
    detailsProblem?: true
    pushName?: true
    attendantId?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Attendant_callsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendant_calls to aggregate.
     */
    where?: attendant_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendant_calls to fetch.
     */
    orderBy?: attendant_callsOrderByWithRelationInput | attendant_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendant_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendant_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendant_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendant_calls
    **/
    _count?: true | Attendant_callsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Attendant_callsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Attendant_callsMaxAggregateInputType
  }

  export type GetAttendant_callsAggregateType<T extends Attendant_callsAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendant_calls]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendant_calls[P]>
      : GetScalarType<T[P], AggregateAttendant_calls[P]>
  }




  export type attendant_callsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendant_callsWhereInput
    orderBy?: attendant_callsOrderByWithAggregationInput | attendant_callsOrderByWithAggregationInput[]
    by: Attendant_callsScalarFieldEnum[] | Attendant_callsScalarFieldEnum
    having?: attendant_callsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Attendant_callsCountAggregateInputType | true
    _min?: Attendant_callsMinAggregateInputType
    _max?: Attendant_callsMaxAggregateInputType
  }

  export type Attendant_callsGroupByOutputType = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    attendantId: string | null
    isResolved: boolean
    createdAt: Date
    updatedAt: Date
    _count: Attendant_callsCountAggregateOutputType | null
    _min: Attendant_callsMinAggregateOutputType | null
    _max: Attendant_callsMaxAggregateOutputType | null
  }

  type GetAttendant_callsGroupByPayload<T extends attendant_callsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Attendant_callsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Attendant_callsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Attendant_callsGroupByOutputType[P]>
            : GetScalarType<T[P], Attendant_callsGroupByOutputType[P]>
        }
      >
    >


  export type attendant_callsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jid?: boolean
    mainProblem?: boolean
    detailsProblem?: boolean
    pushName?: boolean
    attendantId?: boolean
    isResolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attendants?: boolean | attendant_calls$attendantsArgs<ExtArgs>
  }, ExtArgs["result"]["attendant_calls"]>



  export type attendant_callsSelectScalar = {
    id?: boolean
    jid?: boolean
    mainProblem?: boolean
    detailsProblem?: boolean
    pushName?: boolean
    attendantId?: boolean
    isResolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type attendant_callsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jid" | "mainProblem" | "detailsProblem" | "pushName" | "attendantId" | "isResolved" | "createdAt" | "updatedAt", ExtArgs["result"]["attendant_calls"]>
  export type attendant_callsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendants?: boolean | attendant_calls$attendantsArgs<ExtArgs>
  }

  export type $attendant_callsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendant_calls"
    objects: {
      attendants: Prisma.$attendantsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jid: string
      mainProblem: string
      detailsProblem: string
      pushName: string
      attendantId: string | null
      isResolved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendant_calls"]>
    composites: {}
  }

  type attendant_callsGetPayload<S extends boolean | null | undefined | attendant_callsDefaultArgs> = $Result.GetResult<Prisma.$attendant_callsPayload, S>

  type attendant_callsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendant_callsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Attendant_callsCountAggregateInputType | true
    }

  export interface attendant_callsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendant_calls'], meta: { name: 'attendant_calls' } }
    /**
     * Find zero or one Attendant_calls that matches the filter.
     * @param {attendant_callsFindUniqueArgs} args - Arguments to find a Attendant_calls
     * @example
     * // Get one Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendant_callsFindUniqueArgs>(args: SelectSubset<T, attendant_callsFindUniqueArgs<ExtArgs>>): Prisma__attendant_callsClient<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendant_calls that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendant_callsFindUniqueOrThrowArgs} args - Arguments to find a Attendant_calls
     * @example
     * // Get one Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendant_callsFindUniqueOrThrowArgs>(args: SelectSubset<T, attendant_callsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendant_callsClient<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendant_calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendant_callsFindFirstArgs} args - Arguments to find a Attendant_calls
     * @example
     * // Get one Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendant_callsFindFirstArgs>(args?: SelectSubset<T, attendant_callsFindFirstArgs<ExtArgs>>): Prisma__attendant_callsClient<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendant_calls that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendant_callsFindFirstOrThrowArgs} args - Arguments to find a Attendant_calls
     * @example
     * // Get one Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendant_callsFindFirstOrThrowArgs>(args?: SelectSubset<T, attendant_callsFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendant_callsClient<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendant_calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendant_callsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.findMany()
     * 
     * // Get first 10 Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendant_callsWithIdOnly = await prisma.attendant_calls.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendant_callsFindManyArgs>(args?: SelectSubset<T, attendant_callsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendant_calls.
     * @param {attendant_callsCreateArgs} args - Arguments to create a Attendant_calls.
     * @example
     * // Create one Attendant_calls
     * const Attendant_calls = await prisma.attendant_calls.create({
     *   data: {
     *     // ... data to create a Attendant_calls
     *   }
     * })
     * 
     */
    create<T extends attendant_callsCreateArgs>(args: SelectSubset<T, attendant_callsCreateArgs<ExtArgs>>): Prisma__attendant_callsClient<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendant_calls.
     * @param {attendant_callsCreateManyArgs} args - Arguments to create many Attendant_calls.
     * @example
     * // Create many Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendant_callsCreateManyArgs>(args?: SelectSubset<T, attendant_callsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendant_calls.
     * @param {attendant_callsDeleteArgs} args - Arguments to delete one Attendant_calls.
     * @example
     * // Delete one Attendant_calls
     * const Attendant_calls = await prisma.attendant_calls.delete({
     *   where: {
     *     // ... filter to delete one Attendant_calls
     *   }
     * })
     * 
     */
    delete<T extends attendant_callsDeleteArgs>(args: SelectSubset<T, attendant_callsDeleteArgs<ExtArgs>>): Prisma__attendant_callsClient<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendant_calls.
     * @param {attendant_callsUpdateArgs} args - Arguments to update one Attendant_calls.
     * @example
     * // Update one Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendant_callsUpdateArgs>(args: SelectSubset<T, attendant_callsUpdateArgs<ExtArgs>>): Prisma__attendant_callsClient<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendant_calls.
     * @param {attendant_callsDeleteManyArgs} args - Arguments to filter Attendant_calls to delete.
     * @example
     * // Delete a few Attendant_calls
     * const { count } = await prisma.attendant_calls.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendant_callsDeleteManyArgs>(args?: SelectSubset<T, attendant_callsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendant_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendant_callsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendant_callsUpdateManyArgs>(args: SelectSubset<T, attendant_callsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendant_calls.
     * @param {attendant_callsUpsertArgs} args - Arguments to update or create a Attendant_calls.
     * @example
     * // Update or create a Attendant_calls
     * const attendant_calls = await prisma.attendant_calls.upsert({
     *   create: {
     *     // ... data to create a Attendant_calls
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendant_calls we want to update
     *   }
     * })
     */
    upsert<T extends attendant_callsUpsertArgs>(args: SelectSubset<T, attendant_callsUpsertArgs<ExtArgs>>): Prisma__attendant_callsClient<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendant_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendant_callsCountArgs} args - Arguments to filter Attendant_calls to count.
     * @example
     * // Count the number of Attendant_calls
     * const count = await prisma.attendant_calls.count({
     *   where: {
     *     // ... the filter for the Attendant_calls we want to count
     *   }
     * })
    **/
    count<T extends attendant_callsCountArgs>(
      args?: Subset<T, attendant_callsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Attendant_callsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendant_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Attendant_callsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Attendant_callsAggregateArgs>(args: Subset<T, Attendant_callsAggregateArgs>): Prisma.PrismaPromise<GetAttendant_callsAggregateType<T>>

    /**
     * Group by Attendant_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendant_callsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendant_callsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendant_callsGroupByArgs['orderBy'] }
        : { orderBy?: attendant_callsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendant_callsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendant_callsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendant_calls model
   */
  readonly fields: attendant_callsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendant_calls.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendant_callsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendants<T extends attendant_calls$attendantsArgs<ExtArgs> = {}>(args?: Subset<T, attendant_calls$attendantsArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendant_calls model
   */
  interface attendant_callsFieldRefs {
    readonly id: FieldRef<"attendant_calls", 'String'>
    readonly jid: FieldRef<"attendant_calls", 'String'>
    readonly mainProblem: FieldRef<"attendant_calls", 'String'>
    readonly detailsProblem: FieldRef<"attendant_calls", 'String'>
    readonly pushName: FieldRef<"attendant_calls", 'String'>
    readonly attendantId: FieldRef<"attendant_calls", 'String'>
    readonly isResolved: FieldRef<"attendant_calls", 'Boolean'>
    readonly createdAt: FieldRef<"attendant_calls", 'DateTime'>
    readonly updatedAt: FieldRef<"attendant_calls", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attendant_calls findUnique
   */
  export type attendant_callsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * Filter, which attendant_calls to fetch.
     */
    where: attendant_callsWhereUniqueInput
  }

  /**
   * attendant_calls findUniqueOrThrow
   */
  export type attendant_callsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * Filter, which attendant_calls to fetch.
     */
    where: attendant_callsWhereUniqueInput
  }

  /**
   * attendant_calls findFirst
   */
  export type attendant_callsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * Filter, which attendant_calls to fetch.
     */
    where?: attendant_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendant_calls to fetch.
     */
    orderBy?: attendant_callsOrderByWithRelationInput | attendant_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendant_calls.
     */
    cursor?: attendant_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendant_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendant_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendant_calls.
     */
    distinct?: Attendant_callsScalarFieldEnum | Attendant_callsScalarFieldEnum[]
  }

  /**
   * attendant_calls findFirstOrThrow
   */
  export type attendant_callsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * Filter, which attendant_calls to fetch.
     */
    where?: attendant_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendant_calls to fetch.
     */
    orderBy?: attendant_callsOrderByWithRelationInput | attendant_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendant_calls.
     */
    cursor?: attendant_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendant_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendant_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendant_calls.
     */
    distinct?: Attendant_callsScalarFieldEnum | Attendant_callsScalarFieldEnum[]
  }

  /**
   * attendant_calls findMany
   */
  export type attendant_callsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * Filter, which attendant_calls to fetch.
     */
    where?: attendant_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendant_calls to fetch.
     */
    orderBy?: attendant_callsOrderByWithRelationInput | attendant_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendant_calls.
     */
    cursor?: attendant_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendant_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendant_calls.
     */
    skip?: number
    distinct?: Attendant_callsScalarFieldEnum | Attendant_callsScalarFieldEnum[]
  }

  /**
   * attendant_calls create
   */
  export type attendant_callsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * The data needed to create a attendant_calls.
     */
    data: XOR<attendant_callsCreateInput, attendant_callsUncheckedCreateInput>
  }

  /**
   * attendant_calls createMany
   */
  export type attendant_callsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendant_calls.
     */
    data: attendant_callsCreateManyInput | attendant_callsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendant_calls update
   */
  export type attendant_callsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * The data needed to update a attendant_calls.
     */
    data: XOR<attendant_callsUpdateInput, attendant_callsUncheckedUpdateInput>
    /**
     * Choose, which attendant_calls to update.
     */
    where: attendant_callsWhereUniqueInput
  }

  /**
   * attendant_calls updateMany
   */
  export type attendant_callsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendant_calls.
     */
    data: XOR<attendant_callsUpdateManyMutationInput, attendant_callsUncheckedUpdateManyInput>
    /**
     * Filter which attendant_calls to update
     */
    where?: attendant_callsWhereInput
    /**
     * Limit how many attendant_calls to update.
     */
    limit?: number
  }

  /**
   * attendant_calls upsert
   */
  export type attendant_callsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * The filter to search for the attendant_calls to update in case it exists.
     */
    where: attendant_callsWhereUniqueInput
    /**
     * In case the attendant_calls found by the `where` argument doesn't exist, create a new attendant_calls with this data.
     */
    create: XOR<attendant_callsCreateInput, attendant_callsUncheckedCreateInput>
    /**
     * In case the attendant_calls was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendant_callsUpdateInput, attendant_callsUncheckedUpdateInput>
  }

  /**
   * attendant_calls delete
   */
  export type attendant_callsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    /**
     * Filter which attendant_calls to delete.
     */
    where: attendant_callsWhereUniqueInput
  }

  /**
   * attendant_calls deleteMany
   */
  export type attendant_callsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendant_calls to delete
     */
    where?: attendant_callsWhereInput
    /**
     * Limit how many attendant_calls to delete.
     */
    limit?: number
  }

  /**
   * attendant_calls.attendants
   */
  export type attendant_calls$attendantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    where?: attendantsWhereInput
  }

  /**
   * attendant_calls without action
   */
  export type attendant_callsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
  }


  /**
   * Model attendants
   */

  export type AggregateAttendants = {
    _count: AttendantsCountAggregateOutputType | null
    _min: AttendantsMinAggregateOutputType | null
    _max: AttendantsMaxAggregateOutputType | null
  }

  export type AttendantsMinAggregateOutputType = {
    id: string | null
    jid: string | null
    name: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendantsMaxAggregateOutputType = {
    id: string | null
    jid: string | null
    name: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendantsCountAggregateOutputType = {
    id: number
    jid: number
    name: number
    isAdmin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendantsMinAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendantsMaxAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendantsCountAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendants to aggregate.
     */
    where?: attendantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendants to fetch.
     */
    orderBy?: attendantsOrderByWithRelationInput | attendantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendants
    **/
    _count?: true | AttendantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendantsMaxAggregateInputType
  }

  export type GetAttendantsAggregateType<T extends AttendantsAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendants[P]>
      : GetScalarType<T[P], AggregateAttendants[P]>
  }




  export type attendantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendantsWhereInput
    orderBy?: attendantsOrderByWithAggregationInput | attendantsOrderByWithAggregationInput[]
    by: AttendantsScalarFieldEnum[] | AttendantsScalarFieldEnum
    having?: attendantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendantsCountAggregateInputType | true
    _min?: AttendantsMinAggregateInputType
    _max?: AttendantsMaxAggregateInputType
  }

  export type AttendantsGroupByOutputType = {
    id: string
    jid: string
    name: string
    isAdmin: boolean
    createdAt: Date
    updatedAt: Date
    _count: AttendantsCountAggregateOutputType | null
    _min: AttendantsMinAggregateOutputType | null
    _max: AttendantsMaxAggregateOutputType | null
  }

  type GetAttendantsGroupByPayload<T extends attendantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendantsGroupByOutputType[P]>
            : GetScalarType<T[P], AttendantsGroupByOutputType[P]>
        }
      >
    >


  export type attendantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jid?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attendant_calls?: boolean | attendants$attendant_callsArgs<ExtArgs>
    _count?: boolean | AttendantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendants"]>



  export type attendantsSelectScalar = {
    id?: boolean
    jid?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type attendantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jid" | "name" | "isAdmin" | "createdAt" | "updatedAt", ExtArgs["result"]["attendants"]>
  export type attendantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendant_calls?: boolean | attendants$attendant_callsArgs<ExtArgs>
    _count?: boolean | AttendantsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $attendantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendants"
    objects: {
      attendant_calls: Prisma.$attendant_callsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jid: string
      name: string
      isAdmin: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendants"]>
    composites: {}
  }

  type attendantsGetPayload<S extends boolean | null | undefined | attendantsDefaultArgs> = $Result.GetResult<Prisma.$attendantsPayload, S>

  type attendantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendantsCountAggregateInputType | true
    }

  export interface attendantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendants'], meta: { name: 'attendants' } }
    /**
     * Find zero or one Attendants that matches the filter.
     * @param {attendantsFindUniqueArgs} args - Arguments to find a Attendants
     * @example
     * // Get one Attendants
     * const attendants = await prisma.attendants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendantsFindUniqueArgs>(args: SelectSubset<T, attendantsFindUniqueArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendantsFindUniqueOrThrowArgs} args - Arguments to find a Attendants
     * @example
     * // Get one Attendants
     * const attendants = await prisma.attendants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendantsFindUniqueOrThrowArgs>(args: SelectSubset<T, attendantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantsFindFirstArgs} args - Arguments to find a Attendants
     * @example
     * // Get one Attendants
     * const attendants = await prisma.attendants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendantsFindFirstArgs>(args?: SelectSubset<T, attendantsFindFirstArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantsFindFirstOrThrowArgs} args - Arguments to find a Attendants
     * @example
     * // Get one Attendants
     * const attendants = await prisma.attendants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendantsFindFirstOrThrowArgs>(args?: SelectSubset<T, attendantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendants
     * const attendants = await prisma.attendants.findMany()
     * 
     * // Get first 10 Attendants
     * const attendants = await prisma.attendants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendantsWithIdOnly = await prisma.attendants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendantsFindManyArgs>(args?: SelectSubset<T, attendantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendants.
     * @param {attendantsCreateArgs} args - Arguments to create a Attendants.
     * @example
     * // Create one Attendants
     * const Attendants = await prisma.attendants.create({
     *   data: {
     *     // ... data to create a Attendants
     *   }
     * })
     * 
     */
    create<T extends attendantsCreateArgs>(args: SelectSubset<T, attendantsCreateArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendants.
     * @param {attendantsCreateManyArgs} args - Arguments to create many Attendants.
     * @example
     * // Create many Attendants
     * const attendants = await prisma.attendants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendantsCreateManyArgs>(args?: SelectSubset<T, attendantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendants.
     * @param {attendantsDeleteArgs} args - Arguments to delete one Attendants.
     * @example
     * // Delete one Attendants
     * const Attendants = await prisma.attendants.delete({
     *   where: {
     *     // ... filter to delete one Attendants
     *   }
     * })
     * 
     */
    delete<T extends attendantsDeleteArgs>(args: SelectSubset<T, attendantsDeleteArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendants.
     * @param {attendantsUpdateArgs} args - Arguments to update one Attendants.
     * @example
     * // Update one Attendants
     * const attendants = await prisma.attendants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendantsUpdateArgs>(args: SelectSubset<T, attendantsUpdateArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendants.
     * @param {attendantsDeleteManyArgs} args - Arguments to filter Attendants to delete.
     * @example
     * // Delete a few Attendants
     * const { count } = await prisma.attendants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendantsDeleteManyArgs>(args?: SelectSubset<T, attendantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendants
     * const attendants = await prisma.attendants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendantsUpdateManyArgs>(args: SelectSubset<T, attendantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendants.
     * @param {attendantsUpsertArgs} args - Arguments to update or create a Attendants.
     * @example
     * // Update or create a Attendants
     * const attendants = await prisma.attendants.upsert({
     *   create: {
     *     // ... data to create a Attendants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendants we want to update
     *   }
     * })
     */
    upsert<T extends attendantsUpsertArgs>(args: SelectSubset<T, attendantsUpsertArgs<ExtArgs>>): Prisma__attendantsClient<$Result.GetResult<Prisma.$attendantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantsCountArgs} args - Arguments to filter Attendants to count.
     * @example
     * // Count the number of Attendants
     * const count = await prisma.attendants.count({
     *   where: {
     *     // ... the filter for the Attendants we want to count
     *   }
     * })
    **/
    count<T extends attendantsCountArgs>(
      args?: Subset<T, attendantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendantsAggregateArgs>(args: Subset<T, AttendantsAggregateArgs>): Prisma.PrismaPromise<GetAttendantsAggregateType<T>>

    /**
     * Group by Attendants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendantsGroupByArgs['orderBy'] }
        : { orderBy?: attendantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendants model
   */
  readonly fields: attendantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendant_calls<T extends attendants$attendant_callsArgs<ExtArgs> = {}>(args?: Subset<T, attendants$attendant_callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendant_callsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendants model
   */
  interface attendantsFieldRefs {
    readonly id: FieldRef<"attendants", 'String'>
    readonly jid: FieldRef<"attendants", 'String'>
    readonly name: FieldRef<"attendants", 'String'>
    readonly isAdmin: FieldRef<"attendants", 'Boolean'>
    readonly createdAt: FieldRef<"attendants", 'DateTime'>
    readonly updatedAt: FieldRef<"attendants", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attendants findUnique
   */
  export type attendantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * Filter, which attendants to fetch.
     */
    where: attendantsWhereUniqueInput
  }

  /**
   * attendants findUniqueOrThrow
   */
  export type attendantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * Filter, which attendants to fetch.
     */
    where: attendantsWhereUniqueInput
  }

  /**
   * attendants findFirst
   */
  export type attendantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * Filter, which attendants to fetch.
     */
    where?: attendantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendants to fetch.
     */
    orderBy?: attendantsOrderByWithRelationInput | attendantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendants.
     */
    cursor?: attendantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendants.
     */
    distinct?: AttendantsScalarFieldEnum | AttendantsScalarFieldEnum[]
  }

  /**
   * attendants findFirstOrThrow
   */
  export type attendantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * Filter, which attendants to fetch.
     */
    where?: attendantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendants to fetch.
     */
    orderBy?: attendantsOrderByWithRelationInput | attendantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendants.
     */
    cursor?: attendantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendants.
     */
    distinct?: AttendantsScalarFieldEnum | AttendantsScalarFieldEnum[]
  }

  /**
   * attendants findMany
   */
  export type attendantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * Filter, which attendants to fetch.
     */
    where?: attendantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendants to fetch.
     */
    orderBy?: attendantsOrderByWithRelationInput | attendantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendants.
     */
    cursor?: attendantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendants.
     */
    skip?: number
    distinct?: AttendantsScalarFieldEnum | AttendantsScalarFieldEnum[]
  }

  /**
   * attendants create
   */
  export type attendantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * The data needed to create a attendants.
     */
    data: XOR<attendantsCreateInput, attendantsUncheckedCreateInput>
  }

  /**
   * attendants createMany
   */
  export type attendantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendants.
     */
    data: attendantsCreateManyInput | attendantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendants update
   */
  export type attendantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * The data needed to update a attendants.
     */
    data: XOR<attendantsUpdateInput, attendantsUncheckedUpdateInput>
    /**
     * Choose, which attendants to update.
     */
    where: attendantsWhereUniqueInput
  }

  /**
   * attendants updateMany
   */
  export type attendantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendants.
     */
    data: XOR<attendantsUpdateManyMutationInput, attendantsUncheckedUpdateManyInput>
    /**
     * Filter which attendants to update
     */
    where?: attendantsWhereInput
    /**
     * Limit how many attendants to update.
     */
    limit?: number
  }

  /**
   * attendants upsert
   */
  export type attendantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * The filter to search for the attendants to update in case it exists.
     */
    where: attendantsWhereUniqueInput
    /**
     * In case the attendants found by the `where` argument doesn't exist, create a new attendants with this data.
     */
    create: XOR<attendantsCreateInput, attendantsUncheckedCreateInput>
    /**
     * In case the attendants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendantsUpdateInput, attendantsUncheckedUpdateInput>
  }

  /**
   * attendants delete
   */
  export type attendantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
    /**
     * Filter which attendants to delete.
     */
    where: attendantsWhereUniqueInput
  }

  /**
   * attendants deleteMany
   */
  export type attendantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendants to delete
     */
    where?: attendantsWhereInput
    /**
     * Limit how many attendants to delete.
     */
    limit?: number
  }

  /**
   * attendants.attendant_calls
   */
  export type attendants$attendant_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant_calls
     */
    select?: attendant_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant_calls
     */
    omit?: attendant_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendant_callsInclude<ExtArgs> | null
    where?: attendant_callsWhereInput
    orderBy?: attendant_callsOrderByWithRelationInput | attendant_callsOrderByWithRelationInput[]
    cursor?: attendant_callsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Attendant_callsScalarFieldEnum | Attendant_callsScalarFieldEnum[]
  }

  /**
   * attendants without action
   */
  export type attendantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendants
     */
    select?: attendantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendants
     */
    omit?: attendantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantsInclude<ExtArgs> | null
  }


  /**
   * Model budget_consults_aut
   */

  export type AggregateBudget_consults_aut = {
    _count: Budget_consults_autCountAggregateOutputType | null
    _avg: Budget_consults_autAvgAggregateOutputType | null
    _sum: Budget_consults_autSumAggregateOutputType | null
    _min: Budget_consults_autMinAggregateOutputType | null
    _max: Budget_consults_autMaxAggregateOutputType | null
  }

  export type Budget_consults_autAvgAggregateOutputType = {
    budget_code: number | null
  }

  export type Budget_consults_autSumAggregateOutputType = {
    budget_code: number | null
  }

  export type Budget_consults_autMinAggregateOutputType = {
    id: string | null
    budget_code: number | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Budget_consults_autMaxAggregateOutputType = {
    id: string | null
    budget_code: number | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Budget_consults_autCountAggregateOutputType = {
    id: number
    budget_code: number
    is_error: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Budget_consults_autAvgAggregateInputType = {
    budget_code?: true
  }

  export type Budget_consults_autSumAggregateInputType = {
    budget_code?: true
  }

  export type Budget_consults_autMinAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Budget_consults_autMaxAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Budget_consults_autCountAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Budget_consults_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_consults_aut to aggregate.
     */
    where?: budget_consults_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_auts to fetch.
     */
    orderBy?: budget_consults_autOrderByWithRelationInput | budget_consults_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: budget_consults_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned budget_consults_auts
    **/
    _count?: true | Budget_consults_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Budget_consults_autAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Budget_consults_autSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Budget_consults_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Budget_consults_autMaxAggregateInputType
  }

  export type GetBudget_consults_autAggregateType<T extends Budget_consults_autAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget_consults_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget_consults_aut[P]>
      : GetScalarType<T[P], AggregateBudget_consults_aut[P]>
  }




  export type budget_consults_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_consults_autWhereInput
    orderBy?: budget_consults_autOrderByWithAggregationInput | budget_consults_autOrderByWithAggregationInput[]
    by: Budget_consults_autScalarFieldEnum[] | Budget_consults_autScalarFieldEnum
    having?: budget_consults_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Budget_consults_autCountAggregateInputType | true
    _avg?: Budget_consults_autAvgAggregateInputType
    _sum?: Budget_consults_autSumAggregateInputType
    _min?: Budget_consults_autMinAggregateInputType
    _max?: Budget_consults_autMaxAggregateInputType
  }

  export type Budget_consults_autGroupByOutputType = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date
    updatedAt: Date
    _count: Budget_consults_autCountAggregateOutputType | null
    _avg: Budget_consults_autAvgAggregateOutputType | null
    _sum: Budget_consults_autSumAggregateOutputType | null
    _min: Budget_consults_autMinAggregateOutputType | null
    _max: Budget_consults_autMaxAggregateOutputType | null
  }

  type GetBudget_consults_autGroupByPayload<T extends budget_consults_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Budget_consults_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Budget_consults_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Budget_consults_autGroupByOutputType[P]>
            : GetScalarType<T[P], Budget_consults_autGroupByOutputType[P]>
        }
      >
    >


  export type budget_consults_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budget_code?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget_consults_aut"]>



  export type budget_consults_autSelectScalar = {
    id?: boolean
    budget_code?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type budget_consults_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budget_code" | "is_error" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["budget_consults_aut"]>
  export type budget_consults_autInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }

  export type $budget_consults_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "budget_consults_aut"
    objects: {
      users_aut: Prisma.$users_autPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budget_code: number
      is_error: boolean
      user_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget_consults_aut"]>
    composites: {}
  }

  type budget_consults_autGetPayload<S extends boolean | null | undefined | budget_consults_autDefaultArgs> = $Result.GetResult<Prisma.$budget_consults_autPayload, S>

  type budget_consults_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<budget_consults_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Budget_consults_autCountAggregateInputType | true
    }

  export interface budget_consults_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['budget_consults_aut'], meta: { name: 'budget_consults_aut' } }
    /**
     * Find zero or one Budget_consults_aut that matches the filter.
     * @param {budget_consults_autFindUniqueArgs} args - Arguments to find a Budget_consults_aut
     * @example
     * // Get one Budget_consults_aut
     * const budget_consults_aut = await prisma.budget_consults_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends budget_consults_autFindUniqueArgs>(args: SelectSubset<T, budget_consults_autFindUniqueArgs<ExtArgs>>): Prisma__budget_consults_autClient<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget_consults_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {budget_consults_autFindUniqueOrThrowArgs} args - Arguments to find a Budget_consults_aut
     * @example
     * // Get one Budget_consults_aut
     * const budget_consults_aut = await prisma.budget_consults_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends budget_consults_autFindUniqueOrThrowArgs>(args: SelectSubset<T, budget_consults_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__budget_consults_autClient<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_consults_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_autFindFirstArgs} args - Arguments to find a Budget_consults_aut
     * @example
     * // Get one Budget_consults_aut
     * const budget_consults_aut = await prisma.budget_consults_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends budget_consults_autFindFirstArgs>(args?: SelectSubset<T, budget_consults_autFindFirstArgs<ExtArgs>>): Prisma__budget_consults_autClient<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_consults_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_autFindFirstOrThrowArgs} args - Arguments to find a Budget_consults_aut
     * @example
     * // Get one Budget_consults_aut
     * const budget_consults_aut = await prisma.budget_consults_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends budget_consults_autFindFirstOrThrowArgs>(args?: SelectSubset<T, budget_consults_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__budget_consults_autClient<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budget_consults_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budget_consults_auts
     * const budget_consults_auts = await prisma.budget_consults_aut.findMany()
     * 
     * // Get first 10 Budget_consults_auts
     * const budget_consults_auts = await prisma.budget_consults_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budget_consults_autWithIdOnly = await prisma.budget_consults_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends budget_consults_autFindManyArgs>(args?: SelectSubset<T, budget_consults_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget_consults_aut.
     * @param {budget_consults_autCreateArgs} args - Arguments to create a Budget_consults_aut.
     * @example
     * // Create one Budget_consults_aut
     * const Budget_consults_aut = await prisma.budget_consults_aut.create({
     *   data: {
     *     // ... data to create a Budget_consults_aut
     *   }
     * })
     * 
     */
    create<T extends budget_consults_autCreateArgs>(args: SelectSubset<T, budget_consults_autCreateArgs<ExtArgs>>): Prisma__budget_consults_autClient<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budget_consults_auts.
     * @param {budget_consults_autCreateManyArgs} args - Arguments to create many Budget_consults_auts.
     * @example
     * // Create many Budget_consults_auts
     * const budget_consults_aut = await prisma.budget_consults_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends budget_consults_autCreateManyArgs>(args?: SelectSubset<T, budget_consults_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Budget_consults_aut.
     * @param {budget_consults_autDeleteArgs} args - Arguments to delete one Budget_consults_aut.
     * @example
     * // Delete one Budget_consults_aut
     * const Budget_consults_aut = await prisma.budget_consults_aut.delete({
     *   where: {
     *     // ... filter to delete one Budget_consults_aut
     *   }
     * })
     * 
     */
    delete<T extends budget_consults_autDeleteArgs>(args: SelectSubset<T, budget_consults_autDeleteArgs<ExtArgs>>): Prisma__budget_consults_autClient<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget_consults_aut.
     * @param {budget_consults_autUpdateArgs} args - Arguments to update one Budget_consults_aut.
     * @example
     * // Update one Budget_consults_aut
     * const budget_consults_aut = await prisma.budget_consults_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends budget_consults_autUpdateArgs>(args: SelectSubset<T, budget_consults_autUpdateArgs<ExtArgs>>): Prisma__budget_consults_autClient<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budget_consults_auts.
     * @param {budget_consults_autDeleteManyArgs} args - Arguments to filter Budget_consults_auts to delete.
     * @example
     * // Delete a few Budget_consults_auts
     * const { count } = await prisma.budget_consults_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends budget_consults_autDeleteManyArgs>(args?: SelectSubset<T, budget_consults_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budget_consults_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budget_consults_auts
     * const budget_consults_aut = await prisma.budget_consults_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends budget_consults_autUpdateManyArgs>(args: SelectSubset<T, budget_consults_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget_consults_aut.
     * @param {budget_consults_autUpsertArgs} args - Arguments to update or create a Budget_consults_aut.
     * @example
     * // Update or create a Budget_consults_aut
     * const budget_consults_aut = await prisma.budget_consults_aut.upsert({
     *   create: {
     *     // ... data to create a Budget_consults_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget_consults_aut we want to update
     *   }
     * })
     */
    upsert<T extends budget_consults_autUpsertArgs>(args: SelectSubset<T, budget_consults_autUpsertArgs<ExtArgs>>): Prisma__budget_consults_autClient<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budget_consults_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_autCountArgs} args - Arguments to filter Budget_consults_auts to count.
     * @example
     * // Count the number of Budget_consults_auts
     * const count = await prisma.budget_consults_aut.count({
     *   where: {
     *     // ... the filter for the Budget_consults_auts we want to count
     *   }
     * })
    **/
    count<T extends budget_consults_autCountArgs>(
      args?: Subset<T, budget_consults_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Budget_consults_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget_consults_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Budget_consults_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Budget_consults_autAggregateArgs>(args: Subset<T, Budget_consults_autAggregateArgs>): Prisma.PrismaPromise<GetBudget_consults_autAggregateType<T>>

    /**
     * Group by Budget_consults_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends budget_consults_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: budget_consults_autGroupByArgs['orderBy'] }
        : { orderBy?: budget_consults_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, budget_consults_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudget_consults_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the budget_consults_aut model
   */
  readonly fields: budget_consults_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for budget_consults_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__budget_consults_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_aut<T extends users_autDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_autDefaultArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the budget_consults_aut model
   */
  interface budget_consults_autFieldRefs {
    readonly id: FieldRef<"budget_consults_aut", 'String'>
    readonly budget_code: FieldRef<"budget_consults_aut", 'Int'>
    readonly is_error: FieldRef<"budget_consults_aut", 'Boolean'>
    readonly user_id: FieldRef<"budget_consults_aut", 'String'>
    readonly createdAt: FieldRef<"budget_consults_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"budget_consults_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * budget_consults_aut findUnique
   */
  export type budget_consults_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_aut to fetch.
     */
    where: budget_consults_autWhereUniqueInput
  }

  /**
   * budget_consults_aut findUniqueOrThrow
   */
  export type budget_consults_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_aut to fetch.
     */
    where: budget_consults_autWhereUniqueInput
  }

  /**
   * budget_consults_aut findFirst
   */
  export type budget_consults_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_aut to fetch.
     */
    where?: budget_consults_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_auts to fetch.
     */
    orderBy?: budget_consults_autOrderByWithRelationInput | budget_consults_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_consults_auts.
     */
    cursor?: budget_consults_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_consults_auts.
     */
    distinct?: Budget_consults_autScalarFieldEnum | Budget_consults_autScalarFieldEnum[]
  }

  /**
   * budget_consults_aut findFirstOrThrow
   */
  export type budget_consults_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_aut to fetch.
     */
    where?: budget_consults_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_auts to fetch.
     */
    orderBy?: budget_consults_autOrderByWithRelationInput | budget_consults_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_consults_auts.
     */
    cursor?: budget_consults_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_consults_auts.
     */
    distinct?: Budget_consults_autScalarFieldEnum | Budget_consults_autScalarFieldEnum[]
  }

  /**
   * budget_consults_aut findMany
   */
  export type budget_consults_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_auts to fetch.
     */
    where?: budget_consults_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_auts to fetch.
     */
    orderBy?: budget_consults_autOrderByWithRelationInput | budget_consults_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing budget_consults_auts.
     */
    cursor?: budget_consults_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_auts.
     */
    skip?: number
    distinct?: Budget_consults_autScalarFieldEnum | Budget_consults_autScalarFieldEnum[]
  }

  /**
   * budget_consults_aut create
   */
  export type budget_consults_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * The data needed to create a budget_consults_aut.
     */
    data: XOR<budget_consults_autCreateInput, budget_consults_autUncheckedCreateInput>
  }

  /**
   * budget_consults_aut createMany
   */
  export type budget_consults_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many budget_consults_auts.
     */
    data: budget_consults_autCreateManyInput | budget_consults_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * budget_consults_aut update
   */
  export type budget_consults_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * The data needed to update a budget_consults_aut.
     */
    data: XOR<budget_consults_autUpdateInput, budget_consults_autUncheckedUpdateInput>
    /**
     * Choose, which budget_consults_aut to update.
     */
    where: budget_consults_autWhereUniqueInput
  }

  /**
   * budget_consults_aut updateMany
   */
  export type budget_consults_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update budget_consults_auts.
     */
    data: XOR<budget_consults_autUpdateManyMutationInput, budget_consults_autUncheckedUpdateManyInput>
    /**
     * Filter which budget_consults_auts to update
     */
    where?: budget_consults_autWhereInput
    /**
     * Limit how many budget_consults_auts to update.
     */
    limit?: number
  }

  /**
   * budget_consults_aut upsert
   */
  export type budget_consults_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * The filter to search for the budget_consults_aut to update in case it exists.
     */
    where: budget_consults_autWhereUniqueInput
    /**
     * In case the budget_consults_aut found by the `where` argument doesn't exist, create a new budget_consults_aut with this data.
     */
    create: XOR<budget_consults_autCreateInput, budget_consults_autUncheckedCreateInput>
    /**
     * In case the budget_consults_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<budget_consults_autUpdateInput, budget_consults_autUncheckedUpdateInput>
  }

  /**
   * budget_consults_aut delete
   */
  export type budget_consults_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    /**
     * Filter which budget_consults_aut to delete.
     */
    where: budget_consults_autWhereUniqueInput
  }

  /**
   * budget_consults_aut deleteMany
   */
  export type budget_consults_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_consults_auts to delete
     */
    where?: budget_consults_autWhereInput
    /**
     * Limit how many budget_consults_auts to delete.
     */
    limit?: number
  }

  /**
   * budget_consults_aut without action
   */
  export type budget_consults_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
  }


  /**
   * Model budget_consults_clt
   */

  export type AggregateBudget_consults_clt = {
    _count: Budget_consults_cltCountAggregateOutputType | null
    _avg: Budget_consults_cltAvgAggregateOutputType | null
    _sum: Budget_consults_cltSumAggregateOutputType | null
    _min: Budget_consults_cltMinAggregateOutputType | null
    _max: Budget_consults_cltMaxAggregateOutputType | null
  }

  export type Budget_consults_cltAvgAggregateOutputType = {
    budget_code: number | null
  }

  export type Budget_consults_cltSumAggregateOutputType = {
    budget_code: number | null
  }

  export type Budget_consults_cltMinAggregateOutputType = {
    id: string | null
    budget_code: number | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Budget_consults_cltMaxAggregateOutputType = {
    id: string | null
    budget_code: number | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Budget_consults_cltCountAggregateOutputType = {
    id: number
    budget_code: number
    is_error: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Budget_consults_cltAvgAggregateInputType = {
    budget_code?: true
  }

  export type Budget_consults_cltSumAggregateInputType = {
    budget_code?: true
  }

  export type Budget_consults_cltMinAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Budget_consults_cltMaxAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Budget_consults_cltCountAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Budget_consults_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_consults_clt to aggregate.
     */
    where?: budget_consults_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_clts to fetch.
     */
    orderBy?: budget_consults_cltOrderByWithRelationInput | budget_consults_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: budget_consults_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned budget_consults_clts
    **/
    _count?: true | Budget_consults_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Budget_consults_cltAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Budget_consults_cltSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Budget_consults_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Budget_consults_cltMaxAggregateInputType
  }

  export type GetBudget_consults_cltAggregateType<T extends Budget_consults_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget_consults_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget_consults_clt[P]>
      : GetScalarType<T[P], AggregateBudget_consults_clt[P]>
  }




  export type budget_consults_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_consults_cltWhereInput
    orderBy?: budget_consults_cltOrderByWithAggregationInput | budget_consults_cltOrderByWithAggregationInput[]
    by: Budget_consults_cltScalarFieldEnum[] | Budget_consults_cltScalarFieldEnum
    having?: budget_consults_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Budget_consults_cltCountAggregateInputType | true
    _avg?: Budget_consults_cltAvgAggregateInputType
    _sum?: Budget_consults_cltSumAggregateInputType
    _min?: Budget_consults_cltMinAggregateInputType
    _max?: Budget_consults_cltMaxAggregateInputType
  }

  export type Budget_consults_cltGroupByOutputType = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date
    updatedAt: Date
    _count: Budget_consults_cltCountAggregateOutputType | null
    _avg: Budget_consults_cltAvgAggregateOutputType | null
    _sum: Budget_consults_cltSumAggregateOutputType | null
    _min: Budget_consults_cltMinAggregateOutputType | null
    _max: Budget_consults_cltMaxAggregateOutputType | null
  }

  type GetBudget_consults_cltGroupByPayload<T extends budget_consults_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Budget_consults_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Budget_consults_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Budget_consults_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Budget_consults_cltGroupByOutputType[P]>
        }
      >
    >


  export type budget_consults_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budget_code?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget_consults_clt"]>



  export type budget_consults_cltSelectScalar = {
    id?: boolean
    budget_code?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type budget_consults_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budget_code" | "is_error" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["budget_consults_clt"]>
  export type budget_consults_cltInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }

  export type $budget_consults_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "budget_consults_clt"
    objects: {
      users_clt: Prisma.$users_cltPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budget_code: number
      is_error: boolean
      user_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget_consults_clt"]>
    composites: {}
  }

  type budget_consults_cltGetPayload<S extends boolean | null | undefined | budget_consults_cltDefaultArgs> = $Result.GetResult<Prisma.$budget_consults_cltPayload, S>

  type budget_consults_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<budget_consults_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Budget_consults_cltCountAggregateInputType | true
    }

  export interface budget_consults_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['budget_consults_clt'], meta: { name: 'budget_consults_clt' } }
    /**
     * Find zero or one Budget_consults_clt that matches the filter.
     * @param {budget_consults_cltFindUniqueArgs} args - Arguments to find a Budget_consults_clt
     * @example
     * // Get one Budget_consults_clt
     * const budget_consults_clt = await prisma.budget_consults_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends budget_consults_cltFindUniqueArgs>(args: SelectSubset<T, budget_consults_cltFindUniqueArgs<ExtArgs>>): Prisma__budget_consults_cltClient<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget_consults_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {budget_consults_cltFindUniqueOrThrowArgs} args - Arguments to find a Budget_consults_clt
     * @example
     * // Get one Budget_consults_clt
     * const budget_consults_clt = await prisma.budget_consults_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends budget_consults_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, budget_consults_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__budget_consults_cltClient<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_consults_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_cltFindFirstArgs} args - Arguments to find a Budget_consults_clt
     * @example
     * // Get one Budget_consults_clt
     * const budget_consults_clt = await prisma.budget_consults_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends budget_consults_cltFindFirstArgs>(args?: SelectSubset<T, budget_consults_cltFindFirstArgs<ExtArgs>>): Prisma__budget_consults_cltClient<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_consults_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_cltFindFirstOrThrowArgs} args - Arguments to find a Budget_consults_clt
     * @example
     * // Get one Budget_consults_clt
     * const budget_consults_clt = await prisma.budget_consults_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends budget_consults_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, budget_consults_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__budget_consults_cltClient<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budget_consults_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budget_consults_clts
     * const budget_consults_clts = await prisma.budget_consults_clt.findMany()
     * 
     * // Get first 10 Budget_consults_clts
     * const budget_consults_clts = await prisma.budget_consults_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budget_consults_cltWithIdOnly = await prisma.budget_consults_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends budget_consults_cltFindManyArgs>(args?: SelectSubset<T, budget_consults_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget_consults_clt.
     * @param {budget_consults_cltCreateArgs} args - Arguments to create a Budget_consults_clt.
     * @example
     * // Create one Budget_consults_clt
     * const Budget_consults_clt = await prisma.budget_consults_clt.create({
     *   data: {
     *     // ... data to create a Budget_consults_clt
     *   }
     * })
     * 
     */
    create<T extends budget_consults_cltCreateArgs>(args: SelectSubset<T, budget_consults_cltCreateArgs<ExtArgs>>): Prisma__budget_consults_cltClient<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budget_consults_clts.
     * @param {budget_consults_cltCreateManyArgs} args - Arguments to create many Budget_consults_clts.
     * @example
     * // Create many Budget_consults_clts
     * const budget_consults_clt = await prisma.budget_consults_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends budget_consults_cltCreateManyArgs>(args?: SelectSubset<T, budget_consults_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Budget_consults_clt.
     * @param {budget_consults_cltDeleteArgs} args - Arguments to delete one Budget_consults_clt.
     * @example
     * // Delete one Budget_consults_clt
     * const Budget_consults_clt = await prisma.budget_consults_clt.delete({
     *   where: {
     *     // ... filter to delete one Budget_consults_clt
     *   }
     * })
     * 
     */
    delete<T extends budget_consults_cltDeleteArgs>(args: SelectSubset<T, budget_consults_cltDeleteArgs<ExtArgs>>): Prisma__budget_consults_cltClient<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget_consults_clt.
     * @param {budget_consults_cltUpdateArgs} args - Arguments to update one Budget_consults_clt.
     * @example
     * // Update one Budget_consults_clt
     * const budget_consults_clt = await prisma.budget_consults_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends budget_consults_cltUpdateArgs>(args: SelectSubset<T, budget_consults_cltUpdateArgs<ExtArgs>>): Prisma__budget_consults_cltClient<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budget_consults_clts.
     * @param {budget_consults_cltDeleteManyArgs} args - Arguments to filter Budget_consults_clts to delete.
     * @example
     * // Delete a few Budget_consults_clts
     * const { count } = await prisma.budget_consults_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends budget_consults_cltDeleteManyArgs>(args?: SelectSubset<T, budget_consults_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budget_consults_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budget_consults_clts
     * const budget_consults_clt = await prisma.budget_consults_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends budget_consults_cltUpdateManyArgs>(args: SelectSubset<T, budget_consults_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget_consults_clt.
     * @param {budget_consults_cltUpsertArgs} args - Arguments to update or create a Budget_consults_clt.
     * @example
     * // Update or create a Budget_consults_clt
     * const budget_consults_clt = await prisma.budget_consults_clt.upsert({
     *   create: {
     *     // ... data to create a Budget_consults_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget_consults_clt we want to update
     *   }
     * })
     */
    upsert<T extends budget_consults_cltUpsertArgs>(args: SelectSubset<T, budget_consults_cltUpsertArgs<ExtArgs>>): Prisma__budget_consults_cltClient<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budget_consults_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_cltCountArgs} args - Arguments to filter Budget_consults_clts to count.
     * @example
     * // Count the number of Budget_consults_clts
     * const count = await prisma.budget_consults_clt.count({
     *   where: {
     *     // ... the filter for the Budget_consults_clts we want to count
     *   }
     * })
    **/
    count<T extends budget_consults_cltCountArgs>(
      args?: Subset<T, budget_consults_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Budget_consults_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget_consults_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Budget_consults_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Budget_consults_cltAggregateArgs>(args: Subset<T, Budget_consults_cltAggregateArgs>): Prisma.PrismaPromise<GetBudget_consults_cltAggregateType<T>>

    /**
     * Group by Budget_consults_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends budget_consults_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: budget_consults_cltGroupByArgs['orderBy'] }
        : { orderBy?: budget_consults_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, budget_consults_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudget_consults_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the budget_consults_clt model
   */
  readonly fields: budget_consults_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for budget_consults_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__budget_consults_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_clt<T extends users_cltDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_cltDefaultArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the budget_consults_clt model
   */
  interface budget_consults_cltFieldRefs {
    readonly id: FieldRef<"budget_consults_clt", 'String'>
    readonly budget_code: FieldRef<"budget_consults_clt", 'Int'>
    readonly is_error: FieldRef<"budget_consults_clt", 'Boolean'>
    readonly user_id: FieldRef<"budget_consults_clt", 'String'>
    readonly createdAt: FieldRef<"budget_consults_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"budget_consults_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * budget_consults_clt findUnique
   */
  export type budget_consults_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_clt to fetch.
     */
    where: budget_consults_cltWhereUniqueInput
  }

  /**
   * budget_consults_clt findUniqueOrThrow
   */
  export type budget_consults_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_clt to fetch.
     */
    where: budget_consults_cltWhereUniqueInput
  }

  /**
   * budget_consults_clt findFirst
   */
  export type budget_consults_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_clt to fetch.
     */
    where?: budget_consults_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_clts to fetch.
     */
    orderBy?: budget_consults_cltOrderByWithRelationInput | budget_consults_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_consults_clts.
     */
    cursor?: budget_consults_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_consults_clts.
     */
    distinct?: Budget_consults_cltScalarFieldEnum | Budget_consults_cltScalarFieldEnum[]
  }

  /**
   * budget_consults_clt findFirstOrThrow
   */
  export type budget_consults_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_clt to fetch.
     */
    where?: budget_consults_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_clts to fetch.
     */
    orderBy?: budget_consults_cltOrderByWithRelationInput | budget_consults_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_consults_clts.
     */
    cursor?: budget_consults_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_consults_clts.
     */
    distinct?: Budget_consults_cltScalarFieldEnum | Budget_consults_cltScalarFieldEnum[]
  }

  /**
   * budget_consults_clt findMany
   */
  export type budget_consults_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_clts to fetch.
     */
    where?: budget_consults_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_clts to fetch.
     */
    orderBy?: budget_consults_cltOrderByWithRelationInput | budget_consults_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing budget_consults_clts.
     */
    cursor?: budget_consults_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_clts.
     */
    skip?: number
    distinct?: Budget_consults_cltScalarFieldEnum | Budget_consults_cltScalarFieldEnum[]
  }

  /**
   * budget_consults_clt create
   */
  export type budget_consults_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * The data needed to create a budget_consults_clt.
     */
    data: XOR<budget_consults_cltCreateInput, budget_consults_cltUncheckedCreateInput>
  }

  /**
   * budget_consults_clt createMany
   */
  export type budget_consults_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many budget_consults_clts.
     */
    data: budget_consults_cltCreateManyInput | budget_consults_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * budget_consults_clt update
   */
  export type budget_consults_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * The data needed to update a budget_consults_clt.
     */
    data: XOR<budget_consults_cltUpdateInput, budget_consults_cltUncheckedUpdateInput>
    /**
     * Choose, which budget_consults_clt to update.
     */
    where: budget_consults_cltWhereUniqueInput
  }

  /**
   * budget_consults_clt updateMany
   */
  export type budget_consults_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update budget_consults_clts.
     */
    data: XOR<budget_consults_cltUpdateManyMutationInput, budget_consults_cltUncheckedUpdateManyInput>
    /**
     * Filter which budget_consults_clts to update
     */
    where?: budget_consults_cltWhereInput
    /**
     * Limit how many budget_consults_clts to update.
     */
    limit?: number
  }

  /**
   * budget_consults_clt upsert
   */
  export type budget_consults_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * The filter to search for the budget_consults_clt to update in case it exists.
     */
    where: budget_consults_cltWhereUniqueInput
    /**
     * In case the budget_consults_clt found by the `where` argument doesn't exist, create a new budget_consults_clt with this data.
     */
    create: XOR<budget_consults_cltCreateInput, budget_consults_cltUncheckedCreateInput>
    /**
     * In case the budget_consults_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<budget_consults_cltUpdateInput, budget_consults_cltUncheckedUpdateInput>
  }

  /**
   * budget_consults_clt delete
   */
  export type budget_consults_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    /**
     * Filter which budget_consults_clt to delete.
     */
    where: budget_consults_cltWhereUniqueInput
  }

  /**
   * budget_consults_clt deleteMany
   */
  export type budget_consults_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_consults_clts to delete
     */
    where?: budget_consults_cltWhereInput
    /**
     * Limit how many budget_consults_clts to delete.
     */
    limit?: number
  }

  /**
   * budget_consults_clt without action
   */
  export type budget_consults_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
  }


  /**
   * Model budget_consults_goi
   */

  export type AggregateBudget_consults_goi = {
    _count: Budget_consults_goiCountAggregateOutputType | null
    _avg: Budget_consults_goiAvgAggregateOutputType | null
    _sum: Budget_consults_goiSumAggregateOutputType | null
    _min: Budget_consults_goiMinAggregateOutputType | null
    _max: Budget_consults_goiMaxAggregateOutputType | null
  }

  export type Budget_consults_goiAvgAggregateOutputType = {
    budget_code: number | null
  }

  export type Budget_consults_goiSumAggregateOutputType = {
    budget_code: number | null
  }

  export type Budget_consults_goiMinAggregateOutputType = {
    id: string | null
    budget_code: number | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Budget_consults_goiMaxAggregateOutputType = {
    id: string | null
    budget_code: number | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Budget_consults_goiCountAggregateOutputType = {
    id: number
    budget_code: number
    is_error: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Budget_consults_goiAvgAggregateInputType = {
    budget_code?: true
  }

  export type Budget_consults_goiSumAggregateInputType = {
    budget_code?: true
  }

  export type Budget_consults_goiMinAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Budget_consults_goiMaxAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Budget_consults_goiCountAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Budget_consults_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_consults_goi to aggregate.
     */
    where?: budget_consults_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_gois to fetch.
     */
    orderBy?: budget_consults_goiOrderByWithRelationInput | budget_consults_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: budget_consults_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned budget_consults_gois
    **/
    _count?: true | Budget_consults_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Budget_consults_goiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Budget_consults_goiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Budget_consults_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Budget_consults_goiMaxAggregateInputType
  }

  export type GetBudget_consults_goiAggregateType<T extends Budget_consults_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget_consults_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget_consults_goi[P]>
      : GetScalarType<T[P], AggregateBudget_consults_goi[P]>
  }




  export type budget_consults_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_consults_goiWhereInput
    orderBy?: budget_consults_goiOrderByWithAggregationInput | budget_consults_goiOrderByWithAggregationInput[]
    by: Budget_consults_goiScalarFieldEnum[] | Budget_consults_goiScalarFieldEnum
    having?: budget_consults_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Budget_consults_goiCountAggregateInputType | true
    _avg?: Budget_consults_goiAvgAggregateInputType
    _sum?: Budget_consults_goiSumAggregateInputType
    _min?: Budget_consults_goiMinAggregateInputType
    _max?: Budget_consults_goiMaxAggregateInputType
  }

  export type Budget_consults_goiGroupByOutputType = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date
    updatedAt: Date
    _count: Budget_consults_goiCountAggregateOutputType | null
    _avg: Budget_consults_goiAvgAggregateOutputType | null
    _sum: Budget_consults_goiSumAggregateOutputType | null
    _min: Budget_consults_goiMinAggregateOutputType | null
    _max: Budget_consults_goiMaxAggregateOutputType | null
  }

  type GetBudget_consults_goiGroupByPayload<T extends budget_consults_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Budget_consults_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Budget_consults_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Budget_consults_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Budget_consults_goiGroupByOutputType[P]>
        }
      >
    >


  export type budget_consults_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budget_code?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget_consults_goi"]>



  export type budget_consults_goiSelectScalar = {
    id?: boolean
    budget_code?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type budget_consults_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budget_code" | "is_error" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["budget_consults_goi"]>
  export type budget_consults_goiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }

  export type $budget_consults_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "budget_consults_goi"
    objects: {
      users_goi: Prisma.$users_goiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budget_code: number
      is_error: boolean
      user_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget_consults_goi"]>
    composites: {}
  }

  type budget_consults_goiGetPayload<S extends boolean | null | undefined | budget_consults_goiDefaultArgs> = $Result.GetResult<Prisma.$budget_consults_goiPayload, S>

  type budget_consults_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<budget_consults_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Budget_consults_goiCountAggregateInputType | true
    }

  export interface budget_consults_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['budget_consults_goi'], meta: { name: 'budget_consults_goi' } }
    /**
     * Find zero or one Budget_consults_goi that matches the filter.
     * @param {budget_consults_goiFindUniqueArgs} args - Arguments to find a Budget_consults_goi
     * @example
     * // Get one Budget_consults_goi
     * const budget_consults_goi = await prisma.budget_consults_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends budget_consults_goiFindUniqueArgs>(args: SelectSubset<T, budget_consults_goiFindUniqueArgs<ExtArgs>>): Prisma__budget_consults_goiClient<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget_consults_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {budget_consults_goiFindUniqueOrThrowArgs} args - Arguments to find a Budget_consults_goi
     * @example
     * // Get one Budget_consults_goi
     * const budget_consults_goi = await prisma.budget_consults_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends budget_consults_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, budget_consults_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__budget_consults_goiClient<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_consults_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_goiFindFirstArgs} args - Arguments to find a Budget_consults_goi
     * @example
     * // Get one Budget_consults_goi
     * const budget_consults_goi = await prisma.budget_consults_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends budget_consults_goiFindFirstArgs>(args?: SelectSubset<T, budget_consults_goiFindFirstArgs<ExtArgs>>): Prisma__budget_consults_goiClient<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_consults_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_goiFindFirstOrThrowArgs} args - Arguments to find a Budget_consults_goi
     * @example
     * // Get one Budget_consults_goi
     * const budget_consults_goi = await prisma.budget_consults_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends budget_consults_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, budget_consults_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__budget_consults_goiClient<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budget_consults_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budget_consults_gois
     * const budget_consults_gois = await prisma.budget_consults_goi.findMany()
     * 
     * // Get first 10 Budget_consults_gois
     * const budget_consults_gois = await prisma.budget_consults_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budget_consults_goiWithIdOnly = await prisma.budget_consults_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends budget_consults_goiFindManyArgs>(args?: SelectSubset<T, budget_consults_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget_consults_goi.
     * @param {budget_consults_goiCreateArgs} args - Arguments to create a Budget_consults_goi.
     * @example
     * // Create one Budget_consults_goi
     * const Budget_consults_goi = await prisma.budget_consults_goi.create({
     *   data: {
     *     // ... data to create a Budget_consults_goi
     *   }
     * })
     * 
     */
    create<T extends budget_consults_goiCreateArgs>(args: SelectSubset<T, budget_consults_goiCreateArgs<ExtArgs>>): Prisma__budget_consults_goiClient<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budget_consults_gois.
     * @param {budget_consults_goiCreateManyArgs} args - Arguments to create many Budget_consults_gois.
     * @example
     * // Create many Budget_consults_gois
     * const budget_consults_goi = await prisma.budget_consults_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends budget_consults_goiCreateManyArgs>(args?: SelectSubset<T, budget_consults_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Budget_consults_goi.
     * @param {budget_consults_goiDeleteArgs} args - Arguments to delete one Budget_consults_goi.
     * @example
     * // Delete one Budget_consults_goi
     * const Budget_consults_goi = await prisma.budget_consults_goi.delete({
     *   where: {
     *     // ... filter to delete one Budget_consults_goi
     *   }
     * })
     * 
     */
    delete<T extends budget_consults_goiDeleteArgs>(args: SelectSubset<T, budget_consults_goiDeleteArgs<ExtArgs>>): Prisma__budget_consults_goiClient<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget_consults_goi.
     * @param {budget_consults_goiUpdateArgs} args - Arguments to update one Budget_consults_goi.
     * @example
     * // Update one Budget_consults_goi
     * const budget_consults_goi = await prisma.budget_consults_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends budget_consults_goiUpdateArgs>(args: SelectSubset<T, budget_consults_goiUpdateArgs<ExtArgs>>): Prisma__budget_consults_goiClient<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budget_consults_gois.
     * @param {budget_consults_goiDeleteManyArgs} args - Arguments to filter Budget_consults_gois to delete.
     * @example
     * // Delete a few Budget_consults_gois
     * const { count } = await prisma.budget_consults_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends budget_consults_goiDeleteManyArgs>(args?: SelectSubset<T, budget_consults_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budget_consults_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budget_consults_gois
     * const budget_consults_goi = await prisma.budget_consults_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends budget_consults_goiUpdateManyArgs>(args: SelectSubset<T, budget_consults_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget_consults_goi.
     * @param {budget_consults_goiUpsertArgs} args - Arguments to update or create a Budget_consults_goi.
     * @example
     * // Update or create a Budget_consults_goi
     * const budget_consults_goi = await prisma.budget_consults_goi.upsert({
     *   create: {
     *     // ... data to create a Budget_consults_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget_consults_goi we want to update
     *   }
     * })
     */
    upsert<T extends budget_consults_goiUpsertArgs>(args: SelectSubset<T, budget_consults_goiUpsertArgs<ExtArgs>>): Prisma__budget_consults_goiClient<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budget_consults_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_goiCountArgs} args - Arguments to filter Budget_consults_gois to count.
     * @example
     * // Count the number of Budget_consults_gois
     * const count = await prisma.budget_consults_goi.count({
     *   where: {
     *     // ... the filter for the Budget_consults_gois we want to count
     *   }
     * })
    **/
    count<T extends budget_consults_goiCountArgs>(
      args?: Subset<T, budget_consults_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Budget_consults_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget_consults_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Budget_consults_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Budget_consults_goiAggregateArgs>(args: Subset<T, Budget_consults_goiAggregateArgs>): Prisma.PrismaPromise<GetBudget_consults_goiAggregateType<T>>

    /**
     * Group by Budget_consults_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends budget_consults_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: budget_consults_goiGroupByArgs['orderBy'] }
        : { orderBy?: budget_consults_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, budget_consults_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudget_consults_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the budget_consults_goi model
   */
  readonly fields: budget_consults_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for budget_consults_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__budget_consults_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_goi<T extends users_goiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_goiDefaultArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the budget_consults_goi model
   */
  interface budget_consults_goiFieldRefs {
    readonly id: FieldRef<"budget_consults_goi", 'String'>
    readonly budget_code: FieldRef<"budget_consults_goi", 'Int'>
    readonly is_error: FieldRef<"budget_consults_goi", 'Boolean'>
    readonly user_id: FieldRef<"budget_consults_goi", 'String'>
    readonly createdAt: FieldRef<"budget_consults_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"budget_consults_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * budget_consults_goi findUnique
   */
  export type budget_consults_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_goi to fetch.
     */
    where: budget_consults_goiWhereUniqueInput
  }

  /**
   * budget_consults_goi findUniqueOrThrow
   */
  export type budget_consults_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_goi to fetch.
     */
    where: budget_consults_goiWhereUniqueInput
  }

  /**
   * budget_consults_goi findFirst
   */
  export type budget_consults_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_goi to fetch.
     */
    where?: budget_consults_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_gois to fetch.
     */
    orderBy?: budget_consults_goiOrderByWithRelationInput | budget_consults_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_consults_gois.
     */
    cursor?: budget_consults_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_consults_gois.
     */
    distinct?: Budget_consults_goiScalarFieldEnum | Budget_consults_goiScalarFieldEnum[]
  }

  /**
   * budget_consults_goi findFirstOrThrow
   */
  export type budget_consults_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_goi to fetch.
     */
    where?: budget_consults_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_gois to fetch.
     */
    orderBy?: budget_consults_goiOrderByWithRelationInput | budget_consults_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_consults_gois.
     */
    cursor?: budget_consults_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_consults_gois.
     */
    distinct?: Budget_consults_goiScalarFieldEnum | Budget_consults_goiScalarFieldEnum[]
  }

  /**
   * budget_consults_goi findMany
   */
  export type budget_consults_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_gois to fetch.
     */
    where?: budget_consults_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_gois to fetch.
     */
    orderBy?: budget_consults_goiOrderByWithRelationInput | budget_consults_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing budget_consults_gois.
     */
    cursor?: budget_consults_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_gois.
     */
    skip?: number
    distinct?: Budget_consults_goiScalarFieldEnum | Budget_consults_goiScalarFieldEnum[]
  }

  /**
   * budget_consults_goi create
   */
  export type budget_consults_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * The data needed to create a budget_consults_goi.
     */
    data: XOR<budget_consults_goiCreateInput, budget_consults_goiUncheckedCreateInput>
  }

  /**
   * budget_consults_goi createMany
   */
  export type budget_consults_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many budget_consults_gois.
     */
    data: budget_consults_goiCreateManyInput | budget_consults_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * budget_consults_goi update
   */
  export type budget_consults_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * The data needed to update a budget_consults_goi.
     */
    data: XOR<budget_consults_goiUpdateInput, budget_consults_goiUncheckedUpdateInput>
    /**
     * Choose, which budget_consults_goi to update.
     */
    where: budget_consults_goiWhereUniqueInput
  }

  /**
   * budget_consults_goi updateMany
   */
  export type budget_consults_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update budget_consults_gois.
     */
    data: XOR<budget_consults_goiUpdateManyMutationInput, budget_consults_goiUncheckedUpdateManyInput>
    /**
     * Filter which budget_consults_gois to update
     */
    where?: budget_consults_goiWhereInput
    /**
     * Limit how many budget_consults_gois to update.
     */
    limit?: number
  }

  /**
   * budget_consults_goi upsert
   */
  export type budget_consults_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * The filter to search for the budget_consults_goi to update in case it exists.
     */
    where: budget_consults_goiWhereUniqueInput
    /**
     * In case the budget_consults_goi found by the `where` argument doesn't exist, create a new budget_consults_goi with this data.
     */
    create: XOR<budget_consults_goiCreateInput, budget_consults_goiUncheckedCreateInput>
    /**
     * In case the budget_consults_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<budget_consults_goiUpdateInput, budget_consults_goiUncheckedUpdateInput>
  }

  /**
   * budget_consults_goi delete
   */
  export type budget_consults_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    /**
     * Filter which budget_consults_goi to delete.
     */
    where: budget_consults_goiWhereUniqueInput
  }

  /**
   * budget_consults_goi deleteMany
   */
  export type budget_consults_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_consults_gois to delete
     */
    where?: budget_consults_goiWhereInput
    /**
     * Limit how many budget_consults_gois to delete.
     */
    limit?: number
  }

  /**
   * budget_consults_goi without action
   */
  export type budget_consults_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
  }


  /**
   * Model budget_consults_spa
   */

  export type AggregateBudget_consults_spa = {
    _count: Budget_consults_spaCountAggregateOutputType | null
    _avg: Budget_consults_spaAvgAggregateOutputType | null
    _sum: Budget_consults_spaSumAggregateOutputType | null
    _min: Budget_consults_spaMinAggregateOutputType | null
    _max: Budget_consults_spaMaxAggregateOutputType | null
  }

  export type Budget_consults_spaAvgAggregateOutputType = {
    budget_code: number | null
  }

  export type Budget_consults_spaSumAggregateOutputType = {
    budget_code: number | null
  }

  export type Budget_consults_spaMinAggregateOutputType = {
    id: string | null
    budget_code: number | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Budget_consults_spaMaxAggregateOutputType = {
    id: string | null
    budget_code: number | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Budget_consults_spaCountAggregateOutputType = {
    id: number
    budget_code: number
    is_error: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Budget_consults_spaAvgAggregateInputType = {
    budget_code?: true
  }

  export type Budget_consults_spaSumAggregateInputType = {
    budget_code?: true
  }

  export type Budget_consults_spaMinAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Budget_consults_spaMaxAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Budget_consults_spaCountAggregateInputType = {
    id?: true
    budget_code?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Budget_consults_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_consults_spa to aggregate.
     */
    where?: budget_consults_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_spas to fetch.
     */
    orderBy?: budget_consults_spaOrderByWithRelationInput | budget_consults_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: budget_consults_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned budget_consults_spas
    **/
    _count?: true | Budget_consults_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Budget_consults_spaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Budget_consults_spaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Budget_consults_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Budget_consults_spaMaxAggregateInputType
  }

  export type GetBudget_consults_spaAggregateType<T extends Budget_consults_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget_consults_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget_consults_spa[P]>
      : GetScalarType<T[P], AggregateBudget_consults_spa[P]>
  }




  export type budget_consults_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_consults_spaWhereInput
    orderBy?: budget_consults_spaOrderByWithAggregationInput | budget_consults_spaOrderByWithAggregationInput[]
    by: Budget_consults_spaScalarFieldEnum[] | Budget_consults_spaScalarFieldEnum
    having?: budget_consults_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Budget_consults_spaCountAggregateInputType | true
    _avg?: Budget_consults_spaAvgAggregateInputType
    _sum?: Budget_consults_spaSumAggregateInputType
    _min?: Budget_consults_spaMinAggregateInputType
    _max?: Budget_consults_spaMaxAggregateInputType
  }

  export type Budget_consults_spaGroupByOutputType = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date
    updatedAt: Date
    _count: Budget_consults_spaCountAggregateOutputType | null
    _avg: Budget_consults_spaAvgAggregateOutputType | null
    _sum: Budget_consults_spaSumAggregateOutputType | null
    _min: Budget_consults_spaMinAggregateOutputType | null
    _max: Budget_consults_spaMaxAggregateOutputType | null
  }

  type GetBudget_consults_spaGroupByPayload<T extends budget_consults_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Budget_consults_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Budget_consults_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Budget_consults_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Budget_consults_spaGroupByOutputType[P]>
        }
      >
    >


  export type budget_consults_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budget_code?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget_consults_spa"]>



  export type budget_consults_spaSelectScalar = {
    id?: boolean
    budget_code?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type budget_consults_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budget_code" | "is_error" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["budget_consults_spa"]>
  export type budget_consults_spaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }

  export type $budget_consults_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "budget_consults_spa"
    objects: {
      users_spa: Prisma.$users_spaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budget_code: number
      is_error: boolean
      user_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget_consults_spa"]>
    composites: {}
  }

  type budget_consults_spaGetPayload<S extends boolean | null | undefined | budget_consults_spaDefaultArgs> = $Result.GetResult<Prisma.$budget_consults_spaPayload, S>

  type budget_consults_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<budget_consults_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Budget_consults_spaCountAggregateInputType | true
    }

  export interface budget_consults_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['budget_consults_spa'], meta: { name: 'budget_consults_spa' } }
    /**
     * Find zero or one Budget_consults_spa that matches the filter.
     * @param {budget_consults_spaFindUniqueArgs} args - Arguments to find a Budget_consults_spa
     * @example
     * // Get one Budget_consults_spa
     * const budget_consults_spa = await prisma.budget_consults_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends budget_consults_spaFindUniqueArgs>(args: SelectSubset<T, budget_consults_spaFindUniqueArgs<ExtArgs>>): Prisma__budget_consults_spaClient<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget_consults_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {budget_consults_spaFindUniqueOrThrowArgs} args - Arguments to find a Budget_consults_spa
     * @example
     * // Get one Budget_consults_spa
     * const budget_consults_spa = await prisma.budget_consults_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends budget_consults_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, budget_consults_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__budget_consults_spaClient<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_consults_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_spaFindFirstArgs} args - Arguments to find a Budget_consults_spa
     * @example
     * // Get one Budget_consults_spa
     * const budget_consults_spa = await prisma.budget_consults_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends budget_consults_spaFindFirstArgs>(args?: SelectSubset<T, budget_consults_spaFindFirstArgs<ExtArgs>>): Prisma__budget_consults_spaClient<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_consults_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_spaFindFirstOrThrowArgs} args - Arguments to find a Budget_consults_spa
     * @example
     * // Get one Budget_consults_spa
     * const budget_consults_spa = await prisma.budget_consults_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends budget_consults_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, budget_consults_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__budget_consults_spaClient<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budget_consults_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budget_consults_spas
     * const budget_consults_spas = await prisma.budget_consults_spa.findMany()
     * 
     * // Get first 10 Budget_consults_spas
     * const budget_consults_spas = await prisma.budget_consults_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budget_consults_spaWithIdOnly = await prisma.budget_consults_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends budget_consults_spaFindManyArgs>(args?: SelectSubset<T, budget_consults_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget_consults_spa.
     * @param {budget_consults_spaCreateArgs} args - Arguments to create a Budget_consults_spa.
     * @example
     * // Create one Budget_consults_spa
     * const Budget_consults_spa = await prisma.budget_consults_spa.create({
     *   data: {
     *     // ... data to create a Budget_consults_spa
     *   }
     * })
     * 
     */
    create<T extends budget_consults_spaCreateArgs>(args: SelectSubset<T, budget_consults_spaCreateArgs<ExtArgs>>): Prisma__budget_consults_spaClient<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budget_consults_spas.
     * @param {budget_consults_spaCreateManyArgs} args - Arguments to create many Budget_consults_spas.
     * @example
     * // Create many Budget_consults_spas
     * const budget_consults_spa = await prisma.budget_consults_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends budget_consults_spaCreateManyArgs>(args?: SelectSubset<T, budget_consults_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Budget_consults_spa.
     * @param {budget_consults_spaDeleteArgs} args - Arguments to delete one Budget_consults_spa.
     * @example
     * // Delete one Budget_consults_spa
     * const Budget_consults_spa = await prisma.budget_consults_spa.delete({
     *   where: {
     *     // ... filter to delete one Budget_consults_spa
     *   }
     * })
     * 
     */
    delete<T extends budget_consults_spaDeleteArgs>(args: SelectSubset<T, budget_consults_spaDeleteArgs<ExtArgs>>): Prisma__budget_consults_spaClient<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget_consults_spa.
     * @param {budget_consults_spaUpdateArgs} args - Arguments to update one Budget_consults_spa.
     * @example
     * // Update one Budget_consults_spa
     * const budget_consults_spa = await prisma.budget_consults_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends budget_consults_spaUpdateArgs>(args: SelectSubset<T, budget_consults_spaUpdateArgs<ExtArgs>>): Prisma__budget_consults_spaClient<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budget_consults_spas.
     * @param {budget_consults_spaDeleteManyArgs} args - Arguments to filter Budget_consults_spas to delete.
     * @example
     * // Delete a few Budget_consults_spas
     * const { count } = await prisma.budget_consults_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends budget_consults_spaDeleteManyArgs>(args?: SelectSubset<T, budget_consults_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budget_consults_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budget_consults_spas
     * const budget_consults_spa = await prisma.budget_consults_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends budget_consults_spaUpdateManyArgs>(args: SelectSubset<T, budget_consults_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget_consults_spa.
     * @param {budget_consults_spaUpsertArgs} args - Arguments to update or create a Budget_consults_spa.
     * @example
     * // Update or create a Budget_consults_spa
     * const budget_consults_spa = await prisma.budget_consults_spa.upsert({
     *   create: {
     *     // ... data to create a Budget_consults_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget_consults_spa we want to update
     *   }
     * })
     */
    upsert<T extends budget_consults_spaUpsertArgs>(args: SelectSubset<T, budget_consults_spaUpsertArgs<ExtArgs>>): Prisma__budget_consults_spaClient<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budget_consults_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_spaCountArgs} args - Arguments to filter Budget_consults_spas to count.
     * @example
     * // Count the number of Budget_consults_spas
     * const count = await prisma.budget_consults_spa.count({
     *   where: {
     *     // ... the filter for the Budget_consults_spas we want to count
     *   }
     * })
    **/
    count<T extends budget_consults_spaCountArgs>(
      args?: Subset<T, budget_consults_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Budget_consults_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget_consults_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Budget_consults_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Budget_consults_spaAggregateArgs>(args: Subset<T, Budget_consults_spaAggregateArgs>): Prisma.PrismaPromise<GetBudget_consults_spaAggregateType<T>>

    /**
     * Group by Budget_consults_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_consults_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends budget_consults_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: budget_consults_spaGroupByArgs['orderBy'] }
        : { orderBy?: budget_consults_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, budget_consults_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudget_consults_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the budget_consults_spa model
   */
  readonly fields: budget_consults_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for budget_consults_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__budget_consults_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_spa<T extends users_spaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_spaDefaultArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the budget_consults_spa model
   */
  interface budget_consults_spaFieldRefs {
    readonly id: FieldRef<"budget_consults_spa", 'String'>
    readonly budget_code: FieldRef<"budget_consults_spa", 'Int'>
    readonly is_error: FieldRef<"budget_consults_spa", 'Boolean'>
    readonly user_id: FieldRef<"budget_consults_spa", 'String'>
    readonly createdAt: FieldRef<"budget_consults_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"budget_consults_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * budget_consults_spa findUnique
   */
  export type budget_consults_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_spa to fetch.
     */
    where: budget_consults_spaWhereUniqueInput
  }

  /**
   * budget_consults_spa findUniqueOrThrow
   */
  export type budget_consults_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_spa to fetch.
     */
    where: budget_consults_spaWhereUniqueInput
  }

  /**
   * budget_consults_spa findFirst
   */
  export type budget_consults_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_spa to fetch.
     */
    where?: budget_consults_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_spas to fetch.
     */
    orderBy?: budget_consults_spaOrderByWithRelationInput | budget_consults_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_consults_spas.
     */
    cursor?: budget_consults_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_consults_spas.
     */
    distinct?: Budget_consults_spaScalarFieldEnum | Budget_consults_spaScalarFieldEnum[]
  }

  /**
   * budget_consults_spa findFirstOrThrow
   */
  export type budget_consults_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_spa to fetch.
     */
    where?: budget_consults_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_spas to fetch.
     */
    orderBy?: budget_consults_spaOrderByWithRelationInput | budget_consults_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_consults_spas.
     */
    cursor?: budget_consults_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_consults_spas.
     */
    distinct?: Budget_consults_spaScalarFieldEnum | Budget_consults_spaScalarFieldEnum[]
  }

  /**
   * budget_consults_spa findMany
   */
  export type budget_consults_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which budget_consults_spas to fetch.
     */
    where?: budget_consults_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_consults_spas to fetch.
     */
    orderBy?: budget_consults_spaOrderByWithRelationInput | budget_consults_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing budget_consults_spas.
     */
    cursor?: budget_consults_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_consults_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_consults_spas.
     */
    skip?: number
    distinct?: Budget_consults_spaScalarFieldEnum | Budget_consults_spaScalarFieldEnum[]
  }

  /**
   * budget_consults_spa create
   */
  export type budget_consults_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * The data needed to create a budget_consults_spa.
     */
    data: XOR<budget_consults_spaCreateInput, budget_consults_spaUncheckedCreateInput>
  }

  /**
   * budget_consults_spa createMany
   */
  export type budget_consults_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many budget_consults_spas.
     */
    data: budget_consults_spaCreateManyInput | budget_consults_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * budget_consults_spa update
   */
  export type budget_consults_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * The data needed to update a budget_consults_spa.
     */
    data: XOR<budget_consults_spaUpdateInput, budget_consults_spaUncheckedUpdateInput>
    /**
     * Choose, which budget_consults_spa to update.
     */
    where: budget_consults_spaWhereUniqueInput
  }

  /**
   * budget_consults_spa updateMany
   */
  export type budget_consults_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update budget_consults_spas.
     */
    data: XOR<budget_consults_spaUpdateManyMutationInput, budget_consults_spaUncheckedUpdateManyInput>
    /**
     * Filter which budget_consults_spas to update
     */
    where?: budget_consults_spaWhereInput
    /**
     * Limit how many budget_consults_spas to update.
     */
    limit?: number
  }

  /**
   * budget_consults_spa upsert
   */
  export type budget_consults_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * The filter to search for the budget_consults_spa to update in case it exists.
     */
    where: budget_consults_spaWhereUniqueInput
    /**
     * In case the budget_consults_spa found by the `where` argument doesn't exist, create a new budget_consults_spa with this data.
     */
    create: XOR<budget_consults_spaCreateInput, budget_consults_spaUncheckedCreateInput>
    /**
     * In case the budget_consults_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<budget_consults_spaUpdateInput, budget_consults_spaUncheckedUpdateInput>
  }

  /**
   * budget_consults_spa delete
   */
  export type budget_consults_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    /**
     * Filter which budget_consults_spa to delete.
     */
    where: budget_consults_spaWhereUniqueInput
  }

  /**
   * budget_consults_spa deleteMany
   */
  export type budget_consults_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_consults_spas to delete
     */
    where?: budget_consults_spaWhereInput
    /**
     * Limit how many budget_consults_spas to delete.
     */
    limit?: number
  }

  /**
   * budget_consults_spa without action
   */
  export type budget_consults_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
  }


  /**
   * Model calls
   */

  export type AggregateCalls = {
    _count: CallsCountAggregateOutputType | null
    _min: CallsMinAggregateOutputType | null
    _max: CallsMaxAggregateOutputType | null
  }

  export type CallsMinAggregateOutputType = {
    id: string | null
    jid: string | null
    mainProblem: string | null
    detailsProblem: string | null
    pushName: string | null
    attendantId: string | null
    isResolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallsMaxAggregateOutputType = {
    id: string | null
    jid: string | null
    mainProblem: string | null
    detailsProblem: string | null
    pushName: string | null
    attendantId: string | null
    isResolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallsCountAggregateOutputType = {
    id: number
    jid: number
    mainProblem: number
    detailsProblem: number
    pushName: number
    attendantId: number
    isResolved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CallsMinAggregateInputType = {
    id?: true
    jid?: true
    mainProblem?: true
    detailsProblem?: true
    pushName?: true
    attendantId?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallsMaxAggregateInputType = {
    id?: true
    jid?: true
    mainProblem?: true
    detailsProblem?: true
    pushName?: true
    attendantId?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallsCountAggregateInputType = {
    id?: true
    jid?: true
    mainProblem?: true
    detailsProblem?: true
    pushName?: true
    attendantId?: true
    isResolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CallsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calls to aggregate.
     */
    where?: callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calls to fetch.
     */
    orderBy?: callsOrderByWithRelationInput | callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned calls
    **/
    _count?: true | CallsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallsMaxAggregateInputType
  }

  export type GetCallsAggregateType<T extends CallsAggregateArgs> = {
        [P in keyof T & keyof AggregateCalls]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalls[P]>
      : GetScalarType<T[P], AggregateCalls[P]>
  }




  export type callsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: callsWhereInput
    orderBy?: callsOrderByWithAggregationInput | callsOrderByWithAggregationInput[]
    by: CallsScalarFieldEnum[] | CallsScalarFieldEnum
    having?: callsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallsCountAggregateInputType | true
    _min?: CallsMinAggregateInputType
    _max?: CallsMaxAggregateInputType
  }

  export type CallsGroupByOutputType = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    attendantId: string | null
    isResolved: boolean
    createdAt: Date
    updatedAt: Date
    _count: CallsCountAggregateOutputType | null
    _min: CallsMinAggregateOutputType | null
    _max: CallsMaxAggregateOutputType | null
  }

  type GetCallsGroupByPayload<T extends callsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallsGroupByOutputType[P]>
            : GetScalarType<T[P], CallsGroupByOutputType[P]>
        }
      >
    >


  export type callsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jid?: boolean
    mainProblem?: boolean
    detailsProblem?: boolean
    pushName?: boolean
    attendantId?: boolean
    isResolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attendant?: boolean | calls$attendantArgs<ExtArgs>
  }, ExtArgs["result"]["calls"]>



  export type callsSelectScalar = {
    id?: boolean
    jid?: boolean
    mainProblem?: boolean
    detailsProblem?: boolean
    pushName?: boolean
    attendantId?: boolean
    isResolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type callsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jid" | "mainProblem" | "detailsProblem" | "pushName" | "attendantId" | "isResolved" | "createdAt" | "updatedAt", ExtArgs["result"]["calls"]>
  export type callsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendant?: boolean | calls$attendantArgs<ExtArgs>
  }

  export type $callsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "calls"
    objects: {
      attendant: Prisma.$attendantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jid: string
      mainProblem: string
      detailsProblem: string
      pushName: string
      attendantId: string | null
      isResolved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calls"]>
    composites: {}
  }

  type callsGetPayload<S extends boolean | null | undefined | callsDefaultArgs> = $Result.GetResult<Prisma.$callsPayload, S>

  type callsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<callsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallsCountAggregateInputType | true
    }

  export interface callsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['calls'], meta: { name: 'calls' } }
    /**
     * Find zero or one Calls that matches the filter.
     * @param {callsFindUniqueArgs} args - Arguments to find a Calls
     * @example
     * // Get one Calls
     * const calls = await prisma.calls.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends callsFindUniqueArgs>(args: SelectSubset<T, callsFindUniqueArgs<ExtArgs>>): Prisma__callsClient<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Calls that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {callsFindUniqueOrThrowArgs} args - Arguments to find a Calls
     * @example
     * // Get one Calls
     * const calls = await prisma.calls.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends callsFindUniqueOrThrowArgs>(args: SelectSubset<T, callsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__callsClient<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callsFindFirstArgs} args - Arguments to find a Calls
     * @example
     * // Get one Calls
     * const calls = await prisma.calls.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends callsFindFirstArgs>(args?: SelectSubset<T, callsFindFirstArgs<ExtArgs>>): Prisma__callsClient<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calls that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callsFindFirstOrThrowArgs} args - Arguments to find a Calls
     * @example
     * // Get one Calls
     * const calls = await prisma.calls.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends callsFindFirstOrThrowArgs>(args?: SelectSubset<T, callsFindFirstOrThrowArgs<ExtArgs>>): Prisma__callsClient<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calls
     * const calls = await prisma.calls.findMany()
     * 
     * // Get first 10 Calls
     * const calls = await prisma.calls.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callsWithIdOnly = await prisma.calls.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends callsFindManyArgs>(args?: SelectSubset<T, callsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Calls.
     * @param {callsCreateArgs} args - Arguments to create a Calls.
     * @example
     * // Create one Calls
     * const Calls = await prisma.calls.create({
     *   data: {
     *     // ... data to create a Calls
     *   }
     * })
     * 
     */
    create<T extends callsCreateArgs>(args: SelectSubset<T, callsCreateArgs<ExtArgs>>): Prisma__callsClient<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calls.
     * @param {callsCreateManyArgs} args - Arguments to create many Calls.
     * @example
     * // Create many Calls
     * const calls = await prisma.calls.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends callsCreateManyArgs>(args?: SelectSubset<T, callsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Calls.
     * @param {callsDeleteArgs} args - Arguments to delete one Calls.
     * @example
     * // Delete one Calls
     * const Calls = await prisma.calls.delete({
     *   where: {
     *     // ... filter to delete one Calls
     *   }
     * })
     * 
     */
    delete<T extends callsDeleteArgs>(args: SelectSubset<T, callsDeleteArgs<ExtArgs>>): Prisma__callsClient<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Calls.
     * @param {callsUpdateArgs} args - Arguments to update one Calls.
     * @example
     * // Update one Calls
     * const calls = await prisma.calls.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends callsUpdateArgs>(args: SelectSubset<T, callsUpdateArgs<ExtArgs>>): Prisma__callsClient<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calls.
     * @param {callsDeleteManyArgs} args - Arguments to filter Calls to delete.
     * @example
     * // Delete a few Calls
     * const { count } = await prisma.calls.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends callsDeleteManyArgs>(args?: SelectSubset<T, callsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calls
     * const calls = await prisma.calls.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends callsUpdateManyArgs>(args: SelectSubset<T, callsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Calls.
     * @param {callsUpsertArgs} args - Arguments to update or create a Calls.
     * @example
     * // Update or create a Calls
     * const calls = await prisma.calls.upsert({
     *   create: {
     *     // ... data to create a Calls
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calls we want to update
     *   }
     * })
     */
    upsert<T extends callsUpsertArgs>(args: SelectSubset<T, callsUpsertArgs<ExtArgs>>): Prisma__callsClient<$Result.GetResult<Prisma.$callsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callsCountArgs} args - Arguments to filter Calls to count.
     * @example
     * // Count the number of Calls
     * const count = await prisma.calls.count({
     *   where: {
     *     // ... the filter for the Calls we want to count
     *   }
     * })
    **/
    count<T extends callsCountArgs>(
      args?: Subset<T, callsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallsAggregateArgs>(args: Subset<T, CallsAggregateArgs>): Prisma.PrismaPromise<GetCallsAggregateType<T>>

    /**
     * Group by Calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {callsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends callsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: callsGroupByArgs['orderBy'] }
        : { orderBy?: callsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, callsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the calls model
   */
  readonly fields: callsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for calls.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__callsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendant<T extends calls$attendantArgs<ExtArgs> = {}>(args?: Subset<T, calls$attendantArgs<ExtArgs>>): Prisma__attendantClient<$Result.GetResult<Prisma.$attendantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the calls model
   */
  interface callsFieldRefs {
    readonly id: FieldRef<"calls", 'String'>
    readonly jid: FieldRef<"calls", 'String'>
    readonly mainProblem: FieldRef<"calls", 'String'>
    readonly detailsProblem: FieldRef<"calls", 'String'>
    readonly pushName: FieldRef<"calls", 'String'>
    readonly attendantId: FieldRef<"calls", 'String'>
    readonly isResolved: FieldRef<"calls", 'Boolean'>
    readonly createdAt: FieldRef<"calls", 'DateTime'>
    readonly updatedAt: FieldRef<"calls", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * calls findUnique
   */
  export type callsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * Filter, which calls to fetch.
     */
    where: callsWhereUniqueInput
  }

  /**
   * calls findUniqueOrThrow
   */
  export type callsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * Filter, which calls to fetch.
     */
    where: callsWhereUniqueInput
  }

  /**
   * calls findFirst
   */
  export type callsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * Filter, which calls to fetch.
     */
    where?: callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calls to fetch.
     */
    orderBy?: callsOrderByWithRelationInput | callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calls.
     */
    cursor?: callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calls.
     */
    distinct?: CallsScalarFieldEnum | CallsScalarFieldEnum[]
  }

  /**
   * calls findFirstOrThrow
   */
  export type callsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * Filter, which calls to fetch.
     */
    where?: callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calls to fetch.
     */
    orderBy?: callsOrderByWithRelationInput | callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calls.
     */
    cursor?: callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calls.
     */
    distinct?: CallsScalarFieldEnum | CallsScalarFieldEnum[]
  }

  /**
   * calls findMany
   */
  export type callsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * Filter, which calls to fetch.
     */
    where?: callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calls to fetch.
     */
    orderBy?: callsOrderByWithRelationInput | callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing calls.
     */
    cursor?: callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calls.
     */
    skip?: number
    distinct?: CallsScalarFieldEnum | CallsScalarFieldEnum[]
  }

  /**
   * calls create
   */
  export type callsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * The data needed to create a calls.
     */
    data: XOR<callsCreateInput, callsUncheckedCreateInput>
  }

  /**
   * calls createMany
   */
  export type callsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many calls.
     */
    data: callsCreateManyInput | callsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * calls update
   */
  export type callsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * The data needed to update a calls.
     */
    data: XOR<callsUpdateInput, callsUncheckedUpdateInput>
    /**
     * Choose, which calls to update.
     */
    where: callsWhereUniqueInput
  }

  /**
   * calls updateMany
   */
  export type callsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update calls.
     */
    data: XOR<callsUpdateManyMutationInput, callsUncheckedUpdateManyInput>
    /**
     * Filter which calls to update
     */
    where?: callsWhereInput
    /**
     * Limit how many calls to update.
     */
    limit?: number
  }

  /**
   * calls upsert
   */
  export type callsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * The filter to search for the calls to update in case it exists.
     */
    where: callsWhereUniqueInput
    /**
     * In case the calls found by the `where` argument doesn't exist, create a new calls with this data.
     */
    create: XOR<callsCreateInput, callsUncheckedCreateInput>
    /**
     * In case the calls was found with the provided `where` argument, update it with this data.
     */
    update: XOR<callsUpdateInput, callsUncheckedUpdateInput>
  }

  /**
   * calls delete
   */
  export type callsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
    /**
     * Filter which calls to delete.
     */
    where: callsWhereUniqueInput
  }

  /**
   * calls deleteMany
   */
  export type callsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calls to delete
     */
    where?: callsWhereInput
    /**
     * Limit how many calls to delete.
     */
    limit?: number
  }

  /**
   * calls.attendant
   */
  export type calls$attendantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendant
     */
    select?: attendantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendant
     */
    omit?: attendantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendantInclude<ExtArgs> | null
    where?: attendantWhereInput
  }

  /**
   * calls without action
   */
  export type callsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calls
     */
    select?: callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calls
     */
    omit?: callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: callsInclude<ExtArgs> | null
  }


  /**
   * Model cities_quotations
   */

  export type AggregateCities_quotations = {
    _count: Cities_quotationsCountAggregateOutputType | null
    _avg: Cities_quotationsAvgAggregateOutputType | null
    _sum: Cities_quotationsSumAggregateOutputType | null
    _min: Cities_quotationsMinAggregateOutputType | null
    _max: Cities_quotationsMaxAggregateOutputType | null
  }

  export type Cities_quotationsAvgAggregateOutputType = {
    id: number | null
  }

  export type Cities_quotationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Cities_quotationsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Cities_quotationsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Cities_quotationsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Cities_quotationsAvgAggregateInputType = {
    id?: true
  }

  export type Cities_quotationsSumAggregateInputType = {
    id?: true
  }

  export type Cities_quotationsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Cities_quotationsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Cities_quotationsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Cities_quotationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities_quotations to aggregate.
     */
    where?: cities_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_quotations to fetch.
     */
    orderBy?: cities_quotationsOrderByWithRelationInput | cities_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cities_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities_quotations
    **/
    _count?: true | Cities_quotationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cities_quotationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cities_quotationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cities_quotationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cities_quotationsMaxAggregateInputType
  }

  export type GetCities_quotationsAggregateType<T extends Cities_quotationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCities_quotations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities_quotations[P]>
      : GetScalarType<T[P], AggregateCities_quotations[P]>
  }




  export type cities_quotationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cities_quotationsWhereInput
    orderBy?: cities_quotationsOrderByWithAggregationInput | cities_quotationsOrderByWithAggregationInput[]
    by: Cities_quotationsScalarFieldEnum[] | Cities_quotationsScalarFieldEnum
    having?: cities_quotationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cities_quotationsCountAggregateInputType | true
    _avg?: Cities_quotationsAvgAggregateInputType
    _sum?: Cities_quotationsSumAggregateInputType
    _min?: Cities_quotationsMinAggregateInputType
    _max?: Cities_quotationsMaxAggregateInputType
  }

  export type Cities_quotationsGroupByOutputType = {
    id: bigint
    name: string
    _count: Cities_quotationsCountAggregateOutputType | null
    _avg: Cities_quotationsAvgAggregateOutputType | null
    _sum: Cities_quotationsSumAggregateOutputType | null
    _min: Cities_quotationsMinAggregateOutputType | null
    _max: Cities_quotationsMaxAggregateOutputType | null
  }

  type GetCities_quotationsGroupByPayload<T extends cities_quotationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cities_quotationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cities_quotationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cities_quotationsGroupByOutputType[P]>
            : GetScalarType<T[P], Cities_quotationsGroupByOutputType[P]>
        }
      >
    >


  export type cities_quotationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["cities_quotations"]>



  export type cities_quotationsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type cities_quotationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["cities_quotations"]>

  export type $cities_quotationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cities_quotations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["cities_quotations"]>
    composites: {}
  }

  type cities_quotationsGetPayload<S extends boolean | null | undefined | cities_quotationsDefaultArgs> = $Result.GetResult<Prisma.$cities_quotationsPayload, S>

  type cities_quotationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cities_quotationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cities_quotationsCountAggregateInputType | true
    }

  export interface cities_quotationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cities_quotations'], meta: { name: 'cities_quotations' } }
    /**
     * Find zero or one Cities_quotations that matches the filter.
     * @param {cities_quotationsFindUniqueArgs} args - Arguments to find a Cities_quotations
     * @example
     * // Get one Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cities_quotationsFindUniqueArgs>(args: SelectSubset<T, cities_quotationsFindUniqueArgs<ExtArgs>>): Prisma__cities_quotationsClient<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cities_quotations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cities_quotationsFindUniqueOrThrowArgs} args - Arguments to find a Cities_quotations
     * @example
     * // Get one Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cities_quotationsFindUniqueOrThrowArgs>(args: SelectSubset<T, cities_quotationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cities_quotationsClient<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cities_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_quotationsFindFirstArgs} args - Arguments to find a Cities_quotations
     * @example
     * // Get one Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cities_quotationsFindFirstArgs>(args?: SelectSubset<T, cities_quotationsFindFirstArgs<ExtArgs>>): Prisma__cities_quotationsClient<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cities_quotations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_quotationsFindFirstOrThrowArgs} args - Arguments to find a Cities_quotations
     * @example
     * // Get one Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cities_quotationsFindFirstOrThrowArgs>(args?: SelectSubset<T, cities_quotationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cities_quotationsClient<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_quotationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.findMany()
     * 
     * // Get first 10 Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cities_quotationsWithIdOnly = await prisma.cities_quotations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cities_quotationsFindManyArgs>(args?: SelectSubset<T, cities_quotationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cities_quotations.
     * @param {cities_quotationsCreateArgs} args - Arguments to create a Cities_quotations.
     * @example
     * // Create one Cities_quotations
     * const Cities_quotations = await prisma.cities_quotations.create({
     *   data: {
     *     // ... data to create a Cities_quotations
     *   }
     * })
     * 
     */
    create<T extends cities_quotationsCreateArgs>(args: SelectSubset<T, cities_quotationsCreateArgs<ExtArgs>>): Prisma__cities_quotationsClient<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities_quotations.
     * @param {cities_quotationsCreateManyArgs} args - Arguments to create many Cities_quotations.
     * @example
     * // Create many Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cities_quotationsCreateManyArgs>(args?: SelectSubset<T, cities_quotationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cities_quotations.
     * @param {cities_quotationsDeleteArgs} args - Arguments to delete one Cities_quotations.
     * @example
     * // Delete one Cities_quotations
     * const Cities_quotations = await prisma.cities_quotations.delete({
     *   where: {
     *     // ... filter to delete one Cities_quotations
     *   }
     * })
     * 
     */
    delete<T extends cities_quotationsDeleteArgs>(args: SelectSubset<T, cities_quotationsDeleteArgs<ExtArgs>>): Prisma__cities_quotationsClient<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cities_quotations.
     * @param {cities_quotationsUpdateArgs} args - Arguments to update one Cities_quotations.
     * @example
     * // Update one Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cities_quotationsUpdateArgs>(args: SelectSubset<T, cities_quotationsUpdateArgs<ExtArgs>>): Prisma__cities_quotationsClient<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities_quotations.
     * @param {cities_quotationsDeleteManyArgs} args - Arguments to filter Cities_quotations to delete.
     * @example
     * // Delete a few Cities_quotations
     * const { count } = await prisma.cities_quotations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cities_quotationsDeleteManyArgs>(args?: SelectSubset<T, cities_quotationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_quotationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cities_quotationsUpdateManyArgs>(args: SelectSubset<T, cities_quotationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cities_quotations.
     * @param {cities_quotationsUpsertArgs} args - Arguments to update or create a Cities_quotations.
     * @example
     * // Update or create a Cities_quotations
     * const cities_quotations = await prisma.cities_quotations.upsert({
     *   create: {
     *     // ... data to create a Cities_quotations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities_quotations we want to update
     *   }
     * })
     */
    upsert<T extends cities_quotationsUpsertArgs>(args: SelectSubset<T, cities_quotationsUpsertArgs<ExtArgs>>): Prisma__cities_quotationsClient<$Result.GetResult<Prisma.$cities_quotationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_quotationsCountArgs} args - Arguments to filter Cities_quotations to count.
     * @example
     * // Count the number of Cities_quotations
     * const count = await prisma.cities_quotations.count({
     *   where: {
     *     // ... the filter for the Cities_quotations we want to count
     *   }
     * })
    **/
    count<T extends cities_quotationsCountArgs>(
      args?: Subset<T, cities_quotationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cities_quotationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cities_quotationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cities_quotationsAggregateArgs>(args: Subset<T, Cities_quotationsAggregateArgs>): Prisma.PrismaPromise<GetCities_quotationsAggregateType<T>>

    /**
     * Group by Cities_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_quotationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cities_quotationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cities_quotationsGroupByArgs['orderBy'] }
        : { orderBy?: cities_quotationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cities_quotationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCities_quotationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cities_quotations model
   */
  readonly fields: cities_quotationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cities_quotations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cities_quotationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cities_quotations model
   */
  interface cities_quotationsFieldRefs {
    readonly id: FieldRef<"cities_quotations", 'BigInt'>
    readonly name: FieldRef<"cities_quotations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cities_quotations findUnique
   */
  export type cities_quotationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which cities_quotations to fetch.
     */
    where: cities_quotationsWhereUniqueInput
  }

  /**
   * cities_quotations findUniqueOrThrow
   */
  export type cities_quotationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which cities_quotations to fetch.
     */
    where: cities_quotationsWhereUniqueInput
  }

  /**
   * cities_quotations findFirst
   */
  export type cities_quotationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which cities_quotations to fetch.
     */
    where?: cities_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_quotations to fetch.
     */
    orderBy?: cities_quotationsOrderByWithRelationInput | cities_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities_quotations.
     */
    cursor?: cities_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities_quotations.
     */
    distinct?: Cities_quotationsScalarFieldEnum | Cities_quotationsScalarFieldEnum[]
  }

  /**
   * cities_quotations findFirstOrThrow
   */
  export type cities_quotationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which cities_quotations to fetch.
     */
    where?: cities_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_quotations to fetch.
     */
    orderBy?: cities_quotationsOrderByWithRelationInput | cities_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities_quotations.
     */
    cursor?: cities_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities_quotations.
     */
    distinct?: Cities_quotationsScalarFieldEnum | Cities_quotationsScalarFieldEnum[]
  }

  /**
   * cities_quotations findMany
   */
  export type cities_quotationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which cities_quotations to fetch.
     */
    where?: cities_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_quotations to fetch.
     */
    orderBy?: cities_quotationsOrderByWithRelationInput | cities_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities_quotations.
     */
    cursor?: cities_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_quotations.
     */
    skip?: number
    distinct?: Cities_quotationsScalarFieldEnum | Cities_quotationsScalarFieldEnum[]
  }

  /**
   * cities_quotations create
   */
  export type cities_quotationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to create a cities_quotations.
     */
    data: XOR<cities_quotationsCreateInput, cities_quotationsUncheckedCreateInput>
  }

  /**
   * cities_quotations createMany
   */
  export type cities_quotationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cities_quotations.
     */
    data: cities_quotationsCreateManyInput | cities_quotationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cities_quotations update
   */
  export type cities_quotationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to update a cities_quotations.
     */
    data: XOR<cities_quotationsUpdateInput, cities_quotationsUncheckedUpdateInput>
    /**
     * Choose, which cities_quotations to update.
     */
    where: cities_quotationsWhereUniqueInput
  }

  /**
   * cities_quotations updateMany
   */
  export type cities_quotationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cities_quotations.
     */
    data: XOR<cities_quotationsUpdateManyMutationInput, cities_quotationsUncheckedUpdateManyInput>
    /**
     * Filter which cities_quotations to update
     */
    where?: cities_quotationsWhereInput
    /**
     * Limit how many cities_quotations to update.
     */
    limit?: number
  }

  /**
   * cities_quotations upsert
   */
  export type cities_quotationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * The filter to search for the cities_quotations to update in case it exists.
     */
    where: cities_quotationsWhereUniqueInput
    /**
     * In case the cities_quotations found by the `where` argument doesn't exist, create a new cities_quotations with this data.
     */
    create: XOR<cities_quotationsCreateInput, cities_quotationsUncheckedCreateInput>
    /**
     * In case the cities_quotations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cities_quotationsUpdateInput, cities_quotationsUncheckedUpdateInput>
  }

  /**
   * cities_quotations delete
   */
  export type cities_quotationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
    /**
     * Filter which cities_quotations to delete.
     */
    where: cities_quotationsWhereUniqueInput
  }

  /**
   * cities_quotations deleteMany
   */
  export type cities_quotationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities_quotations to delete
     */
    where?: cities_quotationsWhereInput
    /**
     * Limit how many cities_quotations to delete.
     */
    limit?: number
  }

  /**
   * cities_quotations without action
   */
  export type cities_quotationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities_quotations
     */
    select?: cities_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities_quotations
     */
    omit?: cities_quotationsOmit<ExtArgs> | null
  }


  /**
   * Model configs_bot_aut
   */

  export type AggregateConfigs_bot_aut = {
    _count: Configs_bot_autCountAggregateOutputType | null
    _min: Configs_bot_autMinAggregateOutputType | null
    _max: Configs_bot_autMaxAggregateOutputType | null
  }

  export type Configs_bot_autMinAggregateOutputType = {
    id: string | null
    tag: string | null
    is_actived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Configs_bot_autMaxAggregateOutputType = {
    id: string | null
    tag: string | null
    is_actived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Configs_bot_autCountAggregateOutputType = {
    id: number
    tag: number
    is_actived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Configs_bot_autMinAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Configs_bot_autMaxAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Configs_bot_autCountAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Configs_bot_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs_bot_aut to aggregate.
     */
    where?: configs_bot_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_auts to fetch.
     */
    orderBy?: configs_bot_autOrderByWithRelationInput | configs_bot_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configs_bot_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configs_bot_auts
    **/
    _count?: true | Configs_bot_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Configs_bot_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Configs_bot_autMaxAggregateInputType
  }

  export type GetConfigs_bot_autAggregateType<T extends Configs_bot_autAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigs_bot_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigs_bot_aut[P]>
      : GetScalarType<T[P], AggregateConfigs_bot_aut[P]>
  }




  export type configs_bot_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configs_bot_autWhereInput
    orderBy?: configs_bot_autOrderByWithAggregationInput | configs_bot_autOrderByWithAggregationInput[]
    by: Configs_bot_autScalarFieldEnum[] | Configs_bot_autScalarFieldEnum
    having?: configs_bot_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Configs_bot_autCountAggregateInputType | true
    _min?: Configs_bot_autMinAggregateInputType
    _max?: Configs_bot_autMaxAggregateInputType
  }

  export type Configs_bot_autGroupByOutputType = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date
    updatedAt: Date
    _count: Configs_bot_autCountAggregateOutputType | null
    _min: Configs_bot_autMinAggregateOutputType | null
    _max: Configs_bot_autMaxAggregateOutputType | null
  }

  type GetConfigs_bot_autGroupByPayload<T extends configs_bot_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Configs_bot_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Configs_bot_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Configs_bot_autGroupByOutputType[P]>
            : GetScalarType<T[P], Configs_bot_autGroupByOutputType[P]>
        }
      >
    >


  export type configs_bot_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    is_actived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configs_bot_aut"]>



  export type configs_bot_autSelectScalar = {
    id?: boolean
    tag?: boolean
    is_actived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type configs_bot_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag" | "is_actived" | "createdAt" | "updatedAt", ExtArgs["result"]["configs_bot_aut"]>

  export type $configs_bot_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "configs_bot_aut"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
      is_actived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configs_bot_aut"]>
    composites: {}
  }

  type configs_bot_autGetPayload<S extends boolean | null | undefined | configs_bot_autDefaultArgs> = $Result.GetResult<Prisma.$configs_bot_autPayload, S>

  type configs_bot_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<configs_bot_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Configs_bot_autCountAggregateInputType | true
    }

  export interface configs_bot_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['configs_bot_aut'], meta: { name: 'configs_bot_aut' } }
    /**
     * Find zero or one Configs_bot_aut that matches the filter.
     * @param {configs_bot_autFindUniqueArgs} args - Arguments to find a Configs_bot_aut
     * @example
     * // Get one Configs_bot_aut
     * const configs_bot_aut = await prisma.configs_bot_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configs_bot_autFindUniqueArgs>(args: SelectSubset<T, configs_bot_autFindUniqueArgs<ExtArgs>>): Prisma__configs_bot_autClient<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Configs_bot_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {configs_bot_autFindUniqueOrThrowArgs} args - Arguments to find a Configs_bot_aut
     * @example
     * // Get one Configs_bot_aut
     * const configs_bot_aut = await prisma.configs_bot_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configs_bot_autFindUniqueOrThrowArgs>(args: SelectSubset<T, configs_bot_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configs_bot_autClient<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configs_bot_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_autFindFirstArgs} args - Arguments to find a Configs_bot_aut
     * @example
     * // Get one Configs_bot_aut
     * const configs_bot_aut = await prisma.configs_bot_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configs_bot_autFindFirstArgs>(args?: SelectSubset<T, configs_bot_autFindFirstArgs<ExtArgs>>): Prisma__configs_bot_autClient<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configs_bot_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_autFindFirstOrThrowArgs} args - Arguments to find a Configs_bot_aut
     * @example
     * // Get one Configs_bot_aut
     * const configs_bot_aut = await prisma.configs_bot_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configs_bot_autFindFirstOrThrowArgs>(args?: SelectSubset<T, configs_bot_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__configs_bot_autClient<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configs_bot_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs_bot_auts
     * const configs_bot_auts = await prisma.configs_bot_aut.findMany()
     * 
     * // Get first 10 Configs_bot_auts
     * const configs_bot_auts = await prisma.configs_bot_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configs_bot_autWithIdOnly = await prisma.configs_bot_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configs_bot_autFindManyArgs>(args?: SelectSubset<T, configs_bot_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Configs_bot_aut.
     * @param {configs_bot_autCreateArgs} args - Arguments to create a Configs_bot_aut.
     * @example
     * // Create one Configs_bot_aut
     * const Configs_bot_aut = await prisma.configs_bot_aut.create({
     *   data: {
     *     // ... data to create a Configs_bot_aut
     *   }
     * })
     * 
     */
    create<T extends configs_bot_autCreateArgs>(args: SelectSubset<T, configs_bot_autCreateArgs<ExtArgs>>): Prisma__configs_bot_autClient<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configs_bot_auts.
     * @param {configs_bot_autCreateManyArgs} args - Arguments to create many Configs_bot_auts.
     * @example
     * // Create many Configs_bot_auts
     * const configs_bot_aut = await prisma.configs_bot_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configs_bot_autCreateManyArgs>(args?: SelectSubset<T, configs_bot_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configs_bot_aut.
     * @param {configs_bot_autDeleteArgs} args - Arguments to delete one Configs_bot_aut.
     * @example
     * // Delete one Configs_bot_aut
     * const Configs_bot_aut = await prisma.configs_bot_aut.delete({
     *   where: {
     *     // ... filter to delete one Configs_bot_aut
     *   }
     * })
     * 
     */
    delete<T extends configs_bot_autDeleteArgs>(args: SelectSubset<T, configs_bot_autDeleteArgs<ExtArgs>>): Prisma__configs_bot_autClient<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Configs_bot_aut.
     * @param {configs_bot_autUpdateArgs} args - Arguments to update one Configs_bot_aut.
     * @example
     * // Update one Configs_bot_aut
     * const configs_bot_aut = await prisma.configs_bot_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configs_bot_autUpdateArgs>(args: SelectSubset<T, configs_bot_autUpdateArgs<ExtArgs>>): Prisma__configs_bot_autClient<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configs_bot_auts.
     * @param {configs_bot_autDeleteManyArgs} args - Arguments to filter Configs_bot_auts to delete.
     * @example
     * // Delete a few Configs_bot_auts
     * const { count } = await prisma.configs_bot_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configs_bot_autDeleteManyArgs>(args?: SelectSubset<T, configs_bot_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs_bot_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs_bot_auts
     * const configs_bot_aut = await prisma.configs_bot_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configs_bot_autUpdateManyArgs>(args: SelectSubset<T, configs_bot_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configs_bot_aut.
     * @param {configs_bot_autUpsertArgs} args - Arguments to update or create a Configs_bot_aut.
     * @example
     * // Update or create a Configs_bot_aut
     * const configs_bot_aut = await prisma.configs_bot_aut.upsert({
     *   create: {
     *     // ... data to create a Configs_bot_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configs_bot_aut we want to update
     *   }
     * })
     */
    upsert<T extends configs_bot_autUpsertArgs>(args: SelectSubset<T, configs_bot_autUpsertArgs<ExtArgs>>): Prisma__configs_bot_autClient<$Result.GetResult<Prisma.$configs_bot_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Configs_bot_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_autCountArgs} args - Arguments to filter Configs_bot_auts to count.
     * @example
     * // Count the number of Configs_bot_auts
     * const count = await prisma.configs_bot_aut.count({
     *   where: {
     *     // ... the filter for the Configs_bot_auts we want to count
     *   }
     * })
    **/
    count<T extends configs_bot_autCountArgs>(
      args?: Subset<T, configs_bot_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Configs_bot_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configs_bot_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Configs_bot_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Configs_bot_autAggregateArgs>(args: Subset<T, Configs_bot_autAggregateArgs>): Prisma.PrismaPromise<GetConfigs_bot_autAggregateType<T>>

    /**
     * Group by Configs_bot_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configs_bot_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configs_bot_autGroupByArgs['orderBy'] }
        : { orderBy?: configs_bot_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configs_bot_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigs_bot_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the configs_bot_aut model
   */
  readonly fields: configs_bot_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for configs_bot_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configs_bot_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the configs_bot_aut model
   */
  interface configs_bot_autFieldRefs {
    readonly id: FieldRef<"configs_bot_aut", 'String'>
    readonly tag: FieldRef<"configs_bot_aut", 'String'>
    readonly is_actived: FieldRef<"configs_bot_aut", 'Boolean'>
    readonly createdAt: FieldRef<"configs_bot_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"configs_bot_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * configs_bot_aut findUnique
   */
  export type configs_bot_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_aut to fetch.
     */
    where: configs_bot_autWhereUniqueInput
  }

  /**
   * configs_bot_aut findUniqueOrThrow
   */
  export type configs_bot_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_aut to fetch.
     */
    where: configs_bot_autWhereUniqueInput
  }

  /**
   * configs_bot_aut findFirst
   */
  export type configs_bot_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_aut to fetch.
     */
    where?: configs_bot_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_auts to fetch.
     */
    orderBy?: configs_bot_autOrderByWithRelationInput | configs_bot_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs_bot_auts.
     */
    cursor?: configs_bot_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs_bot_auts.
     */
    distinct?: Configs_bot_autScalarFieldEnum | Configs_bot_autScalarFieldEnum[]
  }

  /**
   * configs_bot_aut findFirstOrThrow
   */
  export type configs_bot_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_aut to fetch.
     */
    where?: configs_bot_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_auts to fetch.
     */
    orderBy?: configs_bot_autOrderByWithRelationInput | configs_bot_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs_bot_auts.
     */
    cursor?: configs_bot_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs_bot_auts.
     */
    distinct?: Configs_bot_autScalarFieldEnum | Configs_bot_autScalarFieldEnum[]
  }

  /**
   * configs_bot_aut findMany
   */
  export type configs_bot_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_auts to fetch.
     */
    where?: configs_bot_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_auts to fetch.
     */
    orderBy?: configs_bot_autOrderByWithRelationInput | configs_bot_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configs_bot_auts.
     */
    cursor?: configs_bot_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_auts.
     */
    skip?: number
    distinct?: Configs_bot_autScalarFieldEnum | Configs_bot_autScalarFieldEnum[]
  }

  /**
   * configs_bot_aut create
   */
  export type configs_bot_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * The data needed to create a configs_bot_aut.
     */
    data: XOR<configs_bot_autCreateInput, configs_bot_autUncheckedCreateInput>
  }

  /**
   * configs_bot_aut createMany
   */
  export type configs_bot_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configs_bot_auts.
     */
    data: configs_bot_autCreateManyInput | configs_bot_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * configs_bot_aut update
   */
  export type configs_bot_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * The data needed to update a configs_bot_aut.
     */
    data: XOR<configs_bot_autUpdateInput, configs_bot_autUncheckedUpdateInput>
    /**
     * Choose, which configs_bot_aut to update.
     */
    where: configs_bot_autWhereUniqueInput
  }

  /**
   * configs_bot_aut updateMany
   */
  export type configs_bot_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configs_bot_auts.
     */
    data: XOR<configs_bot_autUpdateManyMutationInput, configs_bot_autUncheckedUpdateManyInput>
    /**
     * Filter which configs_bot_auts to update
     */
    where?: configs_bot_autWhereInput
    /**
     * Limit how many configs_bot_auts to update.
     */
    limit?: number
  }

  /**
   * configs_bot_aut upsert
   */
  export type configs_bot_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * The filter to search for the configs_bot_aut to update in case it exists.
     */
    where: configs_bot_autWhereUniqueInput
    /**
     * In case the configs_bot_aut found by the `where` argument doesn't exist, create a new configs_bot_aut with this data.
     */
    create: XOR<configs_bot_autCreateInput, configs_bot_autUncheckedCreateInput>
    /**
     * In case the configs_bot_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configs_bot_autUpdateInput, configs_bot_autUncheckedUpdateInput>
  }

  /**
   * configs_bot_aut delete
   */
  export type configs_bot_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
    /**
     * Filter which configs_bot_aut to delete.
     */
    where: configs_bot_autWhereUniqueInput
  }

  /**
   * configs_bot_aut deleteMany
   */
  export type configs_bot_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs_bot_auts to delete
     */
    where?: configs_bot_autWhereInput
    /**
     * Limit how many configs_bot_auts to delete.
     */
    limit?: number
  }

  /**
   * configs_bot_aut without action
   */
  export type configs_bot_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_aut
     */
    select?: configs_bot_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_aut
     */
    omit?: configs_bot_autOmit<ExtArgs> | null
  }


  /**
   * Model configs_bot_clt
   */

  export type AggregateConfigs_bot_clt = {
    _count: Configs_bot_cltCountAggregateOutputType | null
    _min: Configs_bot_cltMinAggregateOutputType | null
    _max: Configs_bot_cltMaxAggregateOutputType | null
  }

  export type Configs_bot_cltMinAggregateOutputType = {
    id: string | null
    tag: string | null
    is_actived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Configs_bot_cltMaxAggregateOutputType = {
    id: string | null
    tag: string | null
    is_actived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Configs_bot_cltCountAggregateOutputType = {
    id: number
    tag: number
    is_actived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Configs_bot_cltMinAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Configs_bot_cltMaxAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Configs_bot_cltCountAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Configs_bot_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs_bot_clt to aggregate.
     */
    where?: configs_bot_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_clts to fetch.
     */
    orderBy?: configs_bot_cltOrderByWithRelationInput | configs_bot_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configs_bot_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configs_bot_clts
    **/
    _count?: true | Configs_bot_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Configs_bot_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Configs_bot_cltMaxAggregateInputType
  }

  export type GetConfigs_bot_cltAggregateType<T extends Configs_bot_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigs_bot_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigs_bot_clt[P]>
      : GetScalarType<T[P], AggregateConfigs_bot_clt[P]>
  }




  export type configs_bot_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configs_bot_cltWhereInput
    orderBy?: configs_bot_cltOrderByWithAggregationInput | configs_bot_cltOrderByWithAggregationInput[]
    by: Configs_bot_cltScalarFieldEnum[] | Configs_bot_cltScalarFieldEnum
    having?: configs_bot_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Configs_bot_cltCountAggregateInputType | true
    _min?: Configs_bot_cltMinAggregateInputType
    _max?: Configs_bot_cltMaxAggregateInputType
  }

  export type Configs_bot_cltGroupByOutputType = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date
    updatedAt: Date
    _count: Configs_bot_cltCountAggregateOutputType | null
    _min: Configs_bot_cltMinAggregateOutputType | null
    _max: Configs_bot_cltMaxAggregateOutputType | null
  }

  type GetConfigs_bot_cltGroupByPayload<T extends configs_bot_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Configs_bot_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Configs_bot_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Configs_bot_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Configs_bot_cltGroupByOutputType[P]>
        }
      >
    >


  export type configs_bot_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    is_actived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configs_bot_clt"]>



  export type configs_bot_cltSelectScalar = {
    id?: boolean
    tag?: boolean
    is_actived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type configs_bot_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag" | "is_actived" | "createdAt" | "updatedAt", ExtArgs["result"]["configs_bot_clt"]>

  export type $configs_bot_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "configs_bot_clt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
      is_actived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configs_bot_clt"]>
    composites: {}
  }

  type configs_bot_cltGetPayload<S extends boolean | null | undefined | configs_bot_cltDefaultArgs> = $Result.GetResult<Prisma.$configs_bot_cltPayload, S>

  type configs_bot_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<configs_bot_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Configs_bot_cltCountAggregateInputType | true
    }

  export interface configs_bot_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['configs_bot_clt'], meta: { name: 'configs_bot_clt' } }
    /**
     * Find zero or one Configs_bot_clt that matches the filter.
     * @param {configs_bot_cltFindUniqueArgs} args - Arguments to find a Configs_bot_clt
     * @example
     * // Get one Configs_bot_clt
     * const configs_bot_clt = await prisma.configs_bot_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configs_bot_cltFindUniqueArgs>(args: SelectSubset<T, configs_bot_cltFindUniqueArgs<ExtArgs>>): Prisma__configs_bot_cltClient<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Configs_bot_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {configs_bot_cltFindUniqueOrThrowArgs} args - Arguments to find a Configs_bot_clt
     * @example
     * // Get one Configs_bot_clt
     * const configs_bot_clt = await prisma.configs_bot_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configs_bot_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, configs_bot_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configs_bot_cltClient<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configs_bot_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_cltFindFirstArgs} args - Arguments to find a Configs_bot_clt
     * @example
     * // Get one Configs_bot_clt
     * const configs_bot_clt = await prisma.configs_bot_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configs_bot_cltFindFirstArgs>(args?: SelectSubset<T, configs_bot_cltFindFirstArgs<ExtArgs>>): Prisma__configs_bot_cltClient<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configs_bot_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_cltFindFirstOrThrowArgs} args - Arguments to find a Configs_bot_clt
     * @example
     * // Get one Configs_bot_clt
     * const configs_bot_clt = await prisma.configs_bot_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configs_bot_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, configs_bot_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__configs_bot_cltClient<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configs_bot_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs_bot_clts
     * const configs_bot_clts = await prisma.configs_bot_clt.findMany()
     * 
     * // Get first 10 Configs_bot_clts
     * const configs_bot_clts = await prisma.configs_bot_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configs_bot_cltWithIdOnly = await prisma.configs_bot_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configs_bot_cltFindManyArgs>(args?: SelectSubset<T, configs_bot_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Configs_bot_clt.
     * @param {configs_bot_cltCreateArgs} args - Arguments to create a Configs_bot_clt.
     * @example
     * // Create one Configs_bot_clt
     * const Configs_bot_clt = await prisma.configs_bot_clt.create({
     *   data: {
     *     // ... data to create a Configs_bot_clt
     *   }
     * })
     * 
     */
    create<T extends configs_bot_cltCreateArgs>(args: SelectSubset<T, configs_bot_cltCreateArgs<ExtArgs>>): Prisma__configs_bot_cltClient<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configs_bot_clts.
     * @param {configs_bot_cltCreateManyArgs} args - Arguments to create many Configs_bot_clts.
     * @example
     * // Create many Configs_bot_clts
     * const configs_bot_clt = await prisma.configs_bot_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configs_bot_cltCreateManyArgs>(args?: SelectSubset<T, configs_bot_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configs_bot_clt.
     * @param {configs_bot_cltDeleteArgs} args - Arguments to delete one Configs_bot_clt.
     * @example
     * // Delete one Configs_bot_clt
     * const Configs_bot_clt = await prisma.configs_bot_clt.delete({
     *   where: {
     *     // ... filter to delete one Configs_bot_clt
     *   }
     * })
     * 
     */
    delete<T extends configs_bot_cltDeleteArgs>(args: SelectSubset<T, configs_bot_cltDeleteArgs<ExtArgs>>): Prisma__configs_bot_cltClient<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Configs_bot_clt.
     * @param {configs_bot_cltUpdateArgs} args - Arguments to update one Configs_bot_clt.
     * @example
     * // Update one Configs_bot_clt
     * const configs_bot_clt = await prisma.configs_bot_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configs_bot_cltUpdateArgs>(args: SelectSubset<T, configs_bot_cltUpdateArgs<ExtArgs>>): Prisma__configs_bot_cltClient<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configs_bot_clts.
     * @param {configs_bot_cltDeleteManyArgs} args - Arguments to filter Configs_bot_clts to delete.
     * @example
     * // Delete a few Configs_bot_clts
     * const { count } = await prisma.configs_bot_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configs_bot_cltDeleteManyArgs>(args?: SelectSubset<T, configs_bot_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs_bot_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs_bot_clts
     * const configs_bot_clt = await prisma.configs_bot_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configs_bot_cltUpdateManyArgs>(args: SelectSubset<T, configs_bot_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configs_bot_clt.
     * @param {configs_bot_cltUpsertArgs} args - Arguments to update or create a Configs_bot_clt.
     * @example
     * // Update or create a Configs_bot_clt
     * const configs_bot_clt = await prisma.configs_bot_clt.upsert({
     *   create: {
     *     // ... data to create a Configs_bot_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configs_bot_clt we want to update
     *   }
     * })
     */
    upsert<T extends configs_bot_cltUpsertArgs>(args: SelectSubset<T, configs_bot_cltUpsertArgs<ExtArgs>>): Prisma__configs_bot_cltClient<$Result.GetResult<Prisma.$configs_bot_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Configs_bot_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_cltCountArgs} args - Arguments to filter Configs_bot_clts to count.
     * @example
     * // Count the number of Configs_bot_clts
     * const count = await prisma.configs_bot_clt.count({
     *   where: {
     *     // ... the filter for the Configs_bot_clts we want to count
     *   }
     * })
    **/
    count<T extends configs_bot_cltCountArgs>(
      args?: Subset<T, configs_bot_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Configs_bot_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configs_bot_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Configs_bot_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Configs_bot_cltAggregateArgs>(args: Subset<T, Configs_bot_cltAggregateArgs>): Prisma.PrismaPromise<GetConfigs_bot_cltAggregateType<T>>

    /**
     * Group by Configs_bot_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configs_bot_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configs_bot_cltGroupByArgs['orderBy'] }
        : { orderBy?: configs_bot_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configs_bot_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigs_bot_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the configs_bot_clt model
   */
  readonly fields: configs_bot_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for configs_bot_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configs_bot_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the configs_bot_clt model
   */
  interface configs_bot_cltFieldRefs {
    readonly id: FieldRef<"configs_bot_clt", 'String'>
    readonly tag: FieldRef<"configs_bot_clt", 'String'>
    readonly is_actived: FieldRef<"configs_bot_clt", 'Boolean'>
    readonly createdAt: FieldRef<"configs_bot_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"configs_bot_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * configs_bot_clt findUnique
   */
  export type configs_bot_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_clt to fetch.
     */
    where: configs_bot_cltWhereUniqueInput
  }

  /**
   * configs_bot_clt findUniqueOrThrow
   */
  export type configs_bot_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_clt to fetch.
     */
    where: configs_bot_cltWhereUniqueInput
  }

  /**
   * configs_bot_clt findFirst
   */
  export type configs_bot_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_clt to fetch.
     */
    where?: configs_bot_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_clts to fetch.
     */
    orderBy?: configs_bot_cltOrderByWithRelationInput | configs_bot_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs_bot_clts.
     */
    cursor?: configs_bot_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs_bot_clts.
     */
    distinct?: Configs_bot_cltScalarFieldEnum | Configs_bot_cltScalarFieldEnum[]
  }

  /**
   * configs_bot_clt findFirstOrThrow
   */
  export type configs_bot_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_clt to fetch.
     */
    where?: configs_bot_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_clts to fetch.
     */
    orderBy?: configs_bot_cltOrderByWithRelationInput | configs_bot_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs_bot_clts.
     */
    cursor?: configs_bot_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs_bot_clts.
     */
    distinct?: Configs_bot_cltScalarFieldEnum | Configs_bot_cltScalarFieldEnum[]
  }

  /**
   * configs_bot_clt findMany
   */
  export type configs_bot_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_clts to fetch.
     */
    where?: configs_bot_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_clts to fetch.
     */
    orderBy?: configs_bot_cltOrderByWithRelationInput | configs_bot_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configs_bot_clts.
     */
    cursor?: configs_bot_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_clts.
     */
    skip?: number
    distinct?: Configs_bot_cltScalarFieldEnum | Configs_bot_cltScalarFieldEnum[]
  }

  /**
   * configs_bot_clt create
   */
  export type configs_bot_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * The data needed to create a configs_bot_clt.
     */
    data: XOR<configs_bot_cltCreateInput, configs_bot_cltUncheckedCreateInput>
  }

  /**
   * configs_bot_clt createMany
   */
  export type configs_bot_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configs_bot_clts.
     */
    data: configs_bot_cltCreateManyInput | configs_bot_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * configs_bot_clt update
   */
  export type configs_bot_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * The data needed to update a configs_bot_clt.
     */
    data: XOR<configs_bot_cltUpdateInput, configs_bot_cltUncheckedUpdateInput>
    /**
     * Choose, which configs_bot_clt to update.
     */
    where: configs_bot_cltWhereUniqueInput
  }

  /**
   * configs_bot_clt updateMany
   */
  export type configs_bot_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configs_bot_clts.
     */
    data: XOR<configs_bot_cltUpdateManyMutationInput, configs_bot_cltUncheckedUpdateManyInput>
    /**
     * Filter which configs_bot_clts to update
     */
    where?: configs_bot_cltWhereInput
    /**
     * Limit how many configs_bot_clts to update.
     */
    limit?: number
  }

  /**
   * configs_bot_clt upsert
   */
  export type configs_bot_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * The filter to search for the configs_bot_clt to update in case it exists.
     */
    where: configs_bot_cltWhereUniqueInput
    /**
     * In case the configs_bot_clt found by the `where` argument doesn't exist, create a new configs_bot_clt with this data.
     */
    create: XOR<configs_bot_cltCreateInput, configs_bot_cltUncheckedCreateInput>
    /**
     * In case the configs_bot_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configs_bot_cltUpdateInput, configs_bot_cltUncheckedUpdateInput>
  }

  /**
   * configs_bot_clt delete
   */
  export type configs_bot_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
    /**
     * Filter which configs_bot_clt to delete.
     */
    where: configs_bot_cltWhereUniqueInput
  }

  /**
   * configs_bot_clt deleteMany
   */
  export type configs_bot_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs_bot_clts to delete
     */
    where?: configs_bot_cltWhereInput
    /**
     * Limit how many configs_bot_clts to delete.
     */
    limit?: number
  }

  /**
   * configs_bot_clt without action
   */
  export type configs_bot_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_clt
     */
    select?: configs_bot_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_clt
     */
    omit?: configs_bot_cltOmit<ExtArgs> | null
  }


  /**
   * Model configs_bot_goi
   */

  export type AggregateConfigs_bot_goi = {
    _count: Configs_bot_goiCountAggregateOutputType | null
    _min: Configs_bot_goiMinAggregateOutputType | null
    _max: Configs_bot_goiMaxAggregateOutputType | null
  }

  export type Configs_bot_goiMinAggregateOutputType = {
    id: string | null
    tag: string | null
    is_actived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Configs_bot_goiMaxAggregateOutputType = {
    id: string | null
    tag: string | null
    is_actived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Configs_bot_goiCountAggregateOutputType = {
    id: number
    tag: number
    is_actived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Configs_bot_goiMinAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Configs_bot_goiMaxAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Configs_bot_goiCountAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Configs_bot_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs_bot_goi to aggregate.
     */
    where?: configs_bot_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_gois to fetch.
     */
    orderBy?: configs_bot_goiOrderByWithRelationInput | configs_bot_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configs_bot_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configs_bot_gois
    **/
    _count?: true | Configs_bot_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Configs_bot_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Configs_bot_goiMaxAggregateInputType
  }

  export type GetConfigs_bot_goiAggregateType<T extends Configs_bot_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigs_bot_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigs_bot_goi[P]>
      : GetScalarType<T[P], AggregateConfigs_bot_goi[P]>
  }




  export type configs_bot_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configs_bot_goiWhereInput
    orderBy?: configs_bot_goiOrderByWithAggregationInput | configs_bot_goiOrderByWithAggregationInput[]
    by: Configs_bot_goiScalarFieldEnum[] | Configs_bot_goiScalarFieldEnum
    having?: configs_bot_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Configs_bot_goiCountAggregateInputType | true
    _min?: Configs_bot_goiMinAggregateInputType
    _max?: Configs_bot_goiMaxAggregateInputType
  }

  export type Configs_bot_goiGroupByOutputType = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date
    updatedAt: Date
    _count: Configs_bot_goiCountAggregateOutputType | null
    _min: Configs_bot_goiMinAggregateOutputType | null
    _max: Configs_bot_goiMaxAggregateOutputType | null
  }

  type GetConfigs_bot_goiGroupByPayload<T extends configs_bot_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Configs_bot_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Configs_bot_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Configs_bot_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Configs_bot_goiGroupByOutputType[P]>
        }
      >
    >


  export type configs_bot_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    is_actived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configs_bot_goi"]>



  export type configs_bot_goiSelectScalar = {
    id?: boolean
    tag?: boolean
    is_actived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type configs_bot_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag" | "is_actived" | "createdAt" | "updatedAt", ExtArgs["result"]["configs_bot_goi"]>

  export type $configs_bot_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "configs_bot_goi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
      is_actived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configs_bot_goi"]>
    composites: {}
  }

  type configs_bot_goiGetPayload<S extends boolean | null | undefined | configs_bot_goiDefaultArgs> = $Result.GetResult<Prisma.$configs_bot_goiPayload, S>

  type configs_bot_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<configs_bot_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Configs_bot_goiCountAggregateInputType | true
    }

  export interface configs_bot_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['configs_bot_goi'], meta: { name: 'configs_bot_goi' } }
    /**
     * Find zero or one Configs_bot_goi that matches the filter.
     * @param {configs_bot_goiFindUniqueArgs} args - Arguments to find a Configs_bot_goi
     * @example
     * // Get one Configs_bot_goi
     * const configs_bot_goi = await prisma.configs_bot_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configs_bot_goiFindUniqueArgs>(args: SelectSubset<T, configs_bot_goiFindUniqueArgs<ExtArgs>>): Prisma__configs_bot_goiClient<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Configs_bot_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {configs_bot_goiFindUniqueOrThrowArgs} args - Arguments to find a Configs_bot_goi
     * @example
     * // Get one Configs_bot_goi
     * const configs_bot_goi = await prisma.configs_bot_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configs_bot_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, configs_bot_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configs_bot_goiClient<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configs_bot_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_goiFindFirstArgs} args - Arguments to find a Configs_bot_goi
     * @example
     * // Get one Configs_bot_goi
     * const configs_bot_goi = await prisma.configs_bot_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configs_bot_goiFindFirstArgs>(args?: SelectSubset<T, configs_bot_goiFindFirstArgs<ExtArgs>>): Prisma__configs_bot_goiClient<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configs_bot_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_goiFindFirstOrThrowArgs} args - Arguments to find a Configs_bot_goi
     * @example
     * // Get one Configs_bot_goi
     * const configs_bot_goi = await prisma.configs_bot_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configs_bot_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, configs_bot_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__configs_bot_goiClient<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configs_bot_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs_bot_gois
     * const configs_bot_gois = await prisma.configs_bot_goi.findMany()
     * 
     * // Get first 10 Configs_bot_gois
     * const configs_bot_gois = await prisma.configs_bot_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configs_bot_goiWithIdOnly = await prisma.configs_bot_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configs_bot_goiFindManyArgs>(args?: SelectSubset<T, configs_bot_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Configs_bot_goi.
     * @param {configs_bot_goiCreateArgs} args - Arguments to create a Configs_bot_goi.
     * @example
     * // Create one Configs_bot_goi
     * const Configs_bot_goi = await prisma.configs_bot_goi.create({
     *   data: {
     *     // ... data to create a Configs_bot_goi
     *   }
     * })
     * 
     */
    create<T extends configs_bot_goiCreateArgs>(args: SelectSubset<T, configs_bot_goiCreateArgs<ExtArgs>>): Prisma__configs_bot_goiClient<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configs_bot_gois.
     * @param {configs_bot_goiCreateManyArgs} args - Arguments to create many Configs_bot_gois.
     * @example
     * // Create many Configs_bot_gois
     * const configs_bot_goi = await prisma.configs_bot_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configs_bot_goiCreateManyArgs>(args?: SelectSubset<T, configs_bot_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configs_bot_goi.
     * @param {configs_bot_goiDeleteArgs} args - Arguments to delete one Configs_bot_goi.
     * @example
     * // Delete one Configs_bot_goi
     * const Configs_bot_goi = await prisma.configs_bot_goi.delete({
     *   where: {
     *     // ... filter to delete one Configs_bot_goi
     *   }
     * })
     * 
     */
    delete<T extends configs_bot_goiDeleteArgs>(args: SelectSubset<T, configs_bot_goiDeleteArgs<ExtArgs>>): Prisma__configs_bot_goiClient<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Configs_bot_goi.
     * @param {configs_bot_goiUpdateArgs} args - Arguments to update one Configs_bot_goi.
     * @example
     * // Update one Configs_bot_goi
     * const configs_bot_goi = await prisma.configs_bot_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configs_bot_goiUpdateArgs>(args: SelectSubset<T, configs_bot_goiUpdateArgs<ExtArgs>>): Prisma__configs_bot_goiClient<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configs_bot_gois.
     * @param {configs_bot_goiDeleteManyArgs} args - Arguments to filter Configs_bot_gois to delete.
     * @example
     * // Delete a few Configs_bot_gois
     * const { count } = await prisma.configs_bot_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configs_bot_goiDeleteManyArgs>(args?: SelectSubset<T, configs_bot_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs_bot_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs_bot_gois
     * const configs_bot_goi = await prisma.configs_bot_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configs_bot_goiUpdateManyArgs>(args: SelectSubset<T, configs_bot_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configs_bot_goi.
     * @param {configs_bot_goiUpsertArgs} args - Arguments to update or create a Configs_bot_goi.
     * @example
     * // Update or create a Configs_bot_goi
     * const configs_bot_goi = await prisma.configs_bot_goi.upsert({
     *   create: {
     *     // ... data to create a Configs_bot_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configs_bot_goi we want to update
     *   }
     * })
     */
    upsert<T extends configs_bot_goiUpsertArgs>(args: SelectSubset<T, configs_bot_goiUpsertArgs<ExtArgs>>): Prisma__configs_bot_goiClient<$Result.GetResult<Prisma.$configs_bot_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Configs_bot_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_goiCountArgs} args - Arguments to filter Configs_bot_gois to count.
     * @example
     * // Count the number of Configs_bot_gois
     * const count = await prisma.configs_bot_goi.count({
     *   where: {
     *     // ... the filter for the Configs_bot_gois we want to count
     *   }
     * })
    **/
    count<T extends configs_bot_goiCountArgs>(
      args?: Subset<T, configs_bot_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Configs_bot_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configs_bot_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Configs_bot_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Configs_bot_goiAggregateArgs>(args: Subset<T, Configs_bot_goiAggregateArgs>): Prisma.PrismaPromise<GetConfigs_bot_goiAggregateType<T>>

    /**
     * Group by Configs_bot_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configs_bot_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configs_bot_goiGroupByArgs['orderBy'] }
        : { orderBy?: configs_bot_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configs_bot_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigs_bot_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the configs_bot_goi model
   */
  readonly fields: configs_bot_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for configs_bot_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configs_bot_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the configs_bot_goi model
   */
  interface configs_bot_goiFieldRefs {
    readonly id: FieldRef<"configs_bot_goi", 'String'>
    readonly tag: FieldRef<"configs_bot_goi", 'String'>
    readonly is_actived: FieldRef<"configs_bot_goi", 'Boolean'>
    readonly createdAt: FieldRef<"configs_bot_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"configs_bot_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * configs_bot_goi findUnique
   */
  export type configs_bot_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_goi to fetch.
     */
    where: configs_bot_goiWhereUniqueInput
  }

  /**
   * configs_bot_goi findUniqueOrThrow
   */
  export type configs_bot_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_goi to fetch.
     */
    where: configs_bot_goiWhereUniqueInput
  }

  /**
   * configs_bot_goi findFirst
   */
  export type configs_bot_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_goi to fetch.
     */
    where?: configs_bot_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_gois to fetch.
     */
    orderBy?: configs_bot_goiOrderByWithRelationInput | configs_bot_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs_bot_gois.
     */
    cursor?: configs_bot_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs_bot_gois.
     */
    distinct?: Configs_bot_goiScalarFieldEnum | Configs_bot_goiScalarFieldEnum[]
  }

  /**
   * configs_bot_goi findFirstOrThrow
   */
  export type configs_bot_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_goi to fetch.
     */
    where?: configs_bot_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_gois to fetch.
     */
    orderBy?: configs_bot_goiOrderByWithRelationInput | configs_bot_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs_bot_gois.
     */
    cursor?: configs_bot_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs_bot_gois.
     */
    distinct?: Configs_bot_goiScalarFieldEnum | Configs_bot_goiScalarFieldEnum[]
  }

  /**
   * configs_bot_goi findMany
   */
  export type configs_bot_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_gois to fetch.
     */
    where?: configs_bot_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_gois to fetch.
     */
    orderBy?: configs_bot_goiOrderByWithRelationInput | configs_bot_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configs_bot_gois.
     */
    cursor?: configs_bot_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_gois.
     */
    skip?: number
    distinct?: Configs_bot_goiScalarFieldEnum | Configs_bot_goiScalarFieldEnum[]
  }

  /**
   * configs_bot_goi create
   */
  export type configs_bot_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * The data needed to create a configs_bot_goi.
     */
    data: XOR<configs_bot_goiCreateInput, configs_bot_goiUncheckedCreateInput>
  }

  /**
   * configs_bot_goi createMany
   */
  export type configs_bot_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configs_bot_gois.
     */
    data: configs_bot_goiCreateManyInput | configs_bot_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * configs_bot_goi update
   */
  export type configs_bot_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * The data needed to update a configs_bot_goi.
     */
    data: XOR<configs_bot_goiUpdateInput, configs_bot_goiUncheckedUpdateInput>
    /**
     * Choose, which configs_bot_goi to update.
     */
    where: configs_bot_goiWhereUniqueInput
  }

  /**
   * configs_bot_goi updateMany
   */
  export type configs_bot_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configs_bot_gois.
     */
    data: XOR<configs_bot_goiUpdateManyMutationInput, configs_bot_goiUncheckedUpdateManyInput>
    /**
     * Filter which configs_bot_gois to update
     */
    where?: configs_bot_goiWhereInput
    /**
     * Limit how many configs_bot_gois to update.
     */
    limit?: number
  }

  /**
   * configs_bot_goi upsert
   */
  export type configs_bot_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * The filter to search for the configs_bot_goi to update in case it exists.
     */
    where: configs_bot_goiWhereUniqueInput
    /**
     * In case the configs_bot_goi found by the `where` argument doesn't exist, create a new configs_bot_goi with this data.
     */
    create: XOR<configs_bot_goiCreateInput, configs_bot_goiUncheckedCreateInput>
    /**
     * In case the configs_bot_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configs_bot_goiUpdateInput, configs_bot_goiUncheckedUpdateInput>
  }

  /**
   * configs_bot_goi delete
   */
  export type configs_bot_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
    /**
     * Filter which configs_bot_goi to delete.
     */
    where: configs_bot_goiWhereUniqueInput
  }

  /**
   * configs_bot_goi deleteMany
   */
  export type configs_bot_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs_bot_gois to delete
     */
    where?: configs_bot_goiWhereInput
    /**
     * Limit how many configs_bot_gois to delete.
     */
    limit?: number
  }

  /**
   * configs_bot_goi without action
   */
  export type configs_bot_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_goi
     */
    select?: configs_bot_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_goi
     */
    omit?: configs_bot_goiOmit<ExtArgs> | null
  }


  /**
   * Model configs_bot_spa
   */

  export type AggregateConfigs_bot_spa = {
    _count: Configs_bot_spaCountAggregateOutputType | null
    _min: Configs_bot_spaMinAggregateOutputType | null
    _max: Configs_bot_spaMaxAggregateOutputType | null
  }

  export type Configs_bot_spaMinAggregateOutputType = {
    id: string | null
    tag: string | null
    is_actived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Configs_bot_spaMaxAggregateOutputType = {
    id: string | null
    tag: string | null
    is_actived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Configs_bot_spaCountAggregateOutputType = {
    id: number
    tag: number
    is_actived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Configs_bot_spaMinAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Configs_bot_spaMaxAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Configs_bot_spaCountAggregateInputType = {
    id?: true
    tag?: true
    is_actived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Configs_bot_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs_bot_spa to aggregate.
     */
    where?: configs_bot_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_spas to fetch.
     */
    orderBy?: configs_bot_spaOrderByWithRelationInput | configs_bot_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configs_bot_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configs_bot_spas
    **/
    _count?: true | Configs_bot_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Configs_bot_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Configs_bot_spaMaxAggregateInputType
  }

  export type GetConfigs_bot_spaAggregateType<T extends Configs_bot_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigs_bot_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigs_bot_spa[P]>
      : GetScalarType<T[P], AggregateConfigs_bot_spa[P]>
  }




  export type configs_bot_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configs_bot_spaWhereInput
    orderBy?: configs_bot_spaOrderByWithAggregationInput | configs_bot_spaOrderByWithAggregationInput[]
    by: Configs_bot_spaScalarFieldEnum[] | Configs_bot_spaScalarFieldEnum
    having?: configs_bot_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Configs_bot_spaCountAggregateInputType | true
    _min?: Configs_bot_spaMinAggregateInputType
    _max?: Configs_bot_spaMaxAggregateInputType
  }

  export type Configs_bot_spaGroupByOutputType = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date
    updatedAt: Date
    _count: Configs_bot_spaCountAggregateOutputType | null
    _min: Configs_bot_spaMinAggregateOutputType | null
    _max: Configs_bot_spaMaxAggregateOutputType | null
  }

  type GetConfigs_bot_spaGroupByPayload<T extends configs_bot_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Configs_bot_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Configs_bot_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Configs_bot_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Configs_bot_spaGroupByOutputType[P]>
        }
      >
    >


  export type configs_bot_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    is_actived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configs_bot_spa"]>



  export type configs_bot_spaSelectScalar = {
    id?: boolean
    tag?: boolean
    is_actived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type configs_bot_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag" | "is_actived" | "createdAt" | "updatedAt", ExtArgs["result"]["configs_bot_spa"]>

  export type $configs_bot_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "configs_bot_spa"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
      is_actived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configs_bot_spa"]>
    composites: {}
  }

  type configs_bot_spaGetPayload<S extends boolean | null | undefined | configs_bot_spaDefaultArgs> = $Result.GetResult<Prisma.$configs_bot_spaPayload, S>

  type configs_bot_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<configs_bot_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Configs_bot_spaCountAggregateInputType | true
    }

  export interface configs_bot_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['configs_bot_spa'], meta: { name: 'configs_bot_spa' } }
    /**
     * Find zero or one Configs_bot_spa that matches the filter.
     * @param {configs_bot_spaFindUniqueArgs} args - Arguments to find a Configs_bot_spa
     * @example
     * // Get one Configs_bot_spa
     * const configs_bot_spa = await prisma.configs_bot_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configs_bot_spaFindUniqueArgs>(args: SelectSubset<T, configs_bot_spaFindUniqueArgs<ExtArgs>>): Prisma__configs_bot_spaClient<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Configs_bot_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {configs_bot_spaFindUniqueOrThrowArgs} args - Arguments to find a Configs_bot_spa
     * @example
     * // Get one Configs_bot_spa
     * const configs_bot_spa = await prisma.configs_bot_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configs_bot_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, configs_bot_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configs_bot_spaClient<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configs_bot_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_spaFindFirstArgs} args - Arguments to find a Configs_bot_spa
     * @example
     * // Get one Configs_bot_spa
     * const configs_bot_spa = await prisma.configs_bot_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configs_bot_spaFindFirstArgs>(args?: SelectSubset<T, configs_bot_spaFindFirstArgs<ExtArgs>>): Prisma__configs_bot_spaClient<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configs_bot_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_spaFindFirstOrThrowArgs} args - Arguments to find a Configs_bot_spa
     * @example
     * // Get one Configs_bot_spa
     * const configs_bot_spa = await prisma.configs_bot_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configs_bot_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, configs_bot_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__configs_bot_spaClient<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configs_bot_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs_bot_spas
     * const configs_bot_spas = await prisma.configs_bot_spa.findMany()
     * 
     * // Get first 10 Configs_bot_spas
     * const configs_bot_spas = await prisma.configs_bot_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configs_bot_spaWithIdOnly = await prisma.configs_bot_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configs_bot_spaFindManyArgs>(args?: SelectSubset<T, configs_bot_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Configs_bot_spa.
     * @param {configs_bot_spaCreateArgs} args - Arguments to create a Configs_bot_spa.
     * @example
     * // Create one Configs_bot_spa
     * const Configs_bot_spa = await prisma.configs_bot_spa.create({
     *   data: {
     *     // ... data to create a Configs_bot_spa
     *   }
     * })
     * 
     */
    create<T extends configs_bot_spaCreateArgs>(args: SelectSubset<T, configs_bot_spaCreateArgs<ExtArgs>>): Prisma__configs_bot_spaClient<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configs_bot_spas.
     * @param {configs_bot_spaCreateManyArgs} args - Arguments to create many Configs_bot_spas.
     * @example
     * // Create many Configs_bot_spas
     * const configs_bot_spa = await prisma.configs_bot_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configs_bot_spaCreateManyArgs>(args?: SelectSubset<T, configs_bot_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configs_bot_spa.
     * @param {configs_bot_spaDeleteArgs} args - Arguments to delete one Configs_bot_spa.
     * @example
     * // Delete one Configs_bot_spa
     * const Configs_bot_spa = await prisma.configs_bot_spa.delete({
     *   where: {
     *     // ... filter to delete one Configs_bot_spa
     *   }
     * })
     * 
     */
    delete<T extends configs_bot_spaDeleteArgs>(args: SelectSubset<T, configs_bot_spaDeleteArgs<ExtArgs>>): Prisma__configs_bot_spaClient<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Configs_bot_spa.
     * @param {configs_bot_spaUpdateArgs} args - Arguments to update one Configs_bot_spa.
     * @example
     * // Update one Configs_bot_spa
     * const configs_bot_spa = await prisma.configs_bot_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configs_bot_spaUpdateArgs>(args: SelectSubset<T, configs_bot_spaUpdateArgs<ExtArgs>>): Prisma__configs_bot_spaClient<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configs_bot_spas.
     * @param {configs_bot_spaDeleteManyArgs} args - Arguments to filter Configs_bot_spas to delete.
     * @example
     * // Delete a few Configs_bot_spas
     * const { count } = await prisma.configs_bot_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configs_bot_spaDeleteManyArgs>(args?: SelectSubset<T, configs_bot_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs_bot_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs_bot_spas
     * const configs_bot_spa = await prisma.configs_bot_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configs_bot_spaUpdateManyArgs>(args: SelectSubset<T, configs_bot_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configs_bot_spa.
     * @param {configs_bot_spaUpsertArgs} args - Arguments to update or create a Configs_bot_spa.
     * @example
     * // Update or create a Configs_bot_spa
     * const configs_bot_spa = await prisma.configs_bot_spa.upsert({
     *   create: {
     *     // ... data to create a Configs_bot_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configs_bot_spa we want to update
     *   }
     * })
     */
    upsert<T extends configs_bot_spaUpsertArgs>(args: SelectSubset<T, configs_bot_spaUpsertArgs<ExtArgs>>): Prisma__configs_bot_spaClient<$Result.GetResult<Prisma.$configs_bot_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Configs_bot_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_spaCountArgs} args - Arguments to filter Configs_bot_spas to count.
     * @example
     * // Count the number of Configs_bot_spas
     * const count = await prisma.configs_bot_spa.count({
     *   where: {
     *     // ... the filter for the Configs_bot_spas we want to count
     *   }
     * })
    **/
    count<T extends configs_bot_spaCountArgs>(
      args?: Subset<T, configs_bot_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Configs_bot_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configs_bot_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Configs_bot_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Configs_bot_spaAggregateArgs>(args: Subset<T, Configs_bot_spaAggregateArgs>): Prisma.PrismaPromise<GetConfigs_bot_spaAggregateType<T>>

    /**
     * Group by Configs_bot_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configs_bot_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configs_bot_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configs_bot_spaGroupByArgs['orderBy'] }
        : { orderBy?: configs_bot_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configs_bot_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigs_bot_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the configs_bot_spa model
   */
  readonly fields: configs_bot_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for configs_bot_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configs_bot_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the configs_bot_spa model
   */
  interface configs_bot_spaFieldRefs {
    readonly id: FieldRef<"configs_bot_spa", 'String'>
    readonly tag: FieldRef<"configs_bot_spa", 'String'>
    readonly is_actived: FieldRef<"configs_bot_spa", 'Boolean'>
    readonly createdAt: FieldRef<"configs_bot_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"configs_bot_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * configs_bot_spa findUnique
   */
  export type configs_bot_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_spa to fetch.
     */
    where: configs_bot_spaWhereUniqueInput
  }

  /**
   * configs_bot_spa findUniqueOrThrow
   */
  export type configs_bot_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_spa to fetch.
     */
    where: configs_bot_spaWhereUniqueInput
  }

  /**
   * configs_bot_spa findFirst
   */
  export type configs_bot_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_spa to fetch.
     */
    where?: configs_bot_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_spas to fetch.
     */
    orderBy?: configs_bot_spaOrderByWithRelationInput | configs_bot_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs_bot_spas.
     */
    cursor?: configs_bot_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs_bot_spas.
     */
    distinct?: Configs_bot_spaScalarFieldEnum | Configs_bot_spaScalarFieldEnum[]
  }

  /**
   * configs_bot_spa findFirstOrThrow
   */
  export type configs_bot_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_spa to fetch.
     */
    where?: configs_bot_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_spas to fetch.
     */
    orderBy?: configs_bot_spaOrderByWithRelationInput | configs_bot_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs_bot_spas.
     */
    cursor?: configs_bot_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs_bot_spas.
     */
    distinct?: Configs_bot_spaScalarFieldEnum | Configs_bot_spaScalarFieldEnum[]
  }

  /**
   * configs_bot_spa findMany
   */
  export type configs_bot_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * Filter, which configs_bot_spas to fetch.
     */
    where?: configs_bot_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs_bot_spas to fetch.
     */
    orderBy?: configs_bot_spaOrderByWithRelationInput | configs_bot_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configs_bot_spas.
     */
    cursor?: configs_bot_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs_bot_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs_bot_spas.
     */
    skip?: number
    distinct?: Configs_bot_spaScalarFieldEnum | Configs_bot_spaScalarFieldEnum[]
  }

  /**
   * configs_bot_spa create
   */
  export type configs_bot_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * The data needed to create a configs_bot_spa.
     */
    data: XOR<configs_bot_spaCreateInput, configs_bot_spaUncheckedCreateInput>
  }

  /**
   * configs_bot_spa createMany
   */
  export type configs_bot_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configs_bot_spas.
     */
    data: configs_bot_spaCreateManyInput | configs_bot_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * configs_bot_spa update
   */
  export type configs_bot_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * The data needed to update a configs_bot_spa.
     */
    data: XOR<configs_bot_spaUpdateInput, configs_bot_spaUncheckedUpdateInput>
    /**
     * Choose, which configs_bot_spa to update.
     */
    where: configs_bot_spaWhereUniqueInput
  }

  /**
   * configs_bot_spa updateMany
   */
  export type configs_bot_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configs_bot_spas.
     */
    data: XOR<configs_bot_spaUpdateManyMutationInput, configs_bot_spaUncheckedUpdateManyInput>
    /**
     * Filter which configs_bot_spas to update
     */
    where?: configs_bot_spaWhereInput
    /**
     * Limit how many configs_bot_spas to update.
     */
    limit?: number
  }

  /**
   * configs_bot_spa upsert
   */
  export type configs_bot_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * The filter to search for the configs_bot_spa to update in case it exists.
     */
    where: configs_bot_spaWhereUniqueInput
    /**
     * In case the configs_bot_spa found by the `where` argument doesn't exist, create a new configs_bot_spa with this data.
     */
    create: XOR<configs_bot_spaCreateInput, configs_bot_spaUncheckedCreateInput>
    /**
     * In case the configs_bot_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configs_bot_spaUpdateInput, configs_bot_spaUncheckedUpdateInput>
  }

  /**
   * configs_bot_spa delete
   */
  export type configs_bot_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
    /**
     * Filter which configs_bot_spa to delete.
     */
    where: configs_bot_spaWhereUniqueInput
  }

  /**
   * configs_bot_spa deleteMany
   */
  export type configs_bot_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs_bot_spas to delete
     */
    where?: configs_bot_spaWhereInput
    /**
     * Limit how many configs_bot_spas to delete.
     */
    limit?: number
  }

  /**
   * configs_bot_spa without action
   */
  export type configs_bot_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configs_bot_spa
     */
    select?: configs_bot_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configs_bot_spa
     */
    omit?: configs_bot_spaOmit<ExtArgs> | null
  }


  /**
   * Model coparticipation_type_quotations
   */

  export type AggregateCoparticipation_type_quotations = {
    _count: Coparticipation_type_quotationsCountAggregateOutputType | null
    _avg: Coparticipation_type_quotationsAvgAggregateOutputType | null
    _sum: Coparticipation_type_quotationsSumAggregateOutputType | null
    _min: Coparticipation_type_quotationsMinAggregateOutputType | null
    _max: Coparticipation_type_quotationsMaxAggregateOutputType | null
  }

  export type Coparticipation_type_quotationsAvgAggregateOutputType = {
    id: number | null
  }

  export type Coparticipation_type_quotationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Coparticipation_type_quotationsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Coparticipation_type_quotationsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Coparticipation_type_quotationsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Coparticipation_type_quotationsAvgAggregateInputType = {
    id?: true
  }

  export type Coparticipation_type_quotationsSumAggregateInputType = {
    id?: true
  }

  export type Coparticipation_type_quotationsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Coparticipation_type_quotationsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Coparticipation_type_quotationsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Coparticipation_type_quotationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coparticipation_type_quotations to aggregate.
     */
    where?: coparticipation_type_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coparticipation_type_quotations to fetch.
     */
    orderBy?: coparticipation_type_quotationsOrderByWithRelationInput | coparticipation_type_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coparticipation_type_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coparticipation_type_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coparticipation_type_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coparticipation_type_quotations
    **/
    _count?: true | Coparticipation_type_quotationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Coparticipation_type_quotationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Coparticipation_type_quotationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Coparticipation_type_quotationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Coparticipation_type_quotationsMaxAggregateInputType
  }

  export type GetCoparticipation_type_quotationsAggregateType<T extends Coparticipation_type_quotationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCoparticipation_type_quotations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoparticipation_type_quotations[P]>
      : GetScalarType<T[P], AggregateCoparticipation_type_quotations[P]>
  }




  export type coparticipation_type_quotationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coparticipation_type_quotationsWhereInput
    orderBy?: coparticipation_type_quotationsOrderByWithAggregationInput | coparticipation_type_quotationsOrderByWithAggregationInput[]
    by: Coparticipation_type_quotationsScalarFieldEnum[] | Coparticipation_type_quotationsScalarFieldEnum
    having?: coparticipation_type_quotationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Coparticipation_type_quotationsCountAggregateInputType | true
    _avg?: Coparticipation_type_quotationsAvgAggregateInputType
    _sum?: Coparticipation_type_quotationsSumAggregateInputType
    _min?: Coparticipation_type_quotationsMinAggregateInputType
    _max?: Coparticipation_type_quotationsMaxAggregateInputType
  }

  export type Coparticipation_type_quotationsGroupByOutputType = {
    id: bigint
    name: string
    _count: Coparticipation_type_quotationsCountAggregateOutputType | null
    _avg: Coparticipation_type_quotationsAvgAggregateOutputType | null
    _sum: Coparticipation_type_quotationsSumAggregateOutputType | null
    _min: Coparticipation_type_quotationsMinAggregateOutputType | null
    _max: Coparticipation_type_quotationsMaxAggregateOutputType | null
  }

  type GetCoparticipation_type_quotationsGroupByPayload<T extends coparticipation_type_quotationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Coparticipation_type_quotationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Coparticipation_type_quotationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Coparticipation_type_quotationsGroupByOutputType[P]>
            : GetScalarType<T[P], Coparticipation_type_quotationsGroupByOutputType[P]>
        }
      >
    >


  export type coparticipation_type_quotationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["coparticipation_type_quotations"]>



  export type coparticipation_type_quotationsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type coparticipation_type_quotationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["coparticipation_type_quotations"]>

  export type $coparticipation_type_quotationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coparticipation_type_quotations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["coparticipation_type_quotations"]>
    composites: {}
  }

  type coparticipation_type_quotationsGetPayload<S extends boolean | null | undefined | coparticipation_type_quotationsDefaultArgs> = $Result.GetResult<Prisma.$coparticipation_type_quotationsPayload, S>

  type coparticipation_type_quotationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<coparticipation_type_quotationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Coparticipation_type_quotationsCountAggregateInputType | true
    }

  export interface coparticipation_type_quotationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coparticipation_type_quotations'], meta: { name: 'coparticipation_type_quotations' } }
    /**
     * Find zero or one Coparticipation_type_quotations that matches the filter.
     * @param {coparticipation_type_quotationsFindUniqueArgs} args - Arguments to find a Coparticipation_type_quotations
     * @example
     * // Get one Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coparticipation_type_quotationsFindUniqueArgs>(args: SelectSubset<T, coparticipation_type_quotationsFindUniqueArgs<ExtArgs>>): Prisma__coparticipation_type_quotationsClient<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coparticipation_type_quotations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {coparticipation_type_quotationsFindUniqueOrThrowArgs} args - Arguments to find a Coparticipation_type_quotations
     * @example
     * // Get one Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coparticipation_type_quotationsFindUniqueOrThrowArgs>(args: SelectSubset<T, coparticipation_type_quotationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coparticipation_type_quotationsClient<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coparticipation_type_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coparticipation_type_quotationsFindFirstArgs} args - Arguments to find a Coparticipation_type_quotations
     * @example
     * // Get one Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coparticipation_type_quotationsFindFirstArgs>(args?: SelectSubset<T, coparticipation_type_quotationsFindFirstArgs<ExtArgs>>): Prisma__coparticipation_type_quotationsClient<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coparticipation_type_quotations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coparticipation_type_quotationsFindFirstOrThrowArgs} args - Arguments to find a Coparticipation_type_quotations
     * @example
     * // Get one Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coparticipation_type_quotationsFindFirstOrThrowArgs>(args?: SelectSubset<T, coparticipation_type_quotationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__coparticipation_type_quotationsClient<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coparticipation_type_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coparticipation_type_quotationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.findMany()
     * 
     * // Get first 10 Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coparticipation_type_quotationsWithIdOnly = await prisma.coparticipation_type_quotations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coparticipation_type_quotationsFindManyArgs>(args?: SelectSubset<T, coparticipation_type_quotationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coparticipation_type_quotations.
     * @param {coparticipation_type_quotationsCreateArgs} args - Arguments to create a Coparticipation_type_quotations.
     * @example
     * // Create one Coparticipation_type_quotations
     * const Coparticipation_type_quotations = await prisma.coparticipation_type_quotations.create({
     *   data: {
     *     // ... data to create a Coparticipation_type_quotations
     *   }
     * })
     * 
     */
    create<T extends coparticipation_type_quotationsCreateArgs>(args: SelectSubset<T, coparticipation_type_quotationsCreateArgs<ExtArgs>>): Prisma__coparticipation_type_quotationsClient<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coparticipation_type_quotations.
     * @param {coparticipation_type_quotationsCreateManyArgs} args - Arguments to create many Coparticipation_type_quotations.
     * @example
     * // Create many Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coparticipation_type_quotationsCreateManyArgs>(args?: SelectSubset<T, coparticipation_type_quotationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Coparticipation_type_quotations.
     * @param {coparticipation_type_quotationsDeleteArgs} args - Arguments to delete one Coparticipation_type_quotations.
     * @example
     * // Delete one Coparticipation_type_quotations
     * const Coparticipation_type_quotations = await prisma.coparticipation_type_quotations.delete({
     *   where: {
     *     // ... filter to delete one Coparticipation_type_quotations
     *   }
     * })
     * 
     */
    delete<T extends coparticipation_type_quotationsDeleteArgs>(args: SelectSubset<T, coparticipation_type_quotationsDeleteArgs<ExtArgs>>): Prisma__coparticipation_type_quotationsClient<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coparticipation_type_quotations.
     * @param {coparticipation_type_quotationsUpdateArgs} args - Arguments to update one Coparticipation_type_quotations.
     * @example
     * // Update one Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coparticipation_type_quotationsUpdateArgs>(args: SelectSubset<T, coparticipation_type_quotationsUpdateArgs<ExtArgs>>): Prisma__coparticipation_type_quotationsClient<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coparticipation_type_quotations.
     * @param {coparticipation_type_quotationsDeleteManyArgs} args - Arguments to filter Coparticipation_type_quotations to delete.
     * @example
     * // Delete a few Coparticipation_type_quotations
     * const { count } = await prisma.coparticipation_type_quotations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coparticipation_type_quotationsDeleteManyArgs>(args?: SelectSubset<T, coparticipation_type_quotationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coparticipation_type_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coparticipation_type_quotationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coparticipation_type_quotationsUpdateManyArgs>(args: SelectSubset<T, coparticipation_type_quotationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coparticipation_type_quotations.
     * @param {coparticipation_type_quotationsUpsertArgs} args - Arguments to update or create a Coparticipation_type_quotations.
     * @example
     * // Update or create a Coparticipation_type_quotations
     * const coparticipation_type_quotations = await prisma.coparticipation_type_quotations.upsert({
     *   create: {
     *     // ... data to create a Coparticipation_type_quotations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coparticipation_type_quotations we want to update
     *   }
     * })
     */
    upsert<T extends coparticipation_type_quotationsUpsertArgs>(args: SelectSubset<T, coparticipation_type_quotationsUpsertArgs<ExtArgs>>): Prisma__coparticipation_type_quotationsClient<$Result.GetResult<Prisma.$coparticipation_type_quotationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coparticipation_type_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coparticipation_type_quotationsCountArgs} args - Arguments to filter Coparticipation_type_quotations to count.
     * @example
     * // Count the number of Coparticipation_type_quotations
     * const count = await prisma.coparticipation_type_quotations.count({
     *   where: {
     *     // ... the filter for the Coparticipation_type_quotations we want to count
     *   }
     * })
    **/
    count<T extends coparticipation_type_quotationsCountArgs>(
      args?: Subset<T, coparticipation_type_quotationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Coparticipation_type_quotationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coparticipation_type_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Coparticipation_type_quotationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Coparticipation_type_quotationsAggregateArgs>(args: Subset<T, Coparticipation_type_quotationsAggregateArgs>): Prisma.PrismaPromise<GetCoparticipation_type_quotationsAggregateType<T>>

    /**
     * Group by Coparticipation_type_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coparticipation_type_quotationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coparticipation_type_quotationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coparticipation_type_quotationsGroupByArgs['orderBy'] }
        : { orderBy?: coparticipation_type_quotationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coparticipation_type_quotationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoparticipation_type_quotationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coparticipation_type_quotations model
   */
  readonly fields: coparticipation_type_quotationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coparticipation_type_quotations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coparticipation_type_quotationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coparticipation_type_quotations model
   */
  interface coparticipation_type_quotationsFieldRefs {
    readonly id: FieldRef<"coparticipation_type_quotations", 'BigInt'>
    readonly name: FieldRef<"coparticipation_type_quotations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * coparticipation_type_quotations findUnique
   */
  export type coparticipation_type_quotationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which coparticipation_type_quotations to fetch.
     */
    where: coparticipation_type_quotationsWhereUniqueInput
  }

  /**
   * coparticipation_type_quotations findUniqueOrThrow
   */
  export type coparticipation_type_quotationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which coparticipation_type_quotations to fetch.
     */
    where: coparticipation_type_quotationsWhereUniqueInput
  }

  /**
   * coparticipation_type_quotations findFirst
   */
  export type coparticipation_type_quotationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which coparticipation_type_quotations to fetch.
     */
    where?: coparticipation_type_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coparticipation_type_quotations to fetch.
     */
    orderBy?: coparticipation_type_quotationsOrderByWithRelationInput | coparticipation_type_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coparticipation_type_quotations.
     */
    cursor?: coparticipation_type_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coparticipation_type_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coparticipation_type_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coparticipation_type_quotations.
     */
    distinct?: Coparticipation_type_quotationsScalarFieldEnum | Coparticipation_type_quotationsScalarFieldEnum[]
  }

  /**
   * coparticipation_type_quotations findFirstOrThrow
   */
  export type coparticipation_type_quotationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which coparticipation_type_quotations to fetch.
     */
    where?: coparticipation_type_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coparticipation_type_quotations to fetch.
     */
    orderBy?: coparticipation_type_quotationsOrderByWithRelationInput | coparticipation_type_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coparticipation_type_quotations.
     */
    cursor?: coparticipation_type_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coparticipation_type_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coparticipation_type_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coparticipation_type_quotations.
     */
    distinct?: Coparticipation_type_quotationsScalarFieldEnum | Coparticipation_type_quotationsScalarFieldEnum[]
  }

  /**
   * coparticipation_type_quotations findMany
   */
  export type coparticipation_type_quotationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which coparticipation_type_quotations to fetch.
     */
    where?: coparticipation_type_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coparticipation_type_quotations to fetch.
     */
    orderBy?: coparticipation_type_quotationsOrderByWithRelationInput | coparticipation_type_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coparticipation_type_quotations.
     */
    cursor?: coparticipation_type_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coparticipation_type_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coparticipation_type_quotations.
     */
    skip?: number
    distinct?: Coparticipation_type_quotationsScalarFieldEnum | Coparticipation_type_quotationsScalarFieldEnum[]
  }

  /**
   * coparticipation_type_quotations create
   */
  export type coparticipation_type_quotationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to create a coparticipation_type_quotations.
     */
    data: XOR<coparticipation_type_quotationsCreateInput, coparticipation_type_quotationsUncheckedCreateInput>
  }

  /**
   * coparticipation_type_quotations createMany
   */
  export type coparticipation_type_quotationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coparticipation_type_quotations.
     */
    data: coparticipation_type_quotationsCreateManyInput | coparticipation_type_quotationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coparticipation_type_quotations update
   */
  export type coparticipation_type_quotationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to update a coparticipation_type_quotations.
     */
    data: XOR<coparticipation_type_quotationsUpdateInput, coparticipation_type_quotationsUncheckedUpdateInput>
    /**
     * Choose, which coparticipation_type_quotations to update.
     */
    where: coparticipation_type_quotationsWhereUniqueInput
  }

  /**
   * coparticipation_type_quotations updateMany
   */
  export type coparticipation_type_quotationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coparticipation_type_quotations.
     */
    data: XOR<coparticipation_type_quotationsUpdateManyMutationInput, coparticipation_type_quotationsUncheckedUpdateManyInput>
    /**
     * Filter which coparticipation_type_quotations to update
     */
    where?: coparticipation_type_quotationsWhereInput
    /**
     * Limit how many coparticipation_type_quotations to update.
     */
    limit?: number
  }

  /**
   * coparticipation_type_quotations upsert
   */
  export type coparticipation_type_quotationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * The filter to search for the coparticipation_type_quotations to update in case it exists.
     */
    where: coparticipation_type_quotationsWhereUniqueInput
    /**
     * In case the coparticipation_type_quotations found by the `where` argument doesn't exist, create a new coparticipation_type_quotations with this data.
     */
    create: XOR<coparticipation_type_quotationsCreateInput, coparticipation_type_quotationsUncheckedCreateInput>
    /**
     * In case the coparticipation_type_quotations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coparticipation_type_quotationsUpdateInput, coparticipation_type_quotationsUncheckedUpdateInput>
  }

  /**
   * coparticipation_type_quotations delete
   */
  export type coparticipation_type_quotationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter which coparticipation_type_quotations to delete.
     */
    where: coparticipation_type_quotationsWhereUniqueInput
  }

  /**
   * coparticipation_type_quotations deleteMany
   */
  export type coparticipation_type_quotationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coparticipation_type_quotations to delete
     */
    where?: coparticipation_type_quotationsWhereInput
    /**
     * Limit how many coparticipation_type_quotations to delete.
     */
    limit?: number
  }

  /**
   * coparticipation_type_quotations without action
   */
  export type coparticipation_type_quotationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coparticipation_type_quotations
     */
    select?: coparticipation_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coparticipation_type_quotations
     */
    omit?: coparticipation_type_quotationsOmit<ExtArgs> | null
  }


  /**
   * Model cpf_consults_aut
   */

  export type AggregateCpf_consults_aut = {
    _count: Cpf_consults_autCountAggregateOutputType | null
    _min: Cpf_consults_autMinAggregateOutputType | null
    _max: Cpf_consults_autMaxAggregateOutputType | null
  }

  export type Cpf_consults_autMinAggregateOutputType = {
    id: string | null
    cpf: string | null
    user_id: string | null
    is_error: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Cpf_consults_autMaxAggregateOutputType = {
    id: string | null
    cpf: string | null
    user_id: string | null
    is_error: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Cpf_consults_autCountAggregateOutputType = {
    id: number
    cpf: number
    user_id: number
    is_error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Cpf_consults_autMinAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Cpf_consults_autMaxAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Cpf_consults_autCountAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Cpf_consults_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cpf_consults_aut to aggregate.
     */
    where?: cpf_consults_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_auts to fetch.
     */
    orderBy?: cpf_consults_autOrderByWithRelationInput | cpf_consults_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cpf_consults_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cpf_consults_auts
    **/
    _count?: true | Cpf_consults_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cpf_consults_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cpf_consults_autMaxAggregateInputType
  }

  export type GetCpf_consults_autAggregateType<T extends Cpf_consults_autAggregateArgs> = {
        [P in keyof T & keyof AggregateCpf_consults_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCpf_consults_aut[P]>
      : GetScalarType<T[P], AggregateCpf_consults_aut[P]>
  }




  export type cpf_consults_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cpf_consults_autWhereInput
    orderBy?: cpf_consults_autOrderByWithAggregationInput | cpf_consults_autOrderByWithAggregationInput[]
    by: Cpf_consults_autScalarFieldEnum[] | Cpf_consults_autScalarFieldEnum
    having?: cpf_consults_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cpf_consults_autCountAggregateInputType | true
    _min?: Cpf_consults_autMinAggregateInputType
    _max?: Cpf_consults_autMaxAggregateInputType
  }

  export type Cpf_consults_autGroupByOutputType = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date
    updatedAt: Date
    _count: Cpf_consults_autCountAggregateOutputType | null
    _min: Cpf_consults_autMinAggregateOutputType | null
    _max: Cpf_consults_autMaxAggregateOutputType | null
  }

  type GetCpf_consults_autGroupByPayload<T extends cpf_consults_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cpf_consults_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cpf_consults_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cpf_consults_autGroupByOutputType[P]>
            : GetScalarType<T[P], Cpf_consults_autGroupByOutputType[P]>
        }
      >
    >


  export type cpf_consults_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpf?: boolean
    user_id?: boolean
    is_error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cpf_consults_aut"]>



  export type cpf_consults_autSelectScalar = {
    id?: boolean
    cpf?: boolean
    user_id?: boolean
    is_error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type cpf_consults_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cpf" | "user_id" | "is_error" | "createdAt" | "updatedAt", ExtArgs["result"]["cpf_consults_aut"]>
  export type cpf_consults_autInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }

  export type $cpf_consults_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cpf_consults_aut"
    objects: {
      users_aut: Prisma.$users_autPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cpf: string
      user_id: string
      is_error: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cpf_consults_aut"]>
    composites: {}
  }

  type cpf_consults_autGetPayload<S extends boolean | null | undefined | cpf_consults_autDefaultArgs> = $Result.GetResult<Prisma.$cpf_consults_autPayload, S>

  type cpf_consults_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cpf_consults_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cpf_consults_autCountAggregateInputType | true
    }

  export interface cpf_consults_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cpf_consults_aut'], meta: { name: 'cpf_consults_aut' } }
    /**
     * Find zero or one Cpf_consults_aut that matches the filter.
     * @param {cpf_consults_autFindUniqueArgs} args - Arguments to find a Cpf_consults_aut
     * @example
     * // Get one Cpf_consults_aut
     * const cpf_consults_aut = await prisma.cpf_consults_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cpf_consults_autFindUniqueArgs>(args: SelectSubset<T, cpf_consults_autFindUniqueArgs<ExtArgs>>): Prisma__cpf_consults_autClient<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cpf_consults_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cpf_consults_autFindUniqueOrThrowArgs} args - Arguments to find a Cpf_consults_aut
     * @example
     * // Get one Cpf_consults_aut
     * const cpf_consults_aut = await prisma.cpf_consults_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cpf_consults_autFindUniqueOrThrowArgs>(args: SelectSubset<T, cpf_consults_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cpf_consults_autClient<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cpf_consults_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_autFindFirstArgs} args - Arguments to find a Cpf_consults_aut
     * @example
     * // Get one Cpf_consults_aut
     * const cpf_consults_aut = await prisma.cpf_consults_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cpf_consults_autFindFirstArgs>(args?: SelectSubset<T, cpf_consults_autFindFirstArgs<ExtArgs>>): Prisma__cpf_consults_autClient<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cpf_consults_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_autFindFirstOrThrowArgs} args - Arguments to find a Cpf_consults_aut
     * @example
     * // Get one Cpf_consults_aut
     * const cpf_consults_aut = await prisma.cpf_consults_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cpf_consults_autFindFirstOrThrowArgs>(args?: SelectSubset<T, cpf_consults_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__cpf_consults_autClient<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cpf_consults_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cpf_consults_auts
     * const cpf_consults_auts = await prisma.cpf_consults_aut.findMany()
     * 
     * // Get first 10 Cpf_consults_auts
     * const cpf_consults_auts = await prisma.cpf_consults_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cpf_consults_autWithIdOnly = await prisma.cpf_consults_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cpf_consults_autFindManyArgs>(args?: SelectSubset<T, cpf_consults_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cpf_consults_aut.
     * @param {cpf_consults_autCreateArgs} args - Arguments to create a Cpf_consults_aut.
     * @example
     * // Create one Cpf_consults_aut
     * const Cpf_consults_aut = await prisma.cpf_consults_aut.create({
     *   data: {
     *     // ... data to create a Cpf_consults_aut
     *   }
     * })
     * 
     */
    create<T extends cpf_consults_autCreateArgs>(args: SelectSubset<T, cpf_consults_autCreateArgs<ExtArgs>>): Prisma__cpf_consults_autClient<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cpf_consults_auts.
     * @param {cpf_consults_autCreateManyArgs} args - Arguments to create many Cpf_consults_auts.
     * @example
     * // Create many Cpf_consults_auts
     * const cpf_consults_aut = await prisma.cpf_consults_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cpf_consults_autCreateManyArgs>(args?: SelectSubset<T, cpf_consults_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cpf_consults_aut.
     * @param {cpf_consults_autDeleteArgs} args - Arguments to delete one Cpf_consults_aut.
     * @example
     * // Delete one Cpf_consults_aut
     * const Cpf_consults_aut = await prisma.cpf_consults_aut.delete({
     *   where: {
     *     // ... filter to delete one Cpf_consults_aut
     *   }
     * })
     * 
     */
    delete<T extends cpf_consults_autDeleteArgs>(args: SelectSubset<T, cpf_consults_autDeleteArgs<ExtArgs>>): Prisma__cpf_consults_autClient<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cpf_consults_aut.
     * @param {cpf_consults_autUpdateArgs} args - Arguments to update one Cpf_consults_aut.
     * @example
     * // Update one Cpf_consults_aut
     * const cpf_consults_aut = await prisma.cpf_consults_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cpf_consults_autUpdateArgs>(args: SelectSubset<T, cpf_consults_autUpdateArgs<ExtArgs>>): Prisma__cpf_consults_autClient<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cpf_consults_auts.
     * @param {cpf_consults_autDeleteManyArgs} args - Arguments to filter Cpf_consults_auts to delete.
     * @example
     * // Delete a few Cpf_consults_auts
     * const { count } = await prisma.cpf_consults_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cpf_consults_autDeleteManyArgs>(args?: SelectSubset<T, cpf_consults_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cpf_consults_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cpf_consults_auts
     * const cpf_consults_aut = await prisma.cpf_consults_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cpf_consults_autUpdateManyArgs>(args: SelectSubset<T, cpf_consults_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cpf_consults_aut.
     * @param {cpf_consults_autUpsertArgs} args - Arguments to update or create a Cpf_consults_aut.
     * @example
     * // Update or create a Cpf_consults_aut
     * const cpf_consults_aut = await prisma.cpf_consults_aut.upsert({
     *   create: {
     *     // ... data to create a Cpf_consults_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cpf_consults_aut we want to update
     *   }
     * })
     */
    upsert<T extends cpf_consults_autUpsertArgs>(args: SelectSubset<T, cpf_consults_autUpsertArgs<ExtArgs>>): Prisma__cpf_consults_autClient<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cpf_consults_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_autCountArgs} args - Arguments to filter Cpf_consults_auts to count.
     * @example
     * // Count the number of Cpf_consults_auts
     * const count = await prisma.cpf_consults_aut.count({
     *   where: {
     *     // ... the filter for the Cpf_consults_auts we want to count
     *   }
     * })
    **/
    count<T extends cpf_consults_autCountArgs>(
      args?: Subset<T, cpf_consults_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cpf_consults_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cpf_consults_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cpf_consults_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cpf_consults_autAggregateArgs>(args: Subset<T, Cpf_consults_autAggregateArgs>): Prisma.PrismaPromise<GetCpf_consults_autAggregateType<T>>

    /**
     * Group by Cpf_consults_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cpf_consults_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cpf_consults_autGroupByArgs['orderBy'] }
        : { orderBy?: cpf_consults_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cpf_consults_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCpf_consults_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cpf_consults_aut model
   */
  readonly fields: cpf_consults_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cpf_consults_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cpf_consults_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_aut<T extends users_autDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_autDefaultArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cpf_consults_aut model
   */
  interface cpf_consults_autFieldRefs {
    readonly id: FieldRef<"cpf_consults_aut", 'String'>
    readonly cpf: FieldRef<"cpf_consults_aut", 'String'>
    readonly user_id: FieldRef<"cpf_consults_aut", 'String'>
    readonly is_error: FieldRef<"cpf_consults_aut", 'Boolean'>
    readonly createdAt: FieldRef<"cpf_consults_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"cpf_consults_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cpf_consults_aut findUnique
   */
  export type cpf_consults_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_aut to fetch.
     */
    where: cpf_consults_autWhereUniqueInput
  }

  /**
   * cpf_consults_aut findUniqueOrThrow
   */
  export type cpf_consults_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_aut to fetch.
     */
    where: cpf_consults_autWhereUniqueInput
  }

  /**
   * cpf_consults_aut findFirst
   */
  export type cpf_consults_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_aut to fetch.
     */
    where?: cpf_consults_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_auts to fetch.
     */
    orderBy?: cpf_consults_autOrderByWithRelationInput | cpf_consults_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cpf_consults_auts.
     */
    cursor?: cpf_consults_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cpf_consults_auts.
     */
    distinct?: Cpf_consults_autScalarFieldEnum | Cpf_consults_autScalarFieldEnum[]
  }

  /**
   * cpf_consults_aut findFirstOrThrow
   */
  export type cpf_consults_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_aut to fetch.
     */
    where?: cpf_consults_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_auts to fetch.
     */
    orderBy?: cpf_consults_autOrderByWithRelationInput | cpf_consults_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cpf_consults_auts.
     */
    cursor?: cpf_consults_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cpf_consults_auts.
     */
    distinct?: Cpf_consults_autScalarFieldEnum | Cpf_consults_autScalarFieldEnum[]
  }

  /**
   * cpf_consults_aut findMany
   */
  export type cpf_consults_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_auts to fetch.
     */
    where?: cpf_consults_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_auts to fetch.
     */
    orderBy?: cpf_consults_autOrderByWithRelationInput | cpf_consults_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cpf_consults_auts.
     */
    cursor?: cpf_consults_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_auts.
     */
    skip?: number
    distinct?: Cpf_consults_autScalarFieldEnum | Cpf_consults_autScalarFieldEnum[]
  }

  /**
   * cpf_consults_aut create
   */
  export type cpf_consults_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * The data needed to create a cpf_consults_aut.
     */
    data: XOR<cpf_consults_autCreateInput, cpf_consults_autUncheckedCreateInput>
  }

  /**
   * cpf_consults_aut createMany
   */
  export type cpf_consults_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cpf_consults_auts.
     */
    data: cpf_consults_autCreateManyInput | cpf_consults_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cpf_consults_aut update
   */
  export type cpf_consults_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * The data needed to update a cpf_consults_aut.
     */
    data: XOR<cpf_consults_autUpdateInput, cpf_consults_autUncheckedUpdateInput>
    /**
     * Choose, which cpf_consults_aut to update.
     */
    where: cpf_consults_autWhereUniqueInput
  }

  /**
   * cpf_consults_aut updateMany
   */
  export type cpf_consults_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cpf_consults_auts.
     */
    data: XOR<cpf_consults_autUpdateManyMutationInput, cpf_consults_autUncheckedUpdateManyInput>
    /**
     * Filter which cpf_consults_auts to update
     */
    where?: cpf_consults_autWhereInput
    /**
     * Limit how many cpf_consults_auts to update.
     */
    limit?: number
  }

  /**
   * cpf_consults_aut upsert
   */
  export type cpf_consults_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * The filter to search for the cpf_consults_aut to update in case it exists.
     */
    where: cpf_consults_autWhereUniqueInput
    /**
     * In case the cpf_consults_aut found by the `where` argument doesn't exist, create a new cpf_consults_aut with this data.
     */
    create: XOR<cpf_consults_autCreateInput, cpf_consults_autUncheckedCreateInput>
    /**
     * In case the cpf_consults_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cpf_consults_autUpdateInput, cpf_consults_autUncheckedUpdateInput>
  }

  /**
   * cpf_consults_aut delete
   */
  export type cpf_consults_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    /**
     * Filter which cpf_consults_aut to delete.
     */
    where: cpf_consults_autWhereUniqueInput
  }

  /**
   * cpf_consults_aut deleteMany
   */
  export type cpf_consults_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cpf_consults_auts to delete
     */
    where?: cpf_consults_autWhereInput
    /**
     * Limit how many cpf_consults_auts to delete.
     */
    limit?: number
  }

  /**
   * cpf_consults_aut without action
   */
  export type cpf_consults_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
  }


  /**
   * Model cpf_consults_clt
   */

  export type AggregateCpf_consults_clt = {
    _count: Cpf_consults_cltCountAggregateOutputType | null
    _min: Cpf_consults_cltMinAggregateOutputType | null
    _max: Cpf_consults_cltMaxAggregateOutputType | null
  }

  export type Cpf_consults_cltMinAggregateOutputType = {
    id: string | null
    cpf: string | null
    user_id: string | null
    is_error: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Cpf_consults_cltMaxAggregateOutputType = {
    id: string | null
    cpf: string | null
    user_id: string | null
    is_error: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Cpf_consults_cltCountAggregateOutputType = {
    id: number
    cpf: number
    user_id: number
    is_error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Cpf_consults_cltMinAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Cpf_consults_cltMaxAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Cpf_consults_cltCountAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Cpf_consults_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cpf_consults_clt to aggregate.
     */
    where?: cpf_consults_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_clts to fetch.
     */
    orderBy?: cpf_consults_cltOrderByWithRelationInput | cpf_consults_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cpf_consults_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cpf_consults_clts
    **/
    _count?: true | Cpf_consults_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cpf_consults_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cpf_consults_cltMaxAggregateInputType
  }

  export type GetCpf_consults_cltAggregateType<T extends Cpf_consults_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateCpf_consults_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCpf_consults_clt[P]>
      : GetScalarType<T[P], AggregateCpf_consults_clt[P]>
  }




  export type cpf_consults_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cpf_consults_cltWhereInput
    orderBy?: cpf_consults_cltOrderByWithAggregationInput | cpf_consults_cltOrderByWithAggregationInput[]
    by: Cpf_consults_cltScalarFieldEnum[] | Cpf_consults_cltScalarFieldEnum
    having?: cpf_consults_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cpf_consults_cltCountAggregateInputType | true
    _min?: Cpf_consults_cltMinAggregateInputType
    _max?: Cpf_consults_cltMaxAggregateInputType
  }

  export type Cpf_consults_cltGroupByOutputType = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date
    updatedAt: Date
    _count: Cpf_consults_cltCountAggregateOutputType | null
    _min: Cpf_consults_cltMinAggregateOutputType | null
    _max: Cpf_consults_cltMaxAggregateOutputType | null
  }

  type GetCpf_consults_cltGroupByPayload<T extends cpf_consults_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cpf_consults_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cpf_consults_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cpf_consults_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Cpf_consults_cltGroupByOutputType[P]>
        }
      >
    >


  export type cpf_consults_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpf?: boolean
    user_id?: boolean
    is_error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cpf_consults_clt"]>



  export type cpf_consults_cltSelectScalar = {
    id?: boolean
    cpf?: boolean
    user_id?: boolean
    is_error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type cpf_consults_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cpf" | "user_id" | "is_error" | "createdAt" | "updatedAt", ExtArgs["result"]["cpf_consults_clt"]>
  export type cpf_consults_cltInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }

  export type $cpf_consults_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cpf_consults_clt"
    objects: {
      users_clt: Prisma.$users_cltPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cpf: string
      user_id: string
      is_error: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cpf_consults_clt"]>
    composites: {}
  }

  type cpf_consults_cltGetPayload<S extends boolean | null | undefined | cpf_consults_cltDefaultArgs> = $Result.GetResult<Prisma.$cpf_consults_cltPayload, S>

  type cpf_consults_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cpf_consults_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cpf_consults_cltCountAggregateInputType | true
    }

  export interface cpf_consults_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cpf_consults_clt'], meta: { name: 'cpf_consults_clt' } }
    /**
     * Find zero or one Cpf_consults_clt that matches the filter.
     * @param {cpf_consults_cltFindUniqueArgs} args - Arguments to find a Cpf_consults_clt
     * @example
     * // Get one Cpf_consults_clt
     * const cpf_consults_clt = await prisma.cpf_consults_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cpf_consults_cltFindUniqueArgs>(args: SelectSubset<T, cpf_consults_cltFindUniqueArgs<ExtArgs>>): Prisma__cpf_consults_cltClient<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cpf_consults_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cpf_consults_cltFindUniqueOrThrowArgs} args - Arguments to find a Cpf_consults_clt
     * @example
     * // Get one Cpf_consults_clt
     * const cpf_consults_clt = await prisma.cpf_consults_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cpf_consults_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, cpf_consults_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cpf_consults_cltClient<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cpf_consults_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_cltFindFirstArgs} args - Arguments to find a Cpf_consults_clt
     * @example
     * // Get one Cpf_consults_clt
     * const cpf_consults_clt = await prisma.cpf_consults_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cpf_consults_cltFindFirstArgs>(args?: SelectSubset<T, cpf_consults_cltFindFirstArgs<ExtArgs>>): Prisma__cpf_consults_cltClient<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cpf_consults_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_cltFindFirstOrThrowArgs} args - Arguments to find a Cpf_consults_clt
     * @example
     * // Get one Cpf_consults_clt
     * const cpf_consults_clt = await prisma.cpf_consults_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cpf_consults_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, cpf_consults_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__cpf_consults_cltClient<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cpf_consults_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cpf_consults_clts
     * const cpf_consults_clts = await prisma.cpf_consults_clt.findMany()
     * 
     * // Get first 10 Cpf_consults_clts
     * const cpf_consults_clts = await prisma.cpf_consults_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cpf_consults_cltWithIdOnly = await prisma.cpf_consults_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cpf_consults_cltFindManyArgs>(args?: SelectSubset<T, cpf_consults_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cpf_consults_clt.
     * @param {cpf_consults_cltCreateArgs} args - Arguments to create a Cpf_consults_clt.
     * @example
     * // Create one Cpf_consults_clt
     * const Cpf_consults_clt = await prisma.cpf_consults_clt.create({
     *   data: {
     *     // ... data to create a Cpf_consults_clt
     *   }
     * })
     * 
     */
    create<T extends cpf_consults_cltCreateArgs>(args: SelectSubset<T, cpf_consults_cltCreateArgs<ExtArgs>>): Prisma__cpf_consults_cltClient<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cpf_consults_clts.
     * @param {cpf_consults_cltCreateManyArgs} args - Arguments to create many Cpf_consults_clts.
     * @example
     * // Create many Cpf_consults_clts
     * const cpf_consults_clt = await prisma.cpf_consults_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cpf_consults_cltCreateManyArgs>(args?: SelectSubset<T, cpf_consults_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cpf_consults_clt.
     * @param {cpf_consults_cltDeleteArgs} args - Arguments to delete one Cpf_consults_clt.
     * @example
     * // Delete one Cpf_consults_clt
     * const Cpf_consults_clt = await prisma.cpf_consults_clt.delete({
     *   where: {
     *     // ... filter to delete one Cpf_consults_clt
     *   }
     * })
     * 
     */
    delete<T extends cpf_consults_cltDeleteArgs>(args: SelectSubset<T, cpf_consults_cltDeleteArgs<ExtArgs>>): Prisma__cpf_consults_cltClient<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cpf_consults_clt.
     * @param {cpf_consults_cltUpdateArgs} args - Arguments to update one Cpf_consults_clt.
     * @example
     * // Update one Cpf_consults_clt
     * const cpf_consults_clt = await prisma.cpf_consults_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cpf_consults_cltUpdateArgs>(args: SelectSubset<T, cpf_consults_cltUpdateArgs<ExtArgs>>): Prisma__cpf_consults_cltClient<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cpf_consults_clts.
     * @param {cpf_consults_cltDeleteManyArgs} args - Arguments to filter Cpf_consults_clts to delete.
     * @example
     * // Delete a few Cpf_consults_clts
     * const { count } = await prisma.cpf_consults_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cpf_consults_cltDeleteManyArgs>(args?: SelectSubset<T, cpf_consults_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cpf_consults_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cpf_consults_clts
     * const cpf_consults_clt = await prisma.cpf_consults_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cpf_consults_cltUpdateManyArgs>(args: SelectSubset<T, cpf_consults_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cpf_consults_clt.
     * @param {cpf_consults_cltUpsertArgs} args - Arguments to update or create a Cpf_consults_clt.
     * @example
     * // Update or create a Cpf_consults_clt
     * const cpf_consults_clt = await prisma.cpf_consults_clt.upsert({
     *   create: {
     *     // ... data to create a Cpf_consults_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cpf_consults_clt we want to update
     *   }
     * })
     */
    upsert<T extends cpf_consults_cltUpsertArgs>(args: SelectSubset<T, cpf_consults_cltUpsertArgs<ExtArgs>>): Prisma__cpf_consults_cltClient<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cpf_consults_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_cltCountArgs} args - Arguments to filter Cpf_consults_clts to count.
     * @example
     * // Count the number of Cpf_consults_clts
     * const count = await prisma.cpf_consults_clt.count({
     *   where: {
     *     // ... the filter for the Cpf_consults_clts we want to count
     *   }
     * })
    **/
    count<T extends cpf_consults_cltCountArgs>(
      args?: Subset<T, cpf_consults_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cpf_consults_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cpf_consults_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cpf_consults_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cpf_consults_cltAggregateArgs>(args: Subset<T, Cpf_consults_cltAggregateArgs>): Prisma.PrismaPromise<GetCpf_consults_cltAggregateType<T>>

    /**
     * Group by Cpf_consults_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cpf_consults_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cpf_consults_cltGroupByArgs['orderBy'] }
        : { orderBy?: cpf_consults_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cpf_consults_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCpf_consults_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cpf_consults_clt model
   */
  readonly fields: cpf_consults_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cpf_consults_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cpf_consults_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_clt<T extends users_cltDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_cltDefaultArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cpf_consults_clt model
   */
  interface cpf_consults_cltFieldRefs {
    readonly id: FieldRef<"cpf_consults_clt", 'String'>
    readonly cpf: FieldRef<"cpf_consults_clt", 'String'>
    readonly user_id: FieldRef<"cpf_consults_clt", 'String'>
    readonly is_error: FieldRef<"cpf_consults_clt", 'Boolean'>
    readonly createdAt: FieldRef<"cpf_consults_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"cpf_consults_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cpf_consults_clt findUnique
   */
  export type cpf_consults_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_clt to fetch.
     */
    where: cpf_consults_cltWhereUniqueInput
  }

  /**
   * cpf_consults_clt findUniqueOrThrow
   */
  export type cpf_consults_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_clt to fetch.
     */
    where: cpf_consults_cltWhereUniqueInput
  }

  /**
   * cpf_consults_clt findFirst
   */
  export type cpf_consults_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_clt to fetch.
     */
    where?: cpf_consults_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_clts to fetch.
     */
    orderBy?: cpf_consults_cltOrderByWithRelationInput | cpf_consults_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cpf_consults_clts.
     */
    cursor?: cpf_consults_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cpf_consults_clts.
     */
    distinct?: Cpf_consults_cltScalarFieldEnum | Cpf_consults_cltScalarFieldEnum[]
  }

  /**
   * cpf_consults_clt findFirstOrThrow
   */
  export type cpf_consults_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_clt to fetch.
     */
    where?: cpf_consults_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_clts to fetch.
     */
    orderBy?: cpf_consults_cltOrderByWithRelationInput | cpf_consults_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cpf_consults_clts.
     */
    cursor?: cpf_consults_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cpf_consults_clts.
     */
    distinct?: Cpf_consults_cltScalarFieldEnum | Cpf_consults_cltScalarFieldEnum[]
  }

  /**
   * cpf_consults_clt findMany
   */
  export type cpf_consults_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_clts to fetch.
     */
    where?: cpf_consults_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_clts to fetch.
     */
    orderBy?: cpf_consults_cltOrderByWithRelationInput | cpf_consults_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cpf_consults_clts.
     */
    cursor?: cpf_consults_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_clts.
     */
    skip?: number
    distinct?: Cpf_consults_cltScalarFieldEnum | Cpf_consults_cltScalarFieldEnum[]
  }

  /**
   * cpf_consults_clt create
   */
  export type cpf_consults_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * The data needed to create a cpf_consults_clt.
     */
    data: XOR<cpf_consults_cltCreateInput, cpf_consults_cltUncheckedCreateInput>
  }

  /**
   * cpf_consults_clt createMany
   */
  export type cpf_consults_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cpf_consults_clts.
     */
    data: cpf_consults_cltCreateManyInput | cpf_consults_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cpf_consults_clt update
   */
  export type cpf_consults_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * The data needed to update a cpf_consults_clt.
     */
    data: XOR<cpf_consults_cltUpdateInput, cpf_consults_cltUncheckedUpdateInput>
    /**
     * Choose, which cpf_consults_clt to update.
     */
    where: cpf_consults_cltWhereUniqueInput
  }

  /**
   * cpf_consults_clt updateMany
   */
  export type cpf_consults_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cpf_consults_clts.
     */
    data: XOR<cpf_consults_cltUpdateManyMutationInput, cpf_consults_cltUncheckedUpdateManyInput>
    /**
     * Filter which cpf_consults_clts to update
     */
    where?: cpf_consults_cltWhereInput
    /**
     * Limit how many cpf_consults_clts to update.
     */
    limit?: number
  }

  /**
   * cpf_consults_clt upsert
   */
  export type cpf_consults_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * The filter to search for the cpf_consults_clt to update in case it exists.
     */
    where: cpf_consults_cltWhereUniqueInput
    /**
     * In case the cpf_consults_clt found by the `where` argument doesn't exist, create a new cpf_consults_clt with this data.
     */
    create: XOR<cpf_consults_cltCreateInput, cpf_consults_cltUncheckedCreateInput>
    /**
     * In case the cpf_consults_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cpf_consults_cltUpdateInput, cpf_consults_cltUncheckedUpdateInput>
  }

  /**
   * cpf_consults_clt delete
   */
  export type cpf_consults_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    /**
     * Filter which cpf_consults_clt to delete.
     */
    where: cpf_consults_cltWhereUniqueInput
  }

  /**
   * cpf_consults_clt deleteMany
   */
  export type cpf_consults_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cpf_consults_clts to delete
     */
    where?: cpf_consults_cltWhereInput
    /**
     * Limit how many cpf_consults_clts to delete.
     */
    limit?: number
  }

  /**
   * cpf_consults_clt without action
   */
  export type cpf_consults_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
  }


  /**
   * Model cpf_consults_goi
   */

  export type AggregateCpf_consults_goi = {
    _count: Cpf_consults_goiCountAggregateOutputType | null
    _min: Cpf_consults_goiMinAggregateOutputType | null
    _max: Cpf_consults_goiMaxAggregateOutputType | null
  }

  export type Cpf_consults_goiMinAggregateOutputType = {
    id: string | null
    cpf: string | null
    user_id: string | null
    is_error: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Cpf_consults_goiMaxAggregateOutputType = {
    id: string | null
    cpf: string | null
    user_id: string | null
    is_error: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Cpf_consults_goiCountAggregateOutputType = {
    id: number
    cpf: number
    user_id: number
    is_error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Cpf_consults_goiMinAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Cpf_consults_goiMaxAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Cpf_consults_goiCountAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Cpf_consults_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cpf_consults_goi to aggregate.
     */
    where?: cpf_consults_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_gois to fetch.
     */
    orderBy?: cpf_consults_goiOrderByWithRelationInput | cpf_consults_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cpf_consults_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cpf_consults_gois
    **/
    _count?: true | Cpf_consults_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cpf_consults_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cpf_consults_goiMaxAggregateInputType
  }

  export type GetCpf_consults_goiAggregateType<T extends Cpf_consults_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateCpf_consults_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCpf_consults_goi[P]>
      : GetScalarType<T[P], AggregateCpf_consults_goi[P]>
  }




  export type cpf_consults_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cpf_consults_goiWhereInput
    orderBy?: cpf_consults_goiOrderByWithAggregationInput | cpf_consults_goiOrderByWithAggregationInput[]
    by: Cpf_consults_goiScalarFieldEnum[] | Cpf_consults_goiScalarFieldEnum
    having?: cpf_consults_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cpf_consults_goiCountAggregateInputType | true
    _min?: Cpf_consults_goiMinAggregateInputType
    _max?: Cpf_consults_goiMaxAggregateInputType
  }

  export type Cpf_consults_goiGroupByOutputType = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date
    updatedAt: Date
    _count: Cpf_consults_goiCountAggregateOutputType | null
    _min: Cpf_consults_goiMinAggregateOutputType | null
    _max: Cpf_consults_goiMaxAggregateOutputType | null
  }

  type GetCpf_consults_goiGroupByPayload<T extends cpf_consults_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cpf_consults_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cpf_consults_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cpf_consults_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Cpf_consults_goiGroupByOutputType[P]>
        }
      >
    >


  export type cpf_consults_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpf?: boolean
    user_id?: boolean
    is_error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cpf_consults_goi"]>



  export type cpf_consults_goiSelectScalar = {
    id?: boolean
    cpf?: boolean
    user_id?: boolean
    is_error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type cpf_consults_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cpf" | "user_id" | "is_error" | "createdAt" | "updatedAt", ExtArgs["result"]["cpf_consults_goi"]>
  export type cpf_consults_goiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }

  export type $cpf_consults_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cpf_consults_goi"
    objects: {
      users_goi: Prisma.$users_goiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cpf: string
      user_id: string
      is_error: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cpf_consults_goi"]>
    composites: {}
  }

  type cpf_consults_goiGetPayload<S extends boolean | null | undefined | cpf_consults_goiDefaultArgs> = $Result.GetResult<Prisma.$cpf_consults_goiPayload, S>

  type cpf_consults_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cpf_consults_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cpf_consults_goiCountAggregateInputType | true
    }

  export interface cpf_consults_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cpf_consults_goi'], meta: { name: 'cpf_consults_goi' } }
    /**
     * Find zero or one Cpf_consults_goi that matches the filter.
     * @param {cpf_consults_goiFindUniqueArgs} args - Arguments to find a Cpf_consults_goi
     * @example
     * // Get one Cpf_consults_goi
     * const cpf_consults_goi = await prisma.cpf_consults_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cpf_consults_goiFindUniqueArgs>(args: SelectSubset<T, cpf_consults_goiFindUniqueArgs<ExtArgs>>): Prisma__cpf_consults_goiClient<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cpf_consults_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cpf_consults_goiFindUniqueOrThrowArgs} args - Arguments to find a Cpf_consults_goi
     * @example
     * // Get one Cpf_consults_goi
     * const cpf_consults_goi = await prisma.cpf_consults_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cpf_consults_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, cpf_consults_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cpf_consults_goiClient<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cpf_consults_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_goiFindFirstArgs} args - Arguments to find a Cpf_consults_goi
     * @example
     * // Get one Cpf_consults_goi
     * const cpf_consults_goi = await prisma.cpf_consults_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cpf_consults_goiFindFirstArgs>(args?: SelectSubset<T, cpf_consults_goiFindFirstArgs<ExtArgs>>): Prisma__cpf_consults_goiClient<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cpf_consults_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_goiFindFirstOrThrowArgs} args - Arguments to find a Cpf_consults_goi
     * @example
     * // Get one Cpf_consults_goi
     * const cpf_consults_goi = await prisma.cpf_consults_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cpf_consults_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, cpf_consults_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__cpf_consults_goiClient<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cpf_consults_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cpf_consults_gois
     * const cpf_consults_gois = await prisma.cpf_consults_goi.findMany()
     * 
     * // Get first 10 Cpf_consults_gois
     * const cpf_consults_gois = await prisma.cpf_consults_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cpf_consults_goiWithIdOnly = await prisma.cpf_consults_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cpf_consults_goiFindManyArgs>(args?: SelectSubset<T, cpf_consults_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cpf_consults_goi.
     * @param {cpf_consults_goiCreateArgs} args - Arguments to create a Cpf_consults_goi.
     * @example
     * // Create one Cpf_consults_goi
     * const Cpf_consults_goi = await prisma.cpf_consults_goi.create({
     *   data: {
     *     // ... data to create a Cpf_consults_goi
     *   }
     * })
     * 
     */
    create<T extends cpf_consults_goiCreateArgs>(args: SelectSubset<T, cpf_consults_goiCreateArgs<ExtArgs>>): Prisma__cpf_consults_goiClient<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cpf_consults_gois.
     * @param {cpf_consults_goiCreateManyArgs} args - Arguments to create many Cpf_consults_gois.
     * @example
     * // Create many Cpf_consults_gois
     * const cpf_consults_goi = await prisma.cpf_consults_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cpf_consults_goiCreateManyArgs>(args?: SelectSubset<T, cpf_consults_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cpf_consults_goi.
     * @param {cpf_consults_goiDeleteArgs} args - Arguments to delete one Cpf_consults_goi.
     * @example
     * // Delete one Cpf_consults_goi
     * const Cpf_consults_goi = await prisma.cpf_consults_goi.delete({
     *   where: {
     *     // ... filter to delete one Cpf_consults_goi
     *   }
     * })
     * 
     */
    delete<T extends cpf_consults_goiDeleteArgs>(args: SelectSubset<T, cpf_consults_goiDeleteArgs<ExtArgs>>): Prisma__cpf_consults_goiClient<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cpf_consults_goi.
     * @param {cpf_consults_goiUpdateArgs} args - Arguments to update one Cpf_consults_goi.
     * @example
     * // Update one Cpf_consults_goi
     * const cpf_consults_goi = await prisma.cpf_consults_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cpf_consults_goiUpdateArgs>(args: SelectSubset<T, cpf_consults_goiUpdateArgs<ExtArgs>>): Prisma__cpf_consults_goiClient<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cpf_consults_gois.
     * @param {cpf_consults_goiDeleteManyArgs} args - Arguments to filter Cpf_consults_gois to delete.
     * @example
     * // Delete a few Cpf_consults_gois
     * const { count } = await prisma.cpf_consults_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cpf_consults_goiDeleteManyArgs>(args?: SelectSubset<T, cpf_consults_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cpf_consults_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cpf_consults_gois
     * const cpf_consults_goi = await prisma.cpf_consults_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cpf_consults_goiUpdateManyArgs>(args: SelectSubset<T, cpf_consults_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cpf_consults_goi.
     * @param {cpf_consults_goiUpsertArgs} args - Arguments to update or create a Cpf_consults_goi.
     * @example
     * // Update or create a Cpf_consults_goi
     * const cpf_consults_goi = await prisma.cpf_consults_goi.upsert({
     *   create: {
     *     // ... data to create a Cpf_consults_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cpf_consults_goi we want to update
     *   }
     * })
     */
    upsert<T extends cpf_consults_goiUpsertArgs>(args: SelectSubset<T, cpf_consults_goiUpsertArgs<ExtArgs>>): Prisma__cpf_consults_goiClient<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cpf_consults_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_goiCountArgs} args - Arguments to filter Cpf_consults_gois to count.
     * @example
     * // Count the number of Cpf_consults_gois
     * const count = await prisma.cpf_consults_goi.count({
     *   where: {
     *     // ... the filter for the Cpf_consults_gois we want to count
     *   }
     * })
    **/
    count<T extends cpf_consults_goiCountArgs>(
      args?: Subset<T, cpf_consults_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cpf_consults_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cpf_consults_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cpf_consults_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cpf_consults_goiAggregateArgs>(args: Subset<T, Cpf_consults_goiAggregateArgs>): Prisma.PrismaPromise<GetCpf_consults_goiAggregateType<T>>

    /**
     * Group by Cpf_consults_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cpf_consults_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cpf_consults_goiGroupByArgs['orderBy'] }
        : { orderBy?: cpf_consults_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cpf_consults_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCpf_consults_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cpf_consults_goi model
   */
  readonly fields: cpf_consults_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cpf_consults_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cpf_consults_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_goi<T extends users_goiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_goiDefaultArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cpf_consults_goi model
   */
  interface cpf_consults_goiFieldRefs {
    readonly id: FieldRef<"cpf_consults_goi", 'String'>
    readonly cpf: FieldRef<"cpf_consults_goi", 'String'>
    readonly user_id: FieldRef<"cpf_consults_goi", 'String'>
    readonly is_error: FieldRef<"cpf_consults_goi", 'Boolean'>
    readonly createdAt: FieldRef<"cpf_consults_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"cpf_consults_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cpf_consults_goi findUnique
   */
  export type cpf_consults_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_goi to fetch.
     */
    where: cpf_consults_goiWhereUniqueInput
  }

  /**
   * cpf_consults_goi findUniqueOrThrow
   */
  export type cpf_consults_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_goi to fetch.
     */
    where: cpf_consults_goiWhereUniqueInput
  }

  /**
   * cpf_consults_goi findFirst
   */
  export type cpf_consults_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_goi to fetch.
     */
    where?: cpf_consults_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_gois to fetch.
     */
    orderBy?: cpf_consults_goiOrderByWithRelationInput | cpf_consults_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cpf_consults_gois.
     */
    cursor?: cpf_consults_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cpf_consults_gois.
     */
    distinct?: Cpf_consults_goiScalarFieldEnum | Cpf_consults_goiScalarFieldEnum[]
  }

  /**
   * cpf_consults_goi findFirstOrThrow
   */
  export type cpf_consults_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_goi to fetch.
     */
    where?: cpf_consults_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_gois to fetch.
     */
    orderBy?: cpf_consults_goiOrderByWithRelationInput | cpf_consults_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cpf_consults_gois.
     */
    cursor?: cpf_consults_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cpf_consults_gois.
     */
    distinct?: Cpf_consults_goiScalarFieldEnum | Cpf_consults_goiScalarFieldEnum[]
  }

  /**
   * cpf_consults_goi findMany
   */
  export type cpf_consults_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_gois to fetch.
     */
    where?: cpf_consults_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_gois to fetch.
     */
    orderBy?: cpf_consults_goiOrderByWithRelationInput | cpf_consults_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cpf_consults_gois.
     */
    cursor?: cpf_consults_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_gois.
     */
    skip?: number
    distinct?: Cpf_consults_goiScalarFieldEnum | Cpf_consults_goiScalarFieldEnum[]
  }

  /**
   * cpf_consults_goi create
   */
  export type cpf_consults_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * The data needed to create a cpf_consults_goi.
     */
    data: XOR<cpf_consults_goiCreateInput, cpf_consults_goiUncheckedCreateInput>
  }

  /**
   * cpf_consults_goi createMany
   */
  export type cpf_consults_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cpf_consults_gois.
     */
    data: cpf_consults_goiCreateManyInput | cpf_consults_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cpf_consults_goi update
   */
  export type cpf_consults_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * The data needed to update a cpf_consults_goi.
     */
    data: XOR<cpf_consults_goiUpdateInput, cpf_consults_goiUncheckedUpdateInput>
    /**
     * Choose, which cpf_consults_goi to update.
     */
    where: cpf_consults_goiWhereUniqueInput
  }

  /**
   * cpf_consults_goi updateMany
   */
  export type cpf_consults_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cpf_consults_gois.
     */
    data: XOR<cpf_consults_goiUpdateManyMutationInput, cpf_consults_goiUncheckedUpdateManyInput>
    /**
     * Filter which cpf_consults_gois to update
     */
    where?: cpf_consults_goiWhereInput
    /**
     * Limit how many cpf_consults_gois to update.
     */
    limit?: number
  }

  /**
   * cpf_consults_goi upsert
   */
  export type cpf_consults_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * The filter to search for the cpf_consults_goi to update in case it exists.
     */
    where: cpf_consults_goiWhereUniqueInput
    /**
     * In case the cpf_consults_goi found by the `where` argument doesn't exist, create a new cpf_consults_goi with this data.
     */
    create: XOR<cpf_consults_goiCreateInput, cpf_consults_goiUncheckedCreateInput>
    /**
     * In case the cpf_consults_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cpf_consults_goiUpdateInput, cpf_consults_goiUncheckedUpdateInput>
  }

  /**
   * cpf_consults_goi delete
   */
  export type cpf_consults_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    /**
     * Filter which cpf_consults_goi to delete.
     */
    where: cpf_consults_goiWhereUniqueInput
  }

  /**
   * cpf_consults_goi deleteMany
   */
  export type cpf_consults_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cpf_consults_gois to delete
     */
    where?: cpf_consults_goiWhereInput
    /**
     * Limit how many cpf_consults_gois to delete.
     */
    limit?: number
  }

  /**
   * cpf_consults_goi without action
   */
  export type cpf_consults_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
  }


  /**
   * Model cpf_consults_spa
   */

  export type AggregateCpf_consults_spa = {
    _count: Cpf_consults_spaCountAggregateOutputType | null
    _min: Cpf_consults_spaMinAggregateOutputType | null
    _max: Cpf_consults_spaMaxAggregateOutputType | null
  }

  export type Cpf_consults_spaMinAggregateOutputType = {
    id: string | null
    cpf: string | null
    user_id: string | null
    is_error: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Cpf_consults_spaMaxAggregateOutputType = {
    id: string | null
    cpf: string | null
    user_id: string | null
    is_error: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Cpf_consults_spaCountAggregateOutputType = {
    id: number
    cpf: number
    user_id: number
    is_error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Cpf_consults_spaMinAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Cpf_consults_spaMaxAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Cpf_consults_spaCountAggregateInputType = {
    id?: true
    cpf?: true
    user_id?: true
    is_error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Cpf_consults_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cpf_consults_spa to aggregate.
     */
    where?: cpf_consults_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_spas to fetch.
     */
    orderBy?: cpf_consults_spaOrderByWithRelationInput | cpf_consults_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cpf_consults_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cpf_consults_spas
    **/
    _count?: true | Cpf_consults_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cpf_consults_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cpf_consults_spaMaxAggregateInputType
  }

  export type GetCpf_consults_spaAggregateType<T extends Cpf_consults_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateCpf_consults_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCpf_consults_spa[P]>
      : GetScalarType<T[P], AggregateCpf_consults_spa[P]>
  }




  export type cpf_consults_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cpf_consults_spaWhereInput
    orderBy?: cpf_consults_spaOrderByWithAggregationInput | cpf_consults_spaOrderByWithAggregationInput[]
    by: Cpf_consults_spaScalarFieldEnum[] | Cpf_consults_spaScalarFieldEnum
    having?: cpf_consults_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cpf_consults_spaCountAggregateInputType | true
    _min?: Cpf_consults_spaMinAggregateInputType
    _max?: Cpf_consults_spaMaxAggregateInputType
  }

  export type Cpf_consults_spaGroupByOutputType = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date
    updatedAt: Date
    _count: Cpf_consults_spaCountAggregateOutputType | null
    _min: Cpf_consults_spaMinAggregateOutputType | null
    _max: Cpf_consults_spaMaxAggregateOutputType | null
  }

  type GetCpf_consults_spaGroupByPayload<T extends cpf_consults_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cpf_consults_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cpf_consults_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cpf_consults_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Cpf_consults_spaGroupByOutputType[P]>
        }
      >
    >


  export type cpf_consults_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpf?: boolean
    user_id?: boolean
    is_error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cpf_consults_spa"]>



  export type cpf_consults_spaSelectScalar = {
    id?: boolean
    cpf?: boolean
    user_id?: boolean
    is_error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type cpf_consults_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cpf" | "user_id" | "is_error" | "createdAt" | "updatedAt", ExtArgs["result"]["cpf_consults_spa"]>
  export type cpf_consults_spaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }

  export type $cpf_consults_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cpf_consults_spa"
    objects: {
      users_spa: Prisma.$users_spaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cpf: string
      user_id: string
      is_error: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cpf_consults_spa"]>
    composites: {}
  }

  type cpf_consults_spaGetPayload<S extends boolean | null | undefined | cpf_consults_spaDefaultArgs> = $Result.GetResult<Prisma.$cpf_consults_spaPayload, S>

  type cpf_consults_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cpf_consults_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cpf_consults_spaCountAggregateInputType | true
    }

  export interface cpf_consults_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cpf_consults_spa'], meta: { name: 'cpf_consults_spa' } }
    /**
     * Find zero or one Cpf_consults_spa that matches the filter.
     * @param {cpf_consults_spaFindUniqueArgs} args - Arguments to find a Cpf_consults_spa
     * @example
     * // Get one Cpf_consults_spa
     * const cpf_consults_spa = await prisma.cpf_consults_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cpf_consults_spaFindUniqueArgs>(args: SelectSubset<T, cpf_consults_spaFindUniqueArgs<ExtArgs>>): Prisma__cpf_consults_spaClient<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cpf_consults_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cpf_consults_spaFindUniqueOrThrowArgs} args - Arguments to find a Cpf_consults_spa
     * @example
     * // Get one Cpf_consults_spa
     * const cpf_consults_spa = await prisma.cpf_consults_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cpf_consults_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, cpf_consults_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cpf_consults_spaClient<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cpf_consults_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_spaFindFirstArgs} args - Arguments to find a Cpf_consults_spa
     * @example
     * // Get one Cpf_consults_spa
     * const cpf_consults_spa = await prisma.cpf_consults_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cpf_consults_spaFindFirstArgs>(args?: SelectSubset<T, cpf_consults_spaFindFirstArgs<ExtArgs>>): Prisma__cpf_consults_spaClient<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cpf_consults_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_spaFindFirstOrThrowArgs} args - Arguments to find a Cpf_consults_spa
     * @example
     * // Get one Cpf_consults_spa
     * const cpf_consults_spa = await prisma.cpf_consults_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cpf_consults_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, cpf_consults_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__cpf_consults_spaClient<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cpf_consults_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cpf_consults_spas
     * const cpf_consults_spas = await prisma.cpf_consults_spa.findMany()
     * 
     * // Get first 10 Cpf_consults_spas
     * const cpf_consults_spas = await prisma.cpf_consults_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cpf_consults_spaWithIdOnly = await prisma.cpf_consults_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cpf_consults_spaFindManyArgs>(args?: SelectSubset<T, cpf_consults_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cpf_consults_spa.
     * @param {cpf_consults_spaCreateArgs} args - Arguments to create a Cpf_consults_spa.
     * @example
     * // Create one Cpf_consults_spa
     * const Cpf_consults_spa = await prisma.cpf_consults_spa.create({
     *   data: {
     *     // ... data to create a Cpf_consults_spa
     *   }
     * })
     * 
     */
    create<T extends cpf_consults_spaCreateArgs>(args: SelectSubset<T, cpf_consults_spaCreateArgs<ExtArgs>>): Prisma__cpf_consults_spaClient<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cpf_consults_spas.
     * @param {cpf_consults_spaCreateManyArgs} args - Arguments to create many Cpf_consults_spas.
     * @example
     * // Create many Cpf_consults_spas
     * const cpf_consults_spa = await prisma.cpf_consults_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cpf_consults_spaCreateManyArgs>(args?: SelectSubset<T, cpf_consults_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cpf_consults_spa.
     * @param {cpf_consults_spaDeleteArgs} args - Arguments to delete one Cpf_consults_spa.
     * @example
     * // Delete one Cpf_consults_spa
     * const Cpf_consults_spa = await prisma.cpf_consults_spa.delete({
     *   where: {
     *     // ... filter to delete one Cpf_consults_spa
     *   }
     * })
     * 
     */
    delete<T extends cpf_consults_spaDeleteArgs>(args: SelectSubset<T, cpf_consults_spaDeleteArgs<ExtArgs>>): Prisma__cpf_consults_spaClient<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cpf_consults_spa.
     * @param {cpf_consults_spaUpdateArgs} args - Arguments to update one Cpf_consults_spa.
     * @example
     * // Update one Cpf_consults_spa
     * const cpf_consults_spa = await prisma.cpf_consults_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cpf_consults_spaUpdateArgs>(args: SelectSubset<T, cpf_consults_spaUpdateArgs<ExtArgs>>): Prisma__cpf_consults_spaClient<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cpf_consults_spas.
     * @param {cpf_consults_spaDeleteManyArgs} args - Arguments to filter Cpf_consults_spas to delete.
     * @example
     * // Delete a few Cpf_consults_spas
     * const { count } = await prisma.cpf_consults_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cpf_consults_spaDeleteManyArgs>(args?: SelectSubset<T, cpf_consults_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cpf_consults_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cpf_consults_spas
     * const cpf_consults_spa = await prisma.cpf_consults_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cpf_consults_spaUpdateManyArgs>(args: SelectSubset<T, cpf_consults_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cpf_consults_spa.
     * @param {cpf_consults_spaUpsertArgs} args - Arguments to update or create a Cpf_consults_spa.
     * @example
     * // Update or create a Cpf_consults_spa
     * const cpf_consults_spa = await prisma.cpf_consults_spa.upsert({
     *   create: {
     *     // ... data to create a Cpf_consults_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cpf_consults_spa we want to update
     *   }
     * })
     */
    upsert<T extends cpf_consults_spaUpsertArgs>(args: SelectSubset<T, cpf_consults_spaUpsertArgs<ExtArgs>>): Prisma__cpf_consults_spaClient<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cpf_consults_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_spaCountArgs} args - Arguments to filter Cpf_consults_spas to count.
     * @example
     * // Count the number of Cpf_consults_spas
     * const count = await prisma.cpf_consults_spa.count({
     *   where: {
     *     // ... the filter for the Cpf_consults_spas we want to count
     *   }
     * })
    **/
    count<T extends cpf_consults_spaCountArgs>(
      args?: Subset<T, cpf_consults_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cpf_consults_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cpf_consults_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cpf_consults_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cpf_consults_spaAggregateArgs>(args: Subset<T, Cpf_consults_spaAggregateArgs>): Prisma.PrismaPromise<GetCpf_consults_spaAggregateType<T>>

    /**
     * Group by Cpf_consults_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cpf_consults_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cpf_consults_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cpf_consults_spaGroupByArgs['orderBy'] }
        : { orderBy?: cpf_consults_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cpf_consults_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCpf_consults_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cpf_consults_spa model
   */
  readonly fields: cpf_consults_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cpf_consults_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cpf_consults_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_spa<T extends users_spaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_spaDefaultArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cpf_consults_spa model
   */
  interface cpf_consults_spaFieldRefs {
    readonly id: FieldRef<"cpf_consults_spa", 'String'>
    readonly cpf: FieldRef<"cpf_consults_spa", 'String'>
    readonly user_id: FieldRef<"cpf_consults_spa", 'String'>
    readonly is_error: FieldRef<"cpf_consults_spa", 'Boolean'>
    readonly createdAt: FieldRef<"cpf_consults_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"cpf_consults_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cpf_consults_spa findUnique
   */
  export type cpf_consults_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_spa to fetch.
     */
    where: cpf_consults_spaWhereUniqueInput
  }

  /**
   * cpf_consults_spa findUniqueOrThrow
   */
  export type cpf_consults_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_spa to fetch.
     */
    where: cpf_consults_spaWhereUniqueInput
  }

  /**
   * cpf_consults_spa findFirst
   */
  export type cpf_consults_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_spa to fetch.
     */
    where?: cpf_consults_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_spas to fetch.
     */
    orderBy?: cpf_consults_spaOrderByWithRelationInput | cpf_consults_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cpf_consults_spas.
     */
    cursor?: cpf_consults_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cpf_consults_spas.
     */
    distinct?: Cpf_consults_spaScalarFieldEnum | Cpf_consults_spaScalarFieldEnum[]
  }

  /**
   * cpf_consults_spa findFirstOrThrow
   */
  export type cpf_consults_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_spa to fetch.
     */
    where?: cpf_consults_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_spas to fetch.
     */
    orderBy?: cpf_consults_spaOrderByWithRelationInput | cpf_consults_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cpf_consults_spas.
     */
    cursor?: cpf_consults_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cpf_consults_spas.
     */
    distinct?: Cpf_consults_spaScalarFieldEnum | Cpf_consults_spaScalarFieldEnum[]
  }

  /**
   * cpf_consults_spa findMany
   */
  export type cpf_consults_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * Filter, which cpf_consults_spas to fetch.
     */
    where?: cpf_consults_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cpf_consults_spas to fetch.
     */
    orderBy?: cpf_consults_spaOrderByWithRelationInput | cpf_consults_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cpf_consults_spas.
     */
    cursor?: cpf_consults_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cpf_consults_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cpf_consults_spas.
     */
    skip?: number
    distinct?: Cpf_consults_spaScalarFieldEnum | Cpf_consults_spaScalarFieldEnum[]
  }

  /**
   * cpf_consults_spa create
   */
  export type cpf_consults_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * The data needed to create a cpf_consults_spa.
     */
    data: XOR<cpf_consults_spaCreateInput, cpf_consults_spaUncheckedCreateInput>
  }

  /**
   * cpf_consults_spa createMany
   */
  export type cpf_consults_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cpf_consults_spas.
     */
    data: cpf_consults_spaCreateManyInput | cpf_consults_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cpf_consults_spa update
   */
  export type cpf_consults_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * The data needed to update a cpf_consults_spa.
     */
    data: XOR<cpf_consults_spaUpdateInput, cpf_consults_spaUncheckedUpdateInput>
    /**
     * Choose, which cpf_consults_spa to update.
     */
    where: cpf_consults_spaWhereUniqueInput
  }

  /**
   * cpf_consults_spa updateMany
   */
  export type cpf_consults_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cpf_consults_spas.
     */
    data: XOR<cpf_consults_spaUpdateManyMutationInput, cpf_consults_spaUncheckedUpdateManyInput>
    /**
     * Filter which cpf_consults_spas to update
     */
    where?: cpf_consults_spaWhereInput
    /**
     * Limit how many cpf_consults_spas to update.
     */
    limit?: number
  }

  /**
   * cpf_consults_spa upsert
   */
  export type cpf_consults_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * The filter to search for the cpf_consults_spa to update in case it exists.
     */
    where: cpf_consults_spaWhereUniqueInput
    /**
     * In case the cpf_consults_spa found by the `where` argument doesn't exist, create a new cpf_consults_spa with this data.
     */
    create: XOR<cpf_consults_spaCreateInput, cpf_consults_spaUncheckedCreateInput>
    /**
     * In case the cpf_consults_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cpf_consults_spaUpdateInput, cpf_consults_spaUncheckedUpdateInput>
  }

  /**
   * cpf_consults_spa delete
   */
  export type cpf_consults_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    /**
     * Filter which cpf_consults_spa to delete.
     */
    where: cpf_consults_spaWhereUniqueInput
  }

  /**
   * cpf_consults_spa deleteMany
   */
  export type cpf_consults_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cpf_consults_spas to delete
     */
    where?: cpf_consults_spaWhereInput
    /**
     * Limit how many cpf_consults_spas to delete.
     */
    limit?: number
  }

  /**
   * cpf_consults_spa without action
   */
  export type cpf_consults_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
  }


  /**
   * Model files
   */

  export type AggregateFiles = {
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  export type FilesAvgAggregateOutputType = {
    id: number | null
  }

  export type FilesSumAggregateOutputType = {
    id: bigint | null
  }

  export type FilesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    data: Uint8Array | null
    mimetype: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FilesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    data: Uint8Array | null
    mimetype: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FilesCountAggregateOutputType = {
    id: number
    name: number
    data: number
    mimetype: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FilesAvgAggregateInputType = {
    id?: true
  }

  export type FilesSumAggregateInputType = {
    id?: true
  }

  export type FilesMinAggregateInputType = {
    id?: true
    name?: true
    data?: true
    mimetype?: true
    created_at?: true
    updated_at?: true
  }

  export type FilesMaxAggregateInputType = {
    id?: true
    name?: true
    data?: true
    mimetype?: true
    created_at?: true
    updated_at?: true
  }

  export type FilesCountAggregateInputType = {
    id?: true
    name?: true
    data?: true
    mimetype?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which files to aggregate.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned files
    **/
    _count?: true | FilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesMaxAggregateInputType
  }

  export type GetFilesAggregateType<T extends FilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles[P]>
      : GetScalarType<T[P], AggregateFiles[P]>
  }




  export type filesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: filesWhereInput
    orderBy?: filesOrderByWithAggregationInput | filesOrderByWithAggregationInput[]
    by: FilesScalarFieldEnum[] | FilesScalarFieldEnum
    having?: filesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesCountAggregateInputType | true
    _avg?: FilesAvgAggregateInputType
    _sum?: FilesSumAggregateInputType
    _min?: FilesMinAggregateInputType
    _max?: FilesMaxAggregateInputType
  }

  export type FilesGroupByOutputType = {
    id: bigint
    name: string
    data: Uint8Array
    mimetype: string
    created_at: Date | null
    updated_at: Date | null
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  type GetFilesGroupByPayload<T extends filesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilesGroupByOutputType[P]>
        }
      >
    >


  export type filesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    data?: boolean
    mimetype?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["files"]>



  export type filesSelectScalar = {
    id?: boolean
    name?: boolean
    data?: boolean
    mimetype?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type filesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "data" | "mimetype" | "created_at" | "updated_at", ExtArgs["result"]["files"]>

  export type $filesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "files"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      data: Uint8Array
      mimetype: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["files"]>
    composites: {}
  }

  type filesGetPayload<S extends boolean | null | undefined | filesDefaultArgs> = $Result.GetResult<Prisma.$filesPayload, S>

  type filesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<filesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilesCountAggregateInputType | true
    }

  export interface filesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['files'], meta: { name: 'files' } }
    /**
     * Find zero or one Files that matches the filter.
     * @param {filesFindUniqueArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends filesFindUniqueArgs>(args: SelectSubset<T, filesFindUniqueArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Files that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {filesFindUniqueOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends filesFindUniqueOrThrowArgs>(args: SelectSubset<T, filesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends filesFindFirstArgs>(args?: SelectSubset<T, filesFindFirstArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Files that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends filesFindFirstOrThrowArgs>(args?: SelectSubset<T, filesFindFirstOrThrowArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.files.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.files.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filesWithIdOnly = await prisma.files.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends filesFindManyArgs>(args?: SelectSubset<T, filesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Files.
     * @param {filesCreateArgs} args - Arguments to create a Files.
     * @example
     * // Create one Files
     * const Files = await prisma.files.create({
     *   data: {
     *     // ... data to create a Files
     *   }
     * })
     * 
     */
    create<T extends filesCreateArgs>(args: SelectSubset<T, filesCreateArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {filesCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const files = await prisma.files.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends filesCreateManyArgs>(args?: SelectSubset<T, filesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Files.
     * @param {filesDeleteArgs} args - Arguments to delete one Files.
     * @example
     * // Delete one Files
     * const Files = await prisma.files.delete({
     *   where: {
     *     // ... filter to delete one Files
     *   }
     * })
     * 
     */
    delete<T extends filesDeleteArgs>(args: SelectSubset<T, filesDeleteArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Files.
     * @param {filesUpdateArgs} args - Arguments to update one Files.
     * @example
     * // Update one Files
     * const files = await prisma.files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends filesUpdateArgs>(args: SelectSubset<T, filesUpdateArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {filesDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends filesDeleteManyArgs>(args?: SelectSubset<T, filesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends filesUpdateManyArgs>(args: SelectSubset<T, filesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Files.
     * @param {filesUpsertArgs} args - Arguments to update or create a Files.
     * @example
     * // Update or create a Files
     * const files = await prisma.files.upsert({
     *   create: {
     *     // ... data to create a Files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files we want to update
     *   }
     * })
     */
    upsert<T extends filesUpsertArgs>(args: SelectSubset<T, filesUpsertArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.files.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends filesCountArgs>(
      args?: Subset<T, filesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesAggregateArgs>(args: Subset<T, FilesAggregateArgs>): Prisma.PrismaPromise<GetFilesAggregateType<T>>

    /**
     * Group by Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends filesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: filesGroupByArgs['orderBy'] }
        : { orderBy?: filesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, filesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the files model
   */
  readonly fields: filesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__filesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the files model
   */
  interface filesFieldRefs {
    readonly id: FieldRef<"files", 'BigInt'>
    readonly name: FieldRef<"files", 'String'>
    readonly data: FieldRef<"files", 'Bytes'>
    readonly mimetype: FieldRef<"files", 'String'>
    readonly created_at: FieldRef<"files", 'DateTime'>
    readonly updated_at: FieldRef<"files", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * files findUnique
   */
  export type filesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files findUniqueOrThrow
   */
  export type filesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files findFirst
   */
  export type filesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files findFirstOrThrow
   */
  export type filesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files findMany
   */
  export type filesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files create
   */
  export type filesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * The data needed to create a files.
     */
    data: XOR<filesCreateInput, filesUncheckedCreateInput>
  }

  /**
   * files createMany
   */
  export type filesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many files.
     */
    data: filesCreateManyInput | filesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * files update
   */
  export type filesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * The data needed to update a files.
     */
    data: XOR<filesUpdateInput, filesUncheckedUpdateInput>
    /**
     * Choose, which files to update.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files updateMany
   */
  export type filesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update files.
     */
    data: XOR<filesUpdateManyMutationInput, filesUncheckedUpdateManyInput>
    /**
     * Filter which files to update
     */
    where?: filesWhereInput
    /**
     * Limit how many files to update.
     */
    limit?: number
  }

  /**
   * files upsert
   */
  export type filesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * The filter to search for the files to update in case it exists.
     */
    where: filesWhereUniqueInput
    /**
     * In case the files found by the `where` argument doesn't exist, create a new files with this data.
     */
    create: XOR<filesCreateInput, filesUncheckedCreateInput>
    /**
     * In case the files was found with the provided `where` argument, update it with this data.
     */
    update: XOR<filesUpdateInput, filesUncheckedUpdateInput>
  }

  /**
   * files delete
   */
  export type filesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter which files to delete.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files deleteMany
   */
  export type filesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which files to delete
     */
    where?: filesWhereInput
    /**
     * Limit how many files to delete.
     */
    limit?: number
  }

  /**
   * files without action
   */
  export type filesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
  }


  /**
   * Model maintenance_commands
   */

  export type AggregateMaintenance_commands = {
    _count: Maintenance_commandsCountAggregateOutputType | null
    _avg: Maintenance_commandsAvgAggregateOutputType | null
    _sum: Maintenance_commandsSumAggregateOutputType | null
    _min: Maintenance_commandsMinAggregateOutputType | null
    _max: Maintenance_commandsMaxAggregateOutputType | null
  }

  export type Maintenance_commandsAvgAggregateOutputType = {
    option: number | null
  }

  export type Maintenance_commandsSumAggregateOutputType = {
    option: number | null
  }

  export type Maintenance_commandsMinAggregateOutputType = {
    id: string | null
    bot_type: string | null
    option: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Maintenance_commandsMaxAggregateOutputType = {
    id: string | null
    bot_type: string | null
    option: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Maintenance_commandsCountAggregateOutputType = {
    id: number
    bot_type: number
    option: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Maintenance_commandsAvgAggregateInputType = {
    option?: true
  }

  export type Maintenance_commandsSumAggregateInputType = {
    option?: true
  }

  export type Maintenance_commandsMinAggregateInputType = {
    id?: true
    bot_type?: true
    option?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Maintenance_commandsMaxAggregateInputType = {
    id?: true
    bot_type?: true
    option?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Maintenance_commandsCountAggregateInputType = {
    id?: true
    bot_type?: true
    option?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Maintenance_commandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maintenance_commands to aggregate.
     */
    where?: maintenance_commandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_commands to fetch.
     */
    orderBy?: maintenance_commandsOrderByWithRelationInput | maintenance_commandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: maintenance_commandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned maintenance_commands
    **/
    _count?: true | Maintenance_commandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Maintenance_commandsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Maintenance_commandsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Maintenance_commandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Maintenance_commandsMaxAggregateInputType
  }

  export type GetMaintenance_commandsAggregateType<T extends Maintenance_commandsAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance_commands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance_commands[P]>
      : GetScalarType<T[P], AggregateMaintenance_commands[P]>
  }




  export type maintenance_commandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: maintenance_commandsWhereInput
    orderBy?: maintenance_commandsOrderByWithAggregationInput | maintenance_commandsOrderByWithAggregationInput[]
    by: Maintenance_commandsScalarFieldEnum[] | Maintenance_commandsScalarFieldEnum
    having?: maintenance_commandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Maintenance_commandsCountAggregateInputType | true
    _avg?: Maintenance_commandsAvgAggregateInputType
    _sum?: Maintenance_commandsSumAggregateInputType
    _min?: Maintenance_commandsMinAggregateInputType
    _max?: Maintenance_commandsMaxAggregateInputType
  }

  export type Maintenance_commandsGroupByOutputType = {
    id: string
    bot_type: string
    option: number
    createdAt: Date
    updatedAt: Date
    _count: Maintenance_commandsCountAggregateOutputType | null
    _avg: Maintenance_commandsAvgAggregateOutputType | null
    _sum: Maintenance_commandsSumAggregateOutputType | null
    _min: Maintenance_commandsMinAggregateOutputType | null
    _max: Maintenance_commandsMaxAggregateOutputType | null
  }

  type GetMaintenance_commandsGroupByPayload<T extends maintenance_commandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Maintenance_commandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Maintenance_commandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Maintenance_commandsGroupByOutputType[P]>
            : GetScalarType<T[P], Maintenance_commandsGroupByOutputType[P]>
        }
      >
    >


  export type maintenance_commandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bot_type?: boolean
    option?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["maintenance_commands"]>



  export type maintenance_commandsSelectScalar = {
    id?: boolean
    bot_type?: boolean
    option?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type maintenance_commandsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bot_type" | "option" | "createdAt" | "updatedAt", ExtArgs["result"]["maintenance_commands"]>

  export type $maintenance_commandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "maintenance_commands"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bot_type: string
      option: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenance_commands"]>
    composites: {}
  }

  type maintenance_commandsGetPayload<S extends boolean | null | undefined | maintenance_commandsDefaultArgs> = $Result.GetResult<Prisma.$maintenance_commandsPayload, S>

  type maintenance_commandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<maintenance_commandsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Maintenance_commandsCountAggregateInputType | true
    }

  export interface maintenance_commandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['maintenance_commands'], meta: { name: 'maintenance_commands' } }
    /**
     * Find zero or one Maintenance_commands that matches the filter.
     * @param {maintenance_commandsFindUniqueArgs} args - Arguments to find a Maintenance_commands
     * @example
     * // Get one Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends maintenance_commandsFindUniqueArgs>(args: SelectSubset<T, maintenance_commandsFindUniqueArgs<ExtArgs>>): Prisma__maintenance_commandsClient<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintenance_commands that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {maintenance_commandsFindUniqueOrThrowArgs} args - Arguments to find a Maintenance_commands
     * @example
     * // Get one Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends maintenance_commandsFindUniqueOrThrowArgs>(args: SelectSubset<T, maintenance_commandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__maintenance_commandsClient<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance_commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_commandsFindFirstArgs} args - Arguments to find a Maintenance_commands
     * @example
     * // Get one Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends maintenance_commandsFindFirstArgs>(args?: SelectSubset<T, maintenance_commandsFindFirstArgs<ExtArgs>>): Prisma__maintenance_commandsClient<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance_commands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_commandsFindFirstOrThrowArgs} args - Arguments to find a Maintenance_commands
     * @example
     * // Get one Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends maintenance_commandsFindFirstOrThrowArgs>(args?: SelectSubset<T, maintenance_commandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__maintenance_commandsClient<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintenance_commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_commandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.findMany()
     * 
     * // Get first 10 Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenance_commandsWithIdOnly = await prisma.maintenance_commands.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends maintenance_commandsFindManyArgs>(args?: SelectSubset<T, maintenance_commandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintenance_commands.
     * @param {maintenance_commandsCreateArgs} args - Arguments to create a Maintenance_commands.
     * @example
     * // Create one Maintenance_commands
     * const Maintenance_commands = await prisma.maintenance_commands.create({
     *   data: {
     *     // ... data to create a Maintenance_commands
     *   }
     * })
     * 
     */
    create<T extends maintenance_commandsCreateArgs>(args: SelectSubset<T, maintenance_commandsCreateArgs<ExtArgs>>): Prisma__maintenance_commandsClient<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintenance_commands.
     * @param {maintenance_commandsCreateManyArgs} args - Arguments to create many Maintenance_commands.
     * @example
     * // Create many Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends maintenance_commandsCreateManyArgs>(args?: SelectSubset<T, maintenance_commandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Maintenance_commands.
     * @param {maintenance_commandsDeleteArgs} args - Arguments to delete one Maintenance_commands.
     * @example
     * // Delete one Maintenance_commands
     * const Maintenance_commands = await prisma.maintenance_commands.delete({
     *   where: {
     *     // ... filter to delete one Maintenance_commands
     *   }
     * })
     * 
     */
    delete<T extends maintenance_commandsDeleteArgs>(args: SelectSubset<T, maintenance_commandsDeleteArgs<ExtArgs>>): Prisma__maintenance_commandsClient<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintenance_commands.
     * @param {maintenance_commandsUpdateArgs} args - Arguments to update one Maintenance_commands.
     * @example
     * // Update one Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends maintenance_commandsUpdateArgs>(args: SelectSubset<T, maintenance_commandsUpdateArgs<ExtArgs>>): Prisma__maintenance_commandsClient<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintenance_commands.
     * @param {maintenance_commandsDeleteManyArgs} args - Arguments to filter Maintenance_commands to delete.
     * @example
     * // Delete a few Maintenance_commands
     * const { count } = await prisma.maintenance_commands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends maintenance_commandsDeleteManyArgs>(args?: SelectSubset<T, maintenance_commandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenance_commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_commandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends maintenance_commandsUpdateManyArgs>(args: SelectSubset<T, maintenance_commandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Maintenance_commands.
     * @param {maintenance_commandsUpsertArgs} args - Arguments to update or create a Maintenance_commands.
     * @example
     * // Update or create a Maintenance_commands
     * const maintenance_commands = await prisma.maintenance_commands.upsert({
     *   create: {
     *     // ... data to create a Maintenance_commands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance_commands we want to update
     *   }
     * })
     */
    upsert<T extends maintenance_commandsUpsertArgs>(args: SelectSubset<T, maintenance_commandsUpsertArgs<ExtArgs>>): Prisma__maintenance_commandsClient<$Result.GetResult<Prisma.$maintenance_commandsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintenance_commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_commandsCountArgs} args - Arguments to filter Maintenance_commands to count.
     * @example
     * // Count the number of Maintenance_commands
     * const count = await prisma.maintenance_commands.count({
     *   where: {
     *     // ... the filter for the Maintenance_commands we want to count
     *   }
     * })
    **/
    count<T extends maintenance_commandsCountArgs>(
      args?: Subset<T, maintenance_commandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Maintenance_commandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance_commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Maintenance_commandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Maintenance_commandsAggregateArgs>(args: Subset<T, Maintenance_commandsAggregateArgs>): Prisma.PrismaPromise<GetMaintenance_commandsAggregateType<T>>

    /**
     * Group by Maintenance_commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_commandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends maintenance_commandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: maintenance_commandsGroupByArgs['orderBy'] }
        : { orderBy?: maintenance_commandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, maintenance_commandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenance_commandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the maintenance_commands model
   */
  readonly fields: maintenance_commandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for maintenance_commands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__maintenance_commandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the maintenance_commands model
   */
  interface maintenance_commandsFieldRefs {
    readonly id: FieldRef<"maintenance_commands", 'String'>
    readonly bot_type: FieldRef<"maintenance_commands", 'String'>
    readonly option: FieldRef<"maintenance_commands", 'Int'>
    readonly createdAt: FieldRef<"maintenance_commands", 'DateTime'>
    readonly updatedAt: FieldRef<"maintenance_commands", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * maintenance_commands findUnique
   */
  export type maintenance_commandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * Filter, which maintenance_commands to fetch.
     */
    where: maintenance_commandsWhereUniqueInput
  }

  /**
   * maintenance_commands findUniqueOrThrow
   */
  export type maintenance_commandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * Filter, which maintenance_commands to fetch.
     */
    where: maintenance_commandsWhereUniqueInput
  }

  /**
   * maintenance_commands findFirst
   */
  export type maintenance_commandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * Filter, which maintenance_commands to fetch.
     */
    where?: maintenance_commandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_commands to fetch.
     */
    orderBy?: maintenance_commandsOrderByWithRelationInput | maintenance_commandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maintenance_commands.
     */
    cursor?: maintenance_commandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maintenance_commands.
     */
    distinct?: Maintenance_commandsScalarFieldEnum | Maintenance_commandsScalarFieldEnum[]
  }

  /**
   * maintenance_commands findFirstOrThrow
   */
  export type maintenance_commandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * Filter, which maintenance_commands to fetch.
     */
    where?: maintenance_commandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_commands to fetch.
     */
    orderBy?: maintenance_commandsOrderByWithRelationInput | maintenance_commandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maintenance_commands.
     */
    cursor?: maintenance_commandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maintenance_commands.
     */
    distinct?: Maintenance_commandsScalarFieldEnum | Maintenance_commandsScalarFieldEnum[]
  }

  /**
   * maintenance_commands findMany
   */
  export type maintenance_commandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * Filter, which maintenance_commands to fetch.
     */
    where?: maintenance_commandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_commands to fetch.
     */
    orderBy?: maintenance_commandsOrderByWithRelationInput | maintenance_commandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing maintenance_commands.
     */
    cursor?: maintenance_commandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_commands.
     */
    skip?: number
    distinct?: Maintenance_commandsScalarFieldEnum | Maintenance_commandsScalarFieldEnum[]
  }

  /**
   * maintenance_commands create
   */
  export type maintenance_commandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * The data needed to create a maintenance_commands.
     */
    data: XOR<maintenance_commandsCreateInput, maintenance_commandsUncheckedCreateInput>
  }

  /**
   * maintenance_commands createMany
   */
  export type maintenance_commandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many maintenance_commands.
     */
    data: maintenance_commandsCreateManyInput | maintenance_commandsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * maintenance_commands update
   */
  export type maintenance_commandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * The data needed to update a maintenance_commands.
     */
    data: XOR<maintenance_commandsUpdateInput, maintenance_commandsUncheckedUpdateInput>
    /**
     * Choose, which maintenance_commands to update.
     */
    where: maintenance_commandsWhereUniqueInput
  }

  /**
   * maintenance_commands updateMany
   */
  export type maintenance_commandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update maintenance_commands.
     */
    data: XOR<maintenance_commandsUpdateManyMutationInput, maintenance_commandsUncheckedUpdateManyInput>
    /**
     * Filter which maintenance_commands to update
     */
    where?: maintenance_commandsWhereInput
    /**
     * Limit how many maintenance_commands to update.
     */
    limit?: number
  }

  /**
   * maintenance_commands upsert
   */
  export type maintenance_commandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * The filter to search for the maintenance_commands to update in case it exists.
     */
    where: maintenance_commandsWhereUniqueInput
    /**
     * In case the maintenance_commands found by the `where` argument doesn't exist, create a new maintenance_commands with this data.
     */
    create: XOR<maintenance_commandsCreateInput, maintenance_commandsUncheckedCreateInput>
    /**
     * In case the maintenance_commands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<maintenance_commandsUpdateInput, maintenance_commandsUncheckedUpdateInput>
  }

  /**
   * maintenance_commands delete
   */
  export type maintenance_commandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
    /**
     * Filter which maintenance_commands to delete.
     */
    where: maintenance_commandsWhereUniqueInput
  }

  /**
   * maintenance_commands deleteMany
   */
  export type maintenance_commandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maintenance_commands to delete
     */
    where?: maintenance_commandsWhereInput
    /**
     * Limit how many maintenance_commands to delete.
     */
    limit?: number
  }

  /**
   * maintenance_commands without action
   */
  export type maintenance_commandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_commands
     */
    select?: maintenance_commandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_commands
     */
    omit?: maintenance_commandsOmit<ExtArgs> | null
  }


  /**
   * Model messages_log
   */

  export type AggregateMessages_log = {
    _count: Messages_logCountAggregateOutputType | null
    _avg: Messages_logAvgAggregateOutputType | null
    _sum: Messages_logSumAggregateOutputType | null
    _min: Messages_logMinAggregateOutputType | null
    _max: Messages_logMaxAggregateOutputType | null
  }

  export type Messages_logAvgAggregateOutputType = {
    phone_number: number | null
  }

  export type Messages_logSumAggregateOutputType = {
    phone_number: bigint | null
  }

  export type Messages_logMinAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    message: string | null
    is_attendant: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Messages_logMaxAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    message: string | null
    is_attendant: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Messages_logCountAggregateOutputType = {
    id: number
    phone_number: number
    message: number
    is_attendant: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Messages_logAvgAggregateInputType = {
    phone_number?: true
  }

  export type Messages_logSumAggregateInputType = {
    phone_number?: true
  }

  export type Messages_logMinAggregateInputType = {
    id?: true
    phone_number?: true
    message?: true
    is_attendant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Messages_logMaxAggregateInputType = {
    id?: true
    phone_number?: true
    message?: true
    is_attendant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Messages_logCountAggregateInputType = {
    id?: true
    phone_number?: true
    message?: true
    is_attendant?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Messages_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages_log to aggregate.
     */
    where?: messages_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages_logs to fetch.
     */
    orderBy?: messages_logOrderByWithRelationInput | messages_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messages_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages_logs
    **/
    _count?: true | Messages_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Messages_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Messages_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Messages_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Messages_logMaxAggregateInputType
  }

  export type GetMessages_logAggregateType<T extends Messages_logAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages_log[P]>
      : GetScalarType<T[P], AggregateMessages_log[P]>
  }




  export type messages_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messages_logWhereInput
    orderBy?: messages_logOrderByWithAggregationInput | messages_logOrderByWithAggregationInput[]
    by: Messages_logScalarFieldEnum[] | Messages_logScalarFieldEnum
    having?: messages_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Messages_logCountAggregateInputType | true
    _avg?: Messages_logAvgAggregateInputType
    _sum?: Messages_logSumAggregateInputType
    _min?: Messages_logMinAggregateInputType
    _max?: Messages_logMaxAggregateInputType
  }

  export type Messages_logGroupByOutputType = {
    id: string
    phone_number: bigint
    message: string
    is_attendant: boolean
    createdAt: Date
    updatedAt: Date
    _count: Messages_logCountAggregateOutputType | null
    _avg: Messages_logAvgAggregateOutputType | null
    _sum: Messages_logSumAggregateOutputType | null
    _min: Messages_logMinAggregateOutputType | null
    _max: Messages_logMaxAggregateOutputType | null
  }

  type GetMessages_logGroupByPayload<T extends messages_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Messages_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Messages_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Messages_logGroupByOutputType[P]>
            : GetScalarType<T[P], Messages_logGroupByOutputType[P]>
        }
      >
    >


  export type messages_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    message?: boolean
    is_attendant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["messages_log"]>



  export type messages_logSelectScalar = {
    id?: boolean
    phone_number?: boolean
    message?: boolean
    is_attendant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type messages_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "message" | "is_attendant" | "createdAt" | "updatedAt", ExtArgs["result"]["messages_log"]>

  export type $messages_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messages_log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: bigint
      message: string
      is_attendant: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messages_log"]>
    composites: {}
  }

  type messages_logGetPayload<S extends boolean | null | undefined | messages_logDefaultArgs> = $Result.GetResult<Prisma.$messages_logPayload, S>

  type messages_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messages_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Messages_logCountAggregateInputType | true
    }

  export interface messages_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messages_log'], meta: { name: 'messages_log' } }
    /**
     * Find zero or one Messages_log that matches the filter.
     * @param {messages_logFindUniqueArgs} args - Arguments to find a Messages_log
     * @example
     * // Get one Messages_log
     * const messages_log = await prisma.messages_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messages_logFindUniqueArgs>(args: SelectSubset<T, messages_logFindUniqueArgs<ExtArgs>>): Prisma__messages_logClient<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Messages_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messages_logFindUniqueOrThrowArgs} args - Arguments to find a Messages_log
     * @example
     * // Get one Messages_log
     * const messages_log = await prisma.messages_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messages_logFindUniqueOrThrowArgs>(args: SelectSubset<T, messages_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messages_logClient<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messages_logFindFirstArgs} args - Arguments to find a Messages_log
     * @example
     * // Get one Messages_log
     * const messages_log = await prisma.messages_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messages_logFindFirstArgs>(args?: SelectSubset<T, messages_logFindFirstArgs<ExtArgs>>): Prisma__messages_logClient<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messages_logFindFirstOrThrowArgs} args - Arguments to find a Messages_log
     * @example
     * // Get one Messages_log
     * const messages_log = await prisma.messages_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messages_logFindFirstOrThrowArgs>(args?: SelectSubset<T, messages_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__messages_logClient<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messages_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages_logs
     * const messages_logs = await prisma.messages_log.findMany()
     * 
     * // Get first 10 Messages_logs
     * const messages_logs = await prisma.messages_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messages_logWithIdOnly = await prisma.messages_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messages_logFindManyArgs>(args?: SelectSubset<T, messages_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Messages_log.
     * @param {messages_logCreateArgs} args - Arguments to create a Messages_log.
     * @example
     * // Create one Messages_log
     * const Messages_log = await prisma.messages_log.create({
     *   data: {
     *     // ... data to create a Messages_log
     *   }
     * })
     * 
     */
    create<T extends messages_logCreateArgs>(args: SelectSubset<T, messages_logCreateArgs<ExtArgs>>): Prisma__messages_logClient<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages_logs.
     * @param {messages_logCreateManyArgs} args - Arguments to create many Messages_logs.
     * @example
     * // Create many Messages_logs
     * const messages_log = await prisma.messages_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messages_logCreateManyArgs>(args?: SelectSubset<T, messages_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Messages_log.
     * @param {messages_logDeleteArgs} args - Arguments to delete one Messages_log.
     * @example
     * // Delete one Messages_log
     * const Messages_log = await prisma.messages_log.delete({
     *   where: {
     *     // ... filter to delete one Messages_log
     *   }
     * })
     * 
     */
    delete<T extends messages_logDeleteArgs>(args: SelectSubset<T, messages_logDeleteArgs<ExtArgs>>): Prisma__messages_logClient<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Messages_log.
     * @param {messages_logUpdateArgs} args - Arguments to update one Messages_log.
     * @example
     * // Update one Messages_log
     * const messages_log = await prisma.messages_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messages_logUpdateArgs>(args: SelectSubset<T, messages_logUpdateArgs<ExtArgs>>): Prisma__messages_logClient<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages_logs.
     * @param {messages_logDeleteManyArgs} args - Arguments to filter Messages_logs to delete.
     * @example
     * // Delete a few Messages_logs
     * const { count } = await prisma.messages_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messages_logDeleteManyArgs>(args?: SelectSubset<T, messages_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messages_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages_logs
     * const messages_log = await prisma.messages_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messages_logUpdateManyArgs>(args: SelectSubset<T, messages_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Messages_log.
     * @param {messages_logUpsertArgs} args - Arguments to update or create a Messages_log.
     * @example
     * // Update or create a Messages_log
     * const messages_log = await prisma.messages_log.upsert({
     *   create: {
     *     // ... data to create a Messages_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages_log we want to update
     *   }
     * })
     */
    upsert<T extends messages_logUpsertArgs>(args: SelectSubset<T, messages_logUpsertArgs<ExtArgs>>): Prisma__messages_logClient<$Result.GetResult<Prisma.$messages_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messages_logCountArgs} args - Arguments to filter Messages_logs to count.
     * @example
     * // Count the number of Messages_logs
     * const count = await prisma.messages_log.count({
     *   where: {
     *     // ... the filter for the Messages_logs we want to count
     *   }
     * })
    **/
    count<T extends messages_logCountArgs>(
      args?: Subset<T, messages_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Messages_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Messages_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Messages_logAggregateArgs>(args: Subset<T, Messages_logAggregateArgs>): Prisma.PrismaPromise<GetMessages_logAggregateType<T>>

    /**
     * Group by Messages_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messages_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messages_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messages_logGroupByArgs['orderBy'] }
        : { orderBy?: messages_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messages_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessages_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messages_log model
   */
  readonly fields: messages_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messages_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messages_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messages_log model
   */
  interface messages_logFieldRefs {
    readonly id: FieldRef<"messages_log", 'String'>
    readonly phone_number: FieldRef<"messages_log", 'BigInt'>
    readonly message: FieldRef<"messages_log", 'String'>
    readonly is_attendant: FieldRef<"messages_log", 'Boolean'>
    readonly createdAt: FieldRef<"messages_log", 'DateTime'>
    readonly updatedAt: FieldRef<"messages_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * messages_log findUnique
   */
  export type messages_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * Filter, which messages_log to fetch.
     */
    where: messages_logWhereUniqueInput
  }

  /**
   * messages_log findUniqueOrThrow
   */
  export type messages_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * Filter, which messages_log to fetch.
     */
    where: messages_logWhereUniqueInput
  }

  /**
   * messages_log findFirst
   */
  export type messages_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * Filter, which messages_log to fetch.
     */
    where?: messages_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages_logs to fetch.
     */
    orderBy?: messages_logOrderByWithRelationInput | messages_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages_logs.
     */
    cursor?: messages_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages_logs.
     */
    distinct?: Messages_logScalarFieldEnum | Messages_logScalarFieldEnum[]
  }

  /**
   * messages_log findFirstOrThrow
   */
  export type messages_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * Filter, which messages_log to fetch.
     */
    where?: messages_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages_logs to fetch.
     */
    orderBy?: messages_logOrderByWithRelationInput | messages_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages_logs.
     */
    cursor?: messages_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages_logs.
     */
    distinct?: Messages_logScalarFieldEnum | Messages_logScalarFieldEnum[]
  }

  /**
   * messages_log findMany
   */
  export type messages_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * Filter, which messages_logs to fetch.
     */
    where?: messages_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages_logs to fetch.
     */
    orderBy?: messages_logOrderByWithRelationInput | messages_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages_logs.
     */
    cursor?: messages_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages_logs.
     */
    skip?: number
    distinct?: Messages_logScalarFieldEnum | Messages_logScalarFieldEnum[]
  }

  /**
   * messages_log create
   */
  export type messages_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * The data needed to create a messages_log.
     */
    data: XOR<messages_logCreateInput, messages_logUncheckedCreateInput>
  }

  /**
   * messages_log createMany
   */
  export type messages_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages_logs.
     */
    data: messages_logCreateManyInput | messages_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messages_log update
   */
  export type messages_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * The data needed to update a messages_log.
     */
    data: XOR<messages_logUpdateInput, messages_logUncheckedUpdateInput>
    /**
     * Choose, which messages_log to update.
     */
    where: messages_logWhereUniqueInput
  }

  /**
   * messages_log updateMany
   */
  export type messages_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages_logs.
     */
    data: XOR<messages_logUpdateManyMutationInput, messages_logUncheckedUpdateManyInput>
    /**
     * Filter which messages_logs to update
     */
    where?: messages_logWhereInput
    /**
     * Limit how many messages_logs to update.
     */
    limit?: number
  }

  /**
   * messages_log upsert
   */
  export type messages_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * The filter to search for the messages_log to update in case it exists.
     */
    where: messages_logWhereUniqueInput
    /**
     * In case the messages_log found by the `where` argument doesn't exist, create a new messages_log with this data.
     */
    create: XOR<messages_logCreateInput, messages_logUncheckedCreateInput>
    /**
     * In case the messages_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messages_logUpdateInput, messages_logUncheckedUpdateInput>
  }

  /**
   * messages_log delete
   */
  export type messages_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
    /**
     * Filter which messages_log to delete.
     */
    where: messages_logWhereUniqueInput
  }

  /**
   * messages_log deleteMany
   */
  export type messages_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages_logs to delete
     */
    where?: messages_logWhereInput
    /**
     * Limit how many messages_logs to delete.
     */
    limit?: number
  }

  /**
   * messages_log without action
   */
  export type messages_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages_log
     */
    select?: messages_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages_log
     */
    omit?: messages_logOmit<ExtArgs> | null
  }


  /**
   * Model modality_assistance_quotations
   */

  export type AggregateModality_assistance_quotations = {
    _count: Modality_assistance_quotationsCountAggregateOutputType | null
    _avg: Modality_assistance_quotationsAvgAggregateOutputType | null
    _sum: Modality_assistance_quotationsSumAggregateOutputType | null
    _min: Modality_assistance_quotationsMinAggregateOutputType | null
    _max: Modality_assistance_quotationsMaxAggregateOutputType | null
  }

  export type Modality_assistance_quotationsAvgAggregateOutputType = {
    id: number | null
  }

  export type Modality_assistance_quotationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Modality_assistance_quotationsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Modality_assistance_quotationsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Modality_assistance_quotationsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Modality_assistance_quotationsAvgAggregateInputType = {
    id?: true
  }

  export type Modality_assistance_quotationsSumAggregateInputType = {
    id?: true
  }

  export type Modality_assistance_quotationsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Modality_assistance_quotationsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Modality_assistance_quotationsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Modality_assistance_quotationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modality_assistance_quotations to aggregate.
     */
    where?: modality_assistance_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modality_assistance_quotations to fetch.
     */
    orderBy?: modality_assistance_quotationsOrderByWithRelationInput | modality_assistance_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: modality_assistance_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modality_assistance_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modality_assistance_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned modality_assistance_quotations
    **/
    _count?: true | Modality_assistance_quotationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Modality_assistance_quotationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Modality_assistance_quotationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Modality_assistance_quotationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Modality_assistance_quotationsMaxAggregateInputType
  }

  export type GetModality_assistance_quotationsAggregateType<T extends Modality_assistance_quotationsAggregateArgs> = {
        [P in keyof T & keyof AggregateModality_assistance_quotations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModality_assistance_quotations[P]>
      : GetScalarType<T[P], AggregateModality_assistance_quotations[P]>
  }




  export type modality_assistance_quotationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modality_assistance_quotationsWhereInput
    orderBy?: modality_assistance_quotationsOrderByWithAggregationInput | modality_assistance_quotationsOrderByWithAggregationInput[]
    by: Modality_assistance_quotationsScalarFieldEnum[] | Modality_assistance_quotationsScalarFieldEnum
    having?: modality_assistance_quotationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Modality_assistance_quotationsCountAggregateInputType | true
    _avg?: Modality_assistance_quotationsAvgAggregateInputType
    _sum?: Modality_assistance_quotationsSumAggregateInputType
    _min?: Modality_assistance_quotationsMinAggregateInputType
    _max?: Modality_assistance_quotationsMaxAggregateInputType
  }

  export type Modality_assistance_quotationsGroupByOutputType = {
    id: bigint
    name: string
    _count: Modality_assistance_quotationsCountAggregateOutputType | null
    _avg: Modality_assistance_quotationsAvgAggregateOutputType | null
    _sum: Modality_assistance_quotationsSumAggregateOutputType | null
    _min: Modality_assistance_quotationsMinAggregateOutputType | null
    _max: Modality_assistance_quotationsMaxAggregateOutputType | null
  }

  type GetModality_assistance_quotationsGroupByPayload<T extends modality_assistance_quotationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Modality_assistance_quotationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Modality_assistance_quotationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Modality_assistance_quotationsGroupByOutputType[P]>
            : GetScalarType<T[P], Modality_assistance_quotationsGroupByOutputType[P]>
        }
      >
    >


  export type modality_assistance_quotationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["modality_assistance_quotations"]>



  export type modality_assistance_quotationsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type modality_assistance_quotationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["modality_assistance_quotations"]>

  export type $modality_assistance_quotationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "modality_assistance_quotations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["modality_assistance_quotations"]>
    composites: {}
  }

  type modality_assistance_quotationsGetPayload<S extends boolean | null | undefined | modality_assistance_quotationsDefaultArgs> = $Result.GetResult<Prisma.$modality_assistance_quotationsPayload, S>

  type modality_assistance_quotationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<modality_assistance_quotationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Modality_assistance_quotationsCountAggregateInputType | true
    }

  export interface modality_assistance_quotationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['modality_assistance_quotations'], meta: { name: 'modality_assistance_quotations' } }
    /**
     * Find zero or one Modality_assistance_quotations that matches the filter.
     * @param {modality_assistance_quotationsFindUniqueArgs} args - Arguments to find a Modality_assistance_quotations
     * @example
     * // Get one Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends modality_assistance_quotationsFindUniqueArgs>(args: SelectSubset<T, modality_assistance_quotationsFindUniqueArgs<ExtArgs>>): Prisma__modality_assistance_quotationsClient<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Modality_assistance_quotations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {modality_assistance_quotationsFindUniqueOrThrowArgs} args - Arguments to find a Modality_assistance_quotations
     * @example
     * // Get one Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends modality_assistance_quotationsFindUniqueOrThrowArgs>(args: SelectSubset<T, modality_assistance_quotationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__modality_assistance_quotationsClient<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Modality_assistance_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modality_assistance_quotationsFindFirstArgs} args - Arguments to find a Modality_assistance_quotations
     * @example
     * // Get one Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends modality_assistance_quotationsFindFirstArgs>(args?: SelectSubset<T, modality_assistance_quotationsFindFirstArgs<ExtArgs>>): Prisma__modality_assistance_quotationsClient<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Modality_assistance_quotations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modality_assistance_quotationsFindFirstOrThrowArgs} args - Arguments to find a Modality_assistance_quotations
     * @example
     * // Get one Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends modality_assistance_quotationsFindFirstOrThrowArgs>(args?: SelectSubset<T, modality_assistance_quotationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__modality_assistance_quotationsClient<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modality_assistance_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modality_assistance_quotationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.findMany()
     * 
     * // Get first 10 Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modality_assistance_quotationsWithIdOnly = await prisma.modality_assistance_quotations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends modality_assistance_quotationsFindManyArgs>(args?: SelectSubset<T, modality_assistance_quotationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Modality_assistance_quotations.
     * @param {modality_assistance_quotationsCreateArgs} args - Arguments to create a Modality_assistance_quotations.
     * @example
     * // Create one Modality_assistance_quotations
     * const Modality_assistance_quotations = await prisma.modality_assistance_quotations.create({
     *   data: {
     *     // ... data to create a Modality_assistance_quotations
     *   }
     * })
     * 
     */
    create<T extends modality_assistance_quotationsCreateArgs>(args: SelectSubset<T, modality_assistance_quotationsCreateArgs<ExtArgs>>): Prisma__modality_assistance_quotationsClient<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modality_assistance_quotations.
     * @param {modality_assistance_quotationsCreateManyArgs} args - Arguments to create many Modality_assistance_quotations.
     * @example
     * // Create many Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends modality_assistance_quotationsCreateManyArgs>(args?: SelectSubset<T, modality_assistance_quotationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Modality_assistance_quotations.
     * @param {modality_assistance_quotationsDeleteArgs} args - Arguments to delete one Modality_assistance_quotations.
     * @example
     * // Delete one Modality_assistance_quotations
     * const Modality_assistance_quotations = await prisma.modality_assistance_quotations.delete({
     *   where: {
     *     // ... filter to delete one Modality_assistance_quotations
     *   }
     * })
     * 
     */
    delete<T extends modality_assistance_quotationsDeleteArgs>(args: SelectSubset<T, modality_assistance_quotationsDeleteArgs<ExtArgs>>): Prisma__modality_assistance_quotationsClient<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Modality_assistance_quotations.
     * @param {modality_assistance_quotationsUpdateArgs} args - Arguments to update one Modality_assistance_quotations.
     * @example
     * // Update one Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends modality_assistance_quotationsUpdateArgs>(args: SelectSubset<T, modality_assistance_quotationsUpdateArgs<ExtArgs>>): Prisma__modality_assistance_quotationsClient<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modality_assistance_quotations.
     * @param {modality_assistance_quotationsDeleteManyArgs} args - Arguments to filter Modality_assistance_quotations to delete.
     * @example
     * // Delete a few Modality_assistance_quotations
     * const { count } = await prisma.modality_assistance_quotations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends modality_assistance_quotationsDeleteManyArgs>(args?: SelectSubset<T, modality_assistance_quotationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modality_assistance_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modality_assistance_quotationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends modality_assistance_quotationsUpdateManyArgs>(args: SelectSubset<T, modality_assistance_quotationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Modality_assistance_quotations.
     * @param {modality_assistance_quotationsUpsertArgs} args - Arguments to update or create a Modality_assistance_quotations.
     * @example
     * // Update or create a Modality_assistance_quotations
     * const modality_assistance_quotations = await prisma.modality_assistance_quotations.upsert({
     *   create: {
     *     // ... data to create a Modality_assistance_quotations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modality_assistance_quotations we want to update
     *   }
     * })
     */
    upsert<T extends modality_assistance_quotationsUpsertArgs>(args: SelectSubset<T, modality_assistance_quotationsUpsertArgs<ExtArgs>>): Prisma__modality_assistance_quotationsClient<$Result.GetResult<Prisma.$modality_assistance_quotationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modality_assistance_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modality_assistance_quotationsCountArgs} args - Arguments to filter Modality_assistance_quotations to count.
     * @example
     * // Count the number of Modality_assistance_quotations
     * const count = await prisma.modality_assistance_quotations.count({
     *   where: {
     *     // ... the filter for the Modality_assistance_quotations we want to count
     *   }
     * })
    **/
    count<T extends modality_assistance_quotationsCountArgs>(
      args?: Subset<T, modality_assistance_quotationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Modality_assistance_quotationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modality_assistance_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Modality_assistance_quotationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Modality_assistance_quotationsAggregateArgs>(args: Subset<T, Modality_assistance_quotationsAggregateArgs>): Prisma.PrismaPromise<GetModality_assistance_quotationsAggregateType<T>>

    /**
     * Group by Modality_assistance_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modality_assistance_quotationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends modality_assistance_quotationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: modality_assistance_quotationsGroupByArgs['orderBy'] }
        : { orderBy?: modality_assistance_quotationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, modality_assistance_quotationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModality_assistance_quotationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the modality_assistance_quotations model
   */
  readonly fields: modality_assistance_quotationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for modality_assistance_quotations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__modality_assistance_quotationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the modality_assistance_quotations model
   */
  interface modality_assistance_quotationsFieldRefs {
    readonly id: FieldRef<"modality_assistance_quotations", 'BigInt'>
    readonly name: FieldRef<"modality_assistance_quotations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * modality_assistance_quotations findUnique
   */
  export type modality_assistance_quotationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which modality_assistance_quotations to fetch.
     */
    where: modality_assistance_quotationsWhereUniqueInput
  }

  /**
   * modality_assistance_quotations findUniqueOrThrow
   */
  export type modality_assistance_quotationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which modality_assistance_quotations to fetch.
     */
    where: modality_assistance_quotationsWhereUniqueInput
  }

  /**
   * modality_assistance_quotations findFirst
   */
  export type modality_assistance_quotationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which modality_assistance_quotations to fetch.
     */
    where?: modality_assistance_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modality_assistance_quotations to fetch.
     */
    orderBy?: modality_assistance_quotationsOrderByWithRelationInput | modality_assistance_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modality_assistance_quotations.
     */
    cursor?: modality_assistance_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modality_assistance_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modality_assistance_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modality_assistance_quotations.
     */
    distinct?: Modality_assistance_quotationsScalarFieldEnum | Modality_assistance_quotationsScalarFieldEnum[]
  }

  /**
   * modality_assistance_quotations findFirstOrThrow
   */
  export type modality_assistance_quotationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which modality_assistance_quotations to fetch.
     */
    where?: modality_assistance_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modality_assistance_quotations to fetch.
     */
    orderBy?: modality_assistance_quotationsOrderByWithRelationInput | modality_assistance_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modality_assistance_quotations.
     */
    cursor?: modality_assistance_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modality_assistance_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modality_assistance_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modality_assistance_quotations.
     */
    distinct?: Modality_assistance_quotationsScalarFieldEnum | Modality_assistance_quotationsScalarFieldEnum[]
  }

  /**
   * modality_assistance_quotations findMany
   */
  export type modality_assistance_quotationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which modality_assistance_quotations to fetch.
     */
    where?: modality_assistance_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modality_assistance_quotations to fetch.
     */
    orderBy?: modality_assistance_quotationsOrderByWithRelationInput | modality_assistance_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing modality_assistance_quotations.
     */
    cursor?: modality_assistance_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modality_assistance_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modality_assistance_quotations.
     */
    skip?: number
    distinct?: Modality_assistance_quotationsScalarFieldEnum | Modality_assistance_quotationsScalarFieldEnum[]
  }

  /**
   * modality_assistance_quotations create
   */
  export type modality_assistance_quotationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to create a modality_assistance_quotations.
     */
    data: XOR<modality_assistance_quotationsCreateInput, modality_assistance_quotationsUncheckedCreateInput>
  }

  /**
   * modality_assistance_quotations createMany
   */
  export type modality_assistance_quotationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many modality_assistance_quotations.
     */
    data: modality_assistance_quotationsCreateManyInput | modality_assistance_quotationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * modality_assistance_quotations update
   */
  export type modality_assistance_quotationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to update a modality_assistance_quotations.
     */
    data: XOR<modality_assistance_quotationsUpdateInput, modality_assistance_quotationsUncheckedUpdateInput>
    /**
     * Choose, which modality_assistance_quotations to update.
     */
    where: modality_assistance_quotationsWhereUniqueInput
  }

  /**
   * modality_assistance_quotations updateMany
   */
  export type modality_assistance_quotationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update modality_assistance_quotations.
     */
    data: XOR<modality_assistance_quotationsUpdateManyMutationInput, modality_assistance_quotationsUncheckedUpdateManyInput>
    /**
     * Filter which modality_assistance_quotations to update
     */
    where?: modality_assistance_quotationsWhereInput
    /**
     * Limit how many modality_assistance_quotations to update.
     */
    limit?: number
  }

  /**
   * modality_assistance_quotations upsert
   */
  export type modality_assistance_quotationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * The filter to search for the modality_assistance_quotations to update in case it exists.
     */
    where: modality_assistance_quotationsWhereUniqueInput
    /**
     * In case the modality_assistance_quotations found by the `where` argument doesn't exist, create a new modality_assistance_quotations with this data.
     */
    create: XOR<modality_assistance_quotationsCreateInput, modality_assistance_quotationsUncheckedCreateInput>
    /**
     * In case the modality_assistance_quotations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<modality_assistance_quotationsUpdateInput, modality_assistance_quotationsUncheckedUpdateInput>
  }

  /**
   * modality_assistance_quotations delete
   */
  export type modality_assistance_quotationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
    /**
     * Filter which modality_assistance_quotations to delete.
     */
    where: modality_assistance_quotationsWhereUniqueInput
  }

  /**
   * modality_assistance_quotations deleteMany
   */
  export type modality_assistance_quotationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modality_assistance_quotations to delete
     */
    where?: modality_assistance_quotationsWhereInput
    /**
     * Limit how many modality_assistance_quotations to delete.
     */
    limit?: number
  }

  /**
   * modality_assistance_quotations without action
   */
  export type modality_assistance_quotationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modality_assistance_quotations
     */
    select?: modality_assistance_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modality_assistance_quotations
     */
    omit?: modality_assistance_quotationsOmit<ExtArgs> | null
  }


  /**
   * Model plan_group_quotations
   */

  export type AggregatePlan_group_quotations = {
    _count: Plan_group_quotationsCountAggregateOutputType | null
    _avg: Plan_group_quotationsAvgAggregateOutputType | null
    _sum: Plan_group_quotationsSumAggregateOutputType | null
    _min: Plan_group_quotationsMinAggregateOutputType | null
    _max: Plan_group_quotationsMaxAggregateOutputType | null
  }

  export type Plan_group_quotationsAvgAggregateOutputType = {
    id: number | null
  }

  export type Plan_group_quotationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Plan_group_quotationsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Plan_group_quotationsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Plan_group_quotationsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Plan_group_quotationsAvgAggregateInputType = {
    id?: true
  }

  export type Plan_group_quotationsSumAggregateInputType = {
    id?: true
  }

  export type Plan_group_quotationsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Plan_group_quotationsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Plan_group_quotationsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Plan_group_quotationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_group_quotations to aggregate.
     */
    where?: plan_group_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_group_quotations to fetch.
     */
    orderBy?: plan_group_quotationsOrderByWithRelationInput | plan_group_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_group_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_group_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_group_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_group_quotations
    **/
    _count?: true | Plan_group_quotationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plan_group_quotationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plan_group_quotationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_group_quotationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_group_quotationsMaxAggregateInputType
  }

  export type GetPlan_group_quotationsAggregateType<T extends Plan_group_quotationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_group_quotations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_group_quotations[P]>
      : GetScalarType<T[P], AggregatePlan_group_quotations[P]>
  }




  export type plan_group_quotationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plan_group_quotationsWhereInput
    orderBy?: plan_group_quotationsOrderByWithAggregationInput | plan_group_quotationsOrderByWithAggregationInput[]
    by: Plan_group_quotationsScalarFieldEnum[] | Plan_group_quotationsScalarFieldEnum
    having?: plan_group_quotationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_group_quotationsCountAggregateInputType | true
    _avg?: Plan_group_quotationsAvgAggregateInputType
    _sum?: Plan_group_quotationsSumAggregateInputType
    _min?: Plan_group_quotationsMinAggregateInputType
    _max?: Plan_group_quotationsMaxAggregateInputType
  }

  export type Plan_group_quotationsGroupByOutputType = {
    id: bigint
    name: string
    _count: Plan_group_quotationsCountAggregateOutputType | null
    _avg: Plan_group_quotationsAvgAggregateOutputType | null
    _sum: Plan_group_quotationsSumAggregateOutputType | null
    _min: Plan_group_quotationsMinAggregateOutputType | null
    _max: Plan_group_quotationsMaxAggregateOutputType | null
  }

  type GetPlan_group_quotationsGroupByPayload<T extends plan_group_quotationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_group_quotationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_group_quotationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_group_quotationsGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_group_quotationsGroupByOutputType[P]>
        }
      >
    >


  export type plan_group_quotationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["plan_group_quotations"]>



  export type plan_group_quotationsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type plan_group_quotationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["plan_group_quotations"]>

  export type $plan_group_quotationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plan_group_quotations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["plan_group_quotations"]>
    composites: {}
  }

  type plan_group_quotationsGetPayload<S extends boolean | null | undefined | plan_group_quotationsDefaultArgs> = $Result.GetResult<Prisma.$plan_group_quotationsPayload, S>

  type plan_group_quotationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plan_group_quotationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Plan_group_quotationsCountAggregateInputType | true
    }

  export interface plan_group_quotationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_group_quotations'], meta: { name: 'plan_group_quotations' } }
    /**
     * Find zero or one Plan_group_quotations that matches the filter.
     * @param {plan_group_quotationsFindUniqueArgs} args - Arguments to find a Plan_group_quotations
     * @example
     * // Get one Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plan_group_quotationsFindUniqueArgs>(args: SelectSubset<T, plan_group_quotationsFindUniqueArgs<ExtArgs>>): Prisma__plan_group_quotationsClient<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan_group_quotations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plan_group_quotationsFindUniqueOrThrowArgs} args - Arguments to find a Plan_group_quotations
     * @example
     * // Get one Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plan_group_quotationsFindUniqueOrThrowArgs>(args: SelectSubset<T, plan_group_quotationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plan_group_quotationsClient<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_group_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_group_quotationsFindFirstArgs} args - Arguments to find a Plan_group_quotations
     * @example
     * // Get one Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plan_group_quotationsFindFirstArgs>(args?: SelectSubset<T, plan_group_quotationsFindFirstArgs<ExtArgs>>): Prisma__plan_group_quotationsClient<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_group_quotations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_group_quotationsFindFirstOrThrowArgs} args - Arguments to find a Plan_group_quotations
     * @example
     * // Get one Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plan_group_quotationsFindFirstOrThrowArgs>(args?: SelectSubset<T, plan_group_quotationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__plan_group_quotationsClient<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plan_group_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_group_quotationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.findMany()
     * 
     * // Get first 10 Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plan_group_quotationsWithIdOnly = await prisma.plan_group_quotations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plan_group_quotationsFindManyArgs>(args?: SelectSubset<T, plan_group_quotationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan_group_quotations.
     * @param {plan_group_quotationsCreateArgs} args - Arguments to create a Plan_group_quotations.
     * @example
     * // Create one Plan_group_quotations
     * const Plan_group_quotations = await prisma.plan_group_quotations.create({
     *   data: {
     *     // ... data to create a Plan_group_quotations
     *   }
     * })
     * 
     */
    create<T extends plan_group_quotationsCreateArgs>(args: SelectSubset<T, plan_group_quotationsCreateArgs<ExtArgs>>): Prisma__plan_group_quotationsClient<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plan_group_quotations.
     * @param {plan_group_quotationsCreateManyArgs} args - Arguments to create many Plan_group_quotations.
     * @example
     * // Create many Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plan_group_quotationsCreateManyArgs>(args?: SelectSubset<T, plan_group_quotationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_group_quotations.
     * @param {plan_group_quotationsDeleteArgs} args - Arguments to delete one Plan_group_quotations.
     * @example
     * // Delete one Plan_group_quotations
     * const Plan_group_quotations = await prisma.plan_group_quotations.delete({
     *   where: {
     *     // ... filter to delete one Plan_group_quotations
     *   }
     * })
     * 
     */
    delete<T extends plan_group_quotationsDeleteArgs>(args: SelectSubset<T, plan_group_quotationsDeleteArgs<ExtArgs>>): Prisma__plan_group_quotationsClient<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan_group_quotations.
     * @param {plan_group_quotationsUpdateArgs} args - Arguments to update one Plan_group_quotations.
     * @example
     * // Update one Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plan_group_quotationsUpdateArgs>(args: SelectSubset<T, plan_group_quotationsUpdateArgs<ExtArgs>>): Prisma__plan_group_quotationsClient<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plan_group_quotations.
     * @param {plan_group_quotationsDeleteManyArgs} args - Arguments to filter Plan_group_quotations to delete.
     * @example
     * // Delete a few Plan_group_quotations
     * const { count } = await prisma.plan_group_quotations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plan_group_quotationsDeleteManyArgs>(args?: SelectSubset<T, plan_group_quotationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_group_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_group_quotationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plan_group_quotationsUpdateManyArgs>(args: SelectSubset<T, plan_group_quotationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_group_quotations.
     * @param {plan_group_quotationsUpsertArgs} args - Arguments to update or create a Plan_group_quotations.
     * @example
     * // Update or create a Plan_group_quotations
     * const plan_group_quotations = await prisma.plan_group_quotations.upsert({
     *   create: {
     *     // ... data to create a Plan_group_quotations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_group_quotations we want to update
     *   }
     * })
     */
    upsert<T extends plan_group_quotationsUpsertArgs>(args: SelectSubset<T, plan_group_quotationsUpsertArgs<ExtArgs>>): Prisma__plan_group_quotationsClient<$Result.GetResult<Prisma.$plan_group_quotationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plan_group_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_group_quotationsCountArgs} args - Arguments to filter Plan_group_quotations to count.
     * @example
     * // Count the number of Plan_group_quotations
     * const count = await prisma.plan_group_quotations.count({
     *   where: {
     *     // ... the filter for the Plan_group_quotations we want to count
     *   }
     * })
    **/
    count<T extends plan_group_quotationsCountArgs>(
      args?: Subset<T, plan_group_quotationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_group_quotationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_group_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_group_quotationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_group_quotationsAggregateArgs>(args: Subset<T, Plan_group_quotationsAggregateArgs>): Prisma.PrismaPromise<GetPlan_group_quotationsAggregateType<T>>

    /**
     * Group by Plan_group_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_group_quotationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_group_quotationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_group_quotationsGroupByArgs['orderBy'] }
        : { orderBy?: plan_group_quotationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_group_quotationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_group_quotationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plan_group_quotations model
   */
  readonly fields: plan_group_quotationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_group_quotations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plan_group_quotationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plan_group_quotations model
   */
  interface plan_group_quotationsFieldRefs {
    readonly id: FieldRef<"plan_group_quotations", 'BigInt'>
    readonly name: FieldRef<"plan_group_quotations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * plan_group_quotations findUnique
   */
  export type plan_group_quotationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_group_quotations to fetch.
     */
    where: plan_group_quotationsWhereUniqueInput
  }

  /**
   * plan_group_quotations findUniqueOrThrow
   */
  export type plan_group_quotationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_group_quotations to fetch.
     */
    where: plan_group_quotationsWhereUniqueInput
  }

  /**
   * plan_group_quotations findFirst
   */
  export type plan_group_quotationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_group_quotations to fetch.
     */
    where?: plan_group_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_group_quotations to fetch.
     */
    orderBy?: plan_group_quotationsOrderByWithRelationInput | plan_group_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_group_quotations.
     */
    cursor?: plan_group_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_group_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_group_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_group_quotations.
     */
    distinct?: Plan_group_quotationsScalarFieldEnum | Plan_group_quotationsScalarFieldEnum[]
  }

  /**
   * plan_group_quotations findFirstOrThrow
   */
  export type plan_group_quotationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_group_quotations to fetch.
     */
    where?: plan_group_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_group_quotations to fetch.
     */
    orderBy?: plan_group_quotationsOrderByWithRelationInput | plan_group_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_group_quotations.
     */
    cursor?: plan_group_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_group_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_group_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_group_quotations.
     */
    distinct?: Plan_group_quotationsScalarFieldEnum | Plan_group_quotationsScalarFieldEnum[]
  }

  /**
   * plan_group_quotations findMany
   */
  export type plan_group_quotationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_group_quotations to fetch.
     */
    where?: plan_group_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_group_quotations to fetch.
     */
    orderBy?: plan_group_quotationsOrderByWithRelationInput | plan_group_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_group_quotations.
     */
    cursor?: plan_group_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_group_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_group_quotations.
     */
    skip?: number
    distinct?: Plan_group_quotationsScalarFieldEnum | Plan_group_quotationsScalarFieldEnum[]
  }

  /**
   * plan_group_quotations create
   */
  export type plan_group_quotationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to create a plan_group_quotations.
     */
    data: XOR<plan_group_quotationsCreateInput, plan_group_quotationsUncheckedCreateInput>
  }

  /**
   * plan_group_quotations createMany
   */
  export type plan_group_quotationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_group_quotations.
     */
    data: plan_group_quotationsCreateManyInput | plan_group_quotationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plan_group_quotations update
   */
  export type plan_group_quotationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to update a plan_group_quotations.
     */
    data: XOR<plan_group_quotationsUpdateInput, plan_group_quotationsUncheckedUpdateInput>
    /**
     * Choose, which plan_group_quotations to update.
     */
    where: plan_group_quotationsWhereUniqueInput
  }

  /**
   * plan_group_quotations updateMany
   */
  export type plan_group_quotationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_group_quotations.
     */
    data: XOR<plan_group_quotationsUpdateManyMutationInput, plan_group_quotationsUncheckedUpdateManyInput>
    /**
     * Filter which plan_group_quotations to update
     */
    where?: plan_group_quotationsWhereInput
    /**
     * Limit how many plan_group_quotations to update.
     */
    limit?: number
  }

  /**
   * plan_group_quotations upsert
   */
  export type plan_group_quotationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * The filter to search for the plan_group_quotations to update in case it exists.
     */
    where: plan_group_quotationsWhereUniqueInput
    /**
     * In case the plan_group_quotations found by the `where` argument doesn't exist, create a new plan_group_quotations with this data.
     */
    create: XOR<plan_group_quotationsCreateInput, plan_group_quotationsUncheckedCreateInput>
    /**
     * In case the plan_group_quotations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_group_quotationsUpdateInput, plan_group_quotationsUncheckedUpdateInput>
  }

  /**
   * plan_group_quotations delete
   */
  export type plan_group_quotationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
    /**
     * Filter which plan_group_quotations to delete.
     */
    where: plan_group_quotationsWhereUniqueInput
  }

  /**
   * plan_group_quotations deleteMany
   */
  export type plan_group_quotationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_group_quotations to delete
     */
    where?: plan_group_quotationsWhereInput
    /**
     * Limit how many plan_group_quotations to delete.
     */
    limit?: number
  }

  /**
   * plan_group_quotations without action
   */
  export type plan_group_quotationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_group_quotations
     */
    select?: plan_group_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_group_quotations
     */
    omit?: plan_group_quotationsOmit<ExtArgs> | null
  }


  /**
   * Model plan_type_quotations
   */

  export type AggregatePlan_type_quotations = {
    _count: Plan_type_quotationsCountAggregateOutputType | null
    _avg: Plan_type_quotationsAvgAggregateOutputType | null
    _sum: Plan_type_quotationsSumAggregateOutputType | null
    _min: Plan_type_quotationsMinAggregateOutputType | null
    _max: Plan_type_quotationsMaxAggregateOutputType | null
  }

  export type Plan_type_quotationsAvgAggregateOutputType = {
    id: number | null
  }

  export type Plan_type_quotationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Plan_type_quotationsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Plan_type_quotationsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type Plan_type_quotationsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Plan_type_quotationsAvgAggregateInputType = {
    id?: true
  }

  export type Plan_type_quotationsSumAggregateInputType = {
    id?: true
  }

  export type Plan_type_quotationsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Plan_type_quotationsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Plan_type_quotationsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Plan_type_quotationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_type_quotations to aggregate.
     */
    where?: plan_type_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_type_quotations to fetch.
     */
    orderBy?: plan_type_quotationsOrderByWithRelationInput | plan_type_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_type_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_type_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_type_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_type_quotations
    **/
    _count?: true | Plan_type_quotationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plan_type_quotationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plan_type_quotationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_type_quotationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_type_quotationsMaxAggregateInputType
  }

  export type GetPlan_type_quotationsAggregateType<T extends Plan_type_quotationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_type_quotations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_type_quotations[P]>
      : GetScalarType<T[P], AggregatePlan_type_quotations[P]>
  }




  export type plan_type_quotationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plan_type_quotationsWhereInput
    orderBy?: plan_type_quotationsOrderByWithAggregationInput | plan_type_quotationsOrderByWithAggregationInput[]
    by: Plan_type_quotationsScalarFieldEnum[] | Plan_type_quotationsScalarFieldEnum
    having?: plan_type_quotationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_type_quotationsCountAggregateInputType | true
    _avg?: Plan_type_quotationsAvgAggregateInputType
    _sum?: Plan_type_quotationsSumAggregateInputType
    _min?: Plan_type_quotationsMinAggregateInputType
    _max?: Plan_type_quotationsMaxAggregateInputType
  }

  export type Plan_type_quotationsGroupByOutputType = {
    id: bigint
    name: string
    _count: Plan_type_quotationsCountAggregateOutputType | null
    _avg: Plan_type_quotationsAvgAggregateOutputType | null
    _sum: Plan_type_quotationsSumAggregateOutputType | null
    _min: Plan_type_quotationsMinAggregateOutputType | null
    _max: Plan_type_quotationsMaxAggregateOutputType | null
  }

  type GetPlan_type_quotationsGroupByPayload<T extends plan_type_quotationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_type_quotationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_type_quotationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_type_quotationsGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_type_quotationsGroupByOutputType[P]>
        }
      >
    >


  export type plan_type_quotationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["plan_type_quotations"]>



  export type plan_type_quotationsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type plan_type_quotationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["plan_type_quotations"]>

  export type $plan_type_quotationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plan_type_quotations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["plan_type_quotations"]>
    composites: {}
  }

  type plan_type_quotationsGetPayload<S extends boolean | null | undefined | plan_type_quotationsDefaultArgs> = $Result.GetResult<Prisma.$plan_type_quotationsPayload, S>

  type plan_type_quotationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plan_type_quotationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Plan_type_quotationsCountAggregateInputType | true
    }

  export interface plan_type_quotationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_type_quotations'], meta: { name: 'plan_type_quotations' } }
    /**
     * Find zero or one Plan_type_quotations that matches the filter.
     * @param {plan_type_quotationsFindUniqueArgs} args - Arguments to find a Plan_type_quotations
     * @example
     * // Get one Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plan_type_quotationsFindUniqueArgs>(args: SelectSubset<T, plan_type_quotationsFindUniqueArgs<ExtArgs>>): Prisma__plan_type_quotationsClient<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan_type_quotations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plan_type_quotationsFindUniqueOrThrowArgs} args - Arguments to find a Plan_type_quotations
     * @example
     * // Get one Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plan_type_quotationsFindUniqueOrThrowArgs>(args: SelectSubset<T, plan_type_quotationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plan_type_quotationsClient<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_type_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_type_quotationsFindFirstArgs} args - Arguments to find a Plan_type_quotations
     * @example
     * // Get one Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plan_type_quotationsFindFirstArgs>(args?: SelectSubset<T, plan_type_quotationsFindFirstArgs<ExtArgs>>): Prisma__plan_type_quotationsClient<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_type_quotations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_type_quotationsFindFirstOrThrowArgs} args - Arguments to find a Plan_type_quotations
     * @example
     * // Get one Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plan_type_quotationsFindFirstOrThrowArgs>(args?: SelectSubset<T, plan_type_quotationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__plan_type_quotationsClient<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plan_type_quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_type_quotationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.findMany()
     * 
     * // Get first 10 Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plan_type_quotationsWithIdOnly = await prisma.plan_type_quotations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plan_type_quotationsFindManyArgs>(args?: SelectSubset<T, plan_type_quotationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan_type_quotations.
     * @param {plan_type_quotationsCreateArgs} args - Arguments to create a Plan_type_quotations.
     * @example
     * // Create one Plan_type_quotations
     * const Plan_type_quotations = await prisma.plan_type_quotations.create({
     *   data: {
     *     // ... data to create a Plan_type_quotations
     *   }
     * })
     * 
     */
    create<T extends plan_type_quotationsCreateArgs>(args: SelectSubset<T, plan_type_quotationsCreateArgs<ExtArgs>>): Prisma__plan_type_quotationsClient<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plan_type_quotations.
     * @param {plan_type_quotationsCreateManyArgs} args - Arguments to create many Plan_type_quotations.
     * @example
     * // Create many Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plan_type_quotationsCreateManyArgs>(args?: SelectSubset<T, plan_type_quotationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_type_quotations.
     * @param {plan_type_quotationsDeleteArgs} args - Arguments to delete one Plan_type_quotations.
     * @example
     * // Delete one Plan_type_quotations
     * const Plan_type_quotations = await prisma.plan_type_quotations.delete({
     *   where: {
     *     // ... filter to delete one Plan_type_quotations
     *   }
     * })
     * 
     */
    delete<T extends plan_type_quotationsDeleteArgs>(args: SelectSubset<T, plan_type_quotationsDeleteArgs<ExtArgs>>): Prisma__plan_type_quotationsClient<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan_type_quotations.
     * @param {plan_type_quotationsUpdateArgs} args - Arguments to update one Plan_type_quotations.
     * @example
     * // Update one Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plan_type_quotationsUpdateArgs>(args: SelectSubset<T, plan_type_quotationsUpdateArgs<ExtArgs>>): Prisma__plan_type_quotationsClient<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plan_type_quotations.
     * @param {plan_type_quotationsDeleteManyArgs} args - Arguments to filter Plan_type_quotations to delete.
     * @example
     * // Delete a few Plan_type_quotations
     * const { count } = await prisma.plan_type_quotations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plan_type_quotationsDeleteManyArgs>(args?: SelectSubset<T, plan_type_quotationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_type_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_type_quotationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plan_type_quotationsUpdateManyArgs>(args: SelectSubset<T, plan_type_quotationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_type_quotations.
     * @param {plan_type_quotationsUpsertArgs} args - Arguments to update or create a Plan_type_quotations.
     * @example
     * // Update or create a Plan_type_quotations
     * const plan_type_quotations = await prisma.plan_type_quotations.upsert({
     *   create: {
     *     // ... data to create a Plan_type_quotations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_type_quotations we want to update
     *   }
     * })
     */
    upsert<T extends plan_type_quotationsUpsertArgs>(args: SelectSubset<T, plan_type_quotationsUpsertArgs<ExtArgs>>): Prisma__plan_type_quotationsClient<$Result.GetResult<Prisma.$plan_type_quotationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plan_type_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_type_quotationsCountArgs} args - Arguments to filter Plan_type_quotations to count.
     * @example
     * // Count the number of Plan_type_quotations
     * const count = await prisma.plan_type_quotations.count({
     *   where: {
     *     // ... the filter for the Plan_type_quotations we want to count
     *   }
     * })
    **/
    count<T extends plan_type_quotationsCountArgs>(
      args?: Subset<T, plan_type_quotationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_type_quotationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_type_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_type_quotationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_type_quotationsAggregateArgs>(args: Subset<T, Plan_type_quotationsAggregateArgs>): Prisma.PrismaPromise<GetPlan_type_quotationsAggregateType<T>>

    /**
     * Group by Plan_type_quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_type_quotationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_type_quotationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_type_quotationsGroupByArgs['orderBy'] }
        : { orderBy?: plan_type_quotationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_type_quotationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_type_quotationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plan_type_quotations model
   */
  readonly fields: plan_type_quotationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_type_quotations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plan_type_quotationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plan_type_quotations model
   */
  interface plan_type_quotationsFieldRefs {
    readonly id: FieldRef<"plan_type_quotations", 'BigInt'>
    readonly name: FieldRef<"plan_type_quotations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * plan_type_quotations findUnique
   */
  export type plan_type_quotationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_type_quotations to fetch.
     */
    where: plan_type_quotationsWhereUniqueInput
  }

  /**
   * plan_type_quotations findUniqueOrThrow
   */
  export type plan_type_quotationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_type_quotations to fetch.
     */
    where: plan_type_quotationsWhereUniqueInput
  }

  /**
   * plan_type_quotations findFirst
   */
  export type plan_type_quotationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_type_quotations to fetch.
     */
    where?: plan_type_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_type_quotations to fetch.
     */
    orderBy?: plan_type_quotationsOrderByWithRelationInput | plan_type_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_type_quotations.
     */
    cursor?: plan_type_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_type_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_type_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_type_quotations.
     */
    distinct?: Plan_type_quotationsScalarFieldEnum | Plan_type_quotationsScalarFieldEnum[]
  }

  /**
   * plan_type_quotations findFirstOrThrow
   */
  export type plan_type_quotationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_type_quotations to fetch.
     */
    where?: plan_type_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_type_quotations to fetch.
     */
    orderBy?: plan_type_quotationsOrderByWithRelationInput | plan_type_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_type_quotations.
     */
    cursor?: plan_type_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_type_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_type_quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_type_quotations.
     */
    distinct?: Plan_type_quotationsScalarFieldEnum | Plan_type_quotationsScalarFieldEnum[]
  }

  /**
   * plan_type_quotations findMany
   */
  export type plan_type_quotationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter, which plan_type_quotations to fetch.
     */
    where?: plan_type_quotationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_type_quotations to fetch.
     */
    orderBy?: plan_type_quotationsOrderByWithRelationInput | plan_type_quotationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_type_quotations.
     */
    cursor?: plan_type_quotationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_type_quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_type_quotations.
     */
    skip?: number
    distinct?: Plan_type_quotationsScalarFieldEnum | Plan_type_quotationsScalarFieldEnum[]
  }

  /**
   * plan_type_quotations create
   */
  export type plan_type_quotationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to create a plan_type_quotations.
     */
    data: XOR<plan_type_quotationsCreateInput, plan_type_quotationsUncheckedCreateInput>
  }

  /**
   * plan_type_quotations createMany
   */
  export type plan_type_quotationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_type_quotations.
     */
    data: plan_type_quotationsCreateManyInput | plan_type_quotationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plan_type_quotations update
   */
  export type plan_type_quotationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * The data needed to update a plan_type_quotations.
     */
    data: XOR<plan_type_quotationsUpdateInput, plan_type_quotationsUncheckedUpdateInput>
    /**
     * Choose, which plan_type_quotations to update.
     */
    where: plan_type_quotationsWhereUniqueInput
  }

  /**
   * plan_type_quotations updateMany
   */
  export type plan_type_quotationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_type_quotations.
     */
    data: XOR<plan_type_quotationsUpdateManyMutationInput, plan_type_quotationsUncheckedUpdateManyInput>
    /**
     * Filter which plan_type_quotations to update
     */
    where?: plan_type_quotationsWhereInput
    /**
     * Limit how many plan_type_quotations to update.
     */
    limit?: number
  }

  /**
   * plan_type_quotations upsert
   */
  export type plan_type_quotationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * The filter to search for the plan_type_quotations to update in case it exists.
     */
    where: plan_type_quotationsWhereUniqueInput
    /**
     * In case the plan_type_quotations found by the `where` argument doesn't exist, create a new plan_type_quotations with this data.
     */
    create: XOR<plan_type_quotationsCreateInput, plan_type_quotationsUncheckedCreateInput>
    /**
     * In case the plan_type_quotations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_type_quotationsUpdateInput, plan_type_quotationsUncheckedUpdateInput>
  }

  /**
   * plan_type_quotations delete
   */
  export type plan_type_quotationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
    /**
     * Filter which plan_type_quotations to delete.
     */
    where: plan_type_quotationsWhereUniqueInput
  }

  /**
   * plan_type_quotations deleteMany
   */
  export type plan_type_quotationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_type_quotations to delete
     */
    where?: plan_type_quotationsWhereInput
    /**
     * Limit how many plan_type_quotations to delete.
     */
    limit?: number
  }

  /**
   * plan_type_quotations without action
   */
  export type plan_type_quotationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type_quotations
     */
    select?: plan_type_quotationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type_quotations
     */
    omit?: plan_type_quotationsOmit<ExtArgs> | null
  }


  /**
   * Model problems_clt
   */

  export type AggregateProblems_clt = {
    _count: Problems_cltCountAggregateOutputType | null
    _min: Problems_cltMinAggregateOutputType | null
    _max: Problems_cltMaxAggregateOutputType | null
  }

  export type Problems_cltMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    problem: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Problems_cltMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    problem: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Problems_cltCountAggregateOutputType = {
    id: number
    user_id: number
    problem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Problems_cltMinAggregateInputType = {
    id?: true
    user_id?: true
    problem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Problems_cltMaxAggregateInputType = {
    id?: true
    user_id?: true
    problem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Problems_cltCountAggregateInputType = {
    id?: true
    user_id?: true
    problem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Problems_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problems_clt to aggregate.
     */
    where?: problems_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems_clts to fetch.
     */
    orderBy?: problems_cltOrderByWithRelationInput | problems_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: problems_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned problems_clts
    **/
    _count?: true | Problems_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Problems_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Problems_cltMaxAggregateInputType
  }

  export type GetProblems_cltAggregateType<T extends Problems_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateProblems_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblems_clt[P]>
      : GetScalarType<T[P], AggregateProblems_clt[P]>
  }




  export type problems_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problems_cltWhereInput
    orderBy?: problems_cltOrderByWithAggregationInput | problems_cltOrderByWithAggregationInput[]
    by: Problems_cltScalarFieldEnum[] | Problems_cltScalarFieldEnum
    having?: problems_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Problems_cltCountAggregateInputType | true
    _min?: Problems_cltMinAggregateInputType
    _max?: Problems_cltMaxAggregateInputType
  }

  export type Problems_cltGroupByOutputType = {
    id: string
    user_id: string
    problem: string
    createdAt: Date
    updatedAt: Date
    _count: Problems_cltCountAggregateOutputType | null
    _min: Problems_cltMinAggregateOutputType | null
    _max: Problems_cltMaxAggregateOutputType | null
  }

  type GetProblems_cltGroupByPayload<T extends problems_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Problems_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Problems_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Problems_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Problems_cltGroupByOutputType[P]>
        }
      >
    >


  export type problems_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    problem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["problems_clt"]>



  export type problems_cltSelectScalar = {
    id?: boolean
    user_id?: boolean
    problem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type problems_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "problem" | "createdAt" | "updatedAt", ExtArgs["result"]["problems_clt"]>

  export type $problems_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "problems_clt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      problem: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["problems_clt"]>
    composites: {}
  }

  type problems_cltGetPayload<S extends boolean | null | undefined | problems_cltDefaultArgs> = $Result.GetResult<Prisma.$problems_cltPayload, S>

  type problems_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<problems_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Problems_cltCountAggregateInputType | true
    }

  export interface problems_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['problems_clt'], meta: { name: 'problems_clt' } }
    /**
     * Find zero or one Problems_clt that matches the filter.
     * @param {problems_cltFindUniqueArgs} args - Arguments to find a Problems_clt
     * @example
     * // Get one Problems_clt
     * const problems_clt = await prisma.problems_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends problems_cltFindUniqueArgs>(args: SelectSubset<T, problems_cltFindUniqueArgs<ExtArgs>>): Prisma__problems_cltClient<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Problems_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {problems_cltFindUniqueOrThrowArgs} args - Arguments to find a Problems_clt
     * @example
     * // Get one Problems_clt
     * const problems_clt = await prisma.problems_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends problems_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, problems_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__problems_cltClient<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Problems_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_cltFindFirstArgs} args - Arguments to find a Problems_clt
     * @example
     * // Get one Problems_clt
     * const problems_clt = await prisma.problems_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends problems_cltFindFirstArgs>(args?: SelectSubset<T, problems_cltFindFirstArgs<ExtArgs>>): Prisma__problems_cltClient<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Problems_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_cltFindFirstOrThrowArgs} args - Arguments to find a Problems_clt
     * @example
     * // Get one Problems_clt
     * const problems_clt = await prisma.problems_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends problems_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, problems_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__problems_cltClient<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Problems_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problems_clts
     * const problems_clts = await prisma.problems_clt.findMany()
     * 
     * // Get first 10 Problems_clts
     * const problems_clts = await prisma.problems_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const problems_cltWithIdOnly = await prisma.problems_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends problems_cltFindManyArgs>(args?: SelectSubset<T, problems_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Problems_clt.
     * @param {problems_cltCreateArgs} args - Arguments to create a Problems_clt.
     * @example
     * // Create one Problems_clt
     * const Problems_clt = await prisma.problems_clt.create({
     *   data: {
     *     // ... data to create a Problems_clt
     *   }
     * })
     * 
     */
    create<T extends problems_cltCreateArgs>(args: SelectSubset<T, problems_cltCreateArgs<ExtArgs>>): Prisma__problems_cltClient<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Problems_clts.
     * @param {problems_cltCreateManyArgs} args - Arguments to create many Problems_clts.
     * @example
     * // Create many Problems_clts
     * const problems_clt = await prisma.problems_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends problems_cltCreateManyArgs>(args?: SelectSubset<T, problems_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Problems_clt.
     * @param {problems_cltDeleteArgs} args - Arguments to delete one Problems_clt.
     * @example
     * // Delete one Problems_clt
     * const Problems_clt = await prisma.problems_clt.delete({
     *   where: {
     *     // ... filter to delete one Problems_clt
     *   }
     * })
     * 
     */
    delete<T extends problems_cltDeleteArgs>(args: SelectSubset<T, problems_cltDeleteArgs<ExtArgs>>): Prisma__problems_cltClient<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Problems_clt.
     * @param {problems_cltUpdateArgs} args - Arguments to update one Problems_clt.
     * @example
     * // Update one Problems_clt
     * const problems_clt = await prisma.problems_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends problems_cltUpdateArgs>(args: SelectSubset<T, problems_cltUpdateArgs<ExtArgs>>): Prisma__problems_cltClient<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Problems_clts.
     * @param {problems_cltDeleteManyArgs} args - Arguments to filter Problems_clts to delete.
     * @example
     * // Delete a few Problems_clts
     * const { count } = await prisma.problems_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends problems_cltDeleteManyArgs>(args?: SelectSubset<T, problems_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problems_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problems_clts
     * const problems_clt = await prisma.problems_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends problems_cltUpdateManyArgs>(args: SelectSubset<T, problems_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Problems_clt.
     * @param {problems_cltUpsertArgs} args - Arguments to update or create a Problems_clt.
     * @example
     * // Update or create a Problems_clt
     * const problems_clt = await prisma.problems_clt.upsert({
     *   create: {
     *     // ... data to create a Problems_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problems_clt we want to update
     *   }
     * })
     */
    upsert<T extends problems_cltUpsertArgs>(args: SelectSubset<T, problems_cltUpsertArgs<ExtArgs>>): Prisma__problems_cltClient<$Result.GetResult<Prisma.$problems_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Problems_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_cltCountArgs} args - Arguments to filter Problems_clts to count.
     * @example
     * // Count the number of Problems_clts
     * const count = await prisma.problems_clt.count({
     *   where: {
     *     // ... the filter for the Problems_clts we want to count
     *   }
     * })
    **/
    count<T extends problems_cltCountArgs>(
      args?: Subset<T, problems_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Problems_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problems_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Problems_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Problems_cltAggregateArgs>(args: Subset<T, Problems_cltAggregateArgs>): Prisma.PrismaPromise<GetProblems_cltAggregateType<T>>

    /**
     * Group by Problems_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends problems_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: problems_cltGroupByArgs['orderBy'] }
        : { orderBy?: problems_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, problems_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblems_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the problems_clt model
   */
  readonly fields: problems_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for problems_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__problems_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the problems_clt model
   */
  interface problems_cltFieldRefs {
    readonly id: FieldRef<"problems_clt", 'String'>
    readonly user_id: FieldRef<"problems_clt", 'String'>
    readonly problem: FieldRef<"problems_clt", 'String'>
    readonly createdAt: FieldRef<"problems_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"problems_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * problems_clt findUnique
   */
  export type problems_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * Filter, which problems_clt to fetch.
     */
    where: problems_cltWhereUniqueInput
  }

  /**
   * problems_clt findUniqueOrThrow
   */
  export type problems_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * Filter, which problems_clt to fetch.
     */
    where: problems_cltWhereUniqueInput
  }

  /**
   * problems_clt findFirst
   */
  export type problems_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * Filter, which problems_clt to fetch.
     */
    where?: problems_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems_clts to fetch.
     */
    orderBy?: problems_cltOrderByWithRelationInput | problems_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problems_clts.
     */
    cursor?: problems_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problems_clts.
     */
    distinct?: Problems_cltScalarFieldEnum | Problems_cltScalarFieldEnum[]
  }

  /**
   * problems_clt findFirstOrThrow
   */
  export type problems_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * Filter, which problems_clt to fetch.
     */
    where?: problems_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems_clts to fetch.
     */
    orderBy?: problems_cltOrderByWithRelationInput | problems_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problems_clts.
     */
    cursor?: problems_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problems_clts.
     */
    distinct?: Problems_cltScalarFieldEnum | Problems_cltScalarFieldEnum[]
  }

  /**
   * problems_clt findMany
   */
  export type problems_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * Filter, which problems_clts to fetch.
     */
    where?: problems_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems_clts to fetch.
     */
    orderBy?: problems_cltOrderByWithRelationInput | problems_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing problems_clts.
     */
    cursor?: problems_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems_clts.
     */
    skip?: number
    distinct?: Problems_cltScalarFieldEnum | Problems_cltScalarFieldEnum[]
  }

  /**
   * problems_clt create
   */
  export type problems_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * The data needed to create a problems_clt.
     */
    data: XOR<problems_cltCreateInput, problems_cltUncheckedCreateInput>
  }

  /**
   * problems_clt createMany
   */
  export type problems_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many problems_clts.
     */
    data: problems_cltCreateManyInput | problems_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * problems_clt update
   */
  export type problems_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * The data needed to update a problems_clt.
     */
    data: XOR<problems_cltUpdateInput, problems_cltUncheckedUpdateInput>
    /**
     * Choose, which problems_clt to update.
     */
    where: problems_cltWhereUniqueInput
  }

  /**
   * problems_clt updateMany
   */
  export type problems_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update problems_clts.
     */
    data: XOR<problems_cltUpdateManyMutationInput, problems_cltUncheckedUpdateManyInput>
    /**
     * Filter which problems_clts to update
     */
    where?: problems_cltWhereInput
    /**
     * Limit how many problems_clts to update.
     */
    limit?: number
  }

  /**
   * problems_clt upsert
   */
  export type problems_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * The filter to search for the problems_clt to update in case it exists.
     */
    where: problems_cltWhereUniqueInput
    /**
     * In case the problems_clt found by the `where` argument doesn't exist, create a new problems_clt with this data.
     */
    create: XOR<problems_cltCreateInput, problems_cltUncheckedCreateInput>
    /**
     * In case the problems_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<problems_cltUpdateInput, problems_cltUncheckedUpdateInput>
  }

  /**
   * problems_clt delete
   */
  export type problems_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
    /**
     * Filter which problems_clt to delete.
     */
    where: problems_cltWhereUniqueInput
  }

  /**
   * problems_clt deleteMany
   */
  export type problems_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problems_clts to delete
     */
    where?: problems_cltWhereInput
    /**
     * Limit how many problems_clts to delete.
     */
    limit?: number
  }

  /**
   * problems_clt without action
   */
  export type problems_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_clt
     */
    select?: problems_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the problems_clt
     */
    omit?: problems_cltOmit<ExtArgs> | null
  }


  /**
   * Model Quotation
   */

  export type AggregateQuotation = {
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  export type QuotationAvgAggregateOutputType = {
    id: number | null
    preco_00_a_18_anos: Decimal | null
    preco_19_a_23_anos: Decimal | null
    preco_24_a_28_anos: Decimal | null
    preco_29_a_33_anos: Decimal | null
    preco_34_a_38_anos: Decimal | null
    preco_39_a_43_anos: Decimal | null
    preco_44_a_48_anos: Decimal | null
    preco_49_a_53_anos: Decimal | null
    preco_54_a_58_anos: Decimal | null
    preco_59_anos_ou_mais: Decimal | null
    preco_todas_idades: Decimal | null
    consultas_eletivas: Decimal | null
    consultas_urgencia: Decimal | null
    exames_simples: Decimal | null
    exames_complexos: Decimal | null
    terapias_neurologicas: Decimal | null
    demais_terapias: Decimal | null
    desconto_vidas: number | null
  }

  export type QuotationSumAggregateOutputType = {
    id: bigint | null
    preco_00_a_18_anos: Decimal | null
    preco_19_a_23_anos: Decimal | null
    preco_24_a_28_anos: Decimal | null
    preco_29_a_33_anos: Decimal | null
    preco_34_a_38_anos: Decimal | null
    preco_39_a_43_anos: Decimal | null
    preco_44_a_48_anos: Decimal | null
    preco_49_a_53_anos: Decimal | null
    preco_54_a_58_anos: Decimal | null
    preco_59_anos_ou_mais: Decimal | null
    preco_todas_idades: Decimal | null
    consultas_eletivas: Decimal | null
    consultas_urgencia: Decimal | null
    exames_simples: Decimal | null
    exames_complexos: Decimal | null
    terapias_neurologicas: Decimal | null
    demais_terapias: Decimal | null
    desconto_vidas: number | null
  }

  export type QuotationMinAggregateOutputType = {
    id: bigint | null
    plano_grupo: string | null
    estado: string | null
    coparticipacao_tipo: string | null
    segmentacao: string | null
    acomodacao: string | null
    assistencia_modalidade: string | null
    codigo_interno: string | null
    registro_ans: string | null
    cidade: string | null
    validade_valores: string | null
    tipo_plano: string | null
    preco_00_a_18_anos: Decimal | null
    preco_19_a_23_anos: Decimal | null
    preco_24_a_28_anos: Decimal | null
    preco_29_a_33_anos: Decimal | null
    preco_34_a_38_anos: Decimal | null
    preco_39_a_43_anos: Decimal | null
    preco_44_a_48_anos: Decimal | null
    preco_49_a_53_anos: Decimal | null
    preco_54_a_58_anos: Decimal | null
    preco_59_anos_ou_mais: Decimal | null
    preco_todas_idades: Decimal | null
    consultas_eletivas: Decimal | null
    consultas_urgencia: Decimal | null
    exames_simples: Decimal | null
    exames_complexos: Decimal | null
    terapias_neurologicas: Decimal | null
    demais_terapias: Decimal | null
    desconto_vidas: number | null
    desconto_familiares: string | null
    quantidade_de_familiares: string | null
    campo_vigencia: string | null
  }

  export type QuotationMaxAggregateOutputType = {
    id: bigint | null
    plano_grupo: string | null
    estado: string | null
    coparticipacao_tipo: string | null
    segmentacao: string | null
    acomodacao: string | null
    assistencia_modalidade: string | null
    codigo_interno: string | null
    registro_ans: string | null
    cidade: string | null
    validade_valores: string | null
    tipo_plano: string | null
    preco_00_a_18_anos: Decimal | null
    preco_19_a_23_anos: Decimal | null
    preco_24_a_28_anos: Decimal | null
    preco_29_a_33_anos: Decimal | null
    preco_34_a_38_anos: Decimal | null
    preco_39_a_43_anos: Decimal | null
    preco_44_a_48_anos: Decimal | null
    preco_49_a_53_anos: Decimal | null
    preco_54_a_58_anos: Decimal | null
    preco_59_anos_ou_mais: Decimal | null
    preco_todas_idades: Decimal | null
    consultas_eletivas: Decimal | null
    consultas_urgencia: Decimal | null
    exames_simples: Decimal | null
    exames_complexos: Decimal | null
    terapias_neurologicas: Decimal | null
    demais_terapias: Decimal | null
    desconto_vidas: number | null
    desconto_familiares: string | null
    quantidade_de_familiares: string | null
    campo_vigencia: string | null
  }

  export type QuotationCountAggregateOutputType = {
    id: number
    plano_grupo: number
    estado: number
    coparticipacao_tipo: number
    segmentacao: number
    acomodacao: number
    assistencia_modalidade: number
    codigo_interno: number
    registro_ans: number
    cidade: number
    validade_valores: number
    tipo_plano: number
    preco_00_a_18_anos: number
    preco_19_a_23_anos: number
    preco_24_a_28_anos: number
    preco_29_a_33_anos: number
    preco_34_a_38_anos: number
    preco_39_a_43_anos: number
    preco_44_a_48_anos: number
    preco_49_a_53_anos: number
    preco_54_a_58_anos: number
    preco_59_anos_ou_mais: number
    preco_todas_idades: number
    consultas_eletivas: number
    consultas_urgencia: number
    exames_simples: number
    exames_complexos: number
    terapias_neurologicas: number
    demais_terapias: number
    desconto_vidas: number
    desconto_familiares: number
    quantidade_de_familiares: number
    campo_vigencia: number
    _all: number
  }


  export type QuotationAvgAggregateInputType = {
    id?: true
    preco_00_a_18_anos?: true
    preco_19_a_23_anos?: true
    preco_24_a_28_anos?: true
    preco_29_a_33_anos?: true
    preco_34_a_38_anos?: true
    preco_39_a_43_anos?: true
    preco_44_a_48_anos?: true
    preco_49_a_53_anos?: true
    preco_54_a_58_anos?: true
    preco_59_anos_ou_mais?: true
    preco_todas_idades?: true
    consultas_eletivas?: true
    consultas_urgencia?: true
    exames_simples?: true
    exames_complexos?: true
    terapias_neurologicas?: true
    demais_terapias?: true
    desconto_vidas?: true
  }

  export type QuotationSumAggregateInputType = {
    id?: true
    preco_00_a_18_anos?: true
    preco_19_a_23_anos?: true
    preco_24_a_28_anos?: true
    preco_29_a_33_anos?: true
    preco_34_a_38_anos?: true
    preco_39_a_43_anos?: true
    preco_44_a_48_anos?: true
    preco_49_a_53_anos?: true
    preco_54_a_58_anos?: true
    preco_59_anos_ou_mais?: true
    preco_todas_idades?: true
    consultas_eletivas?: true
    consultas_urgencia?: true
    exames_simples?: true
    exames_complexos?: true
    terapias_neurologicas?: true
    demais_terapias?: true
    desconto_vidas?: true
  }

  export type QuotationMinAggregateInputType = {
    id?: true
    plano_grupo?: true
    estado?: true
    coparticipacao_tipo?: true
    segmentacao?: true
    acomodacao?: true
    assistencia_modalidade?: true
    codigo_interno?: true
    registro_ans?: true
    cidade?: true
    validade_valores?: true
    tipo_plano?: true
    preco_00_a_18_anos?: true
    preco_19_a_23_anos?: true
    preco_24_a_28_anos?: true
    preco_29_a_33_anos?: true
    preco_34_a_38_anos?: true
    preco_39_a_43_anos?: true
    preco_44_a_48_anos?: true
    preco_49_a_53_anos?: true
    preco_54_a_58_anos?: true
    preco_59_anos_ou_mais?: true
    preco_todas_idades?: true
    consultas_eletivas?: true
    consultas_urgencia?: true
    exames_simples?: true
    exames_complexos?: true
    terapias_neurologicas?: true
    demais_terapias?: true
    desconto_vidas?: true
    desconto_familiares?: true
    quantidade_de_familiares?: true
    campo_vigencia?: true
  }

  export type QuotationMaxAggregateInputType = {
    id?: true
    plano_grupo?: true
    estado?: true
    coparticipacao_tipo?: true
    segmentacao?: true
    acomodacao?: true
    assistencia_modalidade?: true
    codigo_interno?: true
    registro_ans?: true
    cidade?: true
    validade_valores?: true
    tipo_plano?: true
    preco_00_a_18_anos?: true
    preco_19_a_23_anos?: true
    preco_24_a_28_anos?: true
    preco_29_a_33_anos?: true
    preco_34_a_38_anos?: true
    preco_39_a_43_anos?: true
    preco_44_a_48_anos?: true
    preco_49_a_53_anos?: true
    preco_54_a_58_anos?: true
    preco_59_anos_ou_mais?: true
    preco_todas_idades?: true
    consultas_eletivas?: true
    consultas_urgencia?: true
    exames_simples?: true
    exames_complexos?: true
    terapias_neurologicas?: true
    demais_terapias?: true
    desconto_vidas?: true
    desconto_familiares?: true
    quantidade_de_familiares?: true
    campo_vigencia?: true
  }

  export type QuotationCountAggregateInputType = {
    id?: true
    plano_grupo?: true
    estado?: true
    coparticipacao_tipo?: true
    segmentacao?: true
    acomodacao?: true
    assistencia_modalidade?: true
    codigo_interno?: true
    registro_ans?: true
    cidade?: true
    validade_valores?: true
    tipo_plano?: true
    preco_00_a_18_anos?: true
    preco_19_a_23_anos?: true
    preco_24_a_28_anos?: true
    preco_29_a_33_anos?: true
    preco_34_a_38_anos?: true
    preco_39_a_43_anos?: true
    preco_44_a_48_anos?: true
    preco_49_a_53_anos?: true
    preco_54_a_58_anos?: true
    preco_59_anos_ou_mais?: true
    preco_todas_idades?: true
    consultas_eletivas?: true
    consultas_urgencia?: true
    exames_simples?: true
    exames_complexos?: true
    terapias_neurologicas?: true
    demais_terapias?: true
    desconto_vidas?: true
    desconto_familiares?: true
    quantidade_de_familiares?: true
    campo_vigencia?: true
    _all?: true
  }

  export type QuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotation to aggregate.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotations
    **/
    _count?: true | QuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationMaxAggregateInputType
  }

  export type GetQuotationAggregateType<T extends QuotationAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotation[P]>
      : GetScalarType<T[P], AggregateQuotation[P]>
  }




  export type QuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithAggregationInput | QuotationOrderByWithAggregationInput[]
    by: QuotationScalarFieldEnum[] | QuotationScalarFieldEnum
    having?: QuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationCountAggregateInputType | true
    _avg?: QuotationAvgAggregateInputType
    _sum?: QuotationSumAggregateInputType
    _min?: QuotationMinAggregateInputType
    _max?: QuotationMaxAggregateInputType
  }

  export type QuotationGroupByOutputType = {
    id: bigint
    plano_grupo: string
    estado: string
    coparticipacao_tipo: string
    segmentacao: string | null
    acomodacao: string
    assistencia_modalidade: string
    codigo_interno: string | null
    registro_ans: string | null
    cidade: string
    validade_valores: string | null
    tipo_plano: string
    preco_00_a_18_anos: Decimal | null
    preco_19_a_23_anos: Decimal | null
    preco_24_a_28_anos: Decimal | null
    preco_29_a_33_anos: Decimal | null
    preco_34_a_38_anos: Decimal | null
    preco_39_a_43_anos: Decimal | null
    preco_44_a_48_anos: Decimal | null
    preco_49_a_53_anos: Decimal | null
    preco_54_a_58_anos: Decimal | null
    preco_59_anos_ou_mais: Decimal | null
    preco_todas_idades: Decimal | null
    consultas_eletivas: Decimal | null
    consultas_urgencia: Decimal | null
    exames_simples: Decimal | null
    exames_complexos: Decimal | null
    terapias_neurologicas: Decimal | null
    demais_terapias: Decimal | null
    desconto_vidas: number | null
    desconto_familiares: string | null
    quantidade_de_familiares: string | null
    campo_vigencia: string | null
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  type GetQuotationGroupByPayload<T extends QuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationGroupByOutputType[P]>
        }
      >
    >


  export type QuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plano_grupo?: boolean
    estado?: boolean
    coparticipacao_tipo?: boolean
    segmentacao?: boolean
    acomodacao?: boolean
    assistencia_modalidade?: boolean
    codigo_interno?: boolean
    registro_ans?: boolean
    cidade?: boolean
    validade_valores?: boolean
    tipo_plano?: boolean
    preco_00_a_18_anos?: boolean
    preco_19_a_23_anos?: boolean
    preco_24_a_28_anos?: boolean
    preco_29_a_33_anos?: boolean
    preco_34_a_38_anos?: boolean
    preco_39_a_43_anos?: boolean
    preco_44_a_48_anos?: boolean
    preco_49_a_53_anos?: boolean
    preco_54_a_58_anos?: boolean
    preco_59_anos_ou_mais?: boolean
    preco_todas_idades?: boolean
    consultas_eletivas?: boolean
    consultas_urgencia?: boolean
    exames_simples?: boolean
    exames_complexos?: boolean
    terapias_neurologicas?: boolean
    demais_terapias?: boolean
    desconto_vidas?: boolean
    desconto_familiares?: boolean
    quantidade_de_familiares?: boolean
    campo_vigencia?: boolean
  }, ExtArgs["result"]["quotation"]>



  export type QuotationSelectScalar = {
    id?: boolean
    plano_grupo?: boolean
    estado?: boolean
    coparticipacao_tipo?: boolean
    segmentacao?: boolean
    acomodacao?: boolean
    assistencia_modalidade?: boolean
    codigo_interno?: boolean
    registro_ans?: boolean
    cidade?: boolean
    validade_valores?: boolean
    tipo_plano?: boolean
    preco_00_a_18_anos?: boolean
    preco_19_a_23_anos?: boolean
    preco_24_a_28_anos?: boolean
    preco_29_a_33_anos?: boolean
    preco_34_a_38_anos?: boolean
    preco_39_a_43_anos?: boolean
    preco_44_a_48_anos?: boolean
    preco_49_a_53_anos?: boolean
    preco_54_a_58_anos?: boolean
    preco_59_anos_ou_mais?: boolean
    preco_todas_idades?: boolean
    consultas_eletivas?: boolean
    consultas_urgencia?: boolean
    exames_simples?: boolean
    exames_complexos?: boolean
    terapias_neurologicas?: boolean
    demais_terapias?: boolean
    desconto_vidas?: boolean
    desconto_familiares?: boolean
    quantidade_de_familiares?: boolean
    campo_vigencia?: boolean
  }

  export type QuotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plano_grupo" | "estado" | "coparticipacao_tipo" | "segmentacao" | "acomodacao" | "assistencia_modalidade" | "codigo_interno" | "registro_ans" | "cidade" | "validade_valores" | "tipo_plano" | "preco_00_a_18_anos" | "preco_19_a_23_anos" | "preco_24_a_28_anos" | "preco_29_a_33_anos" | "preco_34_a_38_anos" | "preco_39_a_43_anos" | "preco_44_a_48_anos" | "preco_49_a_53_anos" | "preco_54_a_58_anos" | "preco_59_anos_ou_mais" | "preco_todas_idades" | "consultas_eletivas" | "consultas_urgencia" | "exames_simples" | "exames_complexos" | "terapias_neurologicas" | "demais_terapias" | "desconto_vidas" | "desconto_familiares" | "quantidade_de_familiares" | "campo_vigencia", ExtArgs["result"]["quotation"]>

  export type $QuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quotation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      plano_grupo: string
      estado: string
      coparticipacao_tipo: string
      segmentacao: string | null
      acomodacao: string
      assistencia_modalidade: string
      codigo_interno: string | null
      registro_ans: string | null
      cidade: string
      validade_valores: string | null
      tipo_plano: string
      preco_00_a_18_anos: Prisma.Decimal | null
      preco_19_a_23_anos: Prisma.Decimal | null
      preco_24_a_28_anos: Prisma.Decimal | null
      preco_29_a_33_anos: Prisma.Decimal | null
      preco_34_a_38_anos: Prisma.Decimal | null
      preco_39_a_43_anos: Prisma.Decimal | null
      preco_44_a_48_anos: Prisma.Decimal | null
      preco_49_a_53_anos: Prisma.Decimal | null
      preco_54_a_58_anos: Prisma.Decimal | null
      preco_59_anos_ou_mais: Prisma.Decimal | null
      preco_todas_idades: Prisma.Decimal | null
      consultas_eletivas: Prisma.Decimal | null
      consultas_urgencia: Prisma.Decimal | null
      exames_simples: Prisma.Decimal | null
      exames_complexos: Prisma.Decimal | null
      terapias_neurologicas: Prisma.Decimal | null
      demais_terapias: Prisma.Decimal | null
      desconto_vidas: number | null
      desconto_familiares: string | null
      quantidade_de_familiares: string | null
      campo_vigencia: string | null
    }, ExtArgs["result"]["quotation"]>
    composites: {}
  }

  type QuotationGetPayload<S extends boolean | null | undefined | QuotationDefaultArgs> = $Result.GetResult<Prisma.$QuotationPayload, S>

  type QuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationCountAggregateInputType | true
    }

  export interface QuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quotation'], meta: { name: 'Quotation' } }
    /**
     * Find zero or one Quotation that matches the filter.
     * @param {QuotationFindUniqueArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationFindUniqueArgs>(args: SelectSubset<T, QuotationFindUniqueArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationFindUniqueOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationFindFirstArgs>(args?: SelectSubset<T, QuotationFindFirstArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotations
     * const quotations = await prisma.quotation.findMany()
     * 
     * // Get first 10 Quotations
     * const quotations = await prisma.quotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationWithIdOnly = await prisma.quotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationFindManyArgs>(args?: SelectSubset<T, QuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quotation.
     * @param {QuotationCreateArgs} args - Arguments to create a Quotation.
     * @example
     * // Create one Quotation
     * const Quotation = await prisma.quotation.create({
     *   data: {
     *     // ... data to create a Quotation
     *   }
     * })
     * 
     */
    create<T extends QuotationCreateArgs>(args: SelectSubset<T, QuotationCreateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotations.
     * @param {QuotationCreateManyArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationCreateManyArgs>(args?: SelectSubset<T, QuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quotation.
     * @param {QuotationDeleteArgs} args - Arguments to delete one Quotation.
     * @example
     * // Delete one Quotation
     * const Quotation = await prisma.quotation.delete({
     *   where: {
     *     // ... filter to delete one Quotation
     *   }
     * })
     * 
     */
    delete<T extends QuotationDeleteArgs>(args: SelectSubset<T, QuotationDeleteArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quotation.
     * @param {QuotationUpdateArgs} args - Arguments to update one Quotation.
     * @example
     * // Update one Quotation
     * const quotation = await prisma.quotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationUpdateArgs>(args: SelectSubset<T, QuotationUpdateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotations.
     * @param {QuotationDeleteManyArgs} args - Arguments to filter Quotations to delete.
     * @example
     * // Delete a few Quotations
     * const { count } = await prisma.quotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationDeleteManyArgs>(args?: SelectSubset<T, QuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationUpdateManyArgs>(args: SelectSubset<T, QuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quotation.
     * @param {QuotationUpsertArgs} args - Arguments to update or create a Quotation.
     * @example
     * // Update or create a Quotation
     * const quotation = await prisma.quotation.upsert({
     *   create: {
     *     // ... data to create a Quotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation we want to update
     *   }
     * })
     */
    upsert<T extends QuotationUpsertArgs>(args: SelectSubset<T, QuotationUpsertArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationCountArgs} args - Arguments to filter Quotations to count.
     * @example
     * // Count the number of Quotations
     * const count = await prisma.quotation.count({
     *   where: {
     *     // ... the filter for the Quotations we want to count
     *   }
     * })
    **/
    count<T extends QuotationCountArgs>(
      args?: Subset<T, QuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationAggregateArgs>(args: Subset<T, QuotationAggregateArgs>): Prisma.PrismaPromise<GetQuotationAggregateType<T>>

    /**
     * Group by Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationGroupByArgs['orderBy'] }
        : { orderBy?: QuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quotation model
   */
  readonly fields: QuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quotation model
   */
  interface QuotationFieldRefs {
    readonly id: FieldRef<"Quotation", 'BigInt'>
    readonly plano_grupo: FieldRef<"Quotation", 'String'>
    readonly estado: FieldRef<"Quotation", 'String'>
    readonly coparticipacao_tipo: FieldRef<"Quotation", 'String'>
    readonly segmentacao: FieldRef<"Quotation", 'String'>
    readonly acomodacao: FieldRef<"Quotation", 'String'>
    readonly assistencia_modalidade: FieldRef<"Quotation", 'String'>
    readonly codigo_interno: FieldRef<"Quotation", 'String'>
    readonly registro_ans: FieldRef<"Quotation", 'String'>
    readonly cidade: FieldRef<"Quotation", 'String'>
    readonly validade_valores: FieldRef<"Quotation", 'String'>
    readonly tipo_plano: FieldRef<"Quotation", 'String'>
    readonly preco_00_a_18_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_19_a_23_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_24_a_28_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_29_a_33_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_34_a_38_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_39_a_43_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_44_a_48_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_49_a_53_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_54_a_58_anos: FieldRef<"Quotation", 'Decimal'>
    readonly preco_59_anos_ou_mais: FieldRef<"Quotation", 'Decimal'>
    readonly preco_todas_idades: FieldRef<"Quotation", 'Decimal'>
    readonly consultas_eletivas: FieldRef<"Quotation", 'Decimal'>
    readonly consultas_urgencia: FieldRef<"Quotation", 'Decimal'>
    readonly exames_simples: FieldRef<"Quotation", 'Decimal'>
    readonly exames_complexos: FieldRef<"Quotation", 'Decimal'>
    readonly terapias_neurologicas: FieldRef<"Quotation", 'Decimal'>
    readonly demais_terapias: FieldRef<"Quotation", 'Decimal'>
    readonly desconto_vidas: FieldRef<"Quotation", 'Int'>
    readonly desconto_familiares: FieldRef<"Quotation", 'String'>
    readonly quantidade_de_familiares: FieldRef<"Quotation", 'String'>
    readonly campo_vigencia: FieldRef<"Quotation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Quotation findUnique
   */
  export type QuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findUniqueOrThrow
   */
  export type QuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findFirst
   */
  export type QuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findFirstOrThrow
   */
  export type QuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findMany
   */
  export type QuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Filter, which Quotations to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation create
   */
  export type QuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data needed to create a Quotation.
     */
    data: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
  }

  /**
   * Quotation createMany
   */
  export type QuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quotation update
   */
  export type QuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data needed to update a Quotation.
     */
    data: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
    /**
     * Choose, which Quotation to update.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation updateMany
   */
  export type QuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
  }

  /**
   * Quotation upsert
   */
  export type QuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The filter to search for the Quotation to update in case it exists.
     */
    where: QuotationWhereUniqueInput
    /**
     * In case the Quotation found by the `where` argument doesn't exist, create a new Quotation with this data.
     */
    create: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
    /**
     * In case the Quotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
  }

  /**
   * Quotation delete
   */
  export type QuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Filter which Quotation to delete.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation deleteMany
   */
  export type QuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotations to delete
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to delete.
     */
    limit?: number
  }

  /**
   * Quotation without action
   */
  export type QuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
  }


  /**
   * Model quote_calculations_aut
   */

  export type AggregateQuote_calculations_aut = {
    _count: Quote_calculations_autCountAggregateOutputType | null
    _min: Quote_calculations_autMinAggregateOutputType | null
    _max: Quote_calculations_autMaxAggregateOutputType | null
  }

  export type Quote_calculations_autMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_name: string | null
    consultant_name: string | null
    ages: string | null
    accommodation: string | null
    plan_type: string | null
    square: string | null
    is_odonto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Quote_calculations_autMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_name: string | null
    consultant_name: string | null
    ages: string | null
    accommodation: string | null
    plan_type: string | null
    square: string | null
    is_odonto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Quote_calculations_autCountAggregateOutputType = {
    id: number
    user_id: number
    client_name: number
    consultant_name: number
    ages: number
    accommodation: number
    plan_type: number
    square: number
    is_odonto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Quote_calculations_autMinAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Quote_calculations_autMaxAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Quote_calculations_autCountAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Quote_calculations_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_calculations_aut to aggregate.
     */
    where?: quote_calculations_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_auts to fetch.
     */
    orderBy?: quote_calculations_autOrderByWithRelationInput | quote_calculations_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quote_calculations_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quote_calculations_auts
    **/
    _count?: true | Quote_calculations_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quote_calculations_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quote_calculations_autMaxAggregateInputType
  }

  export type GetQuote_calculations_autAggregateType<T extends Quote_calculations_autAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote_calculations_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote_calculations_aut[P]>
      : GetScalarType<T[P], AggregateQuote_calculations_aut[P]>
  }




  export type quote_calculations_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_calculations_autWhereInput
    orderBy?: quote_calculations_autOrderByWithAggregationInput | quote_calculations_autOrderByWithAggregationInput[]
    by: Quote_calculations_autScalarFieldEnum[] | Quote_calculations_autScalarFieldEnum
    having?: quote_calculations_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quote_calculations_autCountAggregateInputType | true
    _min?: Quote_calculations_autMinAggregateInputType
    _max?: Quote_calculations_autMaxAggregateInputType
  }

  export type Quote_calculations_autGroupByOutputType = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date
    updatedAt: Date
    _count: Quote_calculations_autCountAggregateOutputType | null
    _min: Quote_calculations_autMinAggregateOutputType | null
    _max: Quote_calculations_autMaxAggregateOutputType | null
  }

  type GetQuote_calculations_autGroupByPayload<T extends quote_calculations_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Quote_calculations_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quote_calculations_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quote_calculations_autGroupByOutputType[P]>
            : GetScalarType<T[P], Quote_calculations_autGroupByOutputType[P]>
        }
      >
    >


  export type quote_calculations_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    client_name?: boolean
    consultant_name?: boolean
    ages?: boolean
    accommodation?: boolean
    plan_type?: boolean
    square?: boolean
    is_odonto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote_calculations_aut"]>



  export type quote_calculations_autSelectScalar = {
    id?: boolean
    user_id?: boolean
    client_name?: boolean
    consultant_name?: boolean
    ages?: boolean
    accommodation?: boolean
    plan_type?: boolean
    square?: boolean
    is_odonto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type quote_calculations_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "client_name" | "consultant_name" | "ages" | "accommodation" | "plan_type" | "square" | "is_odonto" | "createdAt" | "updatedAt", ExtArgs["result"]["quote_calculations_aut"]>
  export type quote_calculations_autInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }

  export type $quote_calculations_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quote_calculations_aut"
    objects: {
      users_aut: Prisma.$users_autPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      client_name: string
      consultant_name: string
      ages: string
      accommodation: string
      plan_type: string
      square: string
      is_odonto: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote_calculations_aut"]>
    composites: {}
  }

  type quote_calculations_autGetPayload<S extends boolean | null | undefined | quote_calculations_autDefaultArgs> = $Result.GetResult<Prisma.$quote_calculations_autPayload, S>

  type quote_calculations_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quote_calculations_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Quote_calculations_autCountAggregateInputType | true
    }

  export interface quote_calculations_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quote_calculations_aut'], meta: { name: 'quote_calculations_aut' } }
    /**
     * Find zero or one Quote_calculations_aut that matches the filter.
     * @param {quote_calculations_autFindUniqueArgs} args - Arguments to find a Quote_calculations_aut
     * @example
     * // Get one Quote_calculations_aut
     * const quote_calculations_aut = await prisma.quote_calculations_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quote_calculations_autFindUniqueArgs>(args: SelectSubset<T, quote_calculations_autFindUniqueArgs<ExtArgs>>): Prisma__quote_calculations_autClient<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote_calculations_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quote_calculations_autFindUniqueOrThrowArgs} args - Arguments to find a Quote_calculations_aut
     * @example
     * // Get one Quote_calculations_aut
     * const quote_calculations_aut = await prisma.quote_calculations_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quote_calculations_autFindUniqueOrThrowArgs>(args: SelectSubset<T, quote_calculations_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quote_calculations_autClient<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_calculations_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_autFindFirstArgs} args - Arguments to find a Quote_calculations_aut
     * @example
     * // Get one Quote_calculations_aut
     * const quote_calculations_aut = await prisma.quote_calculations_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quote_calculations_autFindFirstArgs>(args?: SelectSubset<T, quote_calculations_autFindFirstArgs<ExtArgs>>): Prisma__quote_calculations_autClient<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_calculations_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_autFindFirstOrThrowArgs} args - Arguments to find a Quote_calculations_aut
     * @example
     * // Get one Quote_calculations_aut
     * const quote_calculations_aut = await prisma.quote_calculations_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quote_calculations_autFindFirstOrThrowArgs>(args?: SelectSubset<T, quote_calculations_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__quote_calculations_autClient<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quote_calculations_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quote_calculations_auts
     * const quote_calculations_auts = await prisma.quote_calculations_aut.findMany()
     * 
     * // Get first 10 Quote_calculations_auts
     * const quote_calculations_auts = await prisma.quote_calculations_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quote_calculations_autWithIdOnly = await prisma.quote_calculations_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quote_calculations_autFindManyArgs>(args?: SelectSubset<T, quote_calculations_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote_calculations_aut.
     * @param {quote_calculations_autCreateArgs} args - Arguments to create a Quote_calculations_aut.
     * @example
     * // Create one Quote_calculations_aut
     * const Quote_calculations_aut = await prisma.quote_calculations_aut.create({
     *   data: {
     *     // ... data to create a Quote_calculations_aut
     *   }
     * })
     * 
     */
    create<T extends quote_calculations_autCreateArgs>(args: SelectSubset<T, quote_calculations_autCreateArgs<ExtArgs>>): Prisma__quote_calculations_autClient<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quote_calculations_auts.
     * @param {quote_calculations_autCreateManyArgs} args - Arguments to create many Quote_calculations_auts.
     * @example
     * // Create many Quote_calculations_auts
     * const quote_calculations_aut = await prisma.quote_calculations_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quote_calculations_autCreateManyArgs>(args?: SelectSubset<T, quote_calculations_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quote_calculations_aut.
     * @param {quote_calculations_autDeleteArgs} args - Arguments to delete one Quote_calculations_aut.
     * @example
     * // Delete one Quote_calculations_aut
     * const Quote_calculations_aut = await prisma.quote_calculations_aut.delete({
     *   where: {
     *     // ... filter to delete one Quote_calculations_aut
     *   }
     * })
     * 
     */
    delete<T extends quote_calculations_autDeleteArgs>(args: SelectSubset<T, quote_calculations_autDeleteArgs<ExtArgs>>): Prisma__quote_calculations_autClient<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote_calculations_aut.
     * @param {quote_calculations_autUpdateArgs} args - Arguments to update one Quote_calculations_aut.
     * @example
     * // Update one Quote_calculations_aut
     * const quote_calculations_aut = await prisma.quote_calculations_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quote_calculations_autUpdateArgs>(args: SelectSubset<T, quote_calculations_autUpdateArgs<ExtArgs>>): Prisma__quote_calculations_autClient<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quote_calculations_auts.
     * @param {quote_calculations_autDeleteManyArgs} args - Arguments to filter Quote_calculations_auts to delete.
     * @example
     * // Delete a few Quote_calculations_auts
     * const { count } = await prisma.quote_calculations_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quote_calculations_autDeleteManyArgs>(args?: SelectSubset<T, quote_calculations_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quote_calculations_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quote_calculations_auts
     * const quote_calculations_aut = await prisma.quote_calculations_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quote_calculations_autUpdateManyArgs>(args: SelectSubset<T, quote_calculations_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quote_calculations_aut.
     * @param {quote_calculations_autUpsertArgs} args - Arguments to update or create a Quote_calculations_aut.
     * @example
     * // Update or create a Quote_calculations_aut
     * const quote_calculations_aut = await prisma.quote_calculations_aut.upsert({
     *   create: {
     *     // ... data to create a Quote_calculations_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote_calculations_aut we want to update
     *   }
     * })
     */
    upsert<T extends quote_calculations_autUpsertArgs>(args: SelectSubset<T, quote_calculations_autUpsertArgs<ExtArgs>>): Prisma__quote_calculations_autClient<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quote_calculations_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_autCountArgs} args - Arguments to filter Quote_calculations_auts to count.
     * @example
     * // Count the number of Quote_calculations_auts
     * const count = await prisma.quote_calculations_aut.count({
     *   where: {
     *     // ... the filter for the Quote_calculations_auts we want to count
     *   }
     * })
    **/
    count<T extends quote_calculations_autCountArgs>(
      args?: Subset<T, quote_calculations_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quote_calculations_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote_calculations_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quote_calculations_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quote_calculations_autAggregateArgs>(args: Subset<T, Quote_calculations_autAggregateArgs>): Prisma.PrismaPromise<GetQuote_calculations_autAggregateType<T>>

    /**
     * Group by Quote_calculations_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quote_calculations_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quote_calculations_autGroupByArgs['orderBy'] }
        : { orderBy?: quote_calculations_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quote_calculations_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuote_calculations_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quote_calculations_aut model
   */
  readonly fields: quote_calculations_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quote_calculations_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quote_calculations_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_aut<T extends users_autDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_autDefaultArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quote_calculations_aut model
   */
  interface quote_calculations_autFieldRefs {
    readonly id: FieldRef<"quote_calculations_aut", 'String'>
    readonly user_id: FieldRef<"quote_calculations_aut", 'String'>
    readonly client_name: FieldRef<"quote_calculations_aut", 'String'>
    readonly consultant_name: FieldRef<"quote_calculations_aut", 'String'>
    readonly ages: FieldRef<"quote_calculations_aut", 'String'>
    readonly accommodation: FieldRef<"quote_calculations_aut", 'String'>
    readonly plan_type: FieldRef<"quote_calculations_aut", 'String'>
    readonly square: FieldRef<"quote_calculations_aut", 'String'>
    readonly is_odonto: FieldRef<"quote_calculations_aut", 'Boolean'>
    readonly createdAt: FieldRef<"quote_calculations_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"quote_calculations_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * quote_calculations_aut findUnique
   */
  export type quote_calculations_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_aut to fetch.
     */
    where: quote_calculations_autWhereUniqueInput
  }

  /**
   * quote_calculations_aut findUniqueOrThrow
   */
  export type quote_calculations_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_aut to fetch.
     */
    where: quote_calculations_autWhereUniqueInput
  }

  /**
   * quote_calculations_aut findFirst
   */
  export type quote_calculations_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_aut to fetch.
     */
    where?: quote_calculations_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_auts to fetch.
     */
    orderBy?: quote_calculations_autOrderByWithRelationInput | quote_calculations_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_calculations_auts.
     */
    cursor?: quote_calculations_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_calculations_auts.
     */
    distinct?: Quote_calculations_autScalarFieldEnum | Quote_calculations_autScalarFieldEnum[]
  }

  /**
   * quote_calculations_aut findFirstOrThrow
   */
  export type quote_calculations_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_aut to fetch.
     */
    where?: quote_calculations_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_auts to fetch.
     */
    orderBy?: quote_calculations_autOrderByWithRelationInput | quote_calculations_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_calculations_auts.
     */
    cursor?: quote_calculations_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_calculations_auts.
     */
    distinct?: Quote_calculations_autScalarFieldEnum | Quote_calculations_autScalarFieldEnum[]
  }

  /**
   * quote_calculations_aut findMany
   */
  export type quote_calculations_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_auts to fetch.
     */
    where?: quote_calculations_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_auts to fetch.
     */
    orderBy?: quote_calculations_autOrderByWithRelationInput | quote_calculations_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quote_calculations_auts.
     */
    cursor?: quote_calculations_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_auts.
     */
    skip?: number
    distinct?: Quote_calculations_autScalarFieldEnum | Quote_calculations_autScalarFieldEnum[]
  }

  /**
   * quote_calculations_aut create
   */
  export type quote_calculations_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * The data needed to create a quote_calculations_aut.
     */
    data: XOR<quote_calculations_autCreateInput, quote_calculations_autUncheckedCreateInput>
  }

  /**
   * quote_calculations_aut createMany
   */
  export type quote_calculations_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quote_calculations_auts.
     */
    data: quote_calculations_autCreateManyInput | quote_calculations_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quote_calculations_aut update
   */
  export type quote_calculations_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * The data needed to update a quote_calculations_aut.
     */
    data: XOR<quote_calculations_autUpdateInput, quote_calculations_autUncheckedUpdateInput>
    /**
     * Choose, which quote_calculations_aut to update.
     */
    where: quote_calculations_autWhereUniqueInput
  }

  /**
   * quote_calculations_aut updateMany
   */
  export type quote_calculations_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quote_calculations_auts.
     */
    data: XOR<quote_calculations_autUpdateManyMutationInput, quote_calculations_autUncheckedUpdateManyInput>
    /**
     * Filter which quote_calculations_auts to update
     */
    where?: quote_calculations_autWhereInput
    /**
     * Limit how many quote_calculations_auts to update.
     */
    limit?: number
  }

  /**
   * quote_calculations_aut upsert
   */
  export type quote_calculations_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * The filter to search for the quote_calculations_aut to update in case it exists.
     */
    where: quote_calculations_autWhereUniqueInput
    /**
     * In case the quote_calculations_aut found by the `where` argument doesn't exist, create a new quote_calculations_aut with this data.
     */
    create: XOR<quote_calculations_autCreateInput, quote_calculations_autUncheckedCreateInput>
    /**
     * In case the quote_calculations_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quote_calculations_autUpdateInput, quote_calculations_autUncheckedUpdateInput>
  }

  /**
   * quote_calculations_aut delete
   */
  export type quote_calculations_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    /**
     * Filter which quote_calculations_aut to delete.
     */
    where: quote_calculations_autWhereUniqueInput
  }

  /**
   * quote_calculations_aut deleteMany
   */
  export type quote_calculations_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_calculations_auts to delete
     */
    where?: quote_calculations_autWhereInput
    /**
     * Limit how many quote_calculations_auts to delete.
     */
    limit?: number
  }

  /**
   * quote_calculations_aut without action
   */
  export type quote_calculations_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
  }


  /**
   * Model quote_calculations_clt
   */

  export type AggregateQuote_calculations_clt = {
    _count: Quote_calculations_cltCountAggregateOutputType | null
    _min: Quote_calculations_cltMinAggregateOutputType | null
    _max: Quote_calculations_cltMaxAggregateOutputType | null
  }

  export type Quote_calculations_cltMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_name: string | null
    consultant_name: string | null
    ages: string | null
    accommodation: string | null
    plan_type: string | null
    square: string | null
    is_odonto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Quote_calculations_cltMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_name: string | null
    consultant_name: string | null
    ages: string | null
    accommodation: string | null
    plan_type: string | null
    square: string | null
    is_odonto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Quote_calculations_cltCountAggregateOutputType = {
    id: number
    user_id: number
    client_name: number
    consultant_name: number
    ages: number
    accommodation: number
    plan_type: number
    square: number
    is_odonto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Quote_calculations_cltMinAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Quote_calculations_cltMaxAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Quote_calculations_cltCountAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Quote_calculations_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_calculations_clt to aggregate.
     */
    where?: quote_calculations_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_clts to fetch.
     */
    orderBy?: quote_calculations_cltOrderByWithRelationInput | quote_calculations_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quote_calculations_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quote_calculations_clts
    **/
    _count?: true | Quote_calculations_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quote_calculations_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quote_calculations_cltMaxAggregateInputType
  }

  export type GetQuote_calculations_cltAggregateType<T extends Quote_calculations_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote_calculations_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote_calculations_clt[P]>
      : GetScalarType<T[P], AggregateQuote_calculations_clt[P]>
  }




  export type quote_calculations_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_calculations_cltWhereInput
    orderBy?: quote_calculations_cltOrderByWithAggregationInput | quote_calculations_cltOrderByWithAggregationInput[]
    by: Quote_calculations_cltScalarFieldEnum[] | Quote_calculations_cltScalarFieldEnum
    having?: quote_calculations_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quote_calculations_cltCountAggregateInputType | true
    _min?: Quote_calculations_cltMinAggregateInputType
    _max?: Quote_calculations_cltMaxAggregateInputType
  }

  export type Quote_calculations_cltGroupByOutputType = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date
    updatedAt: Date
    _count: Quote_calculations_cltCountAggregateOutputType | null
    _min: Quote_calculations_cltMinAggregateOutputType | null
    _max: Quote_calculations_cltMaxAggregateOutputType | null
  }

  type GetQuote_calculations_cltGroupByPayload<T extends quote_calculations_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Quote_calculations_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quote_calculations_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quote_calculations_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Quote_calculations_cltGroupByOutputType[P]>
        }
      >
    >


  export type quote_calculations_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    client_name?: boolean
    consultant_name?: boolean
    ages?: boolean
    accommodation?: boolean
    plan_type?: boolean
    square?: boolean
    is_odonto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote_calculations_clt"]>



  export type quote_calculations_cltSelectScalar = {
    id?: boolean
    user_id?: boolean
    client_name?: boolean
    consultant_name?: boolean
    ages?: boolean
    accommodation?: boolean
    plan_type?: boolean
    square?: boolean
    is_odonto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type quote_calculations_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "client_name" | "consultant_name" | "ages" | "accommodation" | "plan_type" | "square" | "is_odonto" | "createdAt" | "updatedAt", ExtArgs["result"]["quote_calculations_clt"]>
  export type quote_calculations_cltInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }

  export type $quote_calculations_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quote_calculations_clt"
    objects: {
      users_clt: Prisma.$users_cltPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      client_name: string
      consultant_name: string
      ages: string
      accommodation: string
      plan_type: string
      square: string
      is_odonto: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote_calculations_clt"]>
    composites: {}
  }

  type quote_calculations_cltGetPayload<S extends boolean | null | undefined | quote_calculations_cltDefaultArgs> = $Result.GetResult<Prisma.$quote_calculations_cltPayload, S>

  type quote_calculations_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quote_calculations_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Quote_calculations_cltCountAggregateInputType | true
    }

  export interface quote_calculations_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quote_calculations_clt'], meta: { name: 'quote_calculations_clt' } }
    /**
     * Find zero or one Quote_calculations_clt that matches the filter.
     * @param {quote_calculations_cltFindUniqueArgs} args - Arguments to find a Quote_calculations_clt
     * @example
     * // Get one Quote_calculations_clt
     * const quote_calculations_clt = await prisma.quote_calculations_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quote_calculations_cltFindUniqueArgs>(args: SelectSubset<T, quote_calculations_cltFindUniqueArgs<ExtArgs>>): Prisma__quote_calculations_cltClient<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote_calculations_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quote_calculations_cltFindUniqueOrThrowArgs} args - Arguments to find a Quote_calculations_clt
     * @example
     * // Get one Quote_calculations_clt
     * const quote_calculations_clt = await prisma.quote_calculations_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quote_calculations_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, quote_calculations_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quote_calculations_cltClient<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_calculations_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_cltFindFirstArgs} args - Arguments to find a Quote_calculations_clt
     * @example
     * // Get one Quote_calculations_clt
     * const quote_calculations_clt = await prisma.quote_calculations_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quote_calculations_cltFindFirstArgs>(args?: SelectSubset<T, quote_calculations_cltFindFirstArgs<ExtArgs>>): Prisma__quote_calculations_cltClient<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_calculations_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_cltFindFirstOrThrowArgs} args - Arguments to find a Quote_calculations_clt
     * @example
     * // Get one Quote_calculations_clt
     * const quote_calculations_clt = await prisma.quote_calculations_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quote_calculations_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, quote_calculations_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__quote_calculations_cltClient<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quote_calculations_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quote_calculations_clts
     * const quote_calculations_clts = await prisma.quote_calculations_clt.findMany()
     * 
     * // Get first 10 Quote_calculations_clts
     * const quote_calculations_clts = await prisma.quote_calculations_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quote_calculations_cltWithIdOnly = await prisma.quote_calculations_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quote_calculations_cltFindManyArgs>(args?: SelectSubset<T, quote_calculations_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote_calculations_clt.
     * @param {quote_calculations_cltCreateArgs} args - Arguments to create a Quote_calculations_clt.
     * @example
     * // Create one Quote_calculations_clt
     * const Quote_calculations_clt = await prisma.quote_calculations_clt.create({
     *   data: {
     *     // ... data to create a Quote_calculations_clt
     *   }
     * })
     * 
     */
    create<T extends quote_calculations_cltCreateArgs>(args: SelectSubset<T, quote_calculations_cltCreateArgs<ExtArgs>>): Prisma__quote_calculations_cltClient<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quote_calculations_clts.
     * @param {quote_calculations_cltCreateManyArgs} args - Arguments to create many Quote_calculations_clts.
     * @example
     * // Create many Quote_calculations_clts
     * const quote_calculations_clt = await prisma.quote_calculations_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quote_calculations_cltCreateManyArgs>(args?: SelectSubset<T, quote_calculations_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quote_calculations_clt.
     * @param {quote_calculations_cltDeleteArgs} args - Arguments to delete one Quote_calculations_clt.
     * @example
     * // Delete one Quote_calculations_clt
     * const Quote_calculations_clt = await prisma.quote_calculations_clt.delete({
     *   where: {
     *     // ... filter to delete one Quote_calculations_clt
     *   }
     * })
     * 
     */
    delete<T extends quote_calculations_cltDeleteArgs>(args: SelectSubset<T, quote_calculations_cltDeleteArgs<ExtArgs>>): Prisma__quote_calculations_cltClient<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote_calculations_clt.
     * @param {quote_calculations_cltUpdateArgs} args - Arguments to update one Quote_calculations_clt.
     * @example
     * // Update one Quote_calculations_clt
     * const quote_calculations_clt = await prisma.quote_calculations_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quote_calculations_cltUpdateArgs>(args: SelectSubset<T, quote_calculations_cltUpdateArgs<ExtArgs>>): Prisma__quote_calculations_cltClient<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quote_calculations_clts.
     * @param {quote_calculations_cltDeleteManyArgs} args - Arguments to filter Quote_calculations_clts to delete.
     * @example
     * // Delete a few Quote_calculations_clts
     * const { count } = await prisma.quote_calculations_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quote_calculations_cltDeleteManyArgs>(args?: SelectSubset<T, quote_calculations_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quote_calculations_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quote_calculations_clts
     * const quote_calculations_clt = await prisma.quote_calculations_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quote_calculations_cltUpdateManyArgs>(args: SelectSubset<T, quote_calculations_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quote_calculations_clt.
     * @param {quote_calculations_cltUpsertArgs} args - Arguments to update or create a Quote_calculations_clt.
     * @example
     * // Update or create a Quote_calculations_clt
     * const quote_calculations_clt = await prisma.quote_calculations_clt.upsert({
     *   create: {
     *     // ... data to create a Quote_calculations_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote_calculations_clt we want to update
     *   }
     * })
     */
    upsert<T extends quote_calculations_cltUpsertArgs>(args: SelectSubset<T, quote_calculations_cltUpsertArgs<ExtArgs>>): Prisma__quote_calculations_cltClient<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quote_calculations_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_cltCountArgs} args - Arguments to filter Quote_calculations_clts to count.
     * @example
     * // Count the number of Quote_calculations_clts
     * const count = await prisma.quote_calculations_clt.count({
     *   where: {
     *     // ... the filter for the Quote_calculations_clts we want to count
     *   }
     * })
    **/
    count<T extends quote_calculations_cltCountArgs>(
      args?: Subset<T, quote_calculations_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quote_calculations_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote_calculations_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quote_calculations_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quote_calculations_cltAggregateArgs>(args: Subset<T, Quote_calculations_cltAggregateArgs>): Prisma.PrismaPromise<GetQuote_calculations_cltAggregateType<T>>

    /**
     * Group by Quote_calculations_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quote_calculations_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quote_calculations_cltGroupByArgs['orderBy'] }
        : { orderBy?: quote_calculations_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quote_calculations_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuote_calculations_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quote_calculations_clt model
   */
  readonly fields: quote_calculations_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quote_calculations_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quote_calculations_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_clt<T extends users_cltDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_cltDefaultArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quote_calculations_clt model
   */
  interface quote_calculations_cltFieldRefs {
    readonly id: FieldRef<"quote_calculations_clt", 'String'>
    readonly user_id: FieldRef<"quote_calculations_clt", 'String'>
    readonly client_name: FieldRef<"quote_calculations_clt", 'String'>
    readonly consultant_name: FieldRef<"quote_calculations_clt", 'String'>
    readonly ages: FieldRef<"quote_calculations_clt", 'String'>
    readonly accommodation: FieldRef<"quote_calculations_clt", 'String'>
    readonly plan_type: FieldRef<"quote_calculations_clt", 'String'>
    readonly square: FieldRef<"quote_calculations_clt", 'String'>
    readonly is_odonto: FieldRef<"quote_calculations_clt", 'Boolean'>
    readonly createdAt: FieldRef<"quote_calculations_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"quote_calculations_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * quote_calculations_clt findUnique
   */
  export type quote_calculations_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_clt to fetch.
     */
    where: quote_calculations_cltWhereUniqueInput
  }

  /**
   * quote_calculations_clt findUniqueOrThrow
   */
  export type quote_calculations_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_clt to fetch.
     */
    where: quote_calculations_cltWhereUniqueInput
  }

  /**
   * quote_calculations_clt findFirst
   */
  export type quote_calculations_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_clt to fetch.
     */
    where?: quote_calculations_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_clts to fetch.
     */
    orderBy?: quote_calculations_cltOrderByWithRelationInput | quote_calculations_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_calculations_clts.
     */
    cursor?: quote_calculations_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_calculations_clts.
     */
    distinct?: Quote_calculations_cltScalarFieldEnum | Quote_calculations_cltScalarFieldEnum[]
  }

  /**
   * quote_calculations_clt findFirstOrThrow
   */
  export type quote_calculations_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_clt to fetch.
     */
    where?: quote_calculations_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_clts to fetch.
     */
    orderBy?: quote_calculations_cltOrderByWithRelationInput | quote_calculations_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_calculations_clts.
     */
    cursor?: quote_calculations_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_calculations_clts.
     */
    distinct?: Quote_calculations_cltScalarFieldEnum | Quote_calculations_cltScalarFieldEnum[]
  }

  /**
   * quote_calculations_clt findMany
   */
  export type quote_calculations_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_clts to fetch.
     */
    where?: quote_calculations_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_clts to fetch.
     */
    orderBy?: quote_calculations_cltOrderByWithRelationInput | quote_calculations_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quote_calculations_clts.
     */
    cursor?: quote_calculations_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_clts.
     */
    skip?: number
    distinct?: Quote_calculations_cltScalarFieldEnum | Quote_calculations_cltScalarFieldEnum[]
  }

  /**
   * quote_calculations_clt create
   */
  export type quote_calculations_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * The data needed to create a quote_calculations_clt.
     */
    data: XOR<quote_calculations_cltCreateInput, quote_calculations_cltUncheckedCreateInput>
  }

  /**
   * quote_calculations_clt createMany
   */
  export type quote_calculations_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quote_calculations_clts.
     */
    data: quote_calculations_cltCreateManyInput | quote_calculations_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quote_calculations_clt update
   */
  export type quote_calculations_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * The data needed to update a quote_calculations_clt.
     */
    data: XOR<quote_calculations_cltUpdateInput, quote_calculations_cltUncheckedUpdateInput>
    /**
     * Choose, which quote_calculations_clt to update.
     */
    where: quote_calculations_cltWhereUniqueInput
  }

  /**
   * quote_calculations_clt updateMany
   */
  export type quote_calculations_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quote_calculations_clts.
     */
    data: XOR<quote_calculations_cltUpdateManyMutationInput, quote_calculations_cltUncheckedUpdateManyInput>
    /**
     * Filter which quote_calculations_clts to update
     */
    where?: quote_calculations_cltWhereInput
    /**
     * Limit how many quote_calculations_clts to update.
     */
    limit?: number
  }

  /**
   * quote_calculations_clt upsert
   */
  export type quote_calculations_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * The filter to search for the quote_calculations_clt to update in case it exists.
     */
    where: quote_calculations_cltWhereUniqueInput
    /**
     * In case the quote_calculations_clt found by the `where` argument doesn't exist, create a new quote_calculations_clt with this data.
     */
    create: XOR<quote_calculations_cltCreateInput, quote_calculations_cltUncheckedCreateInput>
    /**
     * In case the quote_calculations_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quote_calculations_cltUpdateInput, quote_calculations_cltUncheckedUpdateInput>
  }

  /**
   * quote_calculations_clt delete
   */
  export type quote_calculations_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    /**
     * Filter which quote_calculations_clt to delete.
     */
    where: quote_calculations_cltWhereUniqueInput
  }

  /**
   * quote_calculations_clt deleteMany
   */
  export type quote_calculations_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_calculations_clts to delete
     */
    where?: quote_calculations_cltWhereInput
    /**
     * Limit how many quote_calculations_clts to delete.
     */
    limit?: number
  }

  /**
   * quote_calculations_clt without action
   */
  export type quote_calculations_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
  }


  /**
   * Model quote_calculations_goi
   */

  export type AggregateQuote_calculations_goi = {
    _count: Quote_calculations_goiCountAggregateOutputType | null
    _min: Quote_calculations_goiMinAggregateOutputType | null
    _max: Quote_calculations_goiMaxAggregateOutputType | null
  }

  export type Quote_calculations_goiMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_name: string | null
    consultant_name: string | null
    ages: string | null
    accommodation: string | null
    plan_type: string | null
    square: string | null
    is_odonto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Quote_calculations_goiMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_name: string | null
    consultant_name: string | null
    ages: string | null
    accommodation: string | null
    plan_type: string | null
    square: string | null
    is_odonto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Quote_calculations_goiCountAggregateOutputType = {
    id: number
    user_id: number
    client_name: number
    consultant_name: number
    ages: number
    accommodation: number
    plan_type: number
    square: number
    is_odonto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Quote_calculations_goiMinAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Quote_calculations_goiMaxAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Quote_calculations_goiCountAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Quote_calculations_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_calculations_goi to aggregate.
     */
    where?: quote_calculations_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_gois to fetch.
     */
    orderBy?: quote_calculations_goiOrderByWithRelationInput | quote_calculations_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quote_calculations_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quote_calculations_gois
    **/
    _count?: true | Quote_calculations_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quote_calculations_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quote_calculations_goiMaxAggregateInputType
  }

  export type GetQuote_calculations_goiAggregateType<T extends Quote_calculations_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote_calculations_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote_calculations_goi[P]>
      : GetScalarType<T[P], AggregateQuote_calculations_goi[P]>
  }




  export type quote_calculations_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_calculations_goiWhereInput
    orderBy?: quote_calculations_goiOrderByWithAggregationInput | quote_calculations_goiOrderByWithAggregationInput[]
    by: Quote_calculations_goiScalarFieldEnum[] | Quote_calculations_goiScalarFieldEnum
    having?: quote_calculations_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quote_calculations_goiCountAggregateInputType | true
    _min?: Quote_calculations_goiMinAggregateInputType
    _max?: Quote_calculations_goiMaxAggregateInputType
  }

  export type Quote_calculations_goiGroupByOutputType = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date
    updatedAt: Date
    _count: Quote_calculations_goiCountAggregateOutputType | null
    _min: Quote_calculations_goiMinAggregateOutputType | null
    _max: Quote_calculations_goiMaxAggregateOutputType | null
  }

  type GetQuote_calculations_goiGroupByPayload<T extends quote_calculations_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Quote_calculations_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quote_calculations_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quote_calculations_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Quote_calculations_goiGroupByOutputType[P]>
        }
      >
    >


  export type quote_calculations_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    client_name?: boolean
    consultant_name?: boolean
    ages?: boolean
    accommodation?: boolean
    plan_type?: boolean
    square?: boolean
    is_odonto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote_calculations_goi"]>



  export type quote_calculations_goiSelectScalar = {
    id?: boolean
    user_id?: boolean
    client_name?: boolean
    consultant_name?: boolean
    ages?: boolean
    accommodation?: boolean
    plan_type?: boolean
    square?: boolean
    is_odonto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type quote_calculations_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "client_name" | "consultant_name" | "ages" | "accommodation" | "plan_type" | "square" | "is_odonto" | "createdAt" | "updatedAt", ExtArgs["result"]["quote_calculations_goi"]>
  export type quote_calculations_goiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }

  export type $quote_calculations_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quote_calculations_goi"
    objects: {
      users_goi: Prisma.$users_goiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      client_name: string
      consultant_name: string
      ages: string
      accommodation: string
      plan_type: string
      square: string
      is_odonto: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote_calculations_goi"]>
    composites: {}
  }

  type quote_calculations_goiGetPayload<S extends boolean | null | undefined | quote_calculations_goiDefaultArgs> = $Result.GetResult<Prisma.$quote_calculations_goiPayload, S>

  type quote_calculations_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quote_calculations_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Quote_calculations_goiCountAggregateInputType | true
    }

  export interface quote_calculations_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quote_calculations_goi'], meta: { name: 'quote_calculations_goi' } }
    /**
     * Find zero or one Quote_calculations_goi that matches the filter.
     * @param {quote_calculations_goiFindUniqueArgs} args - Arguments to find a Quote_calculations_goi
     * @example
     * // Get one Quote_calculations_goi
     * const quote_calculations_goi = await prisma.quote_calculations_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quote_calculations_goiFindUniqueArgs>(args: SelectSubset<T, quote_calculations_goiFindUniqueArgs<ExtArgs>>): Prisma__quote_calculations_goiClient<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote_calculations_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quote_calculations_goiFindUniqueOrThrowArgs} args - Arguments to find a Quote_calculations_goi
     * @example
     * // Get one Quote_calculations_goi
     * const quote_calculations_goi = await prisma.quote_calculations_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quote_calculations_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, quote_calculations_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quote_calculations_goiClient<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_calculations_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_goiFindFirstArgs} args - Arguments to find a Quote_calculations_goi
     * @example
     * // Get one Quote_calculations_goi
     * const quote_calculations_goi = await prisma.quote_calculations_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quote_calculations_goiFindFirstArgs>(args?: SelectSubset<T, quote_calculations_goiFindFirstArgs<ExtArgs>>): Prisma__quote_calculations_goiClient<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_calculations_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_goiFindFirstOrThrowArgs} args - Arguments to find a Quote_calculations_goi
     * @example
     * // Get one Quote_calculations_goi
     * const quote_calculations_goi = await prisma.quote_calculations_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quote_calculations_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, quote_calculations_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__quote_calculations_goiClient<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quote_calculations_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quote_calculations_gois
     * const quote_calculations_gois = await prisma.quote_calculations_goi.findMany()
     * 
     * // Get first 10 Quote_calculations_gois
     * const quote_calculations_gois = await prisma.quote_calculations_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quote_calculations_goiWithIdOnly = await prisma.quote_calculations_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quote_calculations_goiFindManyArgs>(args?: SelectSubset<T, quote_calculations_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote_calculations_goi.
     * @param {quote_calculations_goiCreateArgs} args - Arguments to create a Quote_calculations_goi.
     * @example
     * // Create one Quote_calculations_goi
     * const Quote_calculations_goi = await prisma.quote_calculations_goi.create({
     *   data: {
     *     // ... data to create a Quote_calculations_goi
     *   }
     * })
     * 
     */
    create<T extends quote_calculations_goiCreateArgs>(args: SelectSubset<T, quote_calculations_goiCreateArgs<ExtArgs>>): Prisma__quote_calculations_goiClient<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quote_calculations_gois.
     * @param {quote_calculations_goiCreateManyArgs} args - Arguments to create many Quote_calculations_gois.
     * @example
     * // Create many Quote_calculations_gois
     * const quote_calculations_goi = await prisma.quote_calculations_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quote_calculations_goiCreateManyArgs>(args?: SelectSubset<T, quote_calculations_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quote_calculations_goi.
     * @param {quote_calculations_goiDeleteArgs} args - Arguments to delete one Quote_calculations_goi.
     * @example
     * // Delete one Quote_calculations_goi
     * const Quote_calculations_goi = await prisma.quote_calculations_goi.delete({
     *   where: {
     *     // ... filter to delete one Quote_calculations_goi
     *   }
     * })
     * 
     */
    delete<T extends quote_calculations_goiDeleteArgs>(args: SelectSubset<T, quote_calculations_goiDeleteArgs<ExtArgs>>): Prisma__quote_calculations_goiClient<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote_calculations_goi.
     * @param {quote_calculations_goiUpdateArgs} args - Arguments to update one Quote_calculations_goi.
     * @example
     * // Update one Quote_calculations_goi
     * const quote_calculations_goi = await prisma.quote_calculations_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quote_calculations_goiUpdateArgs>(args: SelectSubset<T, quote_calculations_goiUpdateArgs<ExtArgs>>): Prisma__quote_calculations_goiClient<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quote_calculations_gois.
     * @param {quote_calculations_goiDeleteManyArgs} args - Arguments to filter Quote_calculations_gois to delete.
     * @example
     * // Delete a few Quote_calculations_gois
     * const { count } = await prisma.quote_calculations_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quote_calculations_goiDeleteManyArgs>(args?: SelectSubset<T, quote_calculations_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quote_calculations_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quote_calculations_gois
     * const quote_calculations_goi = await prisma.quote_calculations_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quote_calculations_goiUpdateManyArgs>(args: SelectSubset<T, quote_calculations_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quote_calculations_goi.
     * @param {quote_calculations_goiUpsertArgs} args - Arguments to update or create a Quote_calculations_goi.
     * @example
     * // Update or create a Quote_calculations_goi
     * const quote_calculations_goi = await prisma.quote_calculations_goi.upsert({
     *   create: {
     *     // ... data to create a Quote_calculations_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote_calculations_goi we want to update
     *   }
     * })
     */
    upsert<T extends quote_calculations_goiUpsertArgs>(args: SelectSubset<T, quote_calculations_goiUpsertArgs<ExtArgs>>): Prisma__quote_calculations_goiClient<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quote_calculations_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_goiCountArgs} args - Arguments to filter Quote_calculations_gois to count.
     * @example
     * // Count the number of Quote_calculations_gois
     * const count = await prisma.quote_calculations_goi.count({
     *   where: {
     *     // ... the filter for the Quote_calculations_gois we want to count
     *   }
     * })
    **/
    count<T extends quote_calculations_goiCountArgs>(
      args?: Subset<T, quote_calculations_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quote_calculations_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote_calculations_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quote_calculations_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quote_calculations_goiAggregateArgs>(args: Subset<T, Quote_calculations_goiAggregateArgs>): Prisma.PrismaPromise<GetQuote_calculations_goiAggregateType<T>>

    /**
     * Group by Quote_calculations_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quote_calculations_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quote_calculations_goiGroupByArgs['orderBy'] }
        : { orderBy?: quote_calculations_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quote_calculations_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuote_calculations_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quote_calculations_goi model
   */
  readonly fields: quote_calculations_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quote_calculations_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quote_calculations_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_goi<T extends users_goiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_goiDefaultArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quote_calculations_goi model
   */
  interface quote_calculations_goiFieldRefs {
    readonly id: FieldRef<"quote_calculations_goi", 'String'>
    readonly user_id: FieldRef<"quote_calculations_goi", 'String'>
    readonly client_name: FieldRef<"quote_calculations_goi", 'String'>
    readonly consultant_name: FieldRef<"quote_calculations_goi", 'String'>
    readonly ages: FieldRef<"quote_calculations_goi", 'String'>
    readonly accommodation: FieldRef<"quote_calculations_goi", 'String'>
    readonly plan_type: FieldRef<"quote_calculations_goi", 'String'>
    readonly square: FieldRef<"quote_calculations_goi", 'String'>
    readonly is_odonto: FieldRef<"quote_calculations_goi", 'Boolean'>
    readonly createdAt: FieldRef<"quote_calculations_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"quote_calculations_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * quote_calculations_goi findUnique
   */
  export type quote_calculations_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_goi to fetch.
     */
    where: quote_calculations_goiWhereUniqueInput
  }

  /**
   * quote_calculations_goi findUniqueOrThrow
   */
  export type quote_calculations_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_goi to fetch.
     */
    where: quote_calculations_goiWhereUniqueInput
  }

  /**
   * quote_calculations_goi findFirst
   */
  export type quote_calculations_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_goi to fetch.
     */
    where?: quote_calculations_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_gois to fetch.
     */
    orderBy?: quote_calculations_goiOrderByWithRelationInput | quote_calculations_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_calculations_gois.
     */
    cursor?: quote_calculations_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_calculations_gois.
     */
    distinct?: Quote_calculations_goiScalarFieldEnum | Quote_calculations_goiScalarFieldEnum[]
  }

  /**
   * quote_calculations_goi findFirstOrThrow
   */
  export type quote_calculations_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_goi to fetch.
     */
    where?: quote_calculations_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_gois to fetch.
     */
    orderBy?: quote_calculations_goiOrderByWithRelationInput | quote_calculations_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_calculations_gois.
     */
    cursor?: quote_calculations_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_calculations_gois.
     */
    distinct?: Quote_calculations_goiScalarFieldEnum | Quote_calculations_goiScalarFieldEnum[]
  }

  /**
   * quote_calculations_goi findMany
   */
  export type quote_calculations_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_gois to fetch.
     */
    where?: quote_calculations_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_gois to fetch.
     */
    orderBy?: quote_calculations_goiOrderByWithRelationInput | quote_calculations_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quote_calculations_gois.
     */
    cursor?: quote_calculations_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_gois.
     */
    skip?: number
    distinct?: Quote_calculations_goiScalarFieldEnum | Quote_calculations_goiScalarFieldEnum[]
  }

  /**
   * quote_calculations_goi create
   */
  export type quote_calculations_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * The data needed to create a quote_calculations_goi.
     */
    data: XOR<quote_calculations_goiCreateInput, quote_calculations_goiUncheckedCreateInput>
  }

  /**
   * quote_calculations_goi createMany
   */
  export type quote_calculations_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quote_calculations_gois.
     */
    data: quote_calculations_goiCreateManyInput | quote_calculations_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quote_calculations_goi update
   */
  export type quote_calculations_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * The data needed to update a quote_calculations_goi.
     */
    data: XOR<quote_calculations_goiUpdateInput, quote_calculations_goiUncheckedUpdateInput>
    /**
     * Choose, which quote_calculations_goi to update.
     */
    where: quote_calculations_goiWhereUniqueInput
  }

  /**
   * quote_calculations_goi updateMany
   */
  export type quote_calculations_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quote_calculations_gois.
     */
    data: XOR<quote_calculations_goiUpdateManyMutationInput, quote_calculations_goiUncheckedUpdateManyInput>
    /**
     * Filter which quote_calculations_gois to update
     */
    where?: quote_calculations_goiWhereInput
    /**
     * Limit how many quote_calculations_gois to update.
     */
    limit?: number
  }

  /**
   * quote_calculations_goi upsert
   */
  export type quote_calculations_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * The filter to search for the quote_calculations_goi to update in case it exists.
     */
    where: quote_calculations_goiWhereUniqueInput
    /**
     * In case the quote_calculations_goi found by the `where` argument doesn't exist, create a new quote_calculations_goi with this data.
     */
    create: XOR<quote_calculations_goiCreateInput, quote_calculations_goiUncheckedCreateInput>
    /**
     * In case the quote_calculations_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quote_calculations_goiUpdateInput, quote_calculations_goiUncheckedUpdateInput>
  }

  /**
   * quote_calculations_goi delete
   */
  export type quote_calculations_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    /**
     * Filter which quote_calculations_goi to delete.
     */
    where: quote_calculations_goiWhereUniqueInput
  }

  /**
   * quote_calculations_goi deleteMany
   */
  export type quote_calculations_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_calculations_gois to delete
     */
    where?: quote_calculations_goiWhereInput
    /**
     * Limit how many quote_calculations_gois to delete.
     */
    limit?: number
  }

  /**
   * quote_calculations_goi without action
   */
  export type quote_calculations_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
  }


  /**
   * Model quote_calculations_spa
   */

  export type AggregateQuote_calculations_spa = {
    _count: Quote_calculations_spaCountAggregateOutputType | null
    _min: Quote_calculations_spaMinAggregateOutputType | null
    _max: Quote_calculations_spaMaxAggregateOutputType | null
  }

  export type Quote_calculations_spaMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_name: string | null
    consultant_name: string | null
    ages: string | null
    accommodation: string | null
    plan_type: string | null
    square: string | null
    is_odonto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Quote_calculations_spaMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_name: string | null
    consultant_name: string | null
    ages: string | null
    accommodation: string | null
    plan_type: string | null
    square: string | null
    is_odonto: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Quote_calculations_spaCountAggregateOutputType = {
    id: number
    user_id: number
    client_name: number
    consultant_name: number
    ages: number
    accommodation: number
    plan_type: number
    square: number
    is_odonto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Quote_calculations_spaMinAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Quote_calculations_spaMaxAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Quote_calculations_spaCountAggregateInputType = {
    id?: true
    user_id?: true
    client_name?: true
    consultant_name?: true
    ages?: true
    accommodation?: true
    plan_type?: true
    square?: true
    is_odonto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Quote_calculations_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_calculations_spa to aggregate.
     */
    where?: quote_calculations_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_spas to fetch.
     */
    orderBy?: quote_calculations_spaOrderByWithRelationInput | quote_calculations_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quote_calculations_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quote_calculations_spas
    **/
    _count?: true | Quote_calculations_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quote_calculations_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quote_calculations_spaMaxAggregateInputType
  }

  export type GetQuote_calculations_spaAggregateType<T extends Quote_calculations_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote_calculations_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote_calculations_spa[P]>
      : GetScalarType<T[P], AggregateQuote_calculations_spa[P]>
  }




  export type quote_calculations_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quote_calculations_spaWhereInput
    orderBy?: quote_calculations_spaOrderByWithAggregationInput | quote_calculations_spaOrderByWithAggregationInput[]
    by: Quote_calculations_spaScalarFieldEnum[] | Quote_calculations_spaScalarFieldEnum
    having?: quote_calculations_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quote_calculations_spaCountAggregateInputType | true
    _min?: Quote_calculations_spaMinAggregateInputType
    _max?: Quote_calculations_spaMaxAggregateInputType
  }

  export type Quote_calculations_spaGroupByOutputType = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date
    updatedAt: Date
    _count: Quote_calculations_spaCountAggregateOutputType | null
    _min: Quote_calculations_spaMinAggregateOutputType | null
    _max: Quote_calculations_spaMaxAggregateOutputType | null
  }

  type GetQuote_calculations_spaGroupByPayload<T extends quote_calculations_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Quote_calculations_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quote_calculations_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quote_calculations_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Quote_calculations_spaGroupByOutputType[P]>
        }
      >
    >


  export type quote_calculations_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    client_name?: boolean
    consultant_name?: boolean
    ages?: boolean
    accommodation?: boolean
    plan_type?: boolean
    square?: boolean
    is_odonto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote_calculations_spa"]>



  export type quote_calculations_spaSelectScalar = {
    id?: boolean
    user_id?: boolean
    client_name?: boolean
    consultant_name?: boolean
    ages?: boolean
    accommodation?: boolean
    plan_type?: boolean
    square?: boolean
    is_odonto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type quote_calculations_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "client_name" | "consultant_name" | "ages" | "accommodation" | "plan_type" | "square" | "is_odonto" | "createdAt" | "updatedAt", ExtArgs["result"]["quote_calculations_spa"]>
  export type quote_calculations_spaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }

  export type $quote_calculations_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quote_calculations_spa"
    objects: {
      users_spa: Prisma.$users_spaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      client_name: string
      consultant_name: string
      ages: string
      accommodation: string
      plan_type: string
      square: string
      is_odonto: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote_calculations_spa"]>
    composites: {}
  }

  type quote_calculations_spaGetPayload<S extends boolean | null | undefined | quote_calculations_spaDefaultArgs> = $Result.GetResult<Prisma.$quote_calculations_spaPayload, S>

  type quote_calculations_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quote_calculations_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Quote_calculations_spaCountAggregateInputType | true
    }

  export interface quote_calculations_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quote_calculations_spa'], meta: { name: 'quote_calculations_spa' } }
    /**
     * Find zero or one Quote_calculations_spa that matches the filter.
     * @param {quote_calculations_spaFindUniqueArgs} args - Arguments to find a Quote_calculations_spa
     * @example
     * // Get one Quote_calculations_spa
     * const quote_calculations_spa = await prisma.quote_calculations_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quote_calculations_spaFindUniqueArgs>(args: SelectSubset<T, quote_calculations_spaFindUniqueArgs<ExtArgs>>): Prisma__quote_calculations_spaClient<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote_calculations_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quote_calculations_spaFindUniqueOrThrowArgs} args - Arguments to find a Quote_calculations_spa
     * @example
     * // Get one Quote_calculations_spa
     * const quote_calculations_spa = await prisma.quote_calculations_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quote_calculations_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, quote_calculations_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quote_calculations_spaClient<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_calculations_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_spaFindFirstArgs} args - Arguments to find a Quote_calculations_spa
     * @example
     * // Get one Quote_calculations_spa
     * const quote_calculations_spa = await prisma.quote_calculations_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quote_calculations_spaFindFirstArgs>(args?: SelectSubset<T, quote_calculations_spaFindFirstArgs<ExtArgs>>): Prisma__quote_calculations_spaClient<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote_calculations_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_spaFindFirstOrThrowArgs} args - Arguments to find a Quote_calculations_spa
     * @example
     * // Get one Quote_calculations_spa
     * const quote_calculations_spa = await prisma.quote_calculations_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quote_calculations_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, quote_calculations_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__quote_calculations_spaClient<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quote_calculations_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quote_calculations_spas
     * const quote_calculations_spas = await prisma.quote_calculations_spa.findMany()
     * 
     * // Get first 10 Quote_calculations_spas
     * const quote_calculations_spas = await prisma.quote_calculations_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quote_calculations_spaWithIdOnly = await prisma.quote_calculations_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quote_calculations_spaFindManyArgs>(args?: SelectSubset<T, quote_calculations_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote_calculations_spa.
     * @param {quote_calculations_spaCreateArgs} args - Arguments to create a Quote_calculations_spa.
     * @example
     * // Create one Quote_calculations_spa
     * const Quote_calculations_spa = await prisma.quote_calculations_spa.create({
     *   data: {
     *     // ... data to create a Quote_calculations_spa
     *   }
     * })
     * 
     */
    create<T extends quote_calculations_spaCreateArgs>(args: SelectSubset<T, quote_calculations_spaCreateArgs<ExtArgs>>): Prisma__quote_calculations_spaClient<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quote_calculations_spas.
     * @param {quote_calculations_spaCreateManyArgs} args - Arguments to create many Quote_calculations_spas.
     * @example
     * // Create many Quote_calculations_spas
     * const quote_calculations_spa = await prisma.quote_calculations_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quote_calculations_spaCreateManyArgs>(args?: SelectSubset<T, quote_calculations_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quote_calculations_spa.
     * @param {quote_calculations_spaDeleteArgs} args - Arguments to delete one Quote_calculations_spa.
     * @example
     * // Delete one Quote_calculations_spa
     * const Quote_calculations_spa = await prisma.quote_calculations_spa.delete({
     *   where: {
     *     // ... filter to delete one Quote_calculations_spa
     *   }
     * })
     * 
     */
    delete<T extends quote_calculations_spaDeleteArgs>(args: SelectSubset<T, quote_calculations_spaDeleteArgs<ExtArgs>>): Prisma__quote_calculations_spaClient<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote_calculations_spa.
     * @param {quote_calculations_spaUpdateArgs} args - Arguments to update one Quote_calculations_spa.
     * @example
     * // Update one Quote_calculations_spa
     * const quote_calculations_spa = await prisma.quote_calculations_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quote_calculations_spaUpdateArgs>(args: SelectSubset<T, quote_calculations_spaUpdateArgs<ExtArgs>>): Prisma__quote_calculations_spaClient<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quote_calculations_spas.
     * @param {quote_calculations_spaDeleteManyArgs} args - Arguments to filter Quote_calculations_spas to delete.
     * @example
     * // Delete a few Quote_calculations_spas
     * const { count } = await prisma.quote_calculations_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quote_calculations_spaDeleteManyArgs>(args?: SelectSubset<T, quote_calculations_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quote_calculations_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quote_calculations_spas
     * const quote_calculations_spa = await prisma.quote_calculations_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quote_calculations_spaUpdateManyArgs>(args: SelectSubset<T, quote_calculations_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quote_calculations_spa.
     * @param {quote_calculations_spaUpsertArgs} args - Arguments to update or create a Quote_calculations_spa.
     * @example
     * // Update or create a Quote_calculations_spa
     * const quote_calculations_spa = await prisma.quote_calculations_spa.upsert({
     *   create: {
     *     // ... data to create a Quote_calculations_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote_calculations_spa we want to update
     *   }
     * })
     */
    upsert<T extends quote_calculations_spaUpsertArgs>(args: SelectSubset<T, quote_calculations_spaUpsertArgs<ExtArgs>>): Prisma__quote_calculations_spaClient<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quote_calculations_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_spaCountArgs} args - Arguments to filter Quote_calculations_spas to count.
     * @example
     * // Count the number of Quote_calculations_spas
     * const count = await prisma.quote_calculations_spa.count({
     *   where: {
     *     // ... the filter for the Quote_calculations_spas we want to count
     *   }
     * })
    **/
    count<T extends quote_calculations_spaCountArgs>(
      args?: Subset<T, quote_calculations_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quote_calculations_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote_calculations_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quote_calculations_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quote_calculations_spaAggregateArgs>(args: Subset<T, Quote_calculations_spaAggregateArgs>): Prisma.PrismaPromise<GetQuote_calculations_spaAggregateType<T>>

    /**
     * Group by Quote_calculations_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quote_calculations_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quote_calculations_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quote_calculations_spaGroupByArgs['orderBy'] }
        : { orderBy?: quote_calculations_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quote_calculations_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuote_calculations_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quote_calculations_spa model
   */
  readonly fields: quote_calculations_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quote_calculations_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quote_calculations_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_spa<T extends users_spaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_spaDefaultArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quote_calculations_spa model
   */
  interface quote_calculations_spaFieldRefs {
    readonly id: FieldRef<"quote_calculations_spa", 'String'>
    readonly user_id: FieldRef<"quote_calculations_spa", 'String'>
    readonly client_name: FieldRef<"quote_calculations_spa", 'String'>
    readonly consultant_name: FieldRef<"quote_calculations_spa", 'String'>
    readonly ages: FieldRef<"quote_calculations_spa", 'String'>
    readonly accommodation: FieldRef<"quote_calculations_spa", 'String'>
    readonly plan_type: FieldRef<"quote_calculations_spa", 'String'>
    readonly square: FieldRef<"quote_calculations_spa", 'String'>
    readonly is_odonto: FieldRef<"quote_calculations_spa", 'Boolean'>
    readonly createdAt: FieldRef<"quote_calculations_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"quote_calculations_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * quote_calculations_spa findUnique
   */
  export type quote_calculations_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_spa to fetch.
     */
    where: quote_calculations_spaWhereUniqueInput
  }

  /**
   * quote_calculations_spa findUniqueOrThrow
   */
  export type quote_calculations_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_spa to fetch.
     */
    where: quote_calculations_spaWhereUniqueInput
  }

  /**
   * quote_calculations_spa findFirst
   */
  export type quote_calculations_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_spa to fetch.
     */
    where?: quote_calculations_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_spas to fetch.
     */
    orderBy?: quote_calculations_spaOrderByWithRelationInput | quote_calculations_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_calculations_spas.
     */
    cursor?: quote_calculations_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_calculations_spas.
     */
    distinct?: Quote_calculations_spaScalarFieldEnum | Quote_calculations_spaScalarFieldEnum[]
  }

  /**
   * quote_calculations_spa findFirstOrThrow
   */
  export type quote_calculations_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_spa to fetch.
     */
    where?: quote_calculations_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_spas to fetch.
     */
    orderBy?: quote_calculations_spaOrderByWithRelationInput | quote_calculations_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quote_calculations_spas.
     */
    cursor?: quote_calculations_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quote_calculations_spas.
     */
    distinct?: Quote_calculations_spaScalarFieldEnum | Quote_calculations_spaScalarFieldEnum[]
  }

  /**
   * quote_calculations_spa findMany
   */
  export type quote_calculations_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * Filter, which quote_calculations_spas to fetch.
     */
    where?: quote_calculations_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quote_calculations_spas to fetch.
     */
    orderBy?: quote_calculations_spaOrderByWithRelationInput | quote_calculations_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quote_calculations_spas.
     */
    cursor?: quote_calculations_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quote_calculations_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quote_calculations_spas.
     */
    skip?: number
    distinct?: Quote_calculations_spaScalarFieldEnum | Quote_calculations_spaScalarFieldEnum[]
  }

  /**
   * quote_calculations_spa create
   */
  export type quote_calculations_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * The data needed to create a quote_calculations_spa.
     */
    data: XOR<quote_calculations_spaCreateInput, quote_calculations_spaUncheckedCreateInput>
  }

  /**
   * quote_calculations_spa createMany
   */
  export type quote_calculations_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quote_calculations_spas.
     */
    data: quote_calculations_spaCreateManyInput | quote_calculations_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quote_calculations_spa update
   */
  export type quote_calculations_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * The data needed to update a quote_calculations_spa.
     */
    data: XOR<quote_calculations_spaUpdateInput, quote_calculations_spaUncheckedUpdateInput>
    /**
     * Choose, which quote_calculations_spa to update.
     */
    where: quote_calculations_spaWhereUniqueInput
  }

  /**
   * quote_calculations_spa updateMany
   */
  export type quote_calculations_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quote_calculations_spas.
     */
    data: XOR<quote_calculations_spaUpdateManyMutationInput, quote_calculations_spaUncheckedUpdateManyInput>
    /**
     * Filter which quote_calculations_spas to update
     */
    where?: quote_calculations_spaWhereInput
    /**
     * Limit how many quote_calculations_spas to update.
     */
    limit?: number
  }

  /**
   * quote_calculations_spa upsert
   */
  export type quote_calculations_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * The filter to search for the quote_calculations_spa to update in case it exists.
     */
    where: quote_calculations_spaWhereUniqueInput
    /**
     * In case the quote_calculations_spa found by the `where` argument doesn't exist, create a new quote_calculations_spa with this data.
     */
    create: XOR<quote_calculations_spaCreateInput, quote_calculations_spaUncheckedCreateInput>
    /**
     * In case the quote_calculations_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quote_calculations_spaUpdateInput, quote_calculations_spaUncheckedUpdateInput>
  }

  /**
   * quote_calculations_spa delete
   */
  export type quote_calculations_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    /**
     * Filter which quote_calculations_spa to delete.
     */
    where: quote_calculations_spaWhereUniqueInput
  }

  /**
   * quote_calculations_spa deleteMany
   */
  export type quote_calculations_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quote_calculations_spas to delete
     */
    where?: quote_calculations_spaWhereInput
    /**
     * Limit how many quote_calculations_spas to delete.
     */
    limit?: number
  }

  /**
   * quote_calculations_spa without action
   */
  export type quote_calculations_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
  }


  /**
   * Model register_partners_aut
   */

  export type AggregateRegister_partners_aut = {
    _count: Register_partners_autCountAggregateOutputType | null
    _min: Register_partners_autMinAggregateOutputType | null
    _max: Register_partners_autMaxAggregateOutputType | null
  }

  export type Register_partners_autMinAggregateOutputType = {
    id: string | null
    complete_name: string | null
    phone_number: string | null
    email: string | null
    birth_date: string | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
    obs: string | null
  }

  export type Register_partners_autMaxAggregateOutputType = {
    id: string | null
    complete_name: string | null
    phone_number: string | null
    email: string | null
    birth_date: string | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
    obs: string | null
  }

  export type Register_partners_autCountAggregateOutputType = {
    id: number
    complete_name: number
    phone_number: number
    email: number
    birth_date: number
    city: number
    createdAt: number
    updatedAt: number
    obs: number
    _all: number
  }


  export type Register_partners_autMinAggregateInputType = {
    id?: true
    complete_name?: true
    phone_number?: true
    email?: true
    birth_date?: true
    city?: true
    createdAt?: true
    updatedAt?: true
    obs?: true
  }

  export type Register_partners_autMaxAggregateInputType = {
    id?: true
    complete_name?: true
    phone_number?: true
    email?: true
    birth_date?: true
    city?: true
    createdAt?: true
    updatedAt?: true
    obs?: true
  }

  export type Register_partners_autCountAggregateInputType = {
    id?: true
    complete_name?: true
    phone_number?: true
    email?: true
    birth_date?: true
    city?: true
    createdAt?: true
    updatedAt?: true
    obs?: true
    _all?: true
  }

  export type Register_partners_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which register_partners_aut to aggregate.
     */
    where?: register_partners_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of register_partners_auts to fetch.
     */
    orderBy?: register_partners_autOrderByWithRelationInput | register_partners_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: register_partners_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` register_partners_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` register_partners_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned register_partners_auts
    **/
    _count?: true | Register_partners_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Register_partners_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Register_partners_autMaxAggregateInputType
  }

  export type GetRegister_partners_autAggregateType<T extends Register_partners_autAggregateArgs> = {
        [P in keyof T & keyof AggregateRegister_partners_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegister_partners_aut[P]>
      : GetScalarType<T[P], AggregateRegister_partners_aut[P]>
  }




  export type register_partners_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: register_partners_autWhereInput
    orderBy?: register_partners_autOrderByWithAggregationInput | register_partners_autOrderByWithAggregationInput[]
    by: Register_partners_autScalarFieldEnum[] | Register_partners_autScalarFieldEnum
    having?: register_partners_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Register_partners_autCountAggregateInputType | true
    _min?: Register_partners_autMinAggregateInputType
    _max?: Register_partners_autMaxAggregateInputType
  }

  export type Register_partners_autGroupByOutputType = {
    id: string
    complete_name: string
    phone_number: string
    email: string
    birth_date: string
    city: string
    createdAt: Date
    updatedAt: Date
    obs: string | null
    _count: Register_partners_autCountAggregateOutputType | null
    _min: Register_partners_autMinAggregateOutputType | null
    _max: Register_partners_autMaxAggregateOutputType | null
  }

  type GetRegister_partners_autGroupByPayload<T extends register_partners_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Register_partners_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Register_partners_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Register_partners_autGroupByOutputType[P]>
            : GetScalarType<T[P], Register_partners_autGroupByOutputType[P]>
        }
      >
    >


  export type register_partners_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complete_name?: boolean
    phone_number?: boolean
    email?: boolean
    birth_date?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obs?: boolean
  }, ExtArgs["result"]["register_partners_aut"]>



  export type register_partners_autSelectScalar = {
    id?: boolean
    complete_name?: boolean
    phone_number?: boolean
    email?: boolean
    birth_date?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obs?: boolean
  }

  export type register_partners_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "complete_name" | "phone_number" | "email" | "birth_date" | "city" | "createdAt" | "updatedAt" | "obs", ExtArgs["result"]["register_partners_aut"]>

  export type $register_partners_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "register_partners_aut"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      complete_name: string
      phone_number: string
      email: string
      birth_date: string
      city: string
      createdAt: Date
      updatedAt: Date
      obs: string | null
    }, ExtArgs["result"]["register_partners_aut"]>
    composites: {}
  }

  type register_partners_autGetPayload<S extends boolean | null | undefined | register_partners_autDefaultArgs> = $Result.GetResult<Prisma.$register_partners_autPayload, S>

  type register_partners_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<register_partners_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Register_partners_autCountAggregateInputType | true
    }

  export interface register_partners_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['register_partners_aut'], meta: { name: 'register_partners_aut' } }
    /**
     * Find zero or one Register_partners_aut that matches the filter.
     * @param {register_partners_autFindUniqueArgs} args - Arguments to find a Register_partners_aut
     * @example
     * // Get one Register_partners_aut
     * const register_partners_aut = await prisma.register_partners_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends register_partners_autFindUniqueArgs>(args: SelectSubset<T, register_partners_autFindUniqueArgs<ExtArgs>>): Prisma__register_partners_autClient<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Register_partners_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {register_partners_autFindUniqueOrThrowArgs} args - Arguments to find a Register_partners_aut
     * @example
     * // Get one Register_partners_aut
     * const register_partners_aut = await prisma.register_partners_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends register_partners_autFindUniqueOrThrowArgs>(args: SelectSubset<T, register_partners_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__register_partners_autClient<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Register_partners_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_autFindFirstArgs} args - Arguments to find a Register_partners_aut
     * @example
     * // Get one Register_partners_aut
     * const register_partners_aut = await prisma.register_partners_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends register_partners_autFindFirstArgs>(args?: SelectSubset<T, register_partners_autFindFirstArgs<ExtArgs>>): Prisma__register_partners_autClient<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Register_partners_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_autFindFirstOrThrowArgs} args - Arguments to find a Register_partners_aut
     * @example
     * // Get one Register_partners_aut
     * const register_partners_aut = await prisma.register_partners_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends register_partners_autFindFirstOrThrowArgs>(args?: SelectSubset<T, register_partners_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__register_partners_autClient<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Register_partners_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Register_partners_auts
     * const register_partners_auts = await prisma.register_partners_aut.findMany()
     * 
     * // Get first 10 Register_partners_auts
     * const register_partners_auts = await prisma.register_partners_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const register_partners_autWithIdOnly = await prisma.register_partners_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends register_partners_autFindManyArgs>(args?: SelectSubset<T, register_partners_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Register_partners_aut.
     * @param {register_partners_autCreateArgs} args - Arguments to create a Register_partners_aut.
     * @example
     * // Create one Register_partners_aut
     * const Register_partners_aut = await prisma.register_partners_aut.create({
     *   data: {
     *     // ... data to create a Register_partners_aut
     *   }
     * })
     * 
     */
    create<T extends register_partners_autCreateArgs>(args: SelectSubset<T, register_partners_autCreateArgs<ExtArgs>>): Prisma__register_partners_autClient<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Register_partners_auts.
     * @param {register_partners_autCreateManyArgs} args - Arguments to create many Register_partners_auts.
     * @example
     * // Create many Register_partners_auts
     * const register_partners_aut = await prisma.register_partners_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends register_partners_autCreateManyArgs>(args?: SelectSubset<T, register_partners_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Register_partners_aut.
     * @param {register_partners_autDeleteArgs} args - Arguments to delete one Register_partners_aut.
     * @example
     * // Delete one Register_partners_aut
     * const Register_partners_aut = await prisma.register_partners_aut.delete({
     *   where: {
     *     // ... filter to delete one Register_partners_aut
     *   }
     * })
     * 
     */
    delete<T extends register_partners_autDeleteArgs>(args: SelectSubset<T, register_partners_autDeleteArgs<ExtArgs>>): Prisma__register_partners_autClient<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Register_partners_aut.
     * @param {register_partners_autUpdateArgs} args - Arguments to update one Register_partners_aut.
     * @example
     * // Update one Register_partners_aut
     * const register_partners_aut = await prisma.register_partners_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends register_partners_autUpdateArgs>(args: SelectSubset<T, register_partners_autUpdateArgs<ExtArgs>>): Prisma__register_partners_autClient<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Register_partners_auts.
     * @param {register_partners_autDeleteManyArgs} args - Arguments to filter Register_partners_auts to delete.
     * @example
     * // Delete a few Register_partners_auts
     * const { count } = await prisma.register_partners_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends register_partners_autDeleteManyArgs>(args?: SelectSubset<T, register_partners_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Register_partners_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Register_partners_auts
     * const register_partners_aut = await prisma.register_partners_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends register_partners_autUpdateManyArgs>(args: SelectSubset<T, register_partners_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Register_partners_aut.
     * @param {register_partners_autUpsertArgs} args - Arguments to update or create a Register_partners_aut.
     * @example
     * // Update or create a Register_partners_aut
     * const register_partners_aut = await prisma.register_partners_aut.upsert({
     *   create: {
     *     // ... data to create a Register_partners_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Register_partners_aut we want to update
     *   }
     * })
     */
    upsert<T extends register_partners_autUpsertArgs>(args: SelectSubset<T, register_partners_autUpsertArgs<ExtArgs>>): Prisma__register_partners_autClient<$Result.GetResult<Prisma.$register_partners_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Register_partners_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_autCountArgs} args - Arguments to filter Register_partners_auts to count.
     * @example
     * // Count the number of Register_partners_auts
     * const count = await prisma.register_partners_aut.count({
     *   where: {
     *     // ... the filter for the Register_partners_auts we want to count
     *   }
     * })
    **/
    count<T extends register_partners_autCountArgs>(
      args?: Subset<T, register_partners_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Register_partners_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Register_partners_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Register_partners_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Register_partners_autAggregateArgs>(args: Subset<T, Register_partners_autAggregateArgs>): Prisma.PrismaPromise<GetRegister_partners_autAggregateType<T>>

    /**
     * Group by Register_partners_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends register_partners_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: register_partners_autGroupByArgs['orderBy'] }
        : { orderBy?: register_partners_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, register_partners_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegister_partners_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the register_partners_aut model
   */
  readonly fields: register_partners_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for register_partners_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__register_partners_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the register_partners_aut model
   */
  interface register_partners_autFieldRefs {
    readonly id: FieldRef<"register_partners_aut", 'String'>
    readonly complete_name: FieldRef<"register_partners_aut", 'String'>
    readonly phone_number: FieldRef<"register_partners_aut", 'String'>
    readonly email: FieldRef<"register_partners_aut", 'String'>
    readonly birth_date: FieldRef<"register_partners_aut", 'String'>
    readonly city: FieldRef<"register_partners_aut", 'String'>
    readonly createdAt: FieldRef<"register_partners_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"register_partners_aut", 'DateTime'>
    readonly obs: FieldRef<"register_partners_aut", 'String'>
  }
    

  // Custom InputTypes
  /**
   * register_partners_aut findUnique
   */
  export type register_partners_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_aut to fetch.
     */
    where: register_partners_autWhereUniqueInput
  }

  /**
   * register_partners_aut findUniqueOrThrow
   */
  export type register_partners_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_aut to fetch.
     */
    where: register_partners_autWhereUniqueInput
  }

  /**
   * register_partners_aut findFirst
   */
  export type register_partners_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_aut to fetch.
     */
    where?: register_partners_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of register_partners_auts to fetch.
     */
    orderBy?: register_partners_autOrderByWithRelationInput | register_partners_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for register_partners_auts.
     */
    cursor?: register_partners_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` register_partners_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` register_partners_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of register_partners_auts.
     */
    distinct?: Register_partners_autScalarFieldEnum | Register_partners_autScalarFieldEnum[]
  }

  /**
   * register_partners_aut findFirstOrThrow
   */
  export type register_partners_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_aut to fetch.
     */
    where?: register_partners_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of register_partners_auts to fetch.
     */
    orderBy?: register_partners_autOrderByWithRelationInput | register_partners_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for register_partners_auts.
     */
    cursor?: register_partners_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` register_partners_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` register_partners_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of register_partners_auts.
     */
    distinct?: Register_partners_autScalarFieldEnum | Register_partners_autScalarFieldEnum[]
  }

  /**
   * register_partners_aut findMany
   */
  export type register_partners_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_auts to fetch.
     */
    where?: register_partners_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of register_partners_auts to fetch.
     */
    orderBy?: register_partners_autOrderByWithRelationInput | register_partners_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing register_partners_auts.
     */
    cursor?: register_partners_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` register_partners_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` register_partners_auts.
     */
    skip?: number
    distinct?: Register_partners_autScalarFieldEnum | Register_partners_autScalarFieldEnum[]
  }

  /**
   * register_partners_aut create
   */
  export type register_partners_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * The data needed to create a register_partners_aut.
     */
    data: XOR<register_partners_autCreateInput, register_partners_autUncheckedCreateInput>
  }

  /**
   * register_partners_aut createMany
   */
  export type register_partners_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many register_partners_auts.
     */
    data: register_partners_autCreateManyInput | register_partners_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * register_partners_aut update
   */
  export type register_partners_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * The data needed to update a register_partners_aut.
     */
    data: XOR<register_partners_autUpdateInput, register_partners_autUncheckedUpdateInput>
    /**
     * Choose, which register_partners_aut to update.
     */
    where: register_partners_autWhereUniqueInput
  }

  /**
   * register_partners_aut updateMany
   */
  export type register_partners_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update register_partners_auts.
     */
    data: XOR<register_partners_autUpdateManyMutationInput, register_partners_autUncheckedUpdateManyInput>
    /**
     * Filter which register_partners_auts to update
     */
    where?: register_partners_autWhereInput
    /**
     * Limit how many register_partners_auts to update.
     */
    limit?: number
  }

  /**
   * register_partners_aut upsert
   */
  export type register_partners_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * The filter to search for the register_partners_aut to update in case it exists.
     */
    where: register_partners_autWhereUniqueInput
    /**
     * In case the register_partners_aut found by the `where` argument doesn't exist, create a new register_partners_aut with this data.
     */
    create: XOR<register_partners_autCreateInput, register_partners_autUncheckedCreateInput>
    /**
     * In case the register_partners_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<register_partners_autUpdateInput, register_partners_autUncheckedUpdateInput>
  }

  /**
   * register_partners_aut delete
   */
  export type register_partners_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
    /**
     * Filter which register_partners_aut to delete.
     */
    where: register_partners_autWhereUniqueInput
  }

  /**
   * register_partners_aut deleteMany
   */
  export type register_partners_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which register_partners_auts to delete
     */
    where?: register_partners_autWhereInput
    /**
     * Limit how many register_partners_auts to delete.
     */
    limit?: number
  }

  /**
   * register_partners_aut without action
   */
  export type register_partners_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_aut
     */
    select?: register_partners_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_aut
     */
    omit?: register_partners_autOmit<ExtArgs> | null
  }


  /**
   * Model register_partners_spa
   */

  export type AggregateRegister_partners_spa = {
    _count: Register_partners_spaCountAggregateOutputType | null
    _min: Register_partners_spaMinAggregateOutputType | null
    _max: Register_partners_spaMaxAggregateOutputType | null
  }

  export type Register_partners_spaMinAggregateOutputType = {
    id: string | null
    complete_name: string | null
    phone_number: string | null
    email: string | null
    birth_date: string | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Register_partners_spaMaxAggregateOutputType = {
    id: string | null
    complete_name: string | null
    phone_number: string | null
    email: string | null
    birth_date: string | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Register_partners_spaCountAggregateOutputType = {
    id: number
    complete_name: number
    phone_number: number
    email: number
    birth_date: number
    city: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Register_partners_spaMinAggregateInputType = {
    id?: true
    complete_name?: true
    phone_number?: true
    email?: true
    birth_date?: true
    city?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Register_partners_spaMaxAggregateInputType = {
    id?: true
    complete_name?: true
    phone_number?: true
    email?: true
    birth_date?: true
    city?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Register_partners_spaCountAggregateInputType = {
    id?: true
    complete_name?: true
    phone_number?: true
    email?: true
    birth_date?: true
    city?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Register_partners_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which register_partners_spa to aggregate.
     */
    where?: register_partners_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of register_partners_spas to fetch.
     */
    orderBy?: register_partners_spaOrderByWithRelationInput | register_partners_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: register_partners_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` register_partners_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` register_partners_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned register_partners_spas
    **/
    _count?: true | Register_partners_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Register_partners_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Register_partners_spaMaxAggregateInputType
  }

  export type GetRegister_partners_spaAggregateType<T extends Register_partners_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateRegister_partners_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegister_partners_spa[P]>
      : GetScalarType<T[P], AggregateRegister_partners_spa[P]>
  }




  export type register_partners_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: register_partners_spaWhereInput
    orderBy?: register_partners_spaOrderByWithAggregationInput | register_partners_spaOrderByWithAggregationInput[]
    by: Register_partners_spaScalarFieldEnum[] | Register_partners_spaScalarFieldEnum
    having?: register_partners_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Register_partners_spaCountAggregateInputType | true
    _min?: Register_partners_spaMinAggregateInputType
    _max?: Register_partners_spaMaxAggregateInputType
  }

  export type Register_partners_spaGroupByOutputType = {
    id: string
    complete_name: string
    phone_number: string
    email: string
    birth_date: string
    city: string
    createdAt: Date
    updatedAt: Date
    _count: Register_partners_spaCountAggregateOutputType | null
    _min: Register_partners_spaMinAggregateOutputType | null
    _max: Register_partners_spaMaxAggregateOutputType | null
  }

  type GetRegister_partners_spaGroupByPayload<T extends register_partners_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Register_partners_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Register_partners_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Register_partners_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Register_partners_spaGroupByOutputType[P]>
        }
      >
    >


  export type register_partners_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    complete_name?: boolean
    phone_number?: boolean
    email?: boolean
    birth_date?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["register_partners_spa"]>



  export type register_partners_spaSelectScalar = {
    id?: boolean
    complete_name?: boolean
    phone_number?: boolean
    email?: boolean
    birth_date?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type register_partners_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "complete_name" | "phone_number" | "email" | "birth_date" | "city" | "createdAt" | "updatedAt", ExtArgs["result"]["register_partners_spa"]>

  export type $register_partners_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "register_partners_spa"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      complete_name: string
      phone_number: string
      email: string
      birth_date: string
      city: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["register_partners_spa"]>
    composites: {}
  }

  type register_partners_spaGetPayload<S extends boolean | null | undefined | register_partners_spaDefaultArgs> = $Result.GetResult<Prisma.$register_partners_spaPayload, S>

  type register_partners_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<register_partners_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Register_partners_spaCountAggregateInputType | true
    }

  export interface register_partners_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['register_partners_spa'], meta: { name: 'register_partners_spa' } }
    /**
     * Find zero or one Register_partners_spa that matches the filter.
     * @param {register_partners_spaFindUniqueArgs} args - Arguments to find a Register_partners_spa
     * @example
     * // Get one Register_partners_spa
     * const register_partners_spa = await prisma.register_partners_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends register_partners_spaFindUniqueArgs>(args: SelectSubset<T, register_partners_spaFindUniqueArgs<ExtArgs>>): Prisma__register_partners_spaClient<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Register_partners_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {register_partners_spaFindUniqueOrThrowArgs} args - Arguments to find a Register_partners_spa
     * @example
     * // Get one Register_partners_spa
     * const register_partners_spa = await prisma.register_partners_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends register_partners_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, register_partners_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__register_partners_spaClient<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Register_partners_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_spaFindFirstArgs} args - Arguments to find a Register_partners_spa
     * @example
     * // Get one Register_partners_spa
     * const register_partners_spa = await prisma.register_partners_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends register_partners_spaFindFirstArgs>(args?: SelectSubset<T, register_partners_spaFindFirstArgs<ExtArgs>>): Prisma__register_partners_spaClient<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Register_partners_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_spaFindFirstOrThrowArgs} args - Arguments to find a Register_partners_spa
     * @example
     * // Get one Register_partners_spa
     * const register_partners_spa = await prisma.register_partners_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends register_partners_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, register_partners_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__register_partners_spaClient<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Register_partners_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Register_partners_spas
     * const register_partners_spas = await prisma.register_partners_spa.findMany()
     * 
     * // Get first 10 Register_partners_spas
     * const register_partners_spas = await prisma.register_partners_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const register_partners_spaWithIdOnly = await prisma.register_partners_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends register_partners_spaFindManyArgs>(args?: SelectSubset<T, register_partners_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Register_partners_spa.
     * @param {register_partners_spaCreateArgs} args - Arguments to create a Register_partners_spa.
     * @example
     * // Create one Register_partners_spa
     * const Register_partners_spa = await prisma.register_partners_spa.create({
     *   data: {
     *     // ... data to create a Register_partners_spa
     *   }
     * })
     * 
     */
    create<T extends register_partners_spaCreateArgs>(args: SelectSubset<T, register_partners_spaCreateArgs<ExtArgs>>): Prisma__register_partners_spaClient<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Register_partners_spas.
     * @param {register_partners_spaCreateManyArgs} args - Arguments to create many Register_partners_spas.
     * @example
     * // Create many Register_partners_spas
     * const register_partners_spa = await prisma.register_partners_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends register_partners_spaCreateManyArgs>(args?: SelectSubset<T, register_partners_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Register_partners_spa.
     * @param {register_partners_spaDeleteArgs} args - Arguments to delete one Register_partners_spa.
     * @example
     * // Delete one Register_partners_spa
     * const Register_partners_spa = await prisma.register_partners_spa.delete({
     *   where: {
     *     // ... filter to delete one Register_partners_spa
     *   }
     * })
     * 
     */
    delete<T extends register_partners_spaDeleteArgs>(args: SelectSubset<T, register_partners_spaDeleteArgs<ExtArgs>>): Prisma__register_partners_spaClient<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Register_partners_spa.
     * @param {register_partners_spaUpdateArgs} args - Arguments to update one Register_partners_spa.
     * @example
     * // Update one Register_partners_spa
     * const register_partners_spa = await prisma.register_partners_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends register_partners_spaUpdateArgs>(args: SelectSubset<T, register_partners_spaUpdateArgs<ExtArgs>>): Prisma__register_partners_spaClient<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Register_partners_spas.
     * @param {register_partners_spaDeleteManyArgs} args - Arguments to filter Register_partners_spas to delete.
     * @example
     * // Delete a few Register_partners_spas
     * const { count } = await prisma.register_partners_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends register_partners_spaDeleteManyArgs>(args?: SelectSubset<T, register_partners_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Register_partners_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Register_partners_spas
     * const register_partners_spa = await prisma.register_partners_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends register_partners_spaUpdateManyArgs>(args: SelectSubset<T, register_partners_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Register_partners_spa.
     * @param {register_partners_spaUpsertArgs} args - Arguments to update or create a Register_partners_spa.
     * @example
     * // Update or create a Register_partners_spa
     * const register_partners_spa = await prisma.register_partners_spa.upsert({
     *   create: {
     *     // ... data to create a Register_partners_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Register_partners_spa we want to update
     *   }
     * })
     */
    upsert<T extends register_partners_spaUpsertArgs>(args: SelectSubset<T, register_partners_spaUpsertArgs<ExtArgs>>): Prisma__register_partners_spaClient<$Result.GetResult<Prisma.$register_partners_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Register_partners_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_spaCountArgs} args - Arguments to filter Register_partners_spas to count.
     * @example
     * // Count the number of Register_partners_spas
     * const count = await prisma.register_partners_spa.count({
     *   where: {
     *     // ... the filter for the Register_partners_spas we want to count
     *   }
     * })
    **/
    count<T extends register_partners_spaCountArgs>(
      args?: Subset<T, register_partners_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Register_partners_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Register_partners_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Register_partners_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Register_partners_spaAggregateArgs>(args: Subset<T, Register_partners_spaAggregateArgs>): Prisma.PrismaPromise<GetRegister_partners_spaAggregateType<T>>

    /**
     * Group by Register_partners_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {register_partners_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends register_partners_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: register_partners_spaGroupByArgs['orderBy'] }
        : { orderBy?: register_partners_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, register_partners_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegister_partners_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the register_partners_spa model
   */
  readonly fields: register_partners_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for register_partners_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__register_partners_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the register_partners_spa model
   */
  interface register_partners_spaFieldRefs {
    readonly id: FieldRef<"register_partners_spa", 'String'>
    readonly complete_name: FieldRef<"register_partners_spa", 'String'>
    readonly phone_number: FieldRef<"register_partners_spa", 'String'>
    readonly email: FieldRef<"register_partners_spa", 'String'>
    readonly birth_date: FieldRef<"register_partners_spa", 'String'>
    readonly city: FieldRef<"register_partners_spa", 'String'>
    readonly createdAt: FieldRef<"register_partners_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"register_partners_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * register_partners_spa findUnique
   */
  export type register_partners_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_spa to fetch.
     */
    where: register_partners_spaWhereUniqueInput
  }

  /**
   * register_partners_spa findUniqueOrThrow
   */
  export type register_partners_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_spa to fetch.
     */
    where: register_partners_spaWhereUniqueInput
  }

  /**
   * register_partners_spa findFirst
   */
  export type register_partners_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_spa to fetch.
     */
    where?: register_partners_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of register_partners_spas to fetch.
     */
    orderBy?: register_partners_spaOrderByWithRelationInput | register_partners_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for register_partners_spas.
     */
    cursor?: register_partners_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` register_partners_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` register_partners_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of register_partners_spas.
     */
    distinct?: Register_partners_spaScalarFieldEnum | Register_partners_spaScalarFieldEnum[]
  }

  /**
   * register_partners_spa findFirstOrThrow
   */
  export type register_partners_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_spa to fetch.
     */
    where?: register_partners_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of register_partners_spas to fetch.
     */
    orderBy?: register_partners_spaOrderByWithRelationInput | register_partners_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for register_partners_spas.
     */
    cursor?: register_partners_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` register_partners_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` register_partners_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of register_partners_spas.
     */
    distinct?: Register_partners_spaScalarFieldEnum | Register_partners_spaScalarFieldEnum[]
  }

  /**
   * register_partners_spa findMany
   */
  export type register_partners_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * Filter, which register_partners_spas to fetch.
     */
    where?: register_partners_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of register_partners_spas to fetch.
     */
    orderBy?: register_partners_spaOrderByWithRelationInput | register_partners_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing register_partners_spas.
     */
    cursor?: register_partners_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` register_partners_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` register_partners_spas.
     */
    skip?: number
    distinct?: Register_partners_spaScalarFieldEnum | Register_partners_spaScalarFieldEnum[]
  }

  /**
   * register_partners_spa create
   */
  export type register_partners_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * The data needed to create a register_partners_spa.
     */
    data: XOR<register_partners_spaCreateInput, register_partners_spaUncheckedCreateInput>
  }

  /**
   * register_partners_spa createMany
   */
  export type register_partners_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many register_partners_spas.
     */
    data: register_partners_spaCreateManyInput | register_partners_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * register_partners_spa update
   */
  export type register_partners_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * The data needed to update a register_partners_spa.
     */
    data: XOR<register_partners_spaUpdateInput, register_partners_spaUncheckedUpdateInput>
    /**
     * Choose, which register_partners_spa to update.
     */
    where: register_partners_spaWhereUniqueInput
  }

  /**
   * register_partners_spa updateMany
   */
  export type register_partners_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update register_partners_spas.
     */
    data: XOR<register_partners_spaUpdateManyMutationInput, register_partners_spaUncheckedUpdateManyInput>
    /**
     * Filter which register_partners_spas to update
     */
    where?: register_partners_spaWhereInput
    /**
     * Limit how many register_partners_spas to update.
     */
    limit?: number
  }

  /**
   * register_partners_spa upsert
   */
  export type register_partners_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * The filter to search for the register_partners_spa to update in case it exists.
     */
    where: register_partners_spaWhereUniqueInput
    /**
     * In case the register_partners_spa found by the `where` argument doesn't exist, create a new register_partners_spa with this data.
     */
    create: XOR<register_partners_spaCreateInput, register_partners_spaUncheckedCreateInput>
    /**
     * In case the register_partners_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<register_partners_spaUpdateInput, register_partners_spaUncheckedUpdateInput>
  }

  /**
   * register_partners_spa delete
   */
  export type register_partners_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
    /**
     * Filter which register_partners_spa to delete.
     */
    where: register_partners_spaWhereUniqueInput
  }

  /**
   * register_partners_spa deleteMany
   */
  export type register_partners_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which register_partners_spas to delete
     */
    where?: register_partners_spaWhereInput
    /**
     * Limit how many register_partners_spas to delete.
     */
    limit?: number
  }

  /**
   * register_partners_spa without action
   */
  export type register_partners_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the register_partners_spa
     */
    select?: register_partners_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the register_partners_spa
     */
    omit?: register_partners_spaOmit<ExtArgs> | null
  }


  /**
   * Model rh_calls
   */

  export type AggregateRh_calls = {
    _count: Rh_callsCountAggregateOutputType | null
    _min: Rh_callsMinAggregateOutputType | null
    _max: Rh_callsMaxAggregateOutputType | null
  }

  export type Rh_callsMinAggregateOutputType = {
    id: string | null
    jid: string | null
    name: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rhNumberId: string | null
  }

  export type Rh_callsMaxAggregateOutputType = {
    id: string | null
    jid: string | null
    name: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rhNumberId: string | null
  }

  export type Rh_callsCountAggregateOutputType = {
    id: number
    jid: number
    name: number
    message: number
    createdAt: number
    updatedAt: number
    rhNumberId: number
    _all: number
  }


  export type Rh_callsMinAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    rhNumberId?: true
  }

  export type Rh_callsMaxAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    rhNumberId?: true
  }

  export type Rh_callsCountAggregateInputType = {
    id?: true
    jid?: true
    name?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    rhNumberId?: true
    _all?: true
  }

  export type Rh_callsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rh_calls to aggregate.
     */
    where?: rh_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rh_calls to fetch.
     */
    orderBy?: rh_callsOrderByWithRelationInput | rh_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rh_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rh_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rh_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rh_calls
    **/
    _count?: true | Rh_callsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rh_callsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rh_callsMaxAggregateInputType
  }

  export type GetRh_callsAggregateType<T extends Rh_callsAggregateArgs> = {
        [P in keyof T & keyof AggregateRh_calls]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRh_calls[P]>
      : GetScalarType<T[P], AggregateRh_calls[P]>
  }




  export type rh_callsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rh_callsWhereInput
    orderBy?: rh_callsOrderByWithAggregationInput | rh_callsOrderByWithAggregationInput[]
    by: Rh_callsScalarFieldEnum[] | Rh_callsScalarFieldEnum
    having?: rh_callsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rh_callsCountAggregateInputType | true
    _min?: Rh_callsMinAggregateInputType
    _max?: Rh_callsMaxAggregateInputType
  }

  export type Rh_callsGroupByOutputType = {
    id: string
    jid: string
    name: string
    message: string
    createdAt: Date
    updatedAt: Date
    rhNumberId: string | null
    _count: Rh_callsCountAggregateOutputType | null
    _min: Rh_callsMinAggregateOutputType | null
    _max: Rh_callsMaxAggregateOutputType | null
  }

  type GetRh_callsGroupByPayload<T extends rh_callsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rh_callsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rh_callsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rh_callsGroupByOutputType[P]>
            : GetScalarType<T[P], Rh_callsGroupByOutputType[P]>
        }
      >
    >


  export type rh_callsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jid?: boolean
    name?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rhNumberId?: boolean
    rh_numbers?: boolean | rh_calls$rh_numbersArgs<ExtArgs>
  }, ExtArgs["result"]["rh_calls"]>



  export type rh_callsSelectScalar = {
    id?: boolean
    jid?: boolean
    name?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rhNumberId?: boolean
  }

  export type rh_callsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jid" | "name" | "message" | "createdAt" | "updatedAt" | "rhNumberId", ExtArgs["result"]["rh_calls"]>
  export type rh_callsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rh_numbers?: boolean | rh_calls$rh_numbersArgs<ExtArgs>
  }

  export type $rh_callsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rh_calls"
    objects: {
      rh_numbers: Prisma.$rh_numbersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jid: string
      name: string
      message: string
      createdAt: Date
      updatedAt: Date
      rhNumberId: string | null
    }, ExtArgs["result"]["rh_calls"]>
    composites: {}
  }

  type rh_callsGetPayload<S extends boolean | null | undefined | rh_callsDefaultArgs> = $Result.GetResult<Prisma.$rh_callsPayload, S>

  type rh_callsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rh_callsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rh_callsCountAggregateInputType | true
    }

  export interface rh_callsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rh_calls'], meta: { name: 'rh_calls' } }
    /**
     * Find zero or one Rh_calls that matches the filter.
     * @param {rh_callsFindUniqueArgs} args - Arguments to find a Rh_calls
     * @example
     * // Get one Rh_calls
     * const rh_calls = await prisma.rh_calls.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rh_callsFindUniqueArgs>(args: SelectSubset<T, rh_callsFindUniqueArgs<ExtArgs>>): Prisma__rh_callsClient<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rh_calls that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rh_callsFindUniqueOrThrowArgs} args - Arguments to find a Rh_calls
     * @example
     * // Get one Rh_calls
     * const rh_calls = await prisma.rh_calls.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rh_callsFindUniqueOrThrowArgs>(args: SelectSubset<T, rh_callsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rh_callsClient<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rh_calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_callsFindFirstArgs} args - Arguments to find a Rh_calls
     * @example
     * // Get one Rh_calls
     * const rh_calls = await prisma.rh_calls.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rh_callsFindFirstArgs>(args?: SelectSubset<T, rh_callsFindFirstArgs<ExtArgs>>): Prisma__rh_callsClient<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rh_calls that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_callsFindFirstOrThrowArgs} args - Arguments to find a Rh_calls
     * @example
     * // Get one Rh_calls
     * const rh_calls = await prisma.rh_calls.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rh_callsFindFirstOrThrowArgs>(args?: SelectSubset<T, rh_callsFindFirstOrThrowArgs<ExtArgs>>): Prisma__rh_callsClient<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rh_calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_callsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rh_calls
     * const rh_calls = await prisma.rh_calls.findMany()
     * 
     * // Get first 10 Rh_calls
     * const rh_calls = await prisma.rh_calls.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rh_callsWithIdOnly = await prisma.rh_calls.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rh_callsFindManyArgs>(args?: SelectSubset<T, rh_callsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rh_calls.
     * @param {rh_callsCreateArgs} args - Arguments to create a Rh_calls.
     * @example
     * // Create one Rh_calls
     * const Rh_calls = await prisma.rh_calls.create({
     *   data: {
     *     // ... data to create a Rh_calls
     *   }
     * })
     * 
     */
    create<T extends rh_callsCreateArgs>(args: SelectSubset<T, rh_callsCreateArgs<ExtArgs>>): Prisma__rh_callsClient<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rh_calls.
     * @param {rh_callsCreateManyArgs} args - Arguments to create many Rh_calls.
     * @example
     * // Create many Rh_calls
     * const rh_calls = await prisma.rh_calls.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rh_callsCreateManyArgs>(args?: SelectSubset<T, rh_callsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rh_calls.
     * @param {rh_callsDeleteArgs} args - Arguments to delete one Rh_calls.
     * @example
     * // Delete one Rh_calls
     * const Rh_calls = await prisma.rh_calls.delete({
     *   where: {
     *     // ... filter to delete one Rh_calls
     *   }
     * })
     * 
     */
    delete<T extends rh_callsDeleteArgs>(args: SelectSubset<T, rh_callsDeleteArgs<ExtArgs>>): Prisma__rh_callsClient<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rh_calls.
     * @param {rh_callsUpdateArgs} args - Arguments to update one Rh_calls.
     * @example
     * // Update one Rh_calls
     * const rh_calls = await prisma.rh_calls.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rh_callsUpdateArgs>(args: SelectSubset<T, rh_callsUpdateArgs<ExtArgs>>): Prisma__rh_callsClient<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rh_calls.
     * @param {rh_callsDeleteManyArgs} args - Arguments to filter Rh_calls to delete.
     * @example
     * // Delete a few Rh_calls
     * const { count } = await prisma.rh_calls.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rh_callsDeleteManyArgs>(args?: SelectSubset<T, rh_callsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rh_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_callsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rh_calls
     * const rh_calls = await prisma.rh_calls.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rh_callsUpdateManyArgs>(args: SelectSubset<T, rh_callsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rh_calls.
     * @param {rh_callsUpsertArgs} args - Arguments to update or create a Rh_calls.
     * @example
     * // Update or create a Rh_calls
     * const rh_calls = await prisma.rh_calls.upsert({
     *   create: {
     *     // ... data to create a Rh_calls
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rh_calls we want to update
     *   }
     * })
     */
    upsert<T extends rh_callsUpsertArgs>(args: SelectSubset<T, rh_callsUpsertArgs<ExtArgs>>): Prisma__rh_callsClient<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rh_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_callsCountArgs} args - Arguments to filter Rh_calls to count.
     * @example
     * // Count the number of Rh_calls
     * const count = await prisma.rh_calls.count({
     *   where: {
     *     // ... the filter for the Rh_calls we want to count
     *   }
     * })
    **/
    count<T extends rh_callsCountArgs>(
      args?: Subset<T, rh_callsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rh_callsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rh_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rh_callsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rh_callsAggregateArgs>(args: Subset<T, Rh_callsAggregateArgs>): Prisma.PrismaPromise<GetRh_callsAggregateType<T>>

    /**
     * Group by Rh_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_callsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rh_callsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rh_callsGroupByArgs['orderBy'] }
        : { orderBy?: rh_callsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rh_callsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRh_callsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rh_calls model
   */
  readonly fields: rh_callsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rh_calls.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rh_callsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rh_numbers<T extends rh_calls$rh_numbersArgs<ExtArgs> = {}>(args?: Subset<T, rh_calls$rh_numbersArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rh_calls model
   */
  interface rh_callsFieldRefs {
    readonly id: FieldRef<"rh_calls", 'String'>
    readonly jid: FieldRef<"rh_calls", 'String'>
    readonly name: FieldRef<"rh_calls", 'String'>
    readonly message: FieldRef<"rh_calls", 'String'>
    readonly createdAt: FieldRef<"rh_calls", 'DateTime'>
    readonly updatedAt: FieldRef<"rh_calls", 'DateTime'>
    readonly rhNumberId: FieldRef<"rh_calls", 'String'>
  }
    

  // Custom InputTypes
  /**
   * rh_calls findUnique
   */
  export type rh_callsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * Filter, which rh_calls to fetch.
     */
    where: rh_callsWhereUniqueInput
  }

  /**
   * rh_calls findUniqueOrThrow
   */
  export type rh_callsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * Filter, which rh_calls to fetch.
     */
    where: rh_callsWhereUniqueInput
  }

  /**
   * rh_calls findFirst
   */
  export type rh_callsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * Filter, which rh_calls to fetch.
     */
    where?: rh_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rh_calls to fetch.
     */
    orderBy?: rh_callsOrderByWithRelationInput | rh_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rh_calls.
     */
    cursor?: rh_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rh_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rh_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rh_calls.
     */
    distinct?: Rh_callsScalarFieldEnum | Rh_callsScalarFieldEnum[]
  }

  /**
   * rh_calls findFirstOrThrow
   */
  export type rh_callsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * Filter, which rh_calls to fetch.
     */
    where?: rh_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rh_calls to fetch.
     */
    orderBy?: rh_callsOrderByWithRelationInput | rh_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rh_calls.
     */
    cursor?: rh_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rh_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rh_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rh_calls.
     */
    distinct?: Rh_callsScalarFieldEnum | Rh_callsScalarFieldEnum[]
  }

  /**
   * rh_calls findMany
   */
  export type rh_callsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * Filter, which rh_calls to fetch.
     */
    where?: rh_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rh_calls to fetch.
     */
    orderBy?: rh_callsOrderByWithRelationInput | rh_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rh_calls.
     */
    cursor?: rh_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rh_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rh_calls.
     */
    skip?: number
    distinct?: Rh_callsScalarFieldEnum | Rh_callsScalarFieldEnum[]
  }

  /**
   * rh_calls create
   */
  export type rh_callsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * The data needed to create a rh_calls.
     */
    data: XOR<rh_callsCreateInput, rh_callsUncheckedCreateInput>
  }

  /**
   * rh_calls createMany
   */
  export type rh_callsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rh_calls.
     */
    data: rh_callsCreateManyInput | rh_callsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rh_calls update
   */
  export type rh_callsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * The data needed to update a rh_calls.
     */
    data: XOR<rh_callsUpdateInput, rh_callsUncheckedUpdateInput>
    /**
     * Choose, which rh_calls to update.
     */
    where: rh_callsWhereUniqueInput
  }

  /**
   * rh_calls updateMany
   */
  export type rh_callsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rh_calls.
     */
    data: XOR<rh_callsUpdateManyMutationInput, rh_callsUncheckedUpdateManyInput>
    /**
     * Filter which rh_calls to update
     */
    where?: rh_callsWhereInput
    /**
     * Limit how many rh_calls to update.
     */
    limit?: number
  }

  /**
   * rh_calls upsert
   */
  export type rh_callsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * The filter to search for the rh_calls to update in case it exists.
     */
    where: rh_callsWhereUniqueInput
    /**
     * In case the rh_calls found by the `where` argument doesn't exist, create a new rh_calls with this data.
     */
    create: XOR<rh_callsCreateInput, rh_callsUncheckedCreateInput>
    /**
     * In case the rh_calls was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rh_callsUpdateInput, rh_callsUncheckedUpdateInput>
  }

  /**
   * rh_calls delete
   */
  export type rh_callsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    /**
     * Filter which rh_calls to delete.
     */
    where: rh_callsWhereUniqueInput
  }

  /**
   * rh_calls deleteMany
   */
  export type rh_callsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rh_calls to delete
     */
    where?: rh_callsWhereInput
    /**
     * Limit how many rh_calls to delete.
     */
    limit?: number
  }

  /**
   * rh_calls.rh_numbers
   */
  export type rh_calls$rh_numbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    where?: rh_numbersWhereInput
  }

  /**
   * rh_calls without action
   */
  export type rh_callsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
  }


  /**
   * Model rh_numbers
   */

  export type AggregateRh_numbers = {
    _count: Rh_numbersCountAggregateOutputType | null
    _min: Rh_numbersMinAggregateOutputType | null
    _max: Rh_numbersMaxAggregateOutputType | null
  }

  export type Rh_numbersMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Rh_numbersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Rh_numbersCountAggregateOutputType = {
    id: number
    name: number
    phone_number: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Rh_numbersMinAggregateInputType = {
    id?: true
    name?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Rh_numbersMaxAggregateInputType = {
    id?: true
    name?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Rh_numbersCountAggregateInputType = {
    id?: true
    name?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Rh_numbersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rh_numbers to aggregate.
     */
    where?: rh_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rh_numbers to fetch.
     */
    orderBy?: rh_numbersOrderByWithRelationInput | rh_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rh_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rh_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rh_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rh_numbers
    **/
    _count?: true | Rh_numbersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rh_numbersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rh_numbersMaxAggregateInputType
  }

  export type GetRh_numbersAggregateType<T extends Rh_numbersAggregateArgs> = {
        [P in keyof T & keyof AggregateRh_numbers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRh_numbers[P]>
      : GetScalarType<T[P], AggregateRh_numbers[P]>
  }




  export type rh_numbersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rh_numbersWhereInput
    orderBy?: rh_numbersOrderByWithAggregationInput | rh_numbersOrderByWithAggregationInput[]
    by: Rh_numbersScalarFieldEnum[] | Rh_numbersScalarFieldEnum
    having?: rh_numbersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rh_numbersCountAggregateInputType | true
    _min?: Rh_numbersMinAggregateInputType
    _max?: Rh_numbersMaxAggregateInputType
  }

  export type Rh_numbersGroupByOutputType = {
    id: string
    name: string
    phone_number: string
    createdAt: Date
    updatedAt: Date
    _count: Rh_numbersCountAggregateOutputType | null
    _min: Rh_numbersMinAggregateOutputType | null
    _max: Rh_numbersMaxAggregateOutputType | null
  }

  type GetRh_numbersGroupByPayload<T extends rh_numbersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rh_numbersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rh_numbersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rh_numbersGroupByOutputType[P]>
            : GetScalarType<T[P], Rh_numbersGroupByOutputType[P]>
        }
      >
    >


  export type rh_numbersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rh_calls?: boolean | rh_numbers$rh_callsArgs<ExtArgs>
    _count?: boolean | Rh_numbersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rh_numbers"]>



  export type rh_numbersSelectScalar = {
    id?: boolean
    name?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type rh_numbersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone_number" | "createdAt" | "updatedAt", ExtArgs["result"]["rh_numbers"]>
  export type rh_numbersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rh_calls?: boolean | rh_numbers$rh_callsArgs<ExtArgs>
    _count?: boolean | Rh_numbersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rh_numbersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rh_numbers"
    objects: {
      rh_calls: Prisma.$rh_callsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone_number: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rh_numbers"]>
    composites: {}
  }

  type rh_numbersGetPayload<S extends boolean | null | undefined | rh_numbersDefaultArgs> = $Result.GetResult<Prisma.$rh_numbersPayload, S>

  type rh_numbersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rh_numbersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rh_numbersCountAggregateInputType | true
    }

  export interface rh_numbersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rh_numbers'], meta: { name: 'rh_numbers' } }
    /**
     * Find zero or one Rh_numbers that matches the filter.
     * @param {rh_numbersFindUniqueArgs} args - Arguments to find a Rh_numbers
     * @example
     * // Get one Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rh_numbersFindUniqueArgs>(args: SelectSubset<T, rh_numbersFindUniqueArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rh_numbers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rh_numbersFindUniqueOrThrowArgs} args - Arguments to find a Rh_numbers
     * @example
     * // Get one Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rh_numbersFindUniqueOrThrowArgs>(args: SelectSubset<T, rh_numbersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rh_numbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_numbersFindFirstArgs} args - Arguments to find a Rh_numbers
     * @example
     * // Get one Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rh_numbersFindFirstArgs>(args?: SelectSubset<T, rh_numbersFindFirstArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rh_numbers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_numbersFindFirstOrThrowArgs} args - Arguments to find a Rh_numbers
     * @example
     * // Get one Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rh_numbersFindFirstOrThrowArgs>(args?: SelectSubset<T, rh_numbersFindFirstOrThrowArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rh_numbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_numbersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.findMany()
     * 
     * // Get first 10 Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rh_numbersWithIdOnly = await prisma.rh_numbers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rh_numbersFindManyArgs>(args?: SelectSubset<T, rh_numbersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rh_numbers.
     * @param {rh_numbersCreateArgs} args - Arguments to create a Rh_numbers.
     * @example
     * // Create one Rh_numbers
     * const Rh_numbers = await prisma.rh_numbers.create({
     *   data: {
     *     // ... data to create a Rh_numbers
     *   }
     * })
     * 
     */
    create<T extends rh_numbersCreateArgs>(args: SelectSubset<T, rh_numbersCreateArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rh_numbers.
     * @param {rh_numbersCreateManyArgs} args - Arguments to create many Rh_numbers.
     * @example
     * // Create many Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rh_numbersCreateManyArgs>(args?: SelectSubset<T, rh_numbersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rh_numbers.
     * @param {rh_numbersDeleteArgs} args - Arguments to delete one Rh_numbers.
     * @example
     * // Delete one Rh_numbers
     * const Rh_numbers = await prisma.rh_numbers.delete({
     *   where: {
     *     // ... filter to delete one Rh_numbers
     *   }
     * })
     * 
     */
    delete<T extends rh_numbersDeleteArgs>(args: SelectSubset<T, rh_numbersDeleteArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rh_numbers.
     * @param {rh_numbersUpdateArgs} args - Arguments to update one Rh_numbers.
     * @example
     * // Update one Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rh_numbersUpdateArgs>(args: SelectSubset<T, rh_numbersUpdateArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rh_numbers.
     * @param {rh_numbersDeleteManyArgs} args - Arguments to filter Rh_numbers to delete.
     * @example
     * // Delete a few Rh_numbers
     * const { count } = await prisma.rh_numbers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rh_numbersDeleteManyArgs>(args?: SelectSubset<T, rh_numbersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rh_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_numbersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rh_numbersUpdateManyArgs>(args: SelectSubset<T, rh_numbersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rh_numbers.
     * @param {rh_numbersUpsertArgs} args - Arguments to update or create a Rh_numbers.
     * @example
     * // Update or create a Rh_numbers
     * const rh_numbers = await prisma.rh_numbers.upsert({
     *   create: {
     *     // ... data to create a Rh_numbers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rh_numbers we want to update
     *   }
     * })
     */
    upsert<T extends rh_numbersUpsertArgs>(args: SelectSubset<T, rh_numbersUpsertArgs<ExtArgs>>): Prisma__rh_numbersClient<$Result.GetResult<Prisma.$rh_numbersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rh_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_numbersCountArgs} args - Arguments to filter Rh_numbers to count.
     * @example
     * // Count the number of Rh_numbers
     * const count = await prisma.rh_numbers.count({
     *   where: {
     *     // ... the filter for the Rh_numbers we want to count
     *   }
     * })
    **/
    count<T extends rh_numbersCountArgs>(
      args?: Subset<T, rh_numbersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rh_numbersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rh_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rh_numbersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rh_numbersAggregateArgs>(args: Subset<T, Rh_numbersAggregateArgs>): Prisma.PrismaPromise<GetRh_numbersAggregateType<T>>

    /**
     * Group by Rh_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rh_numbersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rh_numbersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rh_numbersGroupByArgs['orderBy'] }
        : { orderBy?: rh_numbersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rh_numbersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRh_numbersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rh_numbers model
   */
  readonly fields: rh_numbersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rh_numbers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rh_numbersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rh_calls<T extends rh_numbers$rh_callsArgs<ExtArgs> = {}>(args?: Subset<T, rh_numbers$rh_callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rh_callsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rh_numbers model
   */
  interface rh_numbersFieldRefs {
    readonly id: FieldRef<"rh_numbers", 'String'>
    readonly name: FieldRef<"rh_numbers", 'String'>
    readonly phone_number: FieldRef<"rh_numbers", 'String'>
    readonly createdAt: FieldRef<"rh_numbers", 'DateTime'>
    readonly updatedAt: FieldRef<"rh_numbers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rh_numbers findUnique
   */
  export type rh_numbersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * Filter, which rh_numbers to fetch.
     */
    where: rh_numbersWhereUniqueInput
  }

  /**
   * rh_numbers findUniqueOrThrow
   */
  export type rh_numbersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * Filter, which rh_numbers to fetch.
     */
    where: rh_numbersWhereUniqueInput
  }

  /**
   * rh_numbers findFirst
   */
  export type rh_numbersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * Filter, which rh_numbers to fetch.
     */
    where?: rh_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rh_numbers to fetch.
     */
    orderBy?: rh_numbersOrderByWithRelationInput | rh_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rh_numbers.
     */
    cursor?: rh_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rh_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rh_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rh_numbers.
     */
    distinct?: Rh_numbersScalarFieldEnum | Rh_numbersScalarFieldEnum[]
  }

  /**
   * rh_numbers findFirstOrThrow
   */
  export type rh_numbersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * Filter, which rh_numbers to fetch.
     */
    where?: rh_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rh_numbers to fetch.
     */
    orderBy?: rh_numbersOrderByWithRelationInput | rh_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rh_numbers.
     */
    cursor?: rh_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rh_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rh_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rh_numbers.
     */
    distinct?: Rh_numbersScalarFieldEnum | Rh_numbersScalarFieldEnum[]
  }

  /**
   * rh_numbers findMany
   */
  export type rh_numbersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * Filter, which rh_numbers to fetch.
     */
    where?: rh_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rh_numbers to fetch.
     */
    orderBy?: rh_numbersOrderByWithRelationInput | rh_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rh_numbers.
     */
    cursor?: rh_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rh_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rh_numbers.
     */
    skip?: number
    distinct?: Rh_numbersScalarFieldEnum | Rh_numbersScalarFieldEnum[]
  }

  /**
   * rh_numbers create
   */
  export type rh_numbersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * The data needed to create a rh_numbers.
     */
    data: XOR<rh_numbersCreateInput, rh_numbersUncheckedCreateInput>
  }

  /**
   * rh_numbers createMany
   */
  export type rh_numbersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rh_numbers.
     */
    data: rh_numbersCreateManyInput | rh_numbersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rh_numbers update
   */
  export type rh_numbersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * The data needed to update a rh_numbers.
     */
    data: XOR<rh_numbersUpdateInput, rh_numbersUncheckedUpdateInput>
    /**
     * Choose, which rh_numbers to update.
     */
    where: rh_numbersWhereUniqueInput
  }

  /**
   * rh_numbers updateMany
   */
  export type rh_numbersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rh_numbers.
     */
    data: XOR<rh_numbersUpdateManyMutationInput, rh_numbersUncheckedUpdateManyInput>
    /**
     * Filter which rh_numbers to update
     */
    where?: rh_numbersWhereInput
    /**
     * Limit how many rh_numbers to update.
     */
    limit?: number
  }

  /**
   * rh_numbers upsert
   */
  export type rh_numbersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * The filter to search for the rh_numbers to update in case it exists.
     */
    where: rh_numbersWhereUniqueInput
    /**
     * In case the rh_numbers found by the `where` argument doesn't exist, create a new rh_numbers with this data.
     */
    create: XOR<rh_numbersCreateInput, rh_numbersUncheckedCreateInput>
    /**
     * In case the rh_numbers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rh_numbersUpdateInput, rh_numbersUncheckedUpdateInput>
  }

  /**
   * rh_numbers delete
   */
  export type rh_numbersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
    /**
     * Filter which rh_numbers to delete.
     */
    where: rh_numbersWhereUniqueInput
  }

  /**
   * rh_numbers deleteMany
   */
  export type rh_numbersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rh_numbers to delete
     */
    where?: rh_numbersWhereInput
    /**
     * Limit how many rh_numbers to delete.
     */
    limit?: number
  }

  /**
   * rh_numbers.rh_calls
   */
  export type rh_numbers$rh_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_calls
     */
    select?: rh_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_calls
     */
    omit?: rh_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_callsInclude<ExtArgs> | null
    where?: rh_callsWhereInput
    orderBy?: rh_callsOrderByWithRelationInput | rh_callsOrderByWithRelationInput[]
    cursor?: rh_callsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rh_callsScalarFieldEnum | Rh_callsScalarFieldEnum[]
  }

  /**
   * rh_numbers without action
   */
  export type rh_numbersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rh_numbers
     */
    select?: rh_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rh_numbers
     */
    omit?: rh_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rh_numbersInclude<ExtArgs> | null
  }


  /**
   * Model seller_codes
   */

  export type AggregateSeller_codes = {
    _count: Seller_codesCountAggregateOutputType | null
    _avg: Seller_codesAvgAggregateOutputType | null
    _sum: Seller_codesSumAggregateOutputType | null
    _min: Seller_codesMinAggregateOutputType | null
    _max: Seller_codesMaxAggregateOutputType | null
  }

  export type Seller_codesAvgAggregateOutputType = {
    code: number | null
  }

  export type Seller_codesSumAggregateOutputType = {
    code: number | null
  }

  export type Seller_codesMinAggregateOutputType = {
    id: string | null
    code: number | null
    square: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Seller_codesMaxAggregateOutputType = {
    id: string | null
    code: number | null
    square: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Seller_codesCountAggregateOutputType = {
    id: number
    code: number
    square: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Seller_codesAvgAggregateInputType = {
    code?: true
  }

  export type Seller_codesSumAggregateInputType = {
    code?: true
  }

  export type Seller_codesMinAggregateInputType = {
    id?: true
    code?: true
    square?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Seller_codesMaxAggregateInputType = {
    id?: true
    code?: true
    square?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Seller_codesCountAggregateInputType = {
    id?: true
    code?: true
    square?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Seller_codesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seller_codes to aggregate.
     */
    where?: seller_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seller_codes to fetch.
     */
    orderBy?: seller_codesOrderByWithRelationInput | seller_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seller_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seller_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seller_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seller_codes
    **/
    _count?: true | Seller_codesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Seller_codesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Seller_codesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Seller_codesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Seller_codesMaxAggregateInputType
  }

  export type GetSeller_codesAggregateType<T extends Seller_codesAggregateArgs> = {
        [P in keyof T & keyof AggregateSeller_codes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeller_codes[P]>
      : GetScalarType<T[P], AggregateSeller_codes[P]>
  }




  export type seller_codesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seller_codesWhereInput
    orderBy?: seller_codesOrderByWithAggregationInput | seller_codesOrderByWithAggregationInput[]
    by: Seller_codesScalarFieldEnum[] | Seller_codesScalarFieldEnum
    having?: seller_codesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Seller_codesCountAggregateInputType | true
    _avg?: Seller_codesAvgAggregateInputType
    _sum?: Seller_codesSumAggregateInputType
    _min?: Seller_codesMinAggregateInputType
    _max?: Seller_codesMaxAggregateInputType
  }

  export type Seller_codesGroupByOutputType = {
    id: string
    code: number
    square: string
    createdAt: Date
    updatedAt: Date
    _count: Seller_codesCountAggregateOutputType | null
    _avg: Seller_codesAvgAggregateOutputType | null
    _sum: Seller_codesSumAggregateOutputType | null
    _min: Seller_codesMinAggregateOutputType | null
    _max: Seller_codesMaxAggregateOutputType | null
  }

  type GetSeller_codesGroupByPayload<T extends seller_codesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Seller_codesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Seller_codesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Seller_codesGroupByOutputType[P]>
            : GetScalarType<T[P], Seller_codesGroupByOutputType[P]>
        }
      >
    >


  export type seller_codesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    square?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["seller_codes"]>



  export type seller_codesSelectScalar = {
    id?: boolean
    code?: boolean
    square?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type seller_codesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "square" | "createdAt" | "updatedAt", ExtArgs["result"]["seller_codes"]>

  export type $seller_codesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "seller_codes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: number
      square: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seller_codes"]>
    composites: {}
  }

  type seller_codesGetPayload<S extends boolean | null | undefined | seller_codesDefaultArgs> = $Result.GetResult<Prisma.$seller_codesPayload, S>

  type seller_codesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<seller_codesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Seller_codesCountAggregateInputType | true
    }

  export interface seller_codesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seller_codes'], meta: { name: 'seller_codes' } }
    /**
     * Find zero or one Seller_codes that matches the filter.
     * @param {seller_codesFindUniqueArgs} args - Arguments to find a Seller_codes
     * @example
     * // Get one Seller_codes
     * const seller_codes = await prisma.seller_codes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends seller_codesFindUniqueArgs>(args: SelectSubset<T, seller_codesFindUniqueArgs<ExtArgs>>): Prisma__seller_codesClient<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seller_codes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {seller_codesFindUniqueOrThrowArgs} args - Arguments to find a Seller_codes
     * @example
     * // Get one Seller_codes
     * const seller_codes = await prisma.seller_codes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends seller_codesFindUniqueOrThrowArgs>(args: SelectSubset<T, seller_codesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__seller_codesClient<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seller_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seller_codesFindFirstArgs} args - Arguments to find a Seller_codes
     * @example
     * // Get one Seller_codes
     * const seller_codes = await prisma.seller_codes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends seller_codesFindFirstArgs>(args?: SelectSubset<T, seller_codesFindFirstArgs<ExtArgs>>): Prisma__seller_codesClient<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seller_codes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seller_codesFindFirstOrThrowArgs} args - Arguments to find a Seller_codes
     * @example
     * // Get one Seller_codes
     * const seller_codes = await prisma.seller_codes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends seller_codesFindFirstOrThrowArgs>(args?: SelectSubset<T, seller_codesFindFirstOrThrowArgs<ExtArgs>>): Prisma__seller_codesClient<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seller_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seller_codesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seller_codes
     * const seller_codes = await prisma.seller_codes.findMany()
     * 
     * // Get first 10 Seller_codes
     * const seller_codes = await prisma.seller_codes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seller_codesWithIdOnly = await prisma.seller_codes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends seller_codesFindManyArgs>(args?: SelectSubset<T, seller_codesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seller_codes.
     * @param {seller_codesCreateArgs} args - Arguments to create a Seller_codes.
     * @example
     * // Create one Seller_codes
     * const Seller_codes = await prisma.seller_codes.create({
     *   data: {
     *     // ... data to create a Seller_codes
     *   }
     * })
     * 
     */
    create<T extends seller_codesCreateArgs>(args: SelectSubset<T, seller_codesCreateArgs<ExtArgs>>): Prisma__seller_codesClient<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seller_codes.
     * @param {seller_codesCreateManyArgs} args - Arguments to create many Seller_codes.
     * @example
     * // Create many Seller_codes
     * const seller_codes = await prisma.seller_codes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends seller_codesCreateManyArgs>(args?: SelectSubset<T, seller_codesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seller_codes.
     * @param {seller_codesDeleteArgs} args - Arguments to delete one Seller_codes.
     * @example
     * // Delete one Seller_codes
     * const Seller_codes = await prisma.seller_codes.delete({
     *   where: {
     *     // ... filter to delete one Seller_codes
     *   }
     * })
     * 
     */
    delete<T extends seller_codesDeleteArgs>(args: SelectSubset<T, seller_codesDeleteArgs<ExtArgs>>): Prisma__seller_codesClient<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seller_codes.
     * @param {seller_codesUpdateArgs} args - Arguments to update one Seller_codes.
     * @example
     * // Update one Seller_codes
     * const seller_codes = await prisma.seller_codes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends seller_codesUpdateArgs>(args: SelectSubset<T, seller_codesUpdateArgs<ExtArgs>>): Prisma__seller_codesClient<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seller_codes.
     * @param {seller_codesDeleteManyArgs} args - Arguments to filter Seller_codes to delete.
     * @example
     * // Delete a few Seller_codes
     * const { count } = await prisma.seller_codes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends seller_codesDeleteManyArgs>(args?: SelectSubset<T, seller_codesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seller_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seller_codesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seller_codes
     * const seller_codes = await prisma.seller_codes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends seller_codesUpdateManyArgs>(args: SelectSubset<T, seller_codesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seller_codes.
     * @param {seller_codesUpsertArgs} args - Arguments to update or create a Seller_codes.
     * @example
     * // Update or create a Seller_codes
     * const seller_codes = await prisma.seller_codes.upsert({
     *   create: {
     *     // ... data to create a Seller_codes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seller_codes we want to update
     *   }
     * })
     */
    upsert<T extends seller_codesUpsertArgs>(args: SelectSubset<T, seller_codesUpsertArgs<ExtArgs>>): Prisma__seller_codesClient<$Result.GetResult<Prisma.$seller_codesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seller_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seller_codesCountArgs} args - Arguments to filter Seller_codes to count.
     * @example
     * // Count the number of Seller_codes
     * const count = await prisma.seller_codes.count({
     *   where: {
     *     // ... the filter for the Seller_codes we want to count
     *   }
     * })
    **/
    count<T extends seller_codesCountArgs>(
      args?: Subset<T, seller_codesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Seller_codesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seller_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Seller_codesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Seller_codesAggregateArgs>(args: Subset<T, Seller_codesAggregateArgs>): Prisma.PrismaPromise<GetSeller_codesAggregateType<T>>

    /**
     * Group by Seller_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seller_codesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends seller_codesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: seller_codesGroupByArgs['orderBy'] }
        : { orderBy?: seller_codesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, seller_codesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeller_codesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the seller_codes model
   */
  readonly fields: seller_codesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for seller_codes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__seller_codesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the seller_codes model
   */
  interface seller_codesFieldRefs {
    readonly id: FieldRef<"seller_codes", 'String'>
    readonly code: FieldRef<"seller_codes", 'Int'>
    readonly square: FieldRef<"seller_codes", 'String'>
    readonly createdAt: FieldRef<"seller_codes", 'DateTime'>
    readonly updatedAt: FieldRef<"seller_codes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * seller_codes findUnique
   */
  export type seller_codesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * Filter, which seller_codes to fetch.
     */
    where: seller_codesWhereUniqueInput
  }

  /**
   * seller_codes findUniqueOrThrow
   */
  export type seller_codesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * Filter, which seller_codes to fetch.
     */
    where: seller_codesWhereUniqueInput
  }

  /**
   * seller_codes findFirst
   */
  export type seller_codesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * Filter, which seller_codes to fetch.
     */
    where?: seller_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seller_codes to fetch.
     */
    orderBy?: seller_codesOrderByWithRelationInput | seller_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seller_codes.
     */
    cursor?: seller_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seller_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seller_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seller_codes.
     */
    distinct?: Seller_codesScalarFieldEnum | Seller_codesScalarFieldEnum[]
  }

  /**
   * seller_codes findFirstOrThrow
   */
  export type seller_codesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * Filter, which seller_codes to fetch.
     */
    where?: seller_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seller_codes to fetch.
     */
    orderBy?: seller_codesOrderByWithRelationInput | seller_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seller_codes.
     */
    cursor?: seller_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seller_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seller_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seller_codes.
     */
    distinct?: Seller_codesScalarFieldEnum | Seller_codesScalarFieldEnum[]
  }

  /**
   * seller_codes findMany
   */
  export type seller_codesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * Filter, which seller_codes to fetch.
     */
    where?: seller_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seller_codes to fetch.
     */
    orderBy?: seller_codesOrderByWithRelationInput | seller_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seller_codes.
     */
    cursor?: seller_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seller_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seller_codes.
     */
    skip?: number
    distinct?: Seller_codesScalarFieldEnum | Seller_codesScalarFieldEnum[]
  }

  /**
   * seller_codes create
   */
  export type seller_codesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * The data needed to create a seller_codes.
     */
    data: XOR<seller_codesCreateInput, seller_codesUncheckedCreateInput>
  }

  /**
   * seller_codes createMany
   */
  export type seller_codesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seller_codes.
     */
    data: seller_codesCreateManyInput | seller_codesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * seller_codes update
   */
  export type seller_codesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * The data needed to update a seller_codes.
     */
    data: XOR<seller_codesUpdateInput, seller_codesUncheckedUpdateInput>
    /**
     * Choose, which seller_codes to update.
     */
    where: seller_codesWhereUniqueInput
  }

  /**
   * seller_codes updateMany
   */
  export type seller_codesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seller_codes.
     */
    data: XOR<seller_codesUpdateManyMutationInput, seller_codesUncheckedUpdateManyInput>
    /**
     * Filter which seller_codes to update
     */
    where?: seller_codesWhereInput
    /**
     * Limit how many seller_codes to update.
     */
    limit?: number
  }

  /**
   * seller_codes upsert
   */
  export type seller_codesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * The filter to search for the seller_codes to update in case it exists.
     */
    where: seller_codesWhereUniqueInput
    /**
     * In case the seller_codes found by the `where` argument doesn't exist, create a new seller_codes with this data.
     */
    create: XOR<seller_codesCreateInput, seller_codesUncheckedCreateInput>
    /**
     * In case the seller_codes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seller_codesUpdateInput, seller_codesUncheckedUpdateInput>
  }

  /**
   * seller_codes delete
   */
  export type seller_codesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
    /**
     * Filter which seller_codes to delete.
     */
    where: seller_codesWhereUniqueInput
  }

  /**
   * seller_codes deleteMany
   */
  export type seller_codesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seller_codes to delete
     */
    where?: seller_codesWhereInput
    /**
     * Limit how many seller_codes to delete.
     */
    limit?: number
  }

  /**
   * seller_codes without action
   */
  export type seller_codesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seller_codes
     */
    select?: seller_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seller_codes
     */
    omit?: seller_codesOmit<ExtArgs> | null
  }


  /**
   * Model sessions_aut
   */

  export type AggregateSessions_aut = {
    _count: Sessions_autCountAggregateOutputType | null
    _avg: Sessions_autAvgAggregateOutputType | null
    _sum: Sessions_autSumAggregateOutputType | null
    _min: Sessions_autMinAggregateOutputType | null
    _max: Sessions_autMaxAggregateOutputType | null
  }

  export type Sessions_autAvgAggregateOutputType = {
    entrace_option: number | null
  }

  export type Sessions_autSumAggregateOutputType = {
    entrace_option: number | null
  }

  export type Sessions_autMinAggregateOutputType = {
    id: string | null
    entrace_option: number | null
    is_finished: boolean | null
    is_timeout: boolean | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sessions_autMaxAggregateOutputType = {
    id: string | null
    entrace_option: number | null
    is_finished: boolean | null
    is_timeout: boolean | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sessions_autCountAggregateOutputType = {
    id: number
    entrace_option: number
    is_finished: number
    is_timeout: number
    is_error: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Sessions_autAvgAggregateInputType = {
    entrace_option?: true
  }

  export type Sessions_autSumAggregateInputType = {
    entrace_option?: true
  }

  export type Sessions_autMinAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sessions_autMaxAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sessions_autCountAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Sessions_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions_aut to aggregate.
     */
    where?: sessions_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_auts to fetch.
     */
    orderBy?: sessions_autOrderByWithRelationInput | sessions_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessions_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions_auts
    **/
    _count?: true | Sessions_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sessions_autAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sessions_autSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sessions_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sessions_autMaxAggregateInputType
  }

  export type GetSessions_autAggregateType<T extends Sessions_autAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions_aut[P]>
      : GetScalarType<T[P], AggregateSessions_aut[P]>
  }




  export type sessions_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessions_autWhereInput
    orderBy?: sessions_autOrderByWithAggregationInput | sessions_autOrderByWithAggregationInput[]
    by: Sessions_autScalarFieldEnum[] | Sessions_autScalarFieldEnum
    having?: sessions_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sessions_autCountAggregateInputType | true
    _avg?: Sessions_autAvgAggregateInputType
    _sum?: Sessions_autSumAggregateInputType
    _min?: Sessions_autMinAggregateInputType
    _max?: Sessions_autMaxAggregateInputType
  }

  export type Sessions_autGroupByOutputType = {
    id: string
    entrace_option: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date
    updatedAt: Date
    _count: Sessions_autCountAggregateOutputType | null
    _avg: Sessions_autAvgAggregateOutputType | null
    _sum: Sessions_autSumAggregateOutputType | null
    _min: Sessions_autMinAggregateOutputType | null
    _max: Sessions_autMaxAggregateOutputType | null
  }

  type GetSessions_autGroupByPayload<T extends sessions_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sessions_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sessions_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sessions_autGroupByOutputType[P]>
            : GetScalarType<T[P], Sessions_autGroupByOutputType[P]>
        }
      >
    >


  export type sessions_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entrace_option?: boolean
    is_finished?: boolean
    is_timeout?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions_aut"]>



  export type sessions_autSelectScalar = {
    id?: boolean
    entrace_option?: boolean
    is_finished?: boolean
    is_timeout?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type sessions_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entrace_option" | "is_finished" | "is_timeout" | "is_error" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["sessions_aut"]>
  export type sessions_autInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }

  export type $sessions_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions_aut"
    objects: {
      users_aut: Prisma.$users_autPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entrace_option: number | null
      is_finished: boolean
      is_timeout: boolean
      is_error: boolean
      user_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessions_aut"]>
    composites: {}
  }

  type sessions_autGetPayload<S extends boolean | null | undefined | sessions_autDefaultArgs> = $Result.GetResult<Prisma.$sessions_autPayload, S>

  type sessions_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessions_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sessions_autCountAggregateInputType | true
    }

  export interface sessions_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions_aut'], meta: { name: 'sessions_aut' } }
    /**
     * Find zero or one Sessions_aut that matches the filter.
     * @param {sessions_autFindUniqueArgs} args - Arguments to find a Sessions_aut
     * @example
     * // Get one Sessions_aut
     * const sessions_aut = await prisma.sessions_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessions_autFindUniqueArgs>(args: SelectSubset<T, sessions_autFindUniqueArgs<ExtArgs>>): Prisma__sessions_autClient<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessions_autFindUniqueOrThrowArgs} args - Arguments to find a Sessions_aut
     * @example
     * // Get one Sessions_aut
     * const sessions_aut = await prisma.sessions_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessions_autFindUniqueOrThrowArgs>(args: SelectSubset<T, sessions_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessions_autClient<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_autFindFirstArgs} args - Arguments to find a Sessions_aut
     * @example
     * // Get one Sessions_aut
     * const sessions_aut = await prisma.sessions_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessions_autFindFirstArgs>(args?: SelectSubset<T, sessions_autFindFirstArgs<ExtArgs>>): Prisma__sessions_autClient<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_autFindFirstOrThrowArgs} args - Arguments to find a Sessions_aut
     * @example
     * // Get one Sessions_aut
     * const sessions_aut = await prisma.sessions_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessions_autFindFirstOrThrowArgs>(args?: SelectSubset<T, sessions_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessions_autClient<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions_auts
     * const sessions_auts = await prisma.sessions_aut.findMany()
     * 
     * // Get first 10 Sessions_auts
     * const sessions_auts = await prisma.sessions_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessions_autWithIdOnly = await prisma.sessions_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessions_autFindManyArgs>(args?: SelectSubset<T, sessions_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions_aut.
     * @param {sessions_autCreateArgs} args - Arguments to create a Sessions_aut.
     * @example
     * // Create one Sessions_aut
     * const Sessions_aut = await prisma.sessions_aut.create({
     *   data: {
     *     // ... data to create a Sessions_aut
     *   }
     * })
     * 
     */
    create<T extends sessions_autCreateArgs>(args: SelectSubset<T, sessions_autCreateArgs<ExtArgs>>): Prisma__sessions_autClient<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions_auts.
     * @param {sessions_autCreateManyArgs} args - Arguments to create many Sessions_auts.
     * @example
     * // Create many Sessions_auts
     * const sessions_aut = await prisma.sessions_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessions_autCreateManyArgs>(args?: SelectSubset<T, sessions_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions_aut.
     * @param {sessions_autDeleteArgs} args - Arguments to delete one Sessions_aut.
     * @example
     * // Delete one Sessions_aut
     * const Sessions_aut = await prisma.sessions_aut.delete({
     *   where: {
     *     // ... filter to delete one Sessions_aut
     *   }
     * })
     * 
     */
    delete<T extends sessions_autDeleteArgs>(args: SelectSubset<T, sessions_autDeleteArgs<ExtArgs>>): Prisma__sessions_autClient<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions_aut.
     * @param {sessions_autUpdateArgs} args - Arguments to update one Sessions_aut.
     * @example
     * // Update one Sessions_aut
     * const sessions_aut = await prisma.sessions_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessions_autUpdateArgs>(args: SelectSubset<T, sessions_autUpdateArgs<ExtArgs>>): Prisma__sessions_autClient<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions_auts.
     * @param {sessions_autDeleteManyArgs} args - Arguments to filter Sessions_auts to delete.
     * @example
     * // Delete a few Sessions_auts
     * const { count } = await prisma.sessions_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessions_autDeleteManyArgs>(args?: SelectSubset<T, sessions_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions_auts
     * const sessions_aut = await prisma.sessions_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessions_autUpdateManyArgs>(args: SelectSubset<T, sessions_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions_aut.
     * @param {sessions_autUpsertArgs} args - Arguments to update or create a Sessions_aut.
     * @example
     * // Update or create a Sessions_aut
     * const sessions_aut = await prisma.sessions_aut.upsert({
     *   create: {
     *     // ... data to create a Sessions_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions_aut we want to update
     *   }
     * })
     */
    upsert<T extends sessions_autUpsertArgs>(args: SelectSubset<T, sessions_autUpsertArgs<ExtArgs>>): Prisma__sessions_autClient<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_autCountArgs} args - Arguments to filter Sessions_auts to count.
     * @example
     * // Count the number of Sessions_auts
     * const count = await prisma.sessions_aut.count({
     *   where: {
     *     // ... the filter for the Sessions_auts we want to count
     *   }
     * })
    **/
    count<T extends sessions_autCountArgs>(
      args?: Subset<T, sessions_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sessions_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sessions_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sessions_autAggregateArgs>(args: Subset<T, Sessions_autAggregateArgs>): Prisma.PrismaPromise<GetSessions_autAggregateType<T>>

    /**
     * Group by Sessions_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessions_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessions_autGroupByArgs['orderBy'] }
        : { orderBy?: sessions_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessions_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessions_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions_aut model
   */
  readonly fields: sessions_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessions_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_aut<T extends users_autDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_autDefaultArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions_aut model
   */
  interface sessions_autFieldRefs {
    readonly id: FieldRef<"sessions_aut", 'String'>
    readonly entrace_option: FieldRef<"sessions_aut", 'Int'>
    readonly is_finished: FieldRef<"sessions_aut", 'Boolean'>
    readonly is_timeout: FieldRef<"sessions_aut", 'Boolean'>
    readonly is_error: FieldRef<"sessions_aut", 'Boolean'>
    readonly user_id: FieldRef<"sessions_aut", 'String'>
    readonly createdAt: FieldRef<"sessions_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"sessions_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions_aut findUnique
   */
  export type sessions_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * Filter, which sessions_aut to fetch.
     */
    where: sessions_autWhereUniqueInput
  }

  /**
   * sessions_aut findUniqueOrThrow
   */
  export type sessions_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * Filter, which sessions_aut to fetch.
     */
    where: sessions_autWhereUniqueInput
  }

  /**
   * sessions_aut findFirst
   */
  export type sessions_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * Filter, which sessions_aut to fetch.
     */
    where?: sessions_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_auts to fetch.
     */
    orderBy?: sessions_autOrderByWithRelationInput | sessions_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions_auts.
     */
    cursor?: sessions_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions_auts.
     */
    distinct?: Sessions_autScalarFieldEnum | Sessions_autScalarFieldEnum[]
  }

  /**
   * sessions_aut findFirstOrThrow
   */
  export type sessions_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * Filter, which sessions_aut to fetch.
     */
    where?: sessions_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_auts to fetch.
     */
    orderBy?: sessions_autOrderByWithRelationInput | sessions_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions_auts.
     */
    cursor?: sessions_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions_auts.
     */
    distinct?: Sessions_autScalarFieldEnum | Sessions_autScalarFieldEnum[]
  }

  /**
   * sessions_aut findMany
   */
  export type sessions_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * Filter, which sessions_auts to fetch.
     */
    where?: sessions_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_auts to fetch.
     */
    orderBy?: sessions_autOrderByWithRelationInput | sessions_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions_auts.
     */
    cursor?: sessions_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_auts.
     */
    skip?: number
    distinct?: Sessions_autScalarFieldEnum | Sessions_autScalarFieldEnum[]
  }

  /**
   * sessions_aut create
   */
  export type sessions_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions_aut.
     */
    data: XOR<sessions_autCreateInput, sessions_autUncheckedCreateInput>
  }

  /**
   * sessions_aut createMany
   */
  export type sessions_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions_auts.
     */
    data: sessions_autCreateManyInput | sessions_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions_aut update
   */
  export type sessions_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions_aut.
     */
    data: XOR<sessions_autUpdateInput, sessions_autUncheckedUpdateInput>
    /**
     * Choose, which sessions_aut to update.
     */
    where: sessions_autWhereUniqueInput
  }

  /**
   * sessions_aut updateMany
   */
  export type sessions_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions_auts.
     */
    data: XOR<sessions_autUpdateManyMutationInput, sessions_autUncheckedUpdateManyInput>
    /**
     * Filter which sessions_auts to update
     */
    where?: sessions_autWhereInput
    /**
     * Limit how many sessions_auts to update.
     */
    limit?: number
  }

  /**
   * sessions_aut upsert
   */
  export type sessions_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions_aut to update in case it exists.
     */
    where: sessions_autWhereUniqueInput
    /**
     * In case the sessions_aut found by the `where` argument doesn't exist, create a new sessions_aut with this data.
     */
    create: XOR<sessions_autCreateInput, sessions_autUncheckedCreateInput>
    /**
     * In case the sessions_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessions_autUpdateInput, sessions_autUncheckedUpdateInput>
  }

  /**
   * sessions_aut delete
   */
  export type sessions_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    /**
     * Filter which sessions_aut to delete.
     */
    where: sessions_autWhereUniqueInput
  }

  /**
   * sessions_aut deleteMany
   */
  export type sessions_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions_auts to delete
     */
    where?: sessions_autWhereInput
    /**
     * Limit how many sessions_auts to delete.
     */
    limit?: number
  }

  /**
   * sessions_aut without action
   */
  export type sessions_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
  }


  /**
   * Model sessions_clt
   */

  export type AggregateSessions_clt = {
    _count: Sessions_cltCountAggregateOutputType | null
    _avg: Sessions_cltAvgAggregateOutputType | null
    _sum: Sessions_cltSumAggregateOutputType | null
    _min: Sessions_cltMinAggregateOutputType | null
    _max: Sessions_cltMaxAggregateOutputType | null
  }

  export type Sessions_cltAvgAggregateOutputType = {
    entrace_option: number | null
  }

  export type Sessions_cltSumAggregateOutputType = {
    entrace_option: number | null
  }

  export type Sessions_cltMinAggregateOutputType = {
    id: string | null
    entrace_option: number | null
    is_finished: boolean | null
    is_timeout: boolean | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sessions_cltMaxAggregateOutputType = {
    id: string | null
    entrace_option: number | null
    is_finished: boolean | null
    is_timeout: boolean | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sessions_cltCountAggregateOutputType = {
    id: number
    entrace_option: number
    is_finished: number
    is_timeout: number
    is_error: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Sessions_cltAvgAggregateInputType = {
    entrace_option?: true
  }

  export type Sessions_cltSumAggregateInputType = {
    entrace_option?: true
  }

  export type Sessions_cltMinAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sessions_cltMaxAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sessions_cltCountAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Sessions_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions_clt to aggregate.
     */
    where?: sessions_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_clts to fetch.
     */
    orderBy?: sessions_cltOrderByWithRelationInput | sessions_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessions_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions_clts
    **/
    _count?: true | Sessions_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sessions_cltAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sessions_cltSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sessions_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sessions_cltMaxAggregateInputType
  }

  export type GetSessions_cltAggregateType<T extends Sessions_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions_clt[P]>
      : GetScalarType<T[P], AggregateSessions_clt[P]>
  }




  export type sessions_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessions_cltWhereInput
    orderBy?: sessions_cltOrderByWithAggregationInput | sessions_cltOrderByWithAggregationInput[]
    by: Sessions_cltScalarFieldEnum[] | Sessions_cltScalarFieldEnum
    having?: sessions_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sessions_cltCountAggregateInputType | true
    _avg?: Sessions_cltAvgAggregateInputType
    _sum?: Sessions_cltSumAggregateInputType
    _min?: Sessions_cltMinAggregateInputType
    _max?: Sessions_cltMaxAggregateInputType
  }

  export type Sessions_cltGroupByOutputType = {
    id: string
    entrace_option: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date
    updatedAt: Date
    _count: Sessions_cltCountAggregateOutputType | null
    _avg: Sessions_cltAvgAggregateOutputType | null
    _sum: Sessions_cltSumAggregateOutputType | null
    _min: Sessions_cltMinAggregateOutputType | null
    _max: Sessions_cltMaxAggregateOutputType | null
  }

  type GetSessions_cltGroupByPayload<T extends sessions_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sessions_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sessions_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sessions_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Sessions_cltGroupByOutputType[P]>
        }
      >
    >


  export type sessions_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entrace_option?: boolean
    is_finished?: boolean
    is_timeout?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions_clt"]>



  export type sessions_cltSelectScalar = {
    id?: boolean
    entrace_option?: boolean
    is_finished?: boolean
    is_timeout?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type sessions_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entrace_option" | "is_finished" | "is_timeout" | "is_error" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["sessions_clt"]>
  export type sessions_cltInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }

  export type $sessions_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions_clt"
    objects: {
      users_clt: Prisma.$users_cltPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entrace_option: number | null
      is_finished: boolean
      is_timeout: boolean
      is_error: boolean
      user_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessions_clt"]>
    composites: {}
  }

  type sessions_cltGetPayload<S extends boolean | null | undefined | sessions_cltDefaultArgs> = $Result.GetResult<Prisma.$sessions_cltPayload, S>

  type sessions_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessions_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sessions_cltCountAggregateInputType | true
    }

  export interface sessions_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions_clt'], meta: { name: 'sessions_clt' } }
    /**
     * Find zero or one Sessions_clt that matches the filter.
     * @param {sessions_cltFindUniqueArgs} args - Arguments to find a Sessions_clt
     * @example
     * // Get one Sessions_clt
     * const sessions_clt = await prisma.sessions_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessions_cltFindUniqueArgs>(args: SelectSubset<T, sessions_cltFindUniqueArgs<ExtArgs>>): Prisma__sessions_cltClient<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessions_cltFindUniqueOrThrowArgs} args - Arguments to find a Sessions_clt
     * @example
     * // Get one Sessions_clt
     * const sessions_clt = await prisma.sessions_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessions_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, sessions_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessions_cltClient<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_cltFindFirstArgs} args - Arguments to find a Sessions_clt
     * @example
     * // Get one Sessions_clt
     * const sessions_clt = await prisma.sessions_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessions_cltFindFirstArgs>(args?: SelectSubset<T, sessions_cltFindFirstArgs<ExtArgs>>): Prisma__sessions_cltClient<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_cltFindFirstOrThrowArgs} args - Arguments to find a Sessions_clt
     * @example
     * // Get one Sessions_clt
     * const sessions_clt = await prisma.sessions_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessions_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, sessions_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessions_cltClient<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions_clts
     * const sessions_clts = await prisma.sessions_clt.findMany()
     * 
     * // Get first 10 Sessions_clts
     * const sessions_clts = await prisma.sessions_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessions_cltWithIdOnly = await prisma.sessions_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessions_cltFindManyArgs>(args?: SelectSubset<T, sessions_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions_clt.
     * @param {sessions_cltCreateArgs} args - Arguments to create a Sessions_clt.
     * @example
     * // Create one Sessions_clt
     * const Sessions_clt = await prisma.sessions_clt.create({
     *   data: {
     *     // ... data to create a Sessions_clt
     *   }
     * })
     * 
     */
    create<T extends sessions_cltCreateArgs>(args: SelectSubset<T, sessions_cltCreateArgs<ExtArgs>>): Prisma__sessions_cltClient<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions_clts.
     * @param {sessions_cltCreateManyArgs} args - Arguments to create many Sessions_clts.
     * @example
     * // Create many Sessions_clts
     * const sessions_clt = await prisma.sessions_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessions_cltCreateManyArgs>(args?: SelectSubset<T, sessions_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions_clt.
     * @param {sessions_cltDeleteArgs} args - Arguments to delete one Sessions_clt.
     * @example
     * // Delete one Sessions_clt
     * const Sessions_clt = await prisma.sessions_clt.delete({
     *   where: {
     *     // ... filter to delete one Sessions_clt
     *   }
     * })
     * 
     */
    delete<T extends sessions_cltDeleteArgs>(args: SelectSubset<T, sessions_cltDeleteArgs<ExtArgs>>): Prisma__sessions_cltClient<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions_clt.
     * @param {sessions_cltUpdateArgs} args - Arguments to update one Sessions_clt.
     * @example
     * // Update one Sessions_clt
     * const sessions_clt = await prisma.sessions_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessions_cltUpdateArgs>(args: SelectSubset<T, sessions_cltUpdateArgs<ExtArgs>>): Prisma__sessions_cltClient<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions_clts.
     * @param {sessions_cltDeleteManyArgs} args - Arguments to filter Sessions_clts to delete.
     * @example
     * // Delete a few Sessions_clts
     * const { count } = await prisma.sessions_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessions_cltDeleteManyArgs>(args?: SelectSubset<T, sessions_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions_clts
     * const sessions_clt = await prisma.sessions_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessions_cltUpdateManyArgs>(args: SelectSubset<T, sessions_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions_clt.
     * @param {sessions_cltUpsertArgs} args - Arguments to update or create a Sessions_clt.
     * @example
     * // Update or create a Sessions_clt
     * const sessions_clt = await prisma.sessions_clt.upsert({
     *   create: {
     *     // ... data to create a Sessions_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions_clt we want to update
     *   }
     * })
     */
    upsert<T extends sessions_cltUpsertArgs>(args: SelectSubset<T, sessions_cltUpsertArgs<ExtArgs>>): Prisma__sessions_cltClient<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_cltCountArgs} args - Arguments to filter Sessions_clts to count.
     * @example
     * // Count the number of Sessions_clts
     * const count = await prisma.sessions_clt.count({
     *   where: {
     *     // ... the filter for the Sessions_clts we want to count
     *   }
     * })
    **/
    count<T extends sessions_cltCountArgs>(
      args?: Subset<T, sessions_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sessions_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sessions_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sessions_cltAggregateArgs>(args: Subset<T, Sessions_cltAggregateArgs>): Prisma.PrismaPromise<GetSessions_cltAggregateType<T>>

    /**
     * Group by Sessions_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessions_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessions_cltGroupByArgs['orderBy'] }
        : { orderBy?: sessions_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessions_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessions_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions_clt model
   */
  readonly fields: sessions_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessions_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_clt<T extends users_cltDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_cltDefaultArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions_clt model
   */
  interface sessions_cltFieldRefs {
    readonly id: FieldRef<"sessions_clt", 'String'>
    readonly entrace_option: FieldRef<"sessions_clt", 'Int'>
    readonly is_finished: FieldRef<"sessions_clt", 'Boolean'>
    readonly is_timeout: FieldRef<"sessions_clt", 'Boolean'>
    readonly is_error: FieldRef<"sessions_clt", 'Boolean'>
    readonly user_id: FieldRef<"sessions_clt", 'String'>
    readonly createdAt: FieldRef<"sessions_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"sessions_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions_clt findUnique
   */
  export type sessions_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * Filter, which sessions_clt to fetch.
     */
    where: sessions_cltWhereUniqueInput
  }

  /**
   * sessions_clt findUniqueOrThrow
   */
  export type sessions_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * Filter, which sessions_clt to fetch.
     */
    where: sessions_cltWhereUniqueInput
  }

  /**
   * sessions_clt findFirst
   */
  export type sessions_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * Filter, which sessions_clt to fetch.
     */
    where?: sessions_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_clts to fetch.
     */
    orderBy?: sessions_cltOrderByWithRelationInput | sessions_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions_clts.
     */
    cursor?: sessions_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions_clts.
     */
    distinct?: Sessions_cltScalarFieldEnum | Sessions_cltScalarFieldEnum[]
  }

  /**
   * sessions_clt findFirstOrThrow
   */
  export type sessions_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * Filter, which sessions_clt to fetch.
     */
    where?: sessions_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_clts to fetch.
     */
    orderBy?: sessions_cltOrderByWithRelationInput | sessions_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions_clts.
     */
    cursor?: sessions_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions_clts.
     */
    distinct?: Sessions_cltScalarFieldEnum | Sessions_cltScalarFieldEnum[]
  }

  /**
   * sessions_clt findMany
   */
  export type sessions_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * Filter, which sessions_clts to fetch.
     */
    where?: sessions_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_clts to fetch.
     */
    orderBy?: sessions_cltOrderByWithRelationInput | sessions_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions_clts.
     */
    cursor?: sessions_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_clts.
     */
    skip?: number
    distinct?: Sessions_cltScalarFieldEnum | Sessions_cltScalarFieldEnum[]
  }

  /**
   * sessions_clt create
   */
  export type sessions_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions_clt.
     */
    data: XOR<sessions_cltCreateInput, sessions_cltUncheckedCreateInput>
  }

  /**
   * sessions_clt createMany
   */
  export type sessions_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions_clts.
     */
    data: sessions_cltCreateManyInput | sessions_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions_clt update
   */
  export type sessions_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions_clt.
     */
    data: XOR<sessions_cltUpdateInput, sessions_cltUncheckedUpdateInput>
    /**
     * Choose, which sessions_clt to update.
     */
    where: sessions_cltWhereUniqueInput
  }

  /**
   * sessions_clt updateMany
   */
  export type sessions_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions_clts.
     */
    data: XOR<sessions_cltUpdateManyMutationInput, sessions_cltUncheckedUpdateManyInput>
    /**
     * Filter which sessions_clts to update
     */
    where?: sessions_cltWhereInput
    /**
     * Limit how many sessions_clts to update.
     */
    limit?: number
  }

  /**
   * sessions_clt upsert
   */
  export type sessions_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions_clt to update in case it exists.
     */
    where: sessions_cltWhereUniqueInput
    /**
     * In case the sessions_clt found by the `where` argument doesn't exist, create a new sessions_clt with this data.
     */
    create: XOR<sessions_cltCreateInput, sessions_cltUncheckedCreateInput>
    /**
     * In case the sessions_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessions_cltUpdateInput, sessions_cltUncheckedUpdateInput>
  }

  /**
   * sessions_clt delete
   */
  export type sessions_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    /**
     * Filter which sessions_clt to delete.
     */
    where: sessions_cltWhereUniqueInput
  }

  /**
   * sessions_clt deleteMany
   */
  export type sessions_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions_clts to delete
     */
    where?: sessions_cltWhereInput
    /**
     * Limit how many sessions_clts to delete.
     */
    limit?: number
  }

  /**
   * sessions_clt without action
   */
  export type sessions_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
  }


  /**
   * Model sessions_goi
   */

  export type AggregateSessions_goi = {
    _count: Sessions_goiCountAggregateOutputType | null
    _avg: Sessions_goiAvgAggregateOutputType | null
    _sum: Sessions_goiSumAggregateOutputType | null
    _min: Sessions_goiMinAggregateOutputType | null
    _max: Sessions_goiMaxAggregateOutputType | null
  }

  export type Sessions_goiAvgAggregateOutputType = {
    entrace_option: number | null
  }

  export type Sessions_goiSumAggregateOutputType = {
    entrace_option: number | null
  }

  export type Sessions_goiMinAggregateOutputType = {
    id: string | null
    entrace_option: number | null
    is_finished: boolean | null
    is_timeout: boolean | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sessions_goiMaxAggregateOutputType = {
    id: string | null
    entrace_option: number | null
    is_finished: boolean | null
    is_timeout: boolean | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sessions_goiCountAggregateOutputType = {
    id: number
    entrace_option: number
    is_finished: number
    is_timeout: number
    is_error: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Sessions_goiAvgAggregateInputType = {
    entrace_option?: true
  }

  export type Sessions_goiSumAggregateInputType = {
    entrace_option?: true
  }

  export type Sessions_goiMinAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sessions_goiMaxAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sessions_goiCountAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Sessions_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions_goi to aggregate.
     */
    where?: sessions_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_gois to fetch.
     */
    orderBy?: sessions_goiOrderByWithRelationInput | sessions_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessions_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions_gois
    **/
    _count?: true | Sessions_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sessions_goiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sessions_goiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sessions_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sessions_goiMaxAggregateInputType
  }

  export type GetSessions_goiAggregateType<T extends Sessions_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions_goi[P]>
      : GetScalarType<T[P], AggregateSessions_goi[P]>
  }




  export type sessions_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessions_goiWhereInput
    orderBy?: sessions_goiOrderByWithAggregationInput | sessions_goiOrderByWithAggregationInput[]
    by: Sessions_goiScalarFieldEnum[] | Sessions_goiScalarFieldEnum
    having?: sessions_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sessions_goiCountAggregateInputType | true
    _avg?: Sessions_goiAvgAggregateInputType
    _sum?: Sessions_goiSumAggregateInputType
    _min?: Sessions_goiMinAggregateInputType
    _max?: Sessions_goiMaxAggregateInputType
  }

  export type Sessions_goiGroupByOutputType = {
    id: string
    entrace_option: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date
    updatedAt: Date
    _count: Sessions_goiCountAggregateOutputType | null
    _avg: Sessions_goiAvgAggregateOutputType | null
    _sum: Sessions_goiSumAggregateOutputType | null
    _min: Sessions_goiMinAggregateOutputType | null
    _max: Sessions_goiMaxAggregateOutputType | null
  }

  type GetSessions_goiGroupByPayload<T extends sessions_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sessions_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sessions_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sessions_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Sessions_goiGroupByOutputType[P]>
        }
      >
    >


  export type sessions_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entrace_option?: boolean
    is_finished?: boolean
    is_timeout?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions_goi"]>



  export type sessions_goiSelectScalar = {
    id?: boolean
    entrace_option?: boolean
    is_finished?: boolean
    is_timeout?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type sessions_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entrace_option" | "is_finished" | "is_timeout" | "is_error" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["sessions_goi"]>
  export type sessions_goiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }

  export type $sessions_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions_goi"
    objects: {
      users_goi: Prisma.$users_goiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entrace_option: number | null
      is_finished: boolean
      is_timeout: boolean
      is_error: boolean
      user_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessions_goi"]>
    composites: {}
  }

  type sessions_goiGetPayload<S extends boolean | null | undefined | sessions_goiDefaultArgs> = $Result.GetResult<Prisma.$sessions_goiPayload, S>

  type sessions_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessions_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sessions_goiCountAggregateInputType | true
    }

  export interface sessions_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions_goi'], meta: { name: 'sessions_goi' } }
    /**
     * Find zero or one Sessions_goi that matches the filter.
     * @param {sessions_goiFindUniqueArgs} args - Arguments to find a Sessions_goi
     * @example
     * // Get one Sessions_goi
     * const sessions_goi = await prisma.sessions_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessions_goiFindUniqueArgs>(args: SelectSubset<T, sessions_goiFindUniqueArgs<ExtArgs>>): Prisma__sessions_goiClient<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessions_goiFindUniqueOrThrowArgs} args - Arguments to find a Sessions_goi
     * @example
     * // Get one Sessions_goi
     * const sessions_goi = await prisma.sessions_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessions_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, sessions_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessions_goiClient<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_goiFindFirstArgs} args - Arguments to find a Sessions_goi
     * @example
     * // Get one Sessions_goi
     * const sessions_goi = await prisma.sessions_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessions_goiFindFirstArgs>(args?: SelectSubset<T, sessions_goiFindFirstArgs<ExtArgs>>): Prisma__sessions_goiClient<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_goiFindFirstOrThrowArgs} args - Arguments to find a Sessions_goi
     * @example
     * // Get one Sessions_goi
     * const sessions_goi = await prisma.sessions_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessions_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, sessions_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessions_goiClient<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions_gois
     * const sessions_gois = await prisma.sessions_goi.findMany()
     * 
     * // Get first 10 Sessions_gois
     * const sessions_gois = await prisma.sessions_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessions_goiWithIdOnly = await prisma.sessions_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessions_goiFindManyArgs>(args?: SelectSubset<T, sessions_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions_goi.
     * @param {sessions_goiCreateArgs} args - Arguments to create a Sessions_goi.
     * @example
     * // Create one Sessions_goi
     * const Sessions_goi = await prisma.sessions_goi.create({
     *   data: {
     *     // ... data to create a Sessions_goi
     *   }
     * })
     * 
     */
    create<T extends sessions_goiCreateArgs>(args: SelectSubset<T, sessions_goiCreateArgs<ExtArgs>>): Prisma__sessions_goiClient<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions_gois.
     * @param {sessions_goiCreateManyArgs} args - Arguments to create many Sessions_gois.
     * @example
     * // Create many Sessions_gois
     * const sessions_goi = await prisma.sessions_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessions_goiCreateManyArgs>(args?: SelectSubset<T, sessions_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions_goi.
     * @param {sessions_goiDeleteArgs} args - Arguments to delete one Sessions_goi.
     * @example
     * // Delete one Sessions_goi
     * const Sessions_goi = await prisma.sessions_goi.delete({
     *   where: {
     *     // ... filter to delete one Sessions_goi
     *   }
     * })
     * 
     */
    delete<T extends sessions_goiDeleteArgs>(args: SelectSubset<T, sessions_goiDeleteArgs<ExtArgs>>): Prisma__sessions_goiClient<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions_goi.
     * @param {sessions_goiUpdateArgs} args - Arguments to update one Sessions_goi.
     * @example
     * // Update one Sessions_goi
     * const sessions_goi = await prisma.sessions_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessions_goiUpdateArgs>(args: SelectSubset<T, sessions_goiUpdateArgs<ExtArgs>>): Prisma__sessions_goiClient<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions_gois.
     * @param {sessions_goiDeleteManyArgs} args - Arguments to filter Sessions_gois to delete.
     * @example
     * // Delete a few Sessions_gois
     * const { count } = await prisma.sessions_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessions_goiDeleteManyArgs>(args?: SelectSubset<T, sessions_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions_gois
     * const sessions_goi = await prisma.sessions_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessions_goiUpdateManyArgs>(args: SelectSubset<T, sessions_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions_goi.
     * @param {sessions_goiUpsertArgs} args - Arguments to update or create a Sessions_goi.
     * @example
     * // Update or create a Sessions_goi
     * const sessions_goi = await prisma.sessions_goi.upsert({
     *   create: {
     *     // ... data to create a Sessions_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions_goi we want to update
     *   }
     * })
     */
    upsert<T extends sessions_goiUpsertArgs>(args: SelectSubset<T, sessions_goiUpsertArgs<ExtArgs>>): Prisma__sessions_goiClient<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_goiCountArgs} args - Arguments to filter Sessions_gois to count.
     * @example
     * // Count the number of Sessions_gois
     * const count = await prisma.sessions_goi.count({
     *   where: {
     *     // ... the filter for the Sessions_gois we want to count
     *   }
     * })
    **/
    count<T extends sessions_goiCountArgs>(
      args?: Subset<T, sessions_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sessions_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sessions_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sessions_goiAggregateArgs>(args: Subset<T, Sessions_goiAggregateArgs>): Prisma.PrismaPromise<GetSessions_goiAggregateType<T>>

    /**
     * Group by Sessions_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessions_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessions_goiGroupByArgs['orderBy'] }
        : { orderBy?: sessions_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessions_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessions_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions_goi model
   */
  readonly fields: sessions_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessions_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_goi<T extends users_goiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_goiDefaultArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions_goi model
   */
  interface sessions_goiFieldRefs {
    readonly id: FieldRef<"sessions_goi", 'String'>
    readonly entrace_option: FieldRef<"sessions_goi", 'Int'>
    readonly is_finished: FieldRef<"sessions_goi", 'Boolean'>
    readonly is_timeout: FieldRef<"sessions_goi", 'Boolean'>
    readonly is_error: FieldRef<"sessions_goi", 'Boolean'>
    readonly user_id: FieldRef<"sessions_goi", 'String'>
    readonly createdAt: FieldRef<"sessions_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"sessions_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions_goi findUnique
   */
  export type sessions_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * Filter, which sessions_goi to fetch.
     */
    where: sessions_goiWhereUniqueInput
  }

  /**
   * sessions_goi findUniqueOrThrow
   */
  export type sessions_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * Filter, which sessions_goi to fetch.
     */
    where: sessions_goiWhereUniqueInput
  }

  /**
   * sessions_goi findFirst
   */
  export type sessions_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * Filter, which sessions_goi to fetch.
     */
    where?: sessions_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_gois to fetch.
     */
    orderBy?: sessions_goiOrderByWithRelationInput | sessions_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions_gois.
     */
    cursor?: sessions_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions_gois.
     */
    distinct?: Sessions_goiScalarFieldEnum | Sessions_goiScalarFieldEnum[]
  }

  /**
   * sessions_goi findFirstOrThrow
   */
  export type sessions_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * Filter, which sessions_goi to fetch.
     */
    where?: sessions_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_gois to fetch.
     */
    orderBy?: sessions_goiOrderByWithRelationInput | sessions_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions_gois.
     */
    cursor?: sessions_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions_gois.
     */
    distinct?: Sessions_goiScalarFieldEnum | Sessions_goiScalarFieldEnum[]
  }

  /**
   * sessions_goi findMany
   */
  export type sessions_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * Filter, which sessions_gois to fetch.
     */
    where?: sessions_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_gois to fetch.
     */
    orderBy?: sessions_goiOrderByWithRelationInput | sessions_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions_gois.
     */
    cursor?: sessions_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_gois.
     */
    skip?: number
    distinct?: Sessions_goiScalarFieldEnum | Sessions_goiScalarFieldEnum[]
  }

  /**
   * sessions_goi create
   */
  export type sessions_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions_goi.
     */
    data: XOR<sessions_goiCreateInput, sessions_goiUncheckedCreateInput>
  }

  /**
   * sessions_goi createMany
   */
  export type sessions_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions_gois.
     */
    data: sessions_goiCreateManyInput | sessions_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions_goi update
   */
  export type sessions_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions_goi.
     */
    data: XOR<sessions_goiUpdateInput, sessions_goiUncheckedUpdateInput>
    /**
     * Choose, which sessions_goi to update.
     */
    where: sessions_goiWhereUniqueInput
  }

  /**
   * sessions_goi updateMany
   */
  export type sessions_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions_gois.
     */
    data: XOR<sessions_goiUpdateManyMutationInput, sessions_goiUncheckedUpdateManyInput>
    /**
     * Filter which sessions_gois to update
     */
    where?: sessions_goiWhereInput
    /**
     * Limit how many sessions_gois to update.
     */
    limit?: number
  }

  /**
   * sessions_goi upsert
   */
  export type sessions_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions_goi to update in case it exists.
     */
    where: sessions_goiWhereUniqueInput
    /**
     * In case the sessions_goi found by the `where` argument doesn't exist, create a new sessions_goi with this data.
     */
    create: XOR<sessions_goiCreateInput, sessions_goiUncheckedCreateInput>
    /**
     * In case the sessions_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessions_goiUpdateInput, sessions_goiUncheckedUpdateInput>
  }

  /**
   * sessions_goi delete
   */
  export type sessions_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    /**
     * Filter which sessions_goi to delete.
     */
    where: sessions_goiWhereUniqueInput
  }

  /**
   * sessions_goi deleteMany
   */
  export type sessions_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions_gois to delete
     */
    where?: sessions_goiWhereInput
    /**
     * Limit how many sessions_gois to delete.
     */
    limit?: number
  }

  /**
   * sessions_goi without action
   */
  export type sessions_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
  }


  /**
   * Model sessions_spa
   */

  export type AggregateSessions_spa = {
    _count: Sessions_spaCountAggregateOutputType | null
    _avg: Sessions_spaAvgAggregateOutputType | null
    _sum: Sessions_spaSumAggregateOutputType | null
    _min: Sessions_spaMinAggregateOutputType | null
    _max: Sessions_spaMaxAggregateOutputType | null
  }

  export type Sessions_spaAvgAggregateOutputType = {
    entrace_option: number | null
  }

  export type Sessions_spaSumAggregateOutputType = {
    entrace_option: number | null
  }

  export type Sessions_spaMinAggregateOutputType = {
    id: string | null
    entrace_option: number | null
    is_finished: boolean | null
    is_timeout: boolean | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sessions_spaMaxAggregateOutputType = {
    id: string | null
    entrace_option: number | null
    is_finished: boolean | null
    is_timeout: boolean | null
    is_error: boolean | null
    user_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sessions_spaCountAggregateOutputType = {
    id: number
    entrace_option: number
    is_finished: number
    is_timeout: number
    is_error: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Sessions_spaAvgAggregateInputType = {
    entrace_option?: true
  }

  export type Sessions_spaSumAggregateInputType = {
    entrace_option?: true
  }

  export type Sessions_spaMinAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sessions_spaMaxAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sessions_spaCountAggregateInputType = {
    id?: true
    entrace_option?: true
    is_finished?: true
    is_timeout?: true
    is_error?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Sessions_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions_spa to aggregate.
     */
    where?: sessions_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_spas to fetch.
     */
    orderBy?: sessions_spaOrderByWithRelationInput | sessions_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessions_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions_spas
    **/
    _count?: true | Sessions_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sessions_spaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sessions_spaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sessions_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sessions_spaMaxAggregateInputType
  }

  export type GetSessions_spaAggregateType<T extends Sessions_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions_spa[P]>
      : GetScalarType<T[P], AggregateSessions_spa[P]>
  }




  export type sessions_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessions_spaWhereInput
    orderBy?: sessions_spaOrderByWithAggregationInput | sessions_spaOrderByWithAggregationInput[]
    by: Sessions_spaScalarFieldEnum[] | Sessions_spaScalarFieldEnum
    having?: sessions_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sessions_spaCountAggregateInputType | true
    _avg?: Sessions_spaAvgAggregateInputType
    _sum?: Sessions_spaSumAggregateInputType
    _min?: Sessions_spaMinAggregateInputType
    _max?: Sessions_spaMaxAggregateInputType
  }

  export type Sessions_spaGroupByOutputType = {
    id: string
    entrace_option: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date
    updatedAt: Date
    _count: Sessions_spaCountAggregateOutputType | null
    _avg: Sessions_spaAvgAggregateOutputType | null
    _sum: Sessions_spaSumAggregateOutputType | null
    _min: Sessions_spaMinAggregateOutputType | null
    _max: Sessions_spaMaxAggregateOutputType | null
  }

  type GetSessions_spaGroupByPayload<T extends sessions_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sessions_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sessions_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sessions_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Sessions_spaGroupByOutputType[P]>
        }
      >
    >


  export type sessions_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entrace_option?: boolean
    is_finished?: boolean
    is_timeout?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions_spa"]>



  export type sessions_spaSelectScalar = {
    id?: boolean
    entrace_option?: boolean
    is_finished?: boolean
    is_timeout?: boolean
    is_error?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type sessions_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entrace_option" | "is_finished" | "is_timeout" | "is_error" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["sessions_spa"]>
  export type sessions_spaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }

  export type $sessions_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions_spa"
    objects: {
      users_spa: Prisma.$users_spaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entrace_option: number | null
      is_finished: boolean
      is_timeout: boolean
      is_error: boolean
      user_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessions_spa"]>
    composites: {}
  }

  type sessions_spaGetPayload<S extends boolean | null | undefined | sessions_spaDefaultArgs> = $Result.GetResult<Prisma.$sessions_spaPayload, S>

  type sessions_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessions_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sessions_spaCountAggregateInputType | true
    }

  export interface sessions_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions_spa'], meta: { name: 'sessions_spa' } }
    /**
     * Find zero or one Sessions_spa that matches the filter.
     * @param {sessions_spaFindUniqueArgs} args - Arguments to find a Sessions_spa
     * @example
     * // Get one Sessions_spa
     * const sessions_spa = await prisma.sessions_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessions_spaFindUniqueArgs>(args: SelectSubset<T, sessions_spaFindUniqueArgs<ExtArgs>>): Prisma__sessions_spaClient<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessions_spaFindUniqueOrThrowArgs} args - Arguments to find a Sessions_spa
     * @example
     * // Get one Sessions_spa
     * const sessions_spa = await prisma.sessions_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessions_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, sessions_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessions_spaClient<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_spaFindFirstArgs} args - Arguments to find a Sessions_spa
     * @example
     * // Get one Sessions_spa
     * const sessions_spa = await prisma.sessions_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessions_spaFindFirstArgs>(args?: SelectSubset<T, sessions_spaFindFirstArgs<ExtArgs>>): Prisma__sessions_spaClient<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_spaFindFirstOrThrowArgs} args - Arguments to find a Sessions_spa
     * @example
     * // Get one Sessions_spa
     * const sessions_spa = await prisma.sessions_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessions_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, sessions_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessions_spaClient<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions_spas
     * const sessions_spas = await prisma.sessions_spa.findMany()
     * 
     * // Get first 10 Sessions_spas
     * const sessions_spas = await prisma.sessions_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessions_spaWithIdOnly = await prisma.sessions_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessions_spaFindManyArgs>(args?: SelectSubset<T, sessions_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions_spa.
     * @param {sessions_spaCreateArgs} args - Arguments to create a Sessions_spa.
     * @example
     * // Create one Sessions_spa
     * const Sessions_spa = await prisma.sessions_spa.create({
     *   data: {
     *     // ... data to create a Sessions_spa
     *   }
     * })
     * 
     */
    create<T extends sessions_spaCreateArgs>(args: SelectSubset<T, sessions_spaCreateArgs<ExtArgs>>): Prisma__sessions_spaClient<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions_spas.
     * @param {sessions_spaCreateManyArgs} args - Arguments to create many Sessions_spas.
     * @example
     * // Create many Sessions_spas
     * const sessions_spa = await prisma.sessions_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessions_spaCreateManyArgs>(args?: SelectSubset<T, sessions_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions_spa.
     * @param {sessions_spaDeleteArgs} args - Arguments to delete one Sessions_spa.
     * @example
     * // Delete one Sessions_spa
     * const Sessions_spa = await prisma.sessions_spa.delete({
     *   where: {
     *     // ... filter to delete one Sessions_spa
     *   }
     * })
     * 
     */
    delete<T extends sessions_spaDeleteArgs>(args: SelectSubset<T, sessions_spaDeleteArgs<ExtArgs>>): Prisma__sessions_spaClient<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions_spa.
     * @param {sessions_spaUpdateArgs} args - Arguments to update one Sessions_spa.
     * @example
     * // Update one Sessions_spa
     * const sessions_spa = await prisma.sessions_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessions_spaUpdateArgs>(args: SelectSubset<T, sessions_spaUpdateArgs<ExtArgs>>): Prisma__sessions_spaClient<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions_spas.
     * @param {sessions_spaDeleteManyArgs} args - Arguments to filter Sessions_spas to delete.
     * @example
     * // Delete a few Sessions_spas
     * const { count } = await prisma.sessions_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessions_spaDeleteManyArgs>(args?: SelectSubset<T, sessions_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions_spas
     * const sessions_spa = await prisma.sessions_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessions_spaUpdateManyArgs>(args: SelectSubset<T, sessions_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions_spa.
     * @param {sessions_spaUpsertArgs} args - Arguments to update or create a Sessions_spa.
     * @example
     * // Update or create a Sessions_spa
     * const sessions_spa = await prisma.sessions_spa.upsert({
     *   create: {
     *     // ... data to create a Sessions_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions_spa we want to update
     *   }
     * })
     */
    upsert<T extends sessions_spaUpsertArgs>(args: SelectSubset<T, sessions_spaUpsertArgs<ExtArgs>>): Prisma__sessions_spaClient<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_spaCountArgs} args - Arguments to filter Sessions_spas to count.
     * @example
     * // Count the number of Sessions_spas
     * const count = await prisma.sessions_spa.count({
     *   where: {
     *     // ... the filter for the Sessions_spas we want to count
     *   }
     * })
    **/
    count<T extends sessions_spaCountArgs>(
      args?: Subset<T, sessions_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sessions_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sessions_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sessions_spaAggregateArgs>(args: Subset<T, Sessions_spaAggregateArgs>): Prisma.PrismaPromise<GetSessions_spaAggregateType<T>>

    /**
     * Group by Sessions_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessions_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessions_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessions_spaGroupByArgs['orderBy'] }
        : { orderBy?: sessions_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessions_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessions_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions_spa model
   */
  readonly fields: sessions_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessions_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_spa<T extends users_spaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_spaDefaultArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions_spa model
   */
  interface sessions_spaFieldRefs {
    readonly id: FieldRef<"sessions_spa", 'String'>
    readonly entrace_option: FieldRef<"sessions_spa", 'Int'>
    readonly is_finished: FieldRef<"sessions_spa", 'Boolean'>
    readonly is_timeout: FieldRef<"sessions_spa", 'Boolean'>
    readonly is_error: FieldRef<"sessions_spa", 'Boolean'>
    readonly user_id: FieldRef<"sessions_spa", 'String'>
    readonly createdAt: FieldRef<"sessions_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"sessions_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions_spa findUnique
   */
  export type sessions_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * Filter, which sessions_spa to fetch.
     */
    where: sessions_spaWhereUniqueInput
  }

  /**
   * sessions_spa findUniqueOrThrow
   */
  export type sessions_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * Filter, which sessions_spa to fetch.
     */
    where: sessions_spaWhereUniqueInput
  }

  /**
   * sessions_spa findFirst
   */
  export type sessions_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * Filter, which sessions_spa to fetch.
     */
    where?: sessions_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_spas to fetch.
     */
    orderBy?: sessions_spaOrderByWithRelationInput | sessions_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions_spas.
     */
    cursor?: sessions_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions_spas.
     */
    distinct?: Sessions_spaScalarFieldEnum | Sessions_spaScalarFieldEnum[]
  }

  /**
   * sessions_spa findFirstOrThrow
   */
  export type sessions_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * Filter, which sessions_spa to fetch.
     */
    where?: sessions_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_spas to fetch.
     */
    orderBy?: sessions_spaOrderByWithRelationInput | sessions_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions_spas.
     */
    cursor?: sessions_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions_spas.
     */
    distinct?: Sessions_spaScalarFieldEnum | Sessions_spaScalarFieldEnum[]
  }

  /**
   * sessions_spa findMany
   */
  export type sessions_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * Filter, which sessions_spas to fetch.
     */
    where?: sessions_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions_spas to fetch.
     */
    orderBy?: sessions_spaOrderByWithRelationInput | sessions_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions_spas.
     */
    cursor?: sessions_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions_spas.
     */
    skip?: number
    distinct?: Sessions_spaScalarFieldEnum | Sessions_spaScalarFieldEnum[]
  }

  /**
   * sessions_spa create
   */
  export type sessions_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions_spa.
     */
    data: XOR<sessions_spaCreateInput, sessions_spaUncheckedCreateInput>
  }

  /**
   * sessions_spa createMany
   */
  export type sessions_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions_spas.
     */
    data: sessions_spaCreateManyInput | sessions_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions_spa update
   */
  export type sessions_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions_spa.
     */
    data: XOR<sessions_spaUpdateInput, sessions_spaUncheckedUpdateInput>
    /**
     * Choose, which sessions_spa to update.
     */
    where: sessions_spaWhereUniqueInput
  }

  /**
   * sessions_spa updateMany
   */
  export type sessions_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions_spas.
     */
    data: XOR<sessions_spaUpdateManyMutationInput, sessions_spaUncheckedUpdateManyInput>
    /**
     * Filter which sessions_spas to update
     */
    where?: sessions_spaWhereInput
    /**
     * Limit how many sessions_spas to update.
     */
    limit?: number
  }

  /**
   * sessions_spa upsert
   */
  export type sessions_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions_spa to update in case it exists.
     */
    where: sessions_spaWhereUniqueInput
    /**
     * In case the sessions_spa found by the `where` argument doesn't exist, create a new sessions_spa with this data.
     */
    create: XOR<sessions_spaCreateInput, sessions_spaUncheckedCreateInput>
    /**
     * In case the sessions_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessions_spaUpdateInput, sessions_spaUncheckedUpdateInput>
  }

  /**
   * sessions_spa delete
   */
  export type sessions_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    /**
     * Filter which sessions_spa to delete.
     */
    where: sessions_spaWhereUniqueInput
  }

  /**
   * sessions_spa deleteMany
   */
  export type sessions_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions_spas to delete
     */
    where?: sessions_spaWhereInput
    /**
     * Limit how many sessions_spas to delete.
     */
    limit?: number
  }

  /**
   * sessions_spa without action
   */
  export type sessions_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
  }


  /**
   * Model supervisor_register_partners
   */

  export type AggregateSupervisor_register_partners = {
    _count: Supervisor_register_partnersCountAggregateOutputType | null
    _min: Supervisor_register_partnersMinAggregateOutputType | null
    _max: Supervisor_register_partnersMaxAggregateOutputType | null
  }

  export type Supervisor_register_partnersMinAggregateOutputType = {
    id: string | null
    phone_number: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Supervisor_register_partnersMaxAggregateOutputType = {
    id: string | null
    phone_number: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Supervisor_register_partnersCountAggregateOutputType = {
    id: number
    phone_number: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Supervisor_register_partnersMinAggregateInputType = {
    id?: true
    phone_number?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Supervisor_register_partnersMaxAggregateInputType = {
    id?: true
    phone_number?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Supervisor_register_partnersCountAggregateInputType = {
    id?: true
    phone_number?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Supervisor_register_partnersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supervisor_register_partners to aggregate.
     */
    where?: supervisor_register_partnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supervisor_register_partners to fetch.
     */
    orderBy?: supervisor_register_partnersOrderByWithRelationInput | supervisor_register_partnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supervisor_register_partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supervisor_register_partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supervisor_register_partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned supervisor_register_partners
    **/
    _count?: true | Supervisor_register_partnersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Supervisor_register_partnersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Supervisor_register_partnersMaxAggregateInputType
  }

  export type GetSupervisor_register_partnersAggregateType<T extends Supervisor_register_partnersAggregateArgs> = {
        [P in keyof T & keyof AggregateSupervisor_register_partners]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupervisor_register_partners[P]>
      : GetScalarType<T[P], AggregateSupervisor_register_partners[P]>
  }




  export type supervisor_register_partnersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supervisor_register_partnersWhereInput
    orderBy?: supervisor_register_partnersOrderByWithAggregationInput | supervisor_register_partnersOrderByWithAggregationInput[]
    by: Supervisor_register_partnersScalarFieldEnum[] | Supervisor_register_partnersScalarFieldEnum
    having?: supervisor_register_partnersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Supervisor_register_partnersCountAggregateInputType | true
    _min?: Supervisor_register_partnersMinAggregateInputType
    _max?: Supervisor_register_partnersMaxAggregateInputType
  }

  export type Supervisor_register_partnersGroupByOutputType = {
    id: string
    phone_number: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: Supervisor_register_partnersCountAggregateOutputType | null
    _min: Supervisor_register_partnersMinAggregateOutputType | null
    _max: Supervisor_register_partnersMaxAggregateOutputType | null
  }

  type GetSupervisor_register_partnersGroupByPayload<T extends supervisor_register_partnersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Supervisor_register_partnersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Supervisor_register_partnersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Supervisor_register_partnersGroupByOutputType[P]>
            : GetScalarType<T[P], Supervisor_register_partnersGroupByOutputType[P]>
        }
      >
    >


  export type supervisor_register_partnersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supervisor_register_partners"]>



  export type supervisor_register_partnersSelectScalar = {
    id?: boolean
    phone_number?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type supervisor_register_partnersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["supervisor_register_partners"]>

  export type $supervisor_register_partnersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supervisor_register_partners"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: string | null
      name: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["supervisor_register_partners"]>
    composites: {}
  }

  type supervisor_register_partnersGetPayload<S extends boolean | null | undefined | supervisor_register_partnersDefaultArgs> = $Result.GetResult<Prisma.$supervisor_register_partnersPayload, S>

  type supervisor_register_partnersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<supervisor_register_partnersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Supervisor_register_partnersCountAggregateInputType | true
    }

  export interface supervisor_register_partnersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supervisor_register_partners'], meta: { name: 'supervisor_register_partners' } }
    /**
     * Find zero or one Supervisor_register_partners that matches the filter.
     * @param {supervisor_register_partnersFindUniqueArgs} args - Arguments to find a Supervisor_register_partners
     * @example
     * // Get one Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends supervisor_register_partnersFindUniqueArgs>(args: SelectSubset<T, supervisor_register_partnersFindUniqueArgs<ExtArgs>>): Prisma__supervisor_register_partnersClient<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supervisor_register_partners that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {supervisor_register_partnersFindUniqueOrThrowArgs} args - Arguments to find a Supervisor_register_partners
     * @example
     * // Get one Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends supervisor_register_partnersFindUniqueOrThrowArgs>(args: SelectSubset<T, supervisor_register_partnersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__supervisor_register_partnersClient<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supervisor_register_partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisor_register_partnersFindFirstArgs} args - Arguments to find a Supervisor_register_partners
     * @example
     * // Get one Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends supervisor_register_partnersFindFirstArgs>(args?: SelectSubset<T, supervisor_register_partnersFindFirstArgs<ExtArgs>>): Prisma__supervisor_register_partnersClient<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supervisor_register_partners that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisor_register_partnersFindFirstOrThrowArgs} args - Arguments to find a Supervisor_register_partners
     * @example
     * // Get one Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends supervisor_register_partnersFindFirstOrThrowArgs>(args?: SelectSubset<T, supervisor_register_partnersFindFirstOrThrowArgs<ExtArgs>>): Prisma__supervisor_register_partnersClient<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Supervisor_register_partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisor_register_partnersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.findMany()
     * 
     * // Get first 10 Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supervisor_register_partnersWithIdOnly = await prisma.supervisor_register_partners.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends supervisor_register_partnersFindManyArgs>(args?: SelectSubset<T, supervisor_register_partnersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supervisor_register_partners.
     * @param {supervisor_register_partnersCreateArgs} args - Arguments to create a Supervisor_register_partners.
     * @example
     * // Create one Supervisor_register_partners
     * const Supervisor_register_partners = await prisma.supervisor_register_partners.create({
     *   data: {
     *     // ... data to create a Supervisor_register_partners
     *   }
     * })
     * 
     */
    create<T extends supervisor_register_partnersCreateArgs>(args: SelectSubset<T, supervisor_register_partnersCreateArgs<ExtArgs>>): Prisma__supervisor_register_partnersClient<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Supervisor_register_partners.
     * @param {supervisor_register_partnersCreateManyArgs} args - Arguments to create many Supervisor_register_partners.
     * @example
     * // Create many Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends supervisor_register_partnersCreateManyArgs>(args?: SelectSubset<T, supervisor_register_partnersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supervisor_register_partners.
     * @param {supervisor_register_partnersDeleteArgs} args - Arguments to delete one Supervisor_register_partners.
     * @example
     * // Delete one Supervisor_register_partners
     * const Supervisor_register_partners = await prisma.supervisor_register_partners.delete({
     *   where: {
     *     // ... filter to delete one Supervisor_register_partners
     *   }
     * })
     * 
     */
    delete<T extends supervisor_register_partnersDeleteArgs>(args: SelectSubset<T, supervisor_register_partnersDeleteArgs<ExtArgs>>): Prisma__supervisor_register_partnersClient<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supervisor_register_partners.
     * @param {supervisor_register_partnersUpdateArgs} args - Arguments to update one Supervisor_register_partners.
     * @example
     * // Update one Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends supervisor_register_partnersUpdateArgs>(args: SelectSubset<T, supervisor_register_partnersUpdateArgs<ExtArgs>>): Prisma__supervisor_register_partnersClient<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Supervisor_register_partners.
     * @param {supervisor_register_partnersDeleteManyArgs} args - Arguments to filter Supervisor_register_partners to delete.
     * @example
     * // Delete a few Supervisor_register_partners
     * const { count } = await prisma.supervisor_register_partners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends supervisor_register_partnersDeleteManyArgs>(args?: SelectSubset<T, supervisor_register_partnersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supervisor_register_partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisor_register_partnersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends supervisor_register_partnersUpdateManyArgs>(args: SelectSubset<T, supervisor_register_partnersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supervisor_register_partners.
     * @param {supervisor_register_partnersUpsertArgs} args - Arguments to update or create a Supervisor_register_partners.
     * @example
     * // Update or create a Supervisor_register_partners
     * const supervisor_register_partners = await prisma.supervisor_register_partners.upsert({
     *   create: {
     *     // ... data to create a Supervisor_register_partners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supervisor_register_partners we want to update
     *   }
     * })
     */
    upsert<T extends supervisor_register_partnersUpsertArgs>(args: SelectSubset<T, supervisor_register_partnersUpsertArgs<ExtArgs>>): Prisma__supervisor_register_partnersClient<$Result.GetResult<Prisma.$supervisor_register_partnersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Supervisor_register_partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisor_register_partnersCountArgs} args - Arguments to filter Supervisor_register_partners to count.
     * @example
     * // Count the number of Supervisor_register_partners
     * const count = await prisma.supervisor_register_partners.count({
     *   where: {
     *     // ... the filter for the Supervisor_register_partners we want to count
     *   }
     * })
    **/
    count<T extends supervisor_register_partnersCountArgs>(
      args?: Subset<T, supervisor_register_partnersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Supervisor_register_partnersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supervisor_register_partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Supervisor_register_partnersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Supervisor_register_partnersAggregateArgs>(args: Subset<T, Supervisor_register_partnersAggregateArgs>): Prisma.PrismaPromise<GetSupervisor_register_partnersAggregateType<T>>

    /**
     * Group by Supervisor_register_partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisor_register_partnersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supervisor_register_partnersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supervisor_register_partnersGroupByArgs['orderBy'] }
        : { orderBy?: supervisor_register_partnersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supervisor_register_partnersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupervisor_register_partnersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supervisor_register_partners model
   */
  readonly fields: supervisor_register_partnersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supervisor_register_partners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supervisor_register_partnersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the supervisor_register_partners model
   */
  interface supervisor_register_partnersFieldRefs {
    readonly id: FieldRef<"supervisor_register_partners", 'String'>
    readonly phone_number: FieldRef<"supervisor_register_partners", 'String'>
    readonly name: FieldRef<"supervisor_register_partners", 'String'>
    readonly createdAt: FieldRef<"supervisor_register_partners", 'DateTime'>
    readonly updatedAt: FieldRef<"supervisor_register_partners", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * supervisor_register_partners findUnique
   */
  export type supervisor_register_partnersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * Filter, which supervisor_register_partners to fetch.
     */
    where: supervisor_register_partnersWhereUniqueInput
  }

  /**
   * supervisor_register_partners findUniqueOrThrow
   */
  export type supervisor_register_partnersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * Filter, which supervisor_register_partners to fetch.
     */
    where: supervisor_register_partnersWhereUniqueInput
  }

  /**
   * supervisor_register_partners findFirst
   */
  export type supervisor_register_partnersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * Filter, which supervisor_register_partners to fetch.
     */
    where?: supervisor_register_partnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supervisor_register_partners to fetch.
     */
    orderBy?: supervisor_register_partnersOrderByWithRelationInput | supervisor_register_partnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supervisor_register_partners.
     */
    cursor?: supervisor_register_partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supervisor_register_partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supervisor_register_partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supervisor_register_partners.
     */
    distinct?: Supervisor_register_partnersScalarFieldEnum | Supervisor_register_partnersScalarFieldEnum[]
  }

  /**
   * supervisor_register_partners findFirstOrThrow
   */
  export type supervisor_register_partnersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * Filter, which supervisor_register_partners to fetch.
     */
    where?: supervisor_register_partnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supervisor_register_partners to fetch.
     */
    orderBy?: supervisor_register_partnersOrderByWithRelationInput | supervisor_register_partnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supervisor_register_partners.
     */
    cursor?: supervisor_register_partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supervisor_register_partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supervisor_register_partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supervisor_register_partners.
     */
    distinct?: Supervisor_register_partnersScalarFieldEnum | Supervisor_register_partnersScalarFieldEnum[]
  }

  /**
   * supervisor_register_partners findMany
   */
  export type supervisor_register_partnersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * Filter, which supervisor_register_partners to fetch.
     */
    where?: supervisor_register_partnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supervisor_register_partners to fetch.
     */
    orderBy?: supervisor_register_partnersOrderByWithRelationInput | supervisor_register_partnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing supervisor_register_partners.
     */
    cursor?: supervisor_register_partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supervisor_register_partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supervisor_register_partners.
     */
    skip?: number
    distinct?: Supervisor_register_partnersScalarFieldEnum | Supervisor_register_partnersScalarFieldEnum[]
  }

  /**
   * supervisor_register_partners create
   */
  export type supervisor_register_partnersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * The data needed to create a supervisor_register_partners.
     */
    data: XOR<supervisor_register_partnersCreateInput, supervisor_register_partnersUncheckedCreateInput>
  }

  /**
   * supervisor_register_partners createMany
   */
  export type supervisor_register_partnersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many supervisor_register_partners.
     */
    data: supervisor_register_partnersCreateManyInput | supervisor_register_partnersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supervisor_register_partners update
   */
  export type supervisor_register_partnersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * The data needed to update a supervisor_register_partners.
     */
    data: XOR<supervisor_register_partnersUpdateInput, supervisor_register_partnersUncheckedUpdateInput>
    /**
     * Choose, which supervisor_register_partners to update.
     */
    where: supervisor_register_partnersWhereUniqueInput
  }

  /**
   * supervisor_register_partners updateMany
   */
  export type supervisor_register_partnersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update supervisor_register_partners.
     */
    data: XOR<supervisor_register_partnersUpdateManyMutationInput, supervisor_register_partnersUncheckedUpdateManyInput>
    /**
     * Filter which supervisor_register_partners to update
     */
    where?: supervisor_register_partnersWhereInput
    /**
     * Limit how many supervisor_register_partners to update.
     */
    limit?: number
  }

  /**
   * supervisor_register_partners upsert
   */
  export type supervisor_register_partnersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * The filter to search for the supervisor_register_partners to update in case it exists.
     */
    where: supervisor_register_partnersWhereUniqueInput
    /**
     * In case the supervisor_register_partners found by the `where` argument doesn't exist, create a new supervisor_register_partners with this data.
     */
    create: XOR<supervisor_register_partnersCreateInput, supervisor_register_partnersUncheckedCreateInput>
    /**
     * In case the supervisor_register_partners was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supervisor_register_partnersUpdateInput, supervisor_register_partnersUncheckedUpdateInput>
  }

  /**
   * supervisor_register_partners delete
   */
  export type supervisor_register_partnersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
    /**
     * Filter which supervisor_register_partners to delete.
     */
    where: supervisor_register_partnersWhereUniqueInput
  }

  /**
   * supervisor_register_partners deleteMany
   */
  export type supervisor_register_partnersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supervisor_register_partners to delete
     */
    where?: supervisor_register_partnersWhereInput
    /**
     * Limit how many supervisor_register_partners to delete.
     */
    limit?: number
  }

  /**
   * supervisor_register_partners without action
   */
  export type supervisor_register_partnersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor_register_partners
     */
    select?: supervisor_register_partnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor_register_partners
     */
    omit?: supervisor_register_partnersOmit<ExtArgs> | null
  }


  /**
   * Model testers_aut
   */

  export type AggregateTesters_aut = {
    _count: Testers_autCountAggregateOutputType | null
    _min: Testers_autMinAggregateOutputType | null
    _max: Testers_autMaxAggregateOutputType | null
  }

  export type Testers_autMinAggregateOutputType = {
    id: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Testers_autMaxAggregateOutputType = {
    id: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Testers_autCountAggregateOutputType = {
    id: number
    phone_number: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Testers_autMinAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Testers_autMaxAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Testers_autCountAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Testers_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testers_aut to aggregate.
     */
    where?: testers_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_auts to fetch.
     */
    orderBy?: testers_autOrderByWithRelationInput | testers_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testers_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testers_auts
    **/
    _count?: true | Testers_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Testers_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Testers_autMaxAggregateInputType
  }

  export type GetTesters_autAggregateType<T extends Testers_autAggregateArgs> = {
        [P in keyof T & keyof AggregateTesters_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTesters_aut[P]>
      : GetScalarType<T[P], AggregateTesters_aut[P]>
  }




  export type testers_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testers_autWhereInput
    orderBy?: testers_autOrderByWithAggregationInput | testers_autOrderByWithAggregationInput[]
    by: Testers_autScalarFieldEnum[] | Testers_autScalarFieldEnum
    having?: testers_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Testers_autCountAggregateInputType | true
    _min?: Testers_autMinAggregateInputType
    _max?: Testers_autMaxAggregateInputType
  }

  export type Testers_autGroupByOutputType = {
    id: string
    phone_number: string
    createdAt: Date
    updatedAt: Date
    _count: Testers_autCountAggregateOutputType | null
    _min: Testers_autMinAggregateOutputType | null
    _max: Testers_autMaxAggregateOutputType | null
  }

  type GetTesters_autGroupByPayload<T extends testers_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Testers_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Testers_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Testers_autGroupByOutputType[P]>
            : GetScalarType<T[P], Testers_autGroupByOutputType[P]>
        }
      >
    >


  export type testers_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testers_aut"]>



  export type testers_autSelectScalar = {
    id?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type testers_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "createdAt" | "updatedAt", ExtArgs["result"]["testers_aut"]>

  export type $testers_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testers_aut"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testers_aut"]>
    composites: {}
  }

  type testers_autGetPayload<S extends boolean | null | undefined | testers_autDefaultArgs> = $Result.GetResult<Prisma.$testers_autPayload, S>

  type testers_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testers_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Testers_autCountAggregateInputType | true
    }

  export interface testers_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testers_aut'], meta: { name: 'testers_aut' } }
    /**
     * Find zero or one Testers_aut that matches the filter.
     * @param {testers_autFindUniqueArgs} args - Arguments to find a Testers_aut
     * @example
     * // Get one Testers_aut
     * const testers_aut = await prisma.testers_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testers_autFindUniqueArgs>(args: SelectSubset<T, testers_autFindUniqueArgs<ExtArgs>>): Prisma__testers_autClient<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testers_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testers_autFindUniqueOrThrowArgs} args - Arguments to find a Testers_aut
     * @example
     * // Get one Testers_aut
     * const testers_aut = await prisma.testers_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testers_autFindUniqueOrThrowArgs>(args: SelectSubset<T, testers_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testers_autClient<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testers_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_autFindFirstArgs} args - Arguments to find a Testers_aut
     * @example
     * // Get one Testers_aut
     * const testers_aut = await prisma.testers_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testers_autFindFirstArgs>(args?: SelectSubset<T, testers_autFindFirstArgs<ExtArgs>>): Prisma__testers_autClient<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testers_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_autFindFirstOrThrowArgs} args - Arguments to find a Testers_aut
     * @example
     * // Get one Testers_aut
     * const testers_aut = await prisma.testers_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testers_autFindFirstOrThrowArgs>(args?: SelectSubset<T, testers_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__testers_autClient<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testers_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testers_auts
     * const testers_auts = await prisma.testers_aut.findMany()
     * 
     * // Get first 10 Testers_auts
     * const testers_auts = await prisma.testers_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testers_autWithIdOnly = await prisma.testers_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends testers_autFindManyArgs>(args?: SelectSubset<T, testers_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testers_aut.
     * @param {testers_autCreateArgs} args - Arguments to create a Testers_aut.
     * @example
     * // Create one Testers_aut
     * const Testers_aut = await prisma.testers_aut.create({
     *   data: {
     *     // ... data to create a Testers_aut
     *   }
     * })
     * 
     */
    create<T extends testers_autCreateArgs>(args: SelectSubset<T, testers_autCreateArgs<ExtArgs>>): Prisma__testers_autClient<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testers_auts.
     * @param {testers_autCreateManyArgs} args - Arguments to create many Testers_auts.
     * @example
     * // Create many Testers_auts
     * const testers_aut = await prisma.testers_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testers_autCreateManyArgs>(args?: SelectSubset<T, testers_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testers_aut.
     * @param {testers_autDeleteArgs} args - Arguments to delete one Testers_aut.
     * @example
     * // Delete one Testers_aut
     * const Testers_aut = await prisma.testers_aut.delete({
     *   where: {
     *     // ... filter to delete one Testers_aut
     *   }
     * })
     * 
     */
    delete<T extends testers_autDeleteArgs>(args: SelectSubset<T, testers_autDeleteArgs<ExtArgs>>): Prisma__testers_autClient<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testers_aut.
     * @param {testers_autUpdateArgs} args - Arguments to update one Testers_aut.
     * @example
     * // Update one Testers_aut
     * const testers_aut = await prisma.testers_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testers_autUpdateArgs>(args: SelectSubset<T, testers_autUpdateArgs<ExtArgs>>): Prisma__testers_autClient<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testers_auts.
     * @param {testers_autDeleteManyArgs} args - Arguments to filter Testers_auts to delete.
     * @example
     * // Delete a few Testers_auts
     * const { count } = await prisma.testers_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testers_autDeleteManyArgs>(args?: SelectSubset<T, testers_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testers_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testers_auts
     * const testers_aut = await prisma.testers_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testers_autUpdateManyArgs>(args: SelectSubset<T, testers_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testers_aut.
     * @param {testers_autUpsertArgs} args - Arguments to update or create a Testers_aut.
     * @example
     * // Update or create a Testers_aut
     * const testers_aut = await prisma.testers_aut.upsert({
     *   create: {
     *     // ... data to create a Testers_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testers_aut we want to update
     *   }
     * })
     */
    upsert<T extends testers_autUpsertArgs>(args: SelectSubset<T, testers_autUpsertArgs<ExtArgs>>): Prisma__testers_autClient<$Result.GetResult<Prisma.$testers_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testers_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_autCountArgs} args - Arguments to filter Testers_auts to count.
     * @example
     * // Count the number of Testers_auts
     * const count = await prisma.testers_aut.count({
     *   where: {
     *     // ... the filter for the Testers_auts we want to count
     *   }
     * })
    **/
    count<T extends testers_autCountArgs>(
      args?: Subset<T, testers_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Testers_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testers_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Testers_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Testers_autAggregateArgs>(args: Subset<T, Testers_autAggregateArgs>): Prisma.PrismaPromise<GetTesters_autAggregateType<T>>

    /**
     * Group by Testers_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testers_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testers_autGroupByArgs['orderBy'] }
        : { orderBy?: testers_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testers_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTesters_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testers_aut model
   */
  readonly fields: testers_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testers_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testers_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testers_aut model
   */
  interface testers_autFieldRefs {
    readonly id: FieldRef<"testers_aut", 'String'>
    readonly phone_number: FieldRef<"testers_aut", 'String'>
    readonly createdAt: FieldRef<"testers_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"testers_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * testers_aut findUnique
   */
  export type testers_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * Filter, which testers_aut to fetch.
     */
    where: testers_autWhereUniqueInput
  }

  /**
   * testers_aut findUniqueOrThrow
   */
  export type testers_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * Filter, which testers_aut to fetch.
     */
    where: testers_autWhereUniqueInput
  }

  /**
   * testers_aut findFirst
   */
  export type testers_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * Filter, which testers_aut to fetch.
     */
    where?: testers_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_auts to fetch.
     */
    orderBy?: testers_autOrderByWithRelationInput | testers_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testers_auts.
     */
    cursor?: testers_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testers_auts.
     */
    distinct?: Testers_autScalarFieldEnum | Testers_autScalarFieldEnum[]
  }

  /**
   * testers_aut findFirstOrThrow
   */
  export type testers_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * Filter, which testers_aut to fetch.
     */
    where?: testers_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_auts to fetch.
     */
    orderBy?: testers_autOrderByWithRelationInput | testers_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testers_auts.
     */
    cursor?: testers_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testers_auts.
     */
    distinct?: Testers_autScalarFieldEnum | Testers_autScalarFieldEnum[]
  }

  /**
   * testers_aut findMany
   */
  export type testers_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * Filter, which testers_auts to fetch.
     */
    where?: testers_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_auts to fetch.
     */
    orderBy?: testers_autOrderByWithRelationInput | testers_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testers_auts.
     */
    cursor?: testers_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_auts.
     */
    skip?: number
    distinct?: Testers_autScalarFieldEnum | Testers_autScalarFieldEnum[]
  }

  /**
   * testers_aut create
   */
  export type testers_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * The data needed to create a testers_aut.
     */
    data: XOR<testers_autCreateInput, testers_autUncheckedCreateInput>
  }

  /**
   * testers_aut createMany
   */
  export type testers_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testers_auts.
     */
    data: testers_autCreateManyInput | testers_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testers_aut update
   */
  export type testers_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * The data needed to update a testers_aut.
     */
    data: XOR<testers_autUpdateInput, testers_autUncheckedUpdateInput>
    /**
     * Choose, which testers_aut to update.
     */
    where: testers_autWhereUniqueInput
  }

  /**
   * testers_aut updateMany
   */
  export type testers_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testers_auts.
     */
    data: XOR<testers_autUpdateManyMutationInput, testers_autUncheckedUpdateManyInput>
    /**
     * Filter which testers_auts to update
     */
    where?: testers_autWhereInput
    /**
     * Limit how many testers_auts to update.
     */
    limit?: number
  }

  /**
   * testers_aut upsert
   */
  export type testers_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * The filter to search for the testers_aut to update in case it exists.
     */
    where: testers_autWhereUniqueInput
    /**
     * In case the testers_aut found by the `where` argument doesn't exist, create a new testers_aut with this data.
     */
    create: XOR<testers_autCreateInput, testers_autUncheckedCreateInput>
    /**
     * In case the testers_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testers_autUpdateInput, testers_autUncheckedUpdateInput>
  }

  /**
   * testers_aut delete
   */
  export type testers_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
    /**
     * Filter which testers_aut to delete.
     */
    where: testers_autWhereUniqueInput
  }

  /**
   * testers_aut deleteMany
   */
  export type testers_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testers_auts to delete
     */
    where?: testers_autWhereInput
    /**
     * Limit how many testers_auts to delete.
     */
    limit?: number
  }

  /**
   * testers_aut without action
   */
  export type testers_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_aut
     */
    select?: testers_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_aut
     */
    omit?: testers_autOmit<ExtArgs> | null
  }


  /**
   * Model testers_clt
   */

  export type AggregateTesters_clt = {
    _count: Testers_cltCountAggregateOutputType | null
    _min: Testers_cltMinAggregateOutputType | null
    _max: Testers_cltMaxAggregateOutputType | null
  }

  export type Testers_cltMinAggregateOutputType = {
    id: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Testers_cltMaxAggregateOutputType = {
    id: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Testers_cltCountAggregateOutputType = {
    id: number
    phone_number: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Testers_cltMinAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Testers_cltMaxAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Testers_cltCountAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Testers_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testers_clt to aggregate.
     */
    where?: testers_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_clts to fetch.
     */
    orderBy?: testers_cltOrderByWithRelationInput | testers_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testers_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testers_clts
    **/
    _count?: true | Testers_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Testers_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Testers_cltMaxAggregateInputType
  }

  export type GetTesters_cltAggregateType<T extends Testers_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateTesters_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTesters_clt[P]>
      : GetScalarType<T[P], AggregateTesters_clt[P]>
  }




  export type testers_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testers_cltWhereInput
    orderBy?: testers_cltOrderByWithAggregationInput | testers_cltOrderByWithAggregationInput[]
    by: Testers_cltScalarFieldEnum[] | Testers_cltScalarFieldEnum
    having?: testers_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Testers_cltCountAggregateInputType | true
    _min?: Testers_cltMinAggregateInputType
    _max?: Testers_cltMaxAggregateInputType
  }

  export type Testers_cltGroupByOutputType = {
    id: string
    phone_number: string
    createdAt: Date
    updatedAt: Date
    _count: Testers_cltCountAggregateOutputType | null
    _min: Testers_cltMinAggregateOutputType | null
    _max: Testers_cltMaxAggregateOutputType | null
  }

  type GetTesters_cltGroupByPayload<T extends testers_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Testers_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Testers_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Testers_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Testers_cltGroupByOutputType[P]>
        }
      >
    >


  export type testers_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testers_clt"]>



  export type testers_cltSelectScalar = {
    id?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type testers_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "createdAt" | "updatedAt", ExtArgs["result"]["testers_clt"]>

  export type $testers_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testers_clt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testers_clt"]>
    composites: {}
  }

  type testers_cltGetPayload<S extends boolean | null | undefined | testers_cltDefaultArgs> = $Result.GetResult<Prisma.$testers_cltPayload, S>

  type testers_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testers_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Testers_cltCountAggregateInputType | true
    }

  export interface testers_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testers_clt'], meta: { name: 'testers_clt' } }
    /**
     * Find zero or one Testers_clt that matches the filter.
     * @param {testers_cltFindUniqueArgs} args - Arguments to find a Testers_clt
     * @example
     * // Get one Testers_clt
     * const testers_clt = await prisma.testers_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testers_cltFindUniqueArgs>(args: SelectSubset<T, testers_cltFindUniqueArgs<ExtArgs>>): Prisma__testers_cltClient<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testers_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testers_cltFindUniqueOrThrowArgs} args - Arguments to find a Testers_clt
     * @example
     * // Get one Testers_clt
     * const testers_clt = await prisma.testers_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testers_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, testers_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testers_cltClient<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testers_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_cltFindFirstArgs} args - Arguments to find a Testers_clt
     * @example
     * // Get one Testers_clt
     * const testers_clt = await prisma.testers_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testers_cltFindFirstArgs>(args?: SelectSubset<T, testers_cltFindFirstArgs<ExtArgs>>): Prisma__testers_cltClient<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testers_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_cltFindFirstOrThrowArgs} args - Arguments to find a Testers_clt
     * @example
     * // Get one Testers_clt
     * const testers_clt = await prisma.testers_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testers_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, testers_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__testers_cltClient<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testers_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testers_clts
     * const testers_clts = await prisma.testers_clt.findMany()
     * 
     * // Get first 10 Testers_clts
     * const testers_clts = await prisma.testers_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testers_cltWithIdOnly = await prisma.testers_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends testers_cltFindManyArgs>(args?: SelectSubset<T, testers_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testers_clt.
     * @param {testers_cltCreateArgs} args - Arguments to create a Testers_clt.
     * @example
     * // Create one Testers_clt
     * const Testers_clt = await prisma.testers_clt.create({
     *   data: {
     *     // ... data to create a Testers_clt
     *   }
     * })
     * 
     */
    create<T extends testers_cltCreateArgs>(args: SelectSubset<T, testers_cltCreateArgs<ExtArgs>>): Prisma__testers_cltClient<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testers_clts.
     * @param {testers_cltCreateManyArgs} args - Arguments to create many Testers_clts.
     * @example
     * // Create many Testers_clts
     * const testers_clt = await prisma.testers_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testers_cltCreateManyArgs>(args?: SelectSubset<T, testers_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testers_clt.
     * @param {testers_cltDeleteArgs} args - Arguments to delete one Testers_clt.
     * @example
     * // Delete one Testers_clt
     * const Testers_clt = await prisma.testers_clt.delete({
     *   where: {
     *     // ... filter to delete one Testers_clt
     *   }
     * })
     * 
     */
    delete<T extends testers_cltDeleteArgs>(args: SelectSubset<T, testers_cltDeleteArgs<ExtArgs>>): Prisma__testers_cltClient<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testers_clt.
     * @param {testers_cltUpdateArgs} args - Arguments to update one Testers_clt.
     * @example
     * // Update one Testers_clt
     * const testers_clt = await prisma.testers_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testers_cltUpdateArgs>(args: SelectSubset<T, testers_cltUpdateArgs<ExtArgs>>): Prisma__testers_cltClient<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testers_clts.
     * @param {testers_cltDeleteManyArgs} args - Arguments to filter Testers_clts to delete.
     * @example
     * // Delete a few Testers_clts
     * const { count } = await prisma.testers_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testers_cltDeleteManyArgs>(args?: SelectSubset<T, testers_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testers_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testers_clts
     * const testers_clt = await prisma.testers_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testers_cltUpdateManyArgs>(args: SelectSubset<T, testers_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testers_clt.
     * @param {testers_cltUpsertArgs} args - Arguments to update or create a Testers_clt.
     * @example
     * // Update or create a Testers_clt
     * const testers_clt = await prisma.testers_clt.upsert({
     *   create: {
     *     // ... data to create a Testers_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testers_clt we want to update
     *   }
     * })
     */
    upsert<T extends testers_cltUpsertArgs>(args: SelectSubset<T, testers_cltUpsertArgs<ExtArgs>>): Prisma__testers_cltClient<$Result.GetResult<Prisma.$testers_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testers_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_cltCountArgs} args - Arguments to filter Testers_clts to count.
     * @example
     * // Count the number of Testers_clts
     * const count = await prisma.testers_clt.count({
     *   where: {
     *     // ... the filter for the Testers_clts we want to count
     *   }
     * })
    **/
    count<T extends testers_cltCountArgs>(
      args?: Subset<T, testers_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Testers_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testers_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Testers_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Testers_cltAggregateArgs>(args: Subset<T, Testers_cltAggregateArgs>): Prisma.PrismaPromise<GetTesters_cltAggregateType<T>>

    /**
     * Group by Testers_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testers_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testers_cltGroupByArgs['orderBy'] }
        : { orderBy?: testers_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testers_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTesters_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testers_clt model
   */
  readonly fields: testers_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testers_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testers_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testers_clt model
   */
  interface testers_cltFieldRefs {
    readonly id: FieldRef<"testers_clt", 'String'>
    readonly phone_number: FieldRef<"testers_clt", 'String'>
    readonly createdAt: FieldRef<"testers_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"testers_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * testers_clt findUnique
   */
  export type testers_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * Filter, which testers_clt to fetch.
     */
    where: testers_cltWhereUniqueInput
  }

  /**
   * testers_clt findUniqueOrThrow
   */
  export type testers_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * Filter, which testers_clt to fetch.
     */
    where: testers_cltWhereUniqueInput
  }

  /**
   * testers_clt findFirst
   */
  export type testers_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * Filter, which testers_clt to fetch.
     */
    where?: testers_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_clts to fetch.
     */
    orderBy?: testers_cltOrderByWithRelationInput | testers_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testers_clts.
     */
    cursor?: testers_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testers_clts.
     */
    distinct?: Testers_cltScalarFieldEnum | Testers_cltScalarFieldEnum[]
  }

  /**
   * testers_clt findFirstOrThrow
   */
  export type testers_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * Filter, which testers_clt to fetch.
     */
    where?: testers_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_clts to fetch.
     */
    orderBy?: testers_cltOrderByWithRelationInput | testers_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testers_clts.
     */
    cursor?: testers_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testers_clts.
     */
    distinct?: Testers_cltScalarFieldEnum | Testers_cltScalarFieldEnum[]
  }

  /**
   * testers_clt findMany
   */
  export type testers_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * Filter, which testers_clts to fetch.
     */
    where?: testers_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_clts to fetch.
     */
    orderBy?: testers_cltOrderByWithRelationInput | testers_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testers_clts.
     */
    cursor?: testers_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_clts.
     */
    skip?: number
    distinct?: Testers_cltScalarFieldEnum | Testers_cltScalarFieldEnum[]
  }

  /**
   * testers_clt create
   */
  export type testers_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * The data needed to create a testers_clt.
     */
    data: XOR<testers_cltCreateInput, testers_cltUncheckedCreateInput>
  }

  /**
   * testers_clt createMany
   */
  export type testers_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testers_clts.
     */
    data: testers_cltCreateManyInput | testers_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testers_clt update
   */
  export type testers_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * The data needed to update a testers_clt.
     */
    data: XOR<testers_cltUpdateInput, testers_cltUncheckedUpdateInput>
    /**
     * Choose, which testers_clt to update.
     */
    where: testers_cltWhereUniqueInput
  }

  /**
   * testers_clt updateMany
   */
  export type testers_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testers_clts.
     */
    data: XOR<testers_cltUpdateManyMutationInput, testers_cltUncheckedUpdateManyInput>
    /**
     * Filter which testers_clts to update
     */
    where?: testers_cltWhereInput
    /**
     * Limit how many testers_clts to update.
     */
    limit?: number
  }

  /**
   * testers_clt upsert
   */
  export type testers_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * The filter to search for the testers_clt to update in case it exists.
     */
    where: testers_cltWhereUniqueInput
    /**
     * In case the testers_clt found by the `where` argument doesn't exist, create a new testers_clt with this data.
     */
    create: XOR<testers_cltCreateInput, testers_cltUncheckedCreateInput>
    /**
     * In case the testers_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testers_cltUpdateInput, testers_cltUncheckedUpdateInput>
  }

  /**
   * testers_clt delete
   */
  export type testers_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
    /**
     * Filter which testers_clt to delete.
     */
    where: testers_cltWhereUniqueInput
  }

  /**
   * testers_clt deleteMany
   */
  export type testers_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testers_clts to delete
     */
    where?: testers_cltWhereInput
    /**
     * Limit how many testers_clts to delete.
     */
    limit?: number
  }

  /**
   * testers_clt without action
   */
  export type testers_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_clt
     */
    select?: testers_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_clt
     */
    omit?: testers_cltOmit<ExtArgs> | null
  }


  /**
   * Model testers_goi
   */

  export type AggregateTesters_goi = {
    _count: Testers_goiCountAggregateOutputType | null
    _min: Testers_goiMinAggregateOutputType | null
    _max: Testers_goiMaxAggregateOutputType | null
  }

  export type Testers_goiMinAggregateOutputType = {
    id: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Testers_goiMaxAggregateOutputType = {
    id: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Testers_goiCountAggregateOutputType = {
    id: number
    phone_number: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Testers_goiMinAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Testers_goiMaxAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Testers_goiCountAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Testers_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testers_goi to aggregate.
     */
    where?: testers_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_gois to fetch.
     */
    orderBy?: testers_goiOrderByWithRelationInput | testers_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testers_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testers_gois
    **/
    _count?: true | Testers_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Testers_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Testers_goiMaxAggregateInputType
  }

  export type GetTesters_goiAggregateType<T extends Testers_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateTesters_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTesters_goi[P]>
      : GetScalarType<T[P], AggregateTesters_goi[P]>
  }




  export type testers_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testers_goiWhereInput
    orderBy?: testers_goiOrderByWithAggregationInput | testers_goiOrderByWithAggregationInput[]
    by: Testers_goiScalarFieldEnum[] | Testers_goiScalarFieldEnum
    having?: testers_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Testers_goiCountAggregateInputType | true
    _min?: Testers_goiMinAggregateInputType
    _max?: Testers_goiMaxAggregateInputType
  }

  export type Testers_goiGroupByOutputType = {
    id: string
    phone_number: string
    createdAt: Date
    updatedAt: Date
    _count: Testers_goiCountAggregateOutputType | null
    _min: Testers_goiMinAggregateOutputType | null
    _max: Testers_goiMaxAggregateOutputType | null
  }

  type GetTesters_goiGroupByPayload<T extends testers_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Testers_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Testers_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Testers_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Testers_goiGroupByOutputType[P]>
        }
      >
    >


  export type testers_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testers_goi"]>



  export type testers_goiSelectScalar = {
    id?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type testers_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "createdAt" | "updatedAt", ExtArgs["result"]["testers_goi"]>

  export type $testers_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testers_goi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testers_goi"]>
    composites: {}
  }

  type testers_goiGetPayload<S extends boolean | null | undefined | testers_goiDefaultArgs> = $Result.GetResult<Prisma.$testers_goiPayload, S>

  type testers_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testers_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Testers_goiCountAggregateInputType | true
    }

  export interface testers_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testers_goi'], meta: { name: 'testers_goi' } }
    /**
     * Find zero or one Testers_goi that matches the filter.
     * @param {testers_goiFindUniqueArgs} args - Arguments to find a Testers_goi
     * @example
     * // Get one Testers_goi
     * const testers_goi = await prisma.testers_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testers_goiFindUniqueArgs>(args: SelectSubset<T, testers_goiFindUniqueArgs<ExtArgs>>): Prisma__testers_goiClient<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testers_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testers_goiFindUniqueOrThrowArgs} args - Arguments to find a Testers_goi
     * @example
     * // Get one Testers_goi
     * const testers_goi = await prisma.testers_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testers_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, testers_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testers_goiClient<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testers_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_goiFindFirstArgs} args - Arguments to find a Testers_goi
     * @example
     * // Get one Testers_goi
     * const testers_goi = await prisma.testers_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testers_goiFindFirstArgs>(args?: SelectSubset<T, testers_goiFindFirstArgs<ExtArgs>>): Prisma__testers_goiClient<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testers_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_goiFindFirstOrThrowArgs} args - Arguments to find a Testers_goi
     * @example
     * // Get one Testers_goi
     * const testers_goi = await prisma.testers_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testers_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, testers_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__testers_goiClient<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testers_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testers_gois
     * const testers_gois = await prisma.testers_goi.findMany()
     * 
     * // Get first 10 Testers_gois
     * const testers_gois = await prisma.testers_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testers_goiWithIdOnly = await prisma.testers_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends testers_goiFindManyArgs>(args?: SelectSubset<T, testers_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testers_goi.
     * @param {testers_goiCreateArgs} args - Arguments to create a Testers_goi.
     * @example
     * // Create one Testers_goi
     * const Testers_goi = await prisma.testers_goi.create({
     *   data: {
     *     // ... data to create a Testers_goi
     *   }
     * })
     * 
     */
    create<T extends testers_goiCreateArgs>(args: SelectSubset<T, testers_goiCreateArgs<ExtArgs>>): Prisma__testers_goiClient<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testers_gois.
     * @param {testers_goiCreateManyArgs} args - Arguments to create many Testers_gois.
     * @example
     * // Create many Testers_gois
     * const testers_goi = await prisma.testers_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testers_goiCreateManyArgs>(args?: SelectSubset<T, testers_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testers_goi.
     * @param {testers_goiDeleteArgs} args - Arguments to delete one Testers_goi.
     * @example
     * // Delete one Testers_goi
     * const Testers_goi = await prisma.testers_goi.delete({
     *   where: {
     *     // ... filter to delete one Testers_goi
     *   }
     * })
     * 
     */
    delete<T extends testers_goiDeleteArgs>(args: SelectSubset<T, testers_goiDeleteArgs<ExtArgs>>): Prisma__testers_goiClient<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testers_goi.
     * @param {testers_goiUpdateArgs} args - Arguments to update one Testers_goi.
     * @example
     * // Update one Testers_goi
     * const testers_goi = await prisma.testers_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testers_goiUpdateArgs>(args: SelectSubset<T, testers_goiUpdateArgs<ExtArgs>>): Prisma__testers_goiClient<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testers_gois.
     * @param {testers_goiDeleteManyArgs} args - Arguments to filter Testers_gois to delete.
     * @example
     * // Delete a few Testers_gois
     * const { count } = await prisma.testers_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testers_goiDeleteManyArgs>(args?: SelectSubset<T, testers_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testers_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testers_gois
     * const testers_goi = await prisma.testers_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testers_goiUpdateManyArgs>(args: SelectSubset<T, testers_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testers_goi.
     * @param {testers_goiUpsertArgs} args - Arguments to update or create a Testers_goi.
     * @example
     * // Update or create a Testers_goi
     * const testers_goi = await prisma.testers_goi.upsert({
     *   create: {
     *     // ... data to create a Testers_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testers_goi we want to update
     *   }
     * })
     */
    upsert<T extends testers_goiUpsertArgs>(args: SelectSubset<T, testers_goiUpsertArgs<ExtArgs>>): Prisma__testers_goiClient<$Result.GetResult<Prisma.$testers_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testers_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_goiCountArgs} args - Arguments to filter Testers_gois to count.
     * @example
     * // Count the number of Testers_gois
     * const count = await prisma.testers_goi.count({
     *   where: {
     *     // ... the filter for the Testers_gois we want to count
     *   }
     * })
    **/
    count<T extends testers_goiCountArgs>(
      args?: Subset<T, testers_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Testers_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testers_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Testers_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Testers_goiAggregateArgs>(args: Subset<T, Testers_goiAggregateArgs>): Prisma.PrismaPromise<GetTesters_goiAggregateType<T>>

    /**
     * Group by Testers_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testers_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testers_goiGroupByArgs['orderBy'] }
        : { orderBy?: testers_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testers_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTesters_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testers_goi model
   */
  readonly fields: testers_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testers_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testers_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testers_goi model
   */
  interface testers_goiFieldRefs {
    readonly id: FieldRef<"testers_goi", 'String'>
    readonly phone_number: FieldRef<"testers_goi", 'String'>
    readonly createdAt: FieldRef<"testers_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"testers_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * testers_goi findUnique
   */
  export type testers_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * Filter, which testers_goi to fetch.
     */
    where: testers_goiWhereUniqueInput
  }

  /**
   * testers_goi findUniqueOrThrow
   */
  export type testers_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * Filter, which testers_goi to fetch.
     */
    where: testers_goiWhereUniqueInput
  }

  /**
   * testers_goi findFirst
   */
  export type testers_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * Filter, which testers_goi to fetch.
     */
    where?: testers_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_gois to fetch.
     */
    orderBy?: testers_goiOrderByWithRelationInput | testers_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testers_gois.
     */
    cursor?: testers_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testers_gois.
     */
    distinct?: Testers_goiScalarFieldEnum | Testers_goiScalarFieldEnum[]
  }

  /**
   * testers_goi findFirstOrThrow
   */
  export type testers_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * Filter, which testers_goi to fetch.
     */
    where?: testers_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_gois to fetch.
     */
    orderBy?: testers_goiOrderByWithRelationInput | testers_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testers_gois.
     */
    cursor?: testers_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testers_gois.
     */
    distinct?: Testers_goiScalarFieldEnum | Testers_goiScalarFieldEnum[]
  }

  /**
   * testers_goi findMany
   */
  export type testers_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * Filter, which testers_gois to fetch.
     */
    where?: testers_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_gois to fetch.
     */
    orderBy?: testers_goiOrderByWithRelationInput | testers_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testers_gois.
     */
    cursor?: testers_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_gois.
     */
    skip?: number
    distinct?: Testers_goiScalarFieldEnum | Testers_goiScalarFieldEnum[]
  }

  /**
   * testers_goi create
   */
  export type testers_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * The data needed to create a testers_goi.
     */
    data: XOR<testers_goiCreateInput, testers_goiUncheckedCreateInput>
  }

  /**
   * testers_goi createMany
   */
  export type testers_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testers_gois.
     */
    data: testers_goiCreateManyInput | testers_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testers_goi update
   */
  export type testers_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * The data needed to update a testers_goi.
     */
    data: XOR<testers_goiUpdateInput, testers_goiUncheckedUpdateInput>
    /**
     * Choose, which testers_goi to update.
     */
    where: testers_goiWhereUniqueInput
  }

  /**
   * testers_goi updateMany
   */
  export type testers_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testers_gois.
     */
    data: XOR<testers_goiUpdateManyMutationInput, testers_goiUncheckedUpdateManyInput>
    /**
     * Filter which testers_gois to update
     */
    where?: testers_goiWhereInput
    /**
     * Limit how many testers_gois to update.
     */
    limit?: number
  }

  /**
   * testers_goi upsert
   */
  export type testers_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * The filter to search for the testers_goi to update in case it exists.
     */
    where: testers_goiWhereUniqueInput
    /**
     * In case the testers_goi found by the `where` argument doesn't exist, create a new testers_goi with this data.
     */
    create: XOR<testers_goiCreateInput, testers_goiUncheckedCreateInput>
    /**
     * In case the testers_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testers_goiUpdateInput, testers_goiUncheckedUpdateInput>
  }

  /**
   * testers_goi delete
   */
  export type testers_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
    /**
     * Filter which testers_goi to delete.
     */
    where: testers_goiWhereUniqueInput
  }

  /**
   * testers_goi deleteMany
   */
  export type testers_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testers_gois to delete
     */
    where?: testers_goiWhereInput
    /**
     * Limit how many testers_gois to delete.
     */
    limit?: number
  }

  /**
   * testers_goi without action
   */
  export type testers_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_goi
     */
    select?: testers_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_goi
     */
    omit?: testers_goiOmit<ExtArgs> | null
  }


  /**
   * Model testers_spa
   */

  export type AggregateTesters_spa = {
    _count: Testers_spaCountAggregateOutputType | null
    _min: Testers_spaMinAggregateOutputType | null
    _max: Testers_spaMaxAggregateOutputType | null
  }

  export type Testers_spaMinAggregateOutputType = {
    id: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Testers_spaMaxAggregateOutputType = {
    id: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Testers_spaCountAggregateOutputType = {
    id: number
    phone_number: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Testers_spaMinAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Testers_spaMaxAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Testers_spaCountAggregateInputType = {
    id?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Testers_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testers_spa to aggregate.
     */
    where?: testers_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_spas to fetch.
     */
    orderBy?: testers_spaOrderByWithRelationInput | testers_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testers_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testers_spas
    **/
    _count?: true | Testers_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Testers_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Testers_spaMaxAggregateInputType
  }

  export type GetTesters_spaAggregateType<T extends Testers_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateTesters_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTesters_spa[P]>
      : GetScalarType<T[P], AggregateTesters_spa[P]>
  }




  export type testers_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testers_spaWhereInput
    orderBy?: testers_spaOrderByWithAggregationInput | testers_spaOrderByWithAggregationInput[]
    by: Testers_spaScalarFieldEnum[] | Testers_spaScalarFieldEnum
    having?: testers_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Testers_spaCountAggregateInputType | true
    _min?: Testers_spaMinAggregateInputType
    _max?: Testers_spaMaxAggregateInputType
  }

  export type Testers_spaGroupByOutputType = {
    id: string
    phone_number: string
    createdAt: Date
    updatedAt: Date
    _count: Testers_spaCountAggregateOutputType | null
    _min: Testers_spaMinAggregateOutputType | null
    _max: Testers_spaMaxAggregateOutputType | null
  }

  type GetTesters_spaGroupByPayload<T extends testers_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Testers_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Testers_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Testers_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Testers_spaGroupByOutputType[P]>
        }
      >
    >


  export type testers_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testers_spa"]>



  export type testers_spaSelectScalar = {
    id?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type testers_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "createdAt" | "updatedAt", ExtArgs["result"]["testers_spa"]>

  export type $testers_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testers_spa"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testers_spa"]>
    composites: {}
  }

  type testers_spaGetPayload<S extends boolean | null | undefined | testers_spaDefaultArgs> = $Result.GetResult<Prisma.$testers_spaPayload, S>

  type testers_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testers_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Testers_spaCountAggregateInputType | true
    }

  export interface testers_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testers_spa'], meta: { name: 'testers_spa' } }
    /**
     * Find zero or one Testers_spa that matches the filter.
     * @param {testers_spaFindUniqueArgs} args - Arguments to find a Testers_spa
     * @example
     * // Get one Testers_spa
     * const testers_spa = await prisma.testers_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testers_spaFindUniqueArgs>(args: SelectSubset<T, testers_spaFindUniqueArgs<ExtArgs>>): Prisma__testers_spaClient<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testers_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testers_spaFindUniqueOrThrowArgs} args - Arguments to find a Testers_spa
     * @example
     * // Get one Testers_spa
     * const testers_spa = await prisma.testers_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testers_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, testers_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testers_spaClient<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testers_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_spaFindFirstArgs} args - Arguments to find a Testers_spa
     * @example
     * // Get one Testers_spa
     * const testers_spa = await prisma.testers_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testers_spaFindFirstArgs>(args?: SelectSubset<T, testers_spaFindFirstArgs<ExtArgs>>): Prisma__testers_spaClient<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testers_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_spaFindFirstOrThrowArgs} args - Arguments to find a Testers_spa
     * @example
     * // Get one Testers_spa
     * const testers_spa = await prisma.testers_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testers_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, testers_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__testers_spaClient<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testers_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testers_spas
     * const testers_spas = await prisma.testers_spa.findMany()
     * 
     * // Get first 10 Testers_spas
     * const testers_spas = await prisma.testers_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testers_spaWithIdOnly = await prisma.testers_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends testers_spaFindManyArgs>(args?: SelectSubset<T, testers_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testers_spa.
     * @param {testers_spaCreateArgs} args - Arguments to create a Testers_spa.
     * @example
     * // Create one Testers_spa
     * const Testers_spa = await prisma.testers_spa.create({
     *   data: {
     *     // ... data to create a Testers_spa
     *   }
     * })
     * 
     */
    create<T extends testers_spaCreateArgs>(args: SelectSubset<T, testers_spaCreateArgs<ExtArgs>>): Prisma__testers_spaClient<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testers_spas.
     * @param {testers_spaCreateManyArgs} args - Arguments to create many Testers_spas.
     * @example
     * // Create many Testers_spas
     * const testers_spa = await prisma.testers_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testers_spaCreateManyArgs>(args?: SelectSubset<T, testers_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testers_spa.
     * @param {testers_spaDeleteArgs} args - Arguments to delete one Testers_spa.
     * @example
     * // Delete one Testers_spa
     * const Testers_spa = await prisma.testers_spa.delete({
     *   where: {
     *     // ... filter to delete one Testers_spa
     *   }
     * })
     * 
     */
    delete<T extends testers_spaDeleteArgs>(args: SelectSubset<T, testers_spaDeleteArgs<ExtArgs>>): Prisma__testers_spaClient<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testers_spa.
     * @param {testers_spaUpdateArgs} args - Arguments to update one Testers_spa.
     * @example
     * // Update one Testers_spa
     * const testers_spa = await prisma.testers_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testers_spaUpdateArgs>(args: SelectSubset<T, testers_spaUpdateArgs<ExtArgs>>): Prisma__testers_spaClient<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testers_spas.
     * @param {testers_spaDeleteManyArgs} args - Arguments to filter Testers_spas to delete.
     * @example
     * // Delete a few Testers_spas
     * const { count } = await prisma.testers_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testers_spaDeleteManyArgs>(args?: SelectSubset<T, testers_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testers_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testers_spas
     * const testers_spa = await prisma.testers_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testers_spaUpdateManyArgs>(args: SelectSubset<T, testers_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testers_spa.
     * @param {testers_spaUpsertArgs} args - Arguments to update or create a Testers_spa.
     * @example
     * // Update or create a Testers_spa
     * const testers_spa = await prisma.testers_spa.upsert({
     *   create: {
     *     // ... data to create a Testers_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testers_spa we want to update
     *   }
     * })
     */
    upsert<T extends testers_spaUpsertArgs>(args: SelectSubset<T, testers_spaUpsertArgs<ExtArgs>>): Prisma__testers_spaClient<$Result.GetResult<Prisma.$testers_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testers_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_spaCountArgs} args - Arguments to filter Testers_spas to count.
     * @example
     * // Count the number of Testers_spas
     * const count = await prisma.testers_spa.count({
     *   where: {
     *     // ... the filter for the Testers_spas we want to count
     *   }
     * })
    **/
    count<T extends testers_spaCountArgs>(
      args?: Subset<T, testers_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Testers_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testers_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Testers_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Testers_spaAggregateArgs>(args: Subset<T, Testers_spaAggregateArgs>): Prisma.PrismaPromise<GetTesters_spaAggregateType<T>>

    /**
     * Group by Testers_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testers_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testers_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testers_spaGroupByArgs['orderBy'] }
        : { orderBy?: testers_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testers_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTesters_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testers_spa model
   */
  readonly fields: testers_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testers_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testers_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testers_spa model
   */
  interface testers_spaFieldRefs {
    readonly id: FieldRef<"testers_spa", 'String'>
    readonly phone_number: FieldRef<"testers_spa", 'String'>
    readonly createdAt: FieldRef<"testers_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"testers_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * testers_spa findUnique
   */
  export type testers_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * Filter, which testers_spa to fetch.
     */
    where: testers_spaWhereUniqueInput
  }

  /**
   * testers_spa findUniqueOrThrow
   */
  export type testers_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * Filter, which testers_spa to fetch.
     */
    where: testers_spaWhereUniqueInput
  }

  /**
   * testers_spa findFirst
   */
  export type testers_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * Filter, which testers_spa to fetch.
     */
    where?: testers_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_spas to fetch.
     */
    orderBy?: testers_spaOrderByWithRelationInput | testers_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testers_spas.
     */
    cursor?: testers_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testers_spas.
     */
    distinct?: Testers_spaScalarFieldEnum | Testers_spaScalarFieldEnum[]
  }

  /**
   * testers_spa findFirstOrThrow
   */
  export type testers_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * Filter, which testers_spa to fetch.
     */
    where?: testers_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_spas to fetch.
     */
    orderBy?: testers_spaOrderByWithRelationInput | testers_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testers_spas.
     */
    cursor?: testers_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testers_spas.
     */
    distinct?: Testers_spaScalarFieldEnum | Testers_spaScalarFieldEnum[]
  }

  /**
   * testers_spa findMany
   */
  export type testers_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * Filter, which testers_spas to fetch.
     */
    where?: testers_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testers_spas to fetch.
     */
    orderBy?: testers_spaOrderByWithRelationInput | testers_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testers_spas.
     */
    cursor?: testers_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testers_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testers_spas.
     */
    skip?: number
    distinct?: Testers_spaScalarFieldEnum | Testers_spaScalarFieldEnum[]
  }

  /**
   * testers_spa create
   */
  export type testers_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * The data needed to create a testers_spa.
     */
    data: XOR<testers_spaCreateInput, testers_spaUncheckedCreateInput>
  }

  /**
   * testers_spa createMany
   */
  export type testers_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testers_spas.
     */
    data: testers_spaCreateManyInput | testers_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testers_spa update
   */
  export type testers_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * The data needed to update a testers_spa.
     */
    data: XOR<testers_spaUpdateInput, testers_spaUncheckedUpdateInput>
    /**
     * Choose, which testers_spa to update.
     */
    where: testers_spaWhereUniqueInput
  }

  /**
   * testers_spa updateMany
   */
  export type testers_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testers_spas.
     */
    data: XOR<testers_spaUpdateManyMutationInput, testers_spaUncheckedUpdateManyInput>
    /**
     * Filter which testers_spas to update
     */
    where?: testers_spaWhereInput
    /**
     * Limit how many testers_spas to update.
     */
    limit?: number
  }

  /**
   * testers_spa upsert
   */
  export type testers_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * The filter to search for the testers_spa to update in case it exists.
     */
    where: testers_spaWhereUniqueInput
    /**
     * In case the testers_spa found by the `where` argument doesn't exist, create a new testers_spa with this data.
     */
    create: XOR<testers_spaCreateInput, testers_spaUncheckedCreateInput>
    /**
     * In case the testers_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testers_spaUpdateInput, testers_spaUncheckedUpdateInput>
  }

  /**
   * testers_spa delete
   */
  export type testers_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
    /**
     * Filter which testers_spa to delete.
     */
    where: testers_spaWhereUniqueInput
  }

  /**
   * testers_spa deleteMany
   */
  export type testers_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testers_spas to delete
     */
    where?: testers_spaWhereInput
    /**
     * Limit how many testers_spas to delete.
     */
    limit?: number
  }

  /**
   * testers_spa without action
   */
  export type testers_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testers_spa
     */
    select?: testers_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testers_spa
     */
    omit?: testers_spaOmit<ExtArgs> | null
  }


  /**
   * Model threads_aut
   */

  export type AggregateThreads_aut = {
    _count: Threads_autCountAggregateOutputType | null
    _min: Threads_autMinAggregateOutputType | null
    _max: Threads_autMaxAggregateOutputType | null
  }

  export type Threads_autMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    thread: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Threads_autMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    thread: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Threads_autCountAggregateOutputType = {
    id: number
    user_id: number
    thread: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Threads_autMinAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Threads_autMaxAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Threads_autCountAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Threads_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which threads_aut to aggregate.
     */
    where?: threads_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_auts to fetch.
     */
    orderBy?: threads_autOrderByWithRelationInput | threads_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: threads_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned threads_auts
    **/
    _count?: true | Threads_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Threads_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Threads_autMaxAggregateInputType
  }

  export type GetThreads_autAggregateType<T extends Threads_autAggregateArgs> = {
        [P in keyof T & keyof AggregateThreads_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreads_aut[P]>
      : GetScalarType<T[P], AggregateThreads_aut[P]>
  }




  export type threads_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: threads_autWhereInput
    orderBy?: threads_autOrderByWithAggregationInput | threads_autOrderByWithAggregationInput[]
    by: Threads_autScalarFieldEnum[] | Threads_autScalarFieldEnum
    having?: threads_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Threads_autCountAggregateInputType | true
    _min?: Threads_autMinAggregateInputType
    _max?: Threads_autMaxAggregateInputType
  }

  export type Threads_autGroupByOutputType = {
    id: string
    user_id: string
    thread: string
    createdAt: Date
    updatedAt: Date
    _count: Threads_autCountAggregateOutputType | null
    _min: Threads_autMinAggregateOutputType | null
    _max: Threads_autMaxAggregateOutputType | null
  }

  type GetThreads_autGroupByPayload<T extends threads_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Threads_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Threads_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Threads_autGroupByOutputType[P]>
            : GetScalarType<T[P], Threads_autGroupByOutputType[P]>
        }
      >
    >


  export type threads_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    thread?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["threads_aut"]>



  export type threads_autSelectScalar = {
    id?: boolean
    user_id?: boolean
    thread?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type threads_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "thread" | "createdAt" | "updatedAt", ExtArgs["result"]["threads_aut"]>
  export type threads_autInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }

  export type $threads_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "threads_aut"
    objects: {
      users_aut: Prisma.$users_autPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      thread: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["threads_aut"]>
    composites: {}
  }

  type threads_autGetPayload<S extends boolean | null | undefined | threads_autDefaultArgs> = $Result.GetResult<Prisma.$threads_autPayload, S>

  type threads_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<threads_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Threads_autCountAggregateInputType | true
    }

  export interface threads_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['threads_aut'], meta: { name: 'threads_aut' } }
    /**
     * Find zero or one Threads_aut that matches the filter.
     * @param {threads_autFindUniqueArgs} args - Arguments to find a Threads_aut
     * @example
     * // Get one Threads_aut
     * const threads_aut = await prisma.threads_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends threads_autFindUniqueArgs>(args: SelectSubset<T, threads_autFindUniqueArgs<ExtArgs>>): Prisma__threads_autClient<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Threads_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {threads_autFindUniqueOrThrowArgs} args - Arguments to find a Threads_aut
     * @example
     * // Get one Threads_aut
     * const threads_aut = await prisma.threads_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends threads_autFindUniqueOrThrowArgs>(args: SelectSubset<T, threads_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__threads_autClient<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Threads_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_autFindFirstArgs} args - Arguments to find a Threads_aut
     * @example
     * // Get one Threads_aut
     * const threads_aut = await prisma.threads_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends threads_autFindFirstArgs>(args?: SelectSubset<T, threads_autFindFirstArgs<ExtArgs>>): Prisma__threads_autClient<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Threads_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_autFindFirstOrThrowArgs} args - Arguments to find a Threads_aut
     * @example
     * // Get one Threads_aut
     * const threads_aut = await prisma.threads_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends threads_autFindFirstOrThrowArgs>(args?: SelectSubset<T, threads_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__threads_autClient<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Threads_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads_auts
     * const threads_auts = await prisma.threads_aut.findMany()
     * 
     * // Get first 10 Threads_auts
     * const threads_auts = await prisma.threads_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threads_autWithIdOnly = await prisma.threads_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends threads_autFindManyArgs>(args?: SelectSubset<T, threads_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Threads_aut.
     * @param {threads_autCreateArgs} args - Arguments to create a Threads_aut.
     * @example
     * // Create one Threads_aut
     * const Threads_aut = await prisma.threads_aut.create({
     *   data: {
     *     // ... data to create a Threads_aut
     *   }
     * })
     * 
     */
    create<T extends threads_autCreateArgs>(args: SelectSubset<T, threads_autCreateArgs<ExtArgs>>): Prisma__threads_autClient<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Threads_auts.
     * @param {threads_autCreateManyArgs} args - Arguments to create many Threads_auts.
     * @example
     * // Create many Threads_auts
     * const threads_aut = await prisma.threads_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends threads_autCreateManyArgs>(args?: SelectSubset<T, threads_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Threads_aut.
     * @param {threads_autDeleteArgs} args - Arguments to delete one Threads_aut.
     * @example
     * // Delete one Threads_aut
     * const Threads_aut = await prisma.threads_aut.delete({
     *   where: {
     *     // ... filter to delete one Threads_aut
     *   }
     * })
     * 
     */
    delete<T extends threads_autDeleteArgs>(args: SelectSubset<T, threads_autDeleteArgs<ExtArgs>>): Prisma__threads_autClient<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Threads_aut.
     * @param {threads_autUpdateArgs} args - Arguments to update one Threads_aut.
     * @example
     * // Update one Threads_aut
     * const threads_aut = await prisma.threads_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends threads_autUpdateArgs>(args: SelectSubset<T, threads_autUpdateArgs<ExtArgs>>): Prisma__threads_autClient<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Threads_auts.
     * @param {threads_autDeleteManyArgs} args - Arguments to filter Threads_auts to delete.
     * @example
     * // Delete a few Threads_auts
     * const { count } = await prisma.threads_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends threads_autDeleteManyArgs>(args?: SelectSubset<T, threads_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads_auts
     * const threads_aut = await prisma.threads_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends threads_autUpdateManyArgs>(args: SelectSubset<T, threads_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Threads_aut.
     * @param {threads_autUpsertArgs} args - Arguments to update or create a Threads_aut.
     * @example
     * // Update or create a Threads_aut
     * const threads_aut = await prisma.threads_aut.upsert({
     *   create: {
     *     // ... data to create a Threads_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Threads_aut we want to update
     *   }
     * })
     */
    upsert<T extends threads_autUpsertArgs>(args: SelectSubset<T, threads_autUpsertArgs<ExtArgs>>): Prisma__threads_autClient<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Threads_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_autCountArgs} args - Arguments to filter Threads_auts to count.
     * @example
     * // Count the number of Threads_auts
     * const count = await prisma.threads_aut.count({
     *   where: {
     *     // ... the filter for the Threads_auts we want to count
     *   }
     * })
    **/
    count<T extends threads_autCountArgs>(
      args?: Subset<T, threads_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Threads_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Threads_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Threads_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Threads_autAggregateArgs>(args: Subset<T, Threads_autAggregateArgs>): Prisma.PrismaPromise<GetThreads_autAggregateType<T>>

    /**
     * Group by Threads_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends threads_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: threads_autGroupByArgs['orderBy'] }
        : { orderBy?: threads_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, threads_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreads_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the threads_aut model
   */
  readonly fields: threads_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for threads_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__threads_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_aut<T extends users_autDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_autDefaultArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the threads_aut model
   */
  interface threads_autFieldRefs {
    readonly id: FieldRef<"threads_aut", 'String'>
    readonly user_id: FieldRef<"threads_aut", 'String'>
    readonly thread: FieldRef<"threads_aut", 'String'>
    readonly createdAt: FieldRef<"threads_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"threads_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * threads_aut findUnique
   */
  export type threads_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * Filter, which threads_aut to fetch.
     */
    where: threads_autWhereUniqueInput
  }

  /**
   * threads_aut findUniqueOrThrow
   */
  export type threads_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * Filter, which threads_aut to fetch.
     */
    where: threads_autWhereUniqueInput
  }

  /**
   * threads_aut findFirst
   */
  export type threads_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * Filter, which threads_aut to fetch.
     */
    where?: threads_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_auts to fetch.
     */
    orderBy?: threads_autOrderByWithRelationInput | threads_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for threads_auts.
     */
    cursor?: threads_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of threads_auts.
     */
    distinct?: Threads_autScalarFieldEnum | Threads_autScalarFieldEnum[]
  }

  /**
   * threads_aut findFirstOrThrow
   */
  export type threads_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * Filter, which threads_aut to fetch.
     */
    where?: threads_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_auts to fetch.
     */
    orderBy?: threads_autOrderByWithRelationInput | threads_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for threads_auts.
     */
    cursor?: threads_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of threads_auts.
     */
    distinct?: Threads_autScalarFieldEnum | Threads_autScalarFieldEnum[]
  }

  /**
   * threads_aut findMany
   */
  export type threads_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * Filter, which threads_auts to fetch.
     */
    where?: threads_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_auts to fetch.
     */
    orderBy?: threads_autOrderByWithRelationInput | threads_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing threads_auts.
     */
    cursor?: threads_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_auts.
     */
    skip?: number
    distinct?: Threads_autScalarFieldEnum | Threads_autScalarFieldEnum[]
  }

  /**
   * threads_aut create
   */
  export type threads_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * The data needed to create a threads_aut.
     */
    data: XOR<threads_autCreateInput, threads_autUncheckedCreateInput>
  }

  /**
   * threads_aut createMany
   */
  export type threads_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many threads_auts.
     */
    data: threads_autCreateManyInput | threads_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * threads_aut update
   */
  export type threads_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * The data needed to update a threads_aut.
     */
    data: XOR<threads_autUpdateInput, threads_autUncheckedUpdateInput>
    /**
     * Choose, which threads_aut to update.
     */
    where: threads_autWhereUniqueInput
  }

  /**
   * threads_aut updateMany
   */
  export type threads_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update threads_auts.
     */
    data: XOR<threads_autUpdateManyMutationInput, threads_autUncheckedUpdateManyInput>
    /**
     * Filter which threads_auts to update
     */
    where?: threads_autWhereInput
    /**
     * Limit how many threads_auts to update.
     */
    limit?: number
  }

  /**
   * threads_aut upsert
   */
  export type threads_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * The filter to search for the threads_aut to update in case it exists.
     */
    where: threads_autWhereUniqueInput
    /**
     * In case the threads_aut found by the `where` argument doesn't exist, create a new threads_aut with this data.
     */
    create: XOR<threads_autCreateInput, threads_autUncheckedCreateInput>
    /**
     * In case the threads_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<threads_autUpdateInput, threads_autUncheckedUpdateInput>
  }

  /**
   * threads_aut delete
   */
  export type threads_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    /**
     * Filter which threads_aut to delete.
     */
    where: threads_autWhereUniqueInput
  }

  /**
   * threads_aut deleteMany
   */
  export type threads_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which threads_auts to delete
     */
    where?: threads_autWhereInput
    /**
     * Limit how many threads_auts to delete.
     */
    limit?: number
  }

  /**
   * threads_aut without action
   */
  export type threads_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
  }


  /**
   * Model threads_clt
   */

  export type AggregateThreads_clt = {
    _count: Threads_cltCountAggregateOutputType | null
    _min: Threads_cltMinAggregateOutputType | null
    _max: Threads_cltMaxAggregateOutputType | null
  }

  export type Threads_cltMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    thread: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Threads_cltMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    thread: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Threads_cltCountAggregateOutputType = {
    id: number
    user_id: number
    thread: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Threads_cltMinAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Threads_cltMaxAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Threads_cltCountAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Threads_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which threads_clt to aggregate.
     */
    where?: threads_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_clts to fetch.
     */
    orderBy?: threads_cltOrderByWithRelationInput | threads_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: threads_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned threads_clts
    **/
    _count?: true | Threads_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Threads_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Threads_cltMaxAggregateInputType
  }

  export type GetThreads_cltAggregateType<T extends Threads_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateThreads_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreads_clt[P]>
      : GetScalarType<T[P], AggregateThreads_clt[P]>
  }




  export type threads_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: threads_cltWhereInput
    orderBy?: threads_cltOrderByWithAggregationInput | threads_cltOrderByWithAggregationInput[]
    by: Threads_cltScalarFieldEnum[] | Threads_cltScalarFieldEnum
    having?: threads_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Threads_cltCountAggregateInputType | true
    _min?: Threads_cltMinAggregateInputType
    _max?: Threads_cltMaxAggregateInputType
  }

  export type Threads_cltGroupByOutputType = {
    id: string
    user_id: string
    thread: string
    createdAt: Date
    updatedAt: Date
    _count: Threads_cltCountAggregateOutputType | null
    _min: Threads_cltMinAggregateOutputType | null
    _max: Threads_cltMaxAggregateOutputType | null
  }

  type GetThreads_cltGroupByPayload<T extends threads_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Threads_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Threads_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Threads_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Threads_cltGroupByOutputType[P]>
        }
      >
    >


  export type threads_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    thread?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["threads_clt"]>



  export type threads_cltSelectScalar = {
    id?: boolean
    user_id?: boolean
    thread?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type threads_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "thread" | "createdAt" | "updatedAt", ExtArgs["result"]["threads_clt"]>
  export type threads_cltInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }

  export type $threads_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "threads_clt"
    objects: {
      users_clt: Prisma.$users_cltPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      thread: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["threads_clt"]>
    composites: {}
  }

  type threads_cltGetPayload<S extends boolean | null | undefined | threads_cltDefaultArgs> = $Result.GetResult<Prisma.$threads_cltPayload, S>

  type threads_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<threads_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Threads_cltCountAggregateInputType | true
    }

  export interface threads_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['threads_clt'], meta: { name: 'threads_clt' } }
    /**
     * Find zero or one Threads_clt that matches the filter.
     * @param {threads_cltFindUniqueArgs} args - Arguments to find a Threads_clt
     * @example
     * // Get one Threads_clt
     * const threads_clt = await prisma.threads_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends threads_cltFindUniqueArgs>(args: SelectSubset<T, threads_cltFindUniqueArgs<ExtArgs>>): Prisma__threads_cltClient<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Threads_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {threads_cltFindUniqueOrThrowArgs} args - Arguments to find a Threads_clt
     * @example
     * // Get one Threads_clt
     * const threads_clt = await prisma.threads_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends threads_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, threads_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__threads_cltClient<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Threads_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_cltFindFirstArgs} args - Arguments to find a Threads_clt
     * @example
     * // Get one Threads_clt
     * const threads_clt = await prisma.threads_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends threads_cltFindFirstArgs>(args?: SelectSubset<T, threads_cltFindFirstArgs<ExtArgs>>): Prisma__threads_cltClient<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Threads_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_cltFindFirstOrThrowArgs} args - Arguments to find a Threads_clt
     * @example
     * // Get one Threads_clt
     * const threads_clt = await prisma.threads_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends threads_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, threads_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__threads_cltClient<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Threads_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads_clts
     * const threads_clts = await prisma.threads_clt.findMany()
     * 
     * // Get first 10 Threads_clts
     * const threads_clts = await prisma.threads_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threads_cltWithIdOnly = await prisma.threads_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends threads_cltFindManyArgs>(args?: SelectSubset<T, threads_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Threads_clt.
     * @param {threads_cltCreateArgs} args - Arguments to create a Threads_clt.
     * @example
     * // Create one Threads_clt
     * const Threads_clt = await prisma.threads_clt.create({
     *   data: {
     *     // ... data to create a Threads_clt
     *   }
     * })
     * 
     */
    create<T extends threads_cltCreateArgs>(args: SelectSubset<T, threads_cltCreateArgs<ExtArgs>>): Prisma__threads_cltClient<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Threads_clts.
     * @param {threads_cltCreateManyArgs} args - Arguments to create many Threads_clts.
     * @example
     * // Create many Threads_clts
     * const threads_clt = await prisma.threads_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends threads_cltCreateManyArgs>(args?: SelectSubset<T, threads_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Threads_clt.
     * @param {threads_cltDeleteArgs} args - Arguments to delete one Threads_clt.
     * @example
     * // Delete one Threads_clt
     * const Threads_clt = await prisma.threads_clt.delete({
     *   where: {
     *     // ... filter to delete one Threads_clt
     *   }
     * })
     * 
     */
    delete<T extends threads_cltDeleteArgs>(args: SelectSubset<T, threads_cltDeleteArgs<ExtArgs>>): Prisma__threads_cltClient<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Threads_clt.
     * @param {threads_cltUpdateArgs} args - Arguments to update one Threads_clt.
     * @example
     * // Update one Threads_clt
     * const threads_clt = await prisma.threads_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends threads_cltUpdateArgs>(args: SelectSubset<T, threads_cltUpdateArgs<ExtArgs>>): Prisma__threads_cltClient<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Threads_clts.
     * @param {threads_cltDeleteManyArgs} args - Arguments to filter Threads_clts to delete.
     * @example
     * // Delete a few Threads_clts
     * const { count } = await prisma.threads_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends threads_cltDeleteManyArgs>(args?: SelectSubset<T, threads_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads_clts
     * const threads_clt = await prisma.threads_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends threads_cltUpdateManyArgs>(args: SelectSubset<T, threads_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Threads_clt.
     * @param {threads_cltUpsertArgs} args - Arguments to update or create a Threads_clt.
     * @example
     * // Update or create a Threads_clt
     * const threads_clt = await prisma.threads_clt.upsert({
     *   create: {
     *     // ... data to create a Threads_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Threads_clt we want to update
     *   }
     * })
     */
    upsert<T extends threads_cltUpsertArgs>(args: SelectSubset<T, threads_cltUpsertArgs<ExtArgs>>): Prisma__threads_cltClient<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Threads_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_cltCountArgs} args - Arguments to filter Threads_clts to count.
     * @example
     * // Count the number of Threads_clts
     * const count = await prisma.threads_clt.count({
     *   where: {
     *     // ... the filter for the Threads_clts we want to count
     *   }
     * })
    **/
    count<T extends threads_cltCountArgs>(
      args?: Subset<T, threads_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Threads_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Threads_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Threads_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Threads_cltAggregateArgs>(args: Subset<T, Threads_cltAggregateArgs>): Prisma.PrismaPromise<GetThreads_cltAggregateType<T>>

    /**
     * Group by Threads_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends threads_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: threads_cltGroupByArgs['orderBy'] }
        : { orderBy?: threads_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, threads_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreads_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the threads_clt model
   */
  readonly fields: threads_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for threads_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__threads_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_clt<T extends users_cltDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_cltDefaultArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the threads_clt model
   */
  interface threads_cltFieldRefs {
    readonly id: FieldRef<"threads_clt", 'String'>
    readonly user_id: FieldRef<"threads_clt", 'String'>
    readonly thread: FieldRef<"threads_clt", 'String'>
    readonly createdAt: FieldRef<"threads_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"threads_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * threads_clt findUnique
   */
  export type threads_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * Filter, which threads_clt to fetch.
     */
    where: threads_cltWhereUniqueInput
  }

  /**
   * threads_clt findUniqueOrThrow
   */
  export type threads_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * Filter, which threads_clt to fetch.
     */
    where: threads_cltWhereUniqueInput
  }

  /**
   * threads_clt findFirst
   */
  export type threads_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * Filter, which threads_clt to fetch.
     */
    where?: threads_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_clts to fetch.
     */
    orderBy?: threads_cltOrderByWithRelationInput | threads_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for threads_clts.
     */
    cursor?: threads_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of threads_clts.
     */
    distinct?: Threads_cltScalarFieldEnum | Threads_cltScalarFieldEnum[]
  }

  /**
   * threads_clt findFirstOrThrow
   */
  export type threads_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * Filter, which threads_clt to fetch.
     */
    where?: threads_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_clts to fetch.
     */
    orderBy?: threads_cltOrderByWithRelationInput | threads_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for threads_clts.
     */
    cursor?: threads_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of threads_clts.
     */
    distinct?: Threads_cltScalarFieldEnum | Threads_cltScalarFieldEnum[]
  }

  /**
   * threads_clt findMany
   */
  export type threads_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * Filter, which threads_clts to fetch.
     */
    where?: threads_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_clts to fetch.
     */
    orderBy?: threads_cltOrderByWithRelationInput | threads_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing threads_clts.
     */
    cursor?: threads_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_clts.
     */
    skip?: number
    distinct?: Threads_cltScalarFieldEnum | Threads_cltScalarFieldEnum[]
  }

  /**
   * threads_clt create
   */
  export type threads_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * The data needed to create a threads_clt.
     */
    data: XOR<threads_cltCreateInput, threads_cltUncheckedCreateInput>
  }

  /**
   * threads_clt createMany
   */
  export type threads_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many threads_clts.
     */
    data: threads_cltCreateManyInput | threads_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * threads_clt update
   */
  export type threads_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * The data needed to update a threads_clt.
     */
    data: XOR<threads_cltUpdateInput, threads_cltUncheckedUpdateInput>
    /**
     * Choose, which threads_clt to update.
     */
    where: threads_cltWhereUniqueInput
  }

  /**
   * threads_clt updateMany
   */
  export type threads_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update threads_clts.
     */
    data: XOR<threads_cltUpdateManyMutationInput, threads_cltUncheckedUpdateManyInput>
    /**
     * Filter which threads_clts to update
     */
    where?: threads_cltWhereInput
    /**
     * Limit how many threads_clts to update.
     */
    limit?: number
  }

  /**
   * threads_clt upsert
   */
  export type threads_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * The filter to search for the threads_clt to update in case it exists.
     */
    where: threads_cltWhereUniqueInput
    /**
     * In case the threads_clt found by the `where` argument doesn't exist, create a new threads_clt with this data.
     */
    create: XOR<threads_cltCreateInput, threads_cltUncheckedCreateInput>
    /**
     * In case the threads_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<threads_cltUpdateInput, threads_cltUncheckedUpdateInput>
  }

  /**
   * threads_clt delete
   */
  export type threads_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    /**
     * Filter which threads_clt to delete.
     */
    where: threads_cltWhereUniqueInput
  }

  /**
   * threads_clt deleteMany
   */
  export type threads_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which threads_clts to delete
     */
    where?: threads_cltWhereInput
    /**
     * Limit how many threads_clts to delete.
     */
    limit?: number
  }

  /**
   * threads_clt without action
   */
  export type threads_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
  }


  /**
   * Model threads_goi
   */

  export type AggregateThreads_goi = {
    _count: Threads_goiCountAggregateOutputType | null
    _min: Threads_goiMinAggregateOutputType | null
    _max: Threads_goiMaxAggregateOutputType | null
  }

  export type Threads_goiMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    thread: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Threads_goiMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    thread: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Threads_goiCountAggregateOutputType = {
    id: number
    user_id: number
    thread: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Threads_goiMinAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Threads_goiMaxAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Threads_goiCountAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Threads_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which threads_goi to aggregate.
     */
    where?: threads_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_gois to fetch.
     */
    orderBy?: threads_goiOrderByWithRelationInput | threads_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: threads_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned threads_gois
    **/
    _count?: true | Threads_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Threads_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Threads_goiMaxAggregateInputType
  }

  export type GetThreads_goiAggregateType<T extends Threads_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateThreads_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreads_goi[P]>
      : GetScalarType<T[P], AggregateThreads_goi[P]>
  }




  export type threads_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: threads_goiWhereInput
    orderBy?: threads_goiOrderByWithAggregationInput | threads_goiOrderByWithAggregationInput[]
    by: Threads_goiScalarFieldEnum[] | Threads_goiScalarFieldEnum
    having?: threads_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Threads_goiCountAggregateInputType | true
    _min?: Threads_goiMinAggregateInputType
    _max?: Threads_goiMaxAggregateInputType
  }

  export type Threads_goiGroupByOutputType = {
    id: string
    user_id: string
    thread: string
    createdAt: Date
    updatedAt: Date
    _count: Threads_goiCountAggregateOutputType | null
    _min: Threads_goiMinAggregateOutputType | null
    _max: Threads_goiMaxAggregateOutputType | null
  }

  type GetThreads_goiGroupByPayload<T extends threads_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Threads_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Threads_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Threads_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Threads_goiGroupByOutputType[P]>
        }
      >
    >


  export type threads_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    thread?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["threads_goi"]>



  export type threads_goiSelectScalar = {
    id?: boolean
    user_id?: boolean
    thread?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type threads_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "thread" | "createdAt" | "updatedAt", ExtArgs["result"]["threads_goi"]>
  export type threads_goiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }

  export type $threads_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "threads_goi"
    objects: {
      users_goi: Prisma.$users_goiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      thread: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["threads_goi"]>
    composites: {}
  }

  type threads_goiGetPayload<S extends boolean | null | undefined | threads_goiDefaultArgs> = $Result.GetResult<Prisma.$threads_goiPayload, S>

  type threads_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<threads_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Threads_goiCountAggregateInputType | true
    }

  export interface threads_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['threads_goi'], meta: { name: 'threads_goi' } }
    /**
     * Find zero or one Threads_goi that matches the filter.
     * @param {threads_goiFindUniqueArgs} args - Arguments to find a Threads_goi
     * @example
     * // Get one Threads_goi
     * const threads_goi = await prisma.threads_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends threads_goiFindUniqueArgs>(args: SelectSubset<T, threads_goiFindUniqueArgs<ExtArgs>>): Prisma__threads_goiClient<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Threads_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {threads_goiFindUniqueOrThrowArgs} args - Arguments to find a Threads_goi
     * @example
     * // Get one Threads_goi
     * const threads_goi = await prisma.threads_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends threads_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, threads_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__threads_goiClient<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Threads_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_goiFindFirstArgs} args - Arguments to find a Threads_goi
     * @example
     * // Get one Threads_goi
     * const threads_goi = await prisma.threads_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends threads_goiFindFirstArgs>(args?: SelectSubset<T, threads_goiFindFirstArgs<ExtArgs>>): Prisma__threads_goiClient<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Threads_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_goiFindFirstOrThrowArgs} args - Arguments to find a Threads_goi
     * @example
     * // Get one Threads_goi
     * const threads_goi = await prisma.threads_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends threads_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, threads_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__threads_goiClient<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Threads_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads_gois
     * const threads_gois = await prisma.threads_goi.findMany()
     * 
     * // Get first 10 Threads_gois
     * const threads_gois = await prisma.threads_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threads_goiWithIdOnly = await prisma.threads_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends threads_goiFindManyArgs>(args?: SelectSubset<T, threads_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Threads_goi.
     * @param {threads_goiCreateArgs} args - Arguments to create a Threads_goi.
     * @example
     * // Create one Threads_goi
     * const Threads_goi = await prisma.threads_goi.create({
     *   data: {
     *     // ... data to create a Threads_goi
     *   }
     * })
     * 
     */
    create<T extends threads_goiCreateArgs>(args: SelectSubset<T, threads_goiCreateArgs<ExtArgs>>): Prisma__threads_goiClient<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Threads_gois.
     * @param {threads_goiCreateManyArgs} args - Arguments to create many Threads_gois.
     * @example
     * // Create many Threads_gois
     * const threads_goi = await prisma.threads_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends threads_goiCreateManyArgs>(args?: SelectSubset<T, threads_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Threads_goi.
     * @param {threads_goiDeleteArgs} args - Arguments to delete one Threads_goi.
     * @example
     * // Delete one Threads_goi
     * const Threads_goi = await prisma.threads_goi.delete({
     *   where: {
     *     // ... filter to delete one Threads_goi
     *   }
     * })
     * 
     */
    delete<T extends threads_goiDeleteArgs>(args: SelectSubset<T, threads_goiDeleteArgs<ExtArgs>>): Prisma__threads_goiClient<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Threads_goi.
     * @param {threads_goiUpdateArgs} args - Arguments to update one Threads_goi.
     * @example
     * // Update one Threads_goi
     * const threads_goi = await prisma.threads_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends threads_goiUpdateArgs>(args: SelectSubset<T, threads_goiUpdateArgs<ExtArgs>>): Prisma__threads_goiClient<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Threads_gois.
     * @param {threads_goiDeleteManyArgs} args - Arguments to filter Threads_gois to delete.
     * @example
     * // Delete a few Threads_gois
     * const { count } = await prisma.threads_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends threads_goiDeleteManyArgs>(args?: SelectSubset<T, threads_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads_gois
     * const threads_goi = await prisma.threads_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends threads_goiUpdateManyArgs>(args: SelectSubset<T, threads_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Threads_goi.
     * @param {threads_goiUpsertArgs} args - Arguments to update or create a Threads_goi.
     * @example
     * // Update or create a Threads_goi
     * const threads_goi = await prisma.threads_goi.upsert({
     *   create: {
     *     // ... data to create a Threads_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Threads_goi we want to update
     *   }
     * })
     */
    upsert<T extends threads_goiUpsertArgs>(args: SelectSubset<T, threads_goiUpsertArgs<ExtArgs>>): Prisma__threads_goiClient<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Threads_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_goiCountArgs} args - Arguments to filter Threads_gois to count.
     * @example
     * // Count the number of Threads_gois
     * const count = await prisma.threads_goi.count({
     *   where: {
     *     // ... the filter for the Threads_gois we want to count
     *   }
     * })
    **/
    count<T extends threads_goiCountArgs>(
      args?: Subset<T, threads_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Threads_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Threads_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Threads_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Threads_goiAggregateArgs>(args: Subset<T, Threads_goiAggregateArgs>): Prisma.PrismaPromise<GetThreads_goiAggregateType<T>>

    /**
     * Group by Threads_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends threads_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: threads_goiGroupByArgs['orderBy'] }
        : { orderBy?: threads_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, threads_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreads_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the threads_goi model
   */
  readonly fields: threads_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for threads_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__threads_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_goi<T extends users_goiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_goiDefaultArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the threads_goi model
   */
  interface threads_goiFieldRefs {
    readonly id: FieldRef<"threads_goi", 'String'>
    readonly user_id: FieldRef<"threads_goi", 'String'>
    readonly thread: FieldRef<"threads_goi", 'String'>
    readonly createdAt: FieldRef<"threads_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"threads_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * threads_goi findUnique
   */
  export type threads_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * Filter, which threads_goi to fetch.
     */
    where: threads_goiWhereUniqueInput
  }

  /**
   * threads_goi findUniqueOrThrow
   */
  export type threads_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * Filter, which threads_goi to fetch.
     */
    where: threads_goiWhereUniqueInput
  }

  /**
   * threads_goi findFirst
   */
  export type threads_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * Filter, which threads_goi to fetch.
     */
    where?: threads_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_gois to fetch.
     */
    orderBy?: threads_goiOrderByWithRelationInput | threads_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for threads_gois.
     */
    cursor?: threads_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of threads_gois.
     */
    distinct?: Threads_goiScalarFieldEnum | Threads_goiScalarFieldEnum[]
  }

  /**
   * threads_goi findFirstOrThrow
   */
  export type threads_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * Filter, which threads_goi to fetch.
     */
    where?: threads_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_gois to fetch.
     */
    orderBy?: threads_goiOrderByWithRelationInput | threads_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for threads_gois.
     */
    cursor?: threads_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of threads_gois.
     */
    distinct?: Threads_goiScalarFieldEnum | Threads_goiScalarFieldEnum[]
  }

  /**
   * threads_goi findMany
   */
  export type threads_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * Filter, which threads_gois to fetch.
     */
    where?: threads_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_gois to fetch.
     */
    orderBy?: threads_goiOrderByWithRelationInput | threads_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing threads_gois.
     */
    cursor?: threads_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_gois.
     */
    skip?: number
    distinct?: Threads_goiScalarFieldEnum | Threads_goiScalarFieldEnum[]
  }

  /**
   * threads_goi create
   */
  export type threads_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * The data needed to create a threads_goi.
     */
    data: XOR<threads_goiCreateInput, threads_goiUncheckedCreateInput>
  }

  /**
   * threads_goi createMany
   */
  export type threads_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many threads_gois.
     */
    data: threads_goiCreateManyInput | threads_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * threads_goi update
   */
  export type threads_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * The data needed to update a threads_goi.
     */
    data: XOR<threads_goiUpdateInput, threads_goiUncheckedUpdateInput>
    /**
     * Choose, which threads_goi to update.
     */
    where: threads_goiWhereUniqueInput
  }

  /**
   * threads_goi updateMany
   */
  export type threads_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update threads_gois.
     */
    data: XOR<threads_goiUpdateManyMutationInput, threads_goiUncheckedUpdateManyInput>
    /**
     * Filter which threads_gois to update
     */
    where?: threads_goiWhereInput
    /**
     * Limit how many threads_gois to update.
     */
    limit?: number
  }

  /**
   * threads_goi upsert
   */
  export type threads_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * The filter to search for the threads_goi to update in case it exists.
     */
    where: threads_goiWhereUniqueInput
    /**
     * In case the threads_goi found by the `where` argument doesn't exist, create a new threads_goi with this data.
     */
    create: XOR<threads_goiCreateInput, threads_goiUncheckedCreateInput>
    /**
     * In case the threads_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<threads_goiUpdateInput, threads_goiUncheckedUpdateInput>
  }

  /**
   * threads_goi delete
   */
  export type threads_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    /**
     * Filter which threads_goi to delete.
     */
    where: threads_goiWhereUniqueInput
  }

  /**
   * threads_goi deleteMany
   */
  export type threads_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which threads_gois to delete
     */
    where?: threads_goiWhereInput
    /**
     * Limit how many threads_gois to delete.
     */
    limit?: number
  }

  /**
   * threads_goi without action
   */
  export type threads_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
  }


  /**
   * Model threads_spa
   */

  export type AggregateThreads_spa = {
    _count: Threads_spaCountAggregateOutputType | null
    _min: Threads_spaMinAggregateOutputType | null
    _max: Threads_spaMaxAggregateOutputType | null
  }

  export type Threads_spaMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    thread: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Threads_spaMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    thread: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Threads_spaCountAggregateOutputType = {
    id: number
    user_id: number
    thread: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Threads_spaMinAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Threads_spaMaxAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Threads_spaCountAggregateInputType = {
    id?: true
    user_id?: true
    thread?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Threads_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which threads_spa to aggregate.
     */
    where?: threads_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_spas to fetch.
     */
    orderBy?: threads_spaOrderByWithRelationInput | threads_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: threads_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned threads_spas
    **/
    _count?: true | Threads_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Threads_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Threads_spaMaxAggregateInputType
  }

  export type GetThreads_spaAggregateType<T extends Threads_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateThreads_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreads_spa[P]>
      : GetScalarType<T[P], AggregateThreads_spa[P]>
  }




  export type threads_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: threads_spaWhereInput
    orderBy?: threads_spaOrderByWithAggregationInput | threads_spaOrderByWithAggregationInput[]
    by: Threads_spaScalarFieldEnum[] | Threads_spaScalarFieldEnum
    having?: threads_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Threads_spaCountAggregateInputType | true
    _min?: Threads_spaMinAggregateInputType
    _max?: Threads_spaMaxAggregateInputType
  }

  export type Threads_spaGroupByOutputType = {
    id: string
    user_id: string
    thread: string
    createdAt: Date
    updatedAt: Date
    _count: Threads_spaCountAggregateOutputType | null
    _min: Threads_spaMinAggregateOutputType | null
    _max: Threads_spaMaxAggregateOutputType | null
  }

  type GetThreads_spaGroupByPayload<T extends threads_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Threads_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Threads_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Threads_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Threads_spaGroupByOutputType[P]>
        }
      >
    >


  export type threads_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    thread?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["threads_spa"]>



  export type threads_spaSelectScalar = {
    id?: boolean
    user_id?: boolean
    thread?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type threads_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "thread" | "createdAt" | "updatedAt", ExtArgs["result"]["threads_spa"]>
  export type threads_spaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }

  export type $threads_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "threads_spa"
    objects: {
      users_spa: Prisma.$users_spaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      thread: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["threads_spa"]>
    composites: {}
  }

  type threads_spaGetPayload<S extends boolean | null | undefined | threads_spaDefaultArgs> = $Result.GetResult<Prisma.$threads_spaPayload, S>

  type threads_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<threads_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Threads_spaCountAggregateInputType | true
    }

  export interface threads_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['threads_spa'], meta: { name: 'threads_spa' } }
    /**
     * Find zero or one Threads_spa that matches the filter.
     * @param {threads_spaFindUniqueArgs} args - Arguments to find a Threads_spa
     * @example
     * // Get one Threads_spa
     * const threads_spa = await prisma.threads_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends threads_spaFindUniqueArgs>(args: SelectSubset<T, threads_spaFindUniqueArgs<ExtArgs>>): Prisma__threads_spaClient<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Threads_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {threads_spaFindUniqueOrThrowArgs} args - Arguments to find a Threads_spa
     * @example
     * // Get one Threads_spa
     * const threads_spa = await prisma.threads_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends threads_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, threads_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__threads_spaClient<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Threads_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_spaFindFirstArgs} args - Arguments to find a Threads_spa
     * @example
     * // Get one Threads_spa
     * const threads_spa = await prisma.threads_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends threads_spaFindFirstArgs>(args?: SelectSubset<T, threads_spaFindFirstArgs<ExtArgs>>): Prisma__threads_spaClient<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Threads_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_spaFindFirstOrThrowArgs} args - Arguments to find a Threads_spa
     * @example
     * // Get one Threads_spa
     * const threads_spa = await prisma.threads_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends threads_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, threads_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__threads_spaClient<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Threads_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads_spas
     * const threads_spas = await prisma.threads_spa.findMany()
     * 
     * // Get first 10 Threads_spas
     * const threads_spas = await prisma.threads_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threads_spaWithIdOnly = await prisma.threads_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends threads_spaFindManyArgs>(args?: SelectSubset<T, threads_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Threads_spa.
     * @param {threads_spaCreateArgs} args - Arguments to create a Threads_spa.
     * @example
     * // Create one Threads_spa
     * const Threads_spa = await prisma.threads_spa.create({
     *   data: {
     *     // ... data to create a Threads_spa
     *   }
     * })
     * 
     */
    create<T extends threads_spaCreateArgs>(args: SelectSubset<T, threads_spaCreateArgs<ExtArgs>>): Prisma__threads_spaClient<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Threads_spas.
     * @param {threads_spaCreateManyArgs} args - Arguments to create many Threads_spas.
     * @example
     * // Create many Threads_spas
     * const threads_spa = await prisma.threads_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends threads_spaCreateManyArgs>(args?: SelectSubset<T, threads_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Threads_spa.
     * @param {threads_spaDeleteArgs} args - Arguments to delete one Threads_spa.
     * @example
     * // Delete one Threads_spa
     * const Threads_spa = await prisma.threads_spa.delete({
     *   where: {
     *     // ... filter to delete one Threads_spa
     *   }
     * })
     * 
     */
    delete<T extends threads_spaDeleteArgs>(args: SelectSubset<T, threads_spaDeleteArgs<ExtArgs>>): Prisma__threads_spaClient<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Threads_spa.
     * @param {threads_spaUpdateArgs} args - Arguments to update one Threads_spa.
     * @example
     * // Update one Threads_spa
     * const threads_spa = await prisma.threads_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends threads_spaUpdateArgs>(args: SelectSubset<T, threads_spaUpdateArgs<ExtArgs>>): Prisma__threads_spaClient<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Threads_spas.
     * @param {threads_spaDeleteManyArgs} args - Arguments to filter Threads_spas to delete.
     * @example
     * // Delete a few Threads_spas
     * const { count } = await prisma.threads_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends threads_spaDeleteManyArgs>(args?: SelectSubset<T, threads_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads_spas
     * const threads_spa = await prisma.threads_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends threads_spaUpdateManyArgs>(args: SelectSubset<T, threads_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Threads_spa.
     * @param {threads_spaUpsertArgs} args - Arguments to update or create a Threads_spa.
     * @example
     * // Update or create a Threads_spa
     * const threads_spa = await prisma.threads_spa.upsert({
     *   create: {
     *     // ... data to create a Threads_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Threads_spa we want to update
     *   }
     * })
     */
    upsert<T extends threads_spaUpsertArgs>(args: SelectSubset<T, threads_spaUpsertArgs<ExtArgs>>): Prisma__threads_spaClient<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Threads_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_spaCountArgs} args - Arguments to filter Threads_spas to count.
     * @example
     * // Count the number of Threads_spas
     * const count = await prisma.threads_spa.count({
     *   where: {
     *     // ... the filter for the Threads_spas we want to count
     *   }
     * })
    **/
    count<T extends threads_spaCountArgs>(
      args?: Subset<T, threads_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Threads_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Threads_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Threads_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Threads_spaAggregateArgs>(args: Subset<T, Threads_spaAggregateArgs>): Prisma.PrismaPromise<GetThreads_spaAggregateType<T>>

    /**
     * Group by Threads_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {threads_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends threads_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: threads_spaGroupByArgs['orderBy'] }
        : { orderBy?: threads_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, threads_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreads_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the threads_spa model
   */
  readonly fields: threads_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for threads_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__threads_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_spa<T extends users_spaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_spaDefaultArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the threads_spa model
   */
  interface threads_spaFieldRefs {
    readonly id: FieldRef<"threads_spa", 'String'>
    readonly user_id: FieldRef<"threads_spa", 'String'>
    readonly thread: FieldRef<"threads_spa", 'String'>
    readonly createdAt: FieldRef<"threads_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"threads_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * threads_spa findUnique
   */
  export type threads_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * Filter, which threads_spa to fetch.
     */
    where: threads_spaWhereUniqueInput
  }

  /**
   * threads_spa findUniqueOrThrow
   */
  export type threads_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * Filter, which threads_spa to fetch.
     */
    where: threads_spaWhereUniqueInput
  }

  /**
   * threads_spa findFirst
   */
  export type threads_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * Filter, which threads_spa to fetch.
     */
    where?: threads_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_spas to fetch.
     */
    orderBy?: threads_spaOrderByWithRelationInput | threads_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for threads_spas.
     */
    cursor?: threads_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of threads_spas.
     */
    distinct?: Threads_spaScalarFieldEnum | Threads_spaScalarFieldEnum[]
  }

  /**
   * threads_spa findFirstOrThrow
   */
  export type threads_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * Filter, which threads_spa to fetch.
     */
    where?: threads_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_spas to fetch.
     */
    orderBy?: threads_spaOrderByWithRelationInput | threads_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for threads_spas.
     */
    cursor?: threads_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of threads_spas.
     */
    distinct?: Threads_spaScalarFieldEnum | Threads_spaScalarFieldEnum[]
  }

  /**
   * threads_spa findMany
   */
  export type threads_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * Filter, which threads_spas to fetch.
     */
    where?: threads_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of threads_spas to fetch.
     */
    orderBy?: threads_spaOrderByWithRelationInput | threads_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing threads_spas.
     */
    cursor?: threads_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` threads_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` threads_spas.
     */
    skip?: number
    distinct?: Threads_spaScalarFieldEnum | Threads_spaScalarFieldEnum[]
  }

  /**
   * threads_spa create
   */
  export type threads_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * The data needed to create a threads_spa.
     */
    data: XOR<threads_spaCreateInput, threads_spaUncheckedCreateInput>
  }

  /**
   * threads_spa createMany
   */
  export type threads_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many threads_spas.
     */
    data: threads_spaCreateManyInput | threads_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * threads_spa update
   */
  export type threads_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * The data needed to update a threads_spa.
     */
    data: XOR<threads_spaUpdateInput, threads_spaUncheckedUpdateInput>
    /**
     * Choose, which threads_spa to update.
     */
    where: threads_spaWhereUniqueInput
  }

  /**
   * threads_spa updateMany
   */
  export type threads_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update threads_spas.
     */
    data: XOR<threads_spaUpdateManyMutationInput, threads_spaUncheckedUpdateManyInput>
    /**
     * Filter which threads_spas to update
     */
    where?: threads_spaWhereInput
    /**
     * Limit how many threads_spas to update.
     */
    limit?: number
  }

  /**
   * threads_spa upsert
   */
  export type threads_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * The filter to search for the threads_spa to update in case it exists.
     */
    where: threads_spaWhereUniqueInput
    /**
     * In case the threads_spa found by the `where` argument doesn't exist, create a new threads_spa with this data.
     */
    create: XOR<threads_spaCreateInput, threads_spaUncheckedCreateInput>
    /**
     * In case the threads_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<threads_spaUpdateInput, threads_spaUncheckedUpdateInput>
  }

  /**
   * threads_spa delete
   */
  export type threads_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    /**
     * Filter which threads_spa to delete.
     */
    where: threads_spaWhereUniqueInput
  }

  /**
   * threads_spa deleteMany
   */
  export type threads_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which threads_spas to delete
     */
    where?: threads_spaWhereInput
    /**
     * Limit how many threads_spas to delete.
     */
    limit?: number
  }

  /**
   * threads_spa without action
   */
  export type threads_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
  }


  /**
   * Model tokens_generated_aut
   */

  export type AggregateTokens_generated_aut = {
    _count: Tokens_generated_autCountAggregateOutputType | null
    _min: Tokens_generated_autMinAggregateOutputType | null
    _max: Tokens_generated_autMaxAggregateOutputType | null
  }

  export type Tokens_generated_autMinAggregateOutputType = {
    id: string | null
    create_token_id: string | null
    user_id: string | null
    is_expired: boolean | null
    is_error: boolean | null
    is_confirmed: boolean | null
    is_closed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tokens_generated_autMaxAggregateOutputType = {
    id: string | null
    create_token_id: string | null
    user_id: string | null
    is_expired: boolean | null
    is_error: boolean | null
    is_confirmed: boolean | null
    is_closed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tokens_generated_autCountAggregateOutputType = {
    id: number
    create_token_id: number
    user_id: number
    is_expired: number
    is_error: number
    is_confirmed: number
    is_closed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tokens_generated_autMinAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tokens_generated_autMaxAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tokens_generated_autCountAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tokens_generated_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens_generated_aut to aggregate.
     */
    where?: tokens_generated_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_auts to fetch.
     */
    orderBy?: tokens_generated_autOrderByWithRelationInput | tokens_generated_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokens_generated_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokens_generated_auts
    **/
    _count?: true | Tokens_generated_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tokens_generated_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tokens_generated_autMaxAggregateInputType
  }

  export type GetTokens_generated_autAggregateType<T extends Tokens_generated_autAggregateArgs> = {
        [P in keyof T & keyof AggregateTokens_generated_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokens_generated_aut[P]>
      : GetScalarType<T[P], AggregateTokens_generated_aut[P]>
  }




  export type tokens_generated_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokens_generated_autWhereInput
    orderBy?: tokens_generated_autOrderByWithAggregationInput | tokens_generated_autOrderByWithAggregationInput[]
    by: Tokens_generated_autScalarFieldEnum[] | Tokens_generated_autScalarFieldEnum
    having?: tokens_generated_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tokens_generated_autCountAggregateInputType | true
    _min?: Tokens_generated_autMinAggregateInputType
    _max?: Tokens_generated_autMaxAggregateInputType
  }

  export type Tokens_generated_autGroupByOutputType = {
    id: string
    create_token_id: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date
    updatedAt: Date
    _count: Tokens_generated_autCountAggregateOutputType | null
    _min: Tokens_generated_autMinAggregateOutputType | null
    _max: Tokens_generated_autMaxAggregateOutputType | null
  }

  type GetTokens_generated_autGroupByPayload<T extends tokens_generated_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tokens_generated_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tokens_generated_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tokens_generated_autGroupByOutputType[P]>
            : GetScalarType<T[P], Tokens_generated_autGroupByOutputType[P]>
        }
      >
    >


  export type tokens_generated_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    create_token_id?: boolean
    user_id?: boolean
    is_expired?: boolean
    is_error?: boolean
    is_confirmed?: boolean
    is_closed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokens_generated_aut"]>



  export type tokens_generated_autSelectScalar = {
    id?: boolean
    create_token_id?: boolean
    user_id?: boolean
    is_expired?: boolean
    is_error?: boolean
    is_confirmed?: boolean
    is_closed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tokens_generated_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "create_token_id" | "user_id" | "is_expired" | "is_error" | "is_confirmed" | "is_closed" | "createdAt" | "updatedAt", ExtArgs["result"]["tokens_generated_aut"]>
  export type tokens_generated_autInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }

  export type $tokens_generated_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tokens_generated_aut"
    objects: {
      users_aut: Prisma.$users_autPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      create_token_id: string | null
      user_id: string
      is_expired: boolean
      is_error: boolean
      is_confirmed: boolean
      is_closed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tokens_generated_aut"]>
    composites: {}
  }

  type tokens_generated_autGetPayload<S extends boolean | null | undefined | tokens_generated_autDefaultArgs> = $Result.GetResult<Prisma.$tokens_generated_autPayload, S>

  type tokens_generated_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tokens_generated_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tokens_generated_autCountAggregateInputType | true
    }

  export interface tokens_generated_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tokens_generated_aut'], meta: { name: 'tokens_generated_aut' } }
    /**
     * Find zero or one Tokens_generated_aut that matches the filter.
     * @param {tokens_generated_autFindUniqueArgs} args - Arguments to find a Tokens_generated_aut
     * @example
     * // Get one Tokens_generated_aut
     * const tokens_generated_aut = await prisma.tokens_generated_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tokens_generated_autFindUniqueArgs>(args: SelectSubset<T, tokens_generated_autFindUniqueArgs<ExtArgs>>): Prisma__tokens_generated_autClient<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tokens_generated_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tokens_generated_autFindUniqueOrThrowArgs} args - Arguments to find a Tokens_generated_aut
     * @example
     * // Get one Tokens_generated_aut
     * const tokens_generated_aut = await prisma.tokens_generated_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tokens_generated_autFindUniqueOrThrowArgs>(args: SelectSubset<T, tokens_generated_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tokens_generated_autClient<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens_generated_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_autFindFirstArgs} args - Arguments to find a Tokens_generated_aut
     * @example
     * // Get one Tokens_generated_aut
     * const tokens_generated_aut = await prisma.tokens_generated_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tokens_generated_autFindFirstArgs>(args?: SelectSubset<T, tokens_generated_autFindFirstArgs<ExtArgs>>): Prisma__tokens_generated_autClient<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens_generated_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_autFindFirstOrThrowArgs} args - Arguments to find a Tokens_generated_aut
     * @example
     * // Get one Tokens_generated_aut
     * const tokens_generated_aut = await prisma.tokens_generated_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tokens_generated_autFindFirstOrThrowArgs>(args?: SelectSubset<T, tokens_generated_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__tokens_generated_autClient<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens_generated_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens_generated_auts
     * const tokens_generated_auts = await prisma.tokens_generated_aut.findMany()
     * 
     * // Get first 10 Tokens_generated_auts
     * const tokens_generated_auts = await prisma.tokens_generated_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokens_generated_autWithIdOnly = await prisma.tokens_generated_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tokens_generated_autFindManyArgs>(args?: SelectSubset<T, tokens_generated_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tokens_generated_aut.
     * @param {tokens_generated_autCreateArgs} args - Arguments to create a Tokens_generated_aut.
     * @example
     * // Create one Tokens_generated_aut
     * const Tokens_generated_aut = await prisma.tokens_generated_aut.create({
     *   data: {
     *     // ... data to create a Tokens_generated_aut
     *   }
     * })
     * 
     */
    create<T extends tokens_generated_autCreateArgs>(args: SelectSubset<T, tokens_generated_autCreateArgs<ExtArgs>>): Prisma__tokens_generated_autClient<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens_generated_auts.
     * @param {tokens_generated_autCreateManyArgs} args - Arguments to create many Tokens_generated_auts.
     * @example
     * // Create many Tokens_generated_auts
     * const tokens_generated_aut = await prisma.tokens_generated_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tokens_generated_autCreateManyArgs>(args?: SelectSubset<T, tokens_generated_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tokens_generated_aut.
     * @param {tokens_generated_autDeleteArgs} args - Arguments to delete one Tokens_generated_aut.
     * @example
     * // Delete one Tokens_generated_aut
     * const Tokens_generated_aut = await prisma.tokens_generated_aut.delete({
     *   where: {
     *     // ... filter to delete one Tokens_generated_aut
     *   }
     * })
     * 
     */
    delete<T extends tokens_generated_autDeleteArgs>(args: SelectSubset<T, tokens_generated_autDeleteArgs<ExtArgs>>): Prisma__tokens_generated_autClient<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tokens_generated_aut.
     * @param {tokens_generated_autUpdateArgs} args - Arguments to update one Tokens_generated_aut.
     * @example
     * // Update one Tokens_generated_aut
     * const tokens_generated_aut = await prisma.tokens_generated_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tokens_generated_autUpdateArgs>(args: SelectSubset<T, tokens_generated_autUpdateArgs<ExtArgs>>): Prisma__tokens_generated_autClient<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens_generated_auts.
     * @param {tokens_generated_autDeleteManyArgs} args - Arguments to filter Tokens_generated_auts to delete.
     * @example
     * // Delete a few Tokens_generated_auts
     * const { count } = await prisma.tokens_generated_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tokens_generated_autDeleteManyArgs>(args?: SelectSubset<T, tokens_generated_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens_generated_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens_generated_auts
     * const tokens_generated_aut = await prisma.tokens_generated_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tokens_generated_autUpdateManyArgs>(args: SelectSubset<T, tokens_generated_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tokens_generated_aut.
     * @param {tokens_generated_autUpsertArgs} args - Arguments to update or create a Tokens_generated_aut.
     * @example
     * // Update or create a Tokens_generated_aut
     * const tokens_generated_aut = await prisma.tokens_generated_aut.upsert({
     *   create: {
     *     // ... data to create a Tokens_generated_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tokens_generated_aut we want to update
     *   }
     * })
     */
    upsert<T extends tokens_generated_autUpsertArgs>(args: SelectSubset<T, tokens_generated_autUpsertArgs<ExtArgs>>): Prisma__tokens_generated_autClient<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens_generated_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_autCountArgs} args - Arguments to filter Tokens_generated_auts to count.
     * @example
     * // Count the number of Tokens_generated_auts
     * const count = await prisma.tokens_generated_aut.count({
     *   where: {
     *     // ... the filter for the Tokens_generated_auts we want to count
     *   }
     * })
    **/
    count<T extends tokens_generated_autCountArgs>(
      args?: Subset<T, tokens_generated_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tokens_generated_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tokens_generated_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tokens_generated_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tokens_generated_autAggregateArgs>(args: Subset<T, Tokens_generated_autAggregateArgs>): Prisma.PrismaPromise<GetTokens_generated_autAggregateType<T>>

    /**
     * Group by Tokens_generated_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tokens_generated_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tokens_generated_autGroupByArgs['orderBy'] }
        : { orderBy?: tokens_generated_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tokens_generated_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokens_generated_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tokens_generated_aut model
   */
  readonly fields: tokens_generated_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tokens_generated_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tokens_generated_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_aut<T extends users_autDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_autDefaultArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tokens_generated_aut model
   */
  interface tokens_generated_autFieldRefs {
    readonly id: FieldRef<"tokens_generated_aut", 'String'>
    readonly create_token_id: FieldRef<"tokens_generated_aut", 'String'>
    readonly user_id: FieldRef<"tokens_generated_aut", 'String'>
    readonly is_expired: FieldRef<"tokens_generated_aut", 'Boolean'>
    readonly is_error: FieldRef<"tokens_generated_aut", 'Boolean'>
    readonly is_confirmed: FieldRef<"tokens_generated_aut", 'Boolean'>
    readonly is_closed: FieldRef<"tokens_generated_aut", 'Boolean'>
    readonly createdAt: FieldRef<"tokens_generated_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"tokens_generated_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tokens_generated_aut findUnique
   */
  export type tokens_generated_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_aut to fetch.
     */
    where: tokens_generated_autWhereUniqueInput
  }

  /**
   * tokens_generated_aut findUniqueOrThrow
   */
  export type tokens_generated_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_aut to fetch.
     */
    where: tokens_generated_autWhereUniqueInput
  }

  /**
   * tokens_generated_aut findFirst
   */
  export type tokens_generated_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_aut to fetch.
     */
    where?: tokens_generated_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_auts to fetch.
     */
    orderBy?: tokens_generated_autOrderByWithRelationInput | tokens_generated_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens_generated_auts.
     */
    cursor?: tokens_generated_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens_generated_auts.
     */
    distinct?: Tokens_generated_autScalarFieldEnum | Tokens_generated_autScalarFieldEnum[]
  }

  /**
   * tokens_generated_aut findFirstOrThrow
   */
  export type tokens_generated_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_aut to fetch.
     */
    where?: tokens_generated_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_auts to fetch.
     */
    orderBy?: tokens_generated_autOrderByWithRelationInput | tokens_generated_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens_generated_auts.
     */
    cursor?: tokens_generated_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens_generated_auts.
     */
    distinct?: Tokens_generated_autScalarFieldEnum | Tokens_generated_autScalarFieldEnum[]
  }

  /**
   * tokens_generated_aut findMany
   */
  export type tokens_generated_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_auts to fetch.
     */
    where?: tokens_generated_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_auts to fetch.
     */
    orderBy?: tokens_generated_autOrderByWithRelationInput | tokens_generated_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokens_generated_auts.
     */
    cursor?: tokens_generated_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_auts.
     */
    skip?: number
    distinct?: Tokens_generated_autScalarFieldEnum | Tokens_generated_autScalarFieldEnum[]
  }

  /**
   * tokens_generated_aut create
   */
  export type tokens_generated_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * The data needed to create a tokens_generated_aut.
     */
    data: XOR<tokens_generated_autCreateInput, tokens_generated_autUncheckedCreateInput>
  }

  /**
   * tokens_generated_aut createMany
   */
  export type tokens_generated_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tokens_generated_auts.
     */
    data: tokens_generated_autCreateManyInput | tokens_generated_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens_generated_aut update
   */
  export type tokens_generated_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * The data needed to update a tokens_generated_aut.
     */
    data: XOR<tokens_generated_autUpdateInput, tokens_generated_autUncheckedUpdateInput>
    /**
     * Choose, which tokens_generated_aut to update.
     */
    where: tokens_generated_autWhereUniqueInput
  }

  /**
   * tokens_generated_aut updateMany
   */
  export type tokens_generated_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tokens_generated_auts.
     */
    data: XOR<tokens_generated_autUpdateManyMutationInput, tokens_generated_autUncheckedUpdateManyInput>
    /**
     * Filter which tokens_generated_auts to update
     */
    where?: tokens_generated_autWhereInput
    /**
     * Limit how many tokens_generated_auts to update.
     */
    limit?: number
  }

  /**
   * tokens_generated_aut upsert
   */
  export type tokens_generated_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * The filter to search for the tokens_generated_aut to update in case it exists.
     */
    where: tokens_generated_autWhereUniqueInput
    /**
     * In case the tokens_generated_aut found by the `where` argument doesn't exist, create a new tokens_generated_aut with this data.
     */
    create: XOR<tokens_generated_autCreateInput, tokens_generated_autUncheckedCreateInput>
    /**
     * In case the tokens_generated_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokens_generated_autUpdateInput, tokens_generated_autUncheckedUpdateInput>
  }

  /**
   * tokens_generated_aut delete
   */
  export type tokens_generated_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    /**
     * Filter which tokens_generated_aut to delete.
     */
    where: tokens_generated_autWhereUniqueInput
  }

  /**
   * tokens_generated_aut deleteMany
   */
  export type tokens_generated_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens_generated_auts to delete
     */
    where?: tokens_generated_autWhereInput
    /**
     * Limit how many tokens_generated_auts to delete.
     */
    limit?: number
  }

  /**
   * tokens_generated_aut without action
   */
  export type tokens_generated_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
  }


  /**
   * Model tokens_generated_clt
   */

  export type AggregateTokens_generated_clt = {
    _count: Tokens_generated_cltCountAggregateOutputType | null
    _min: Tokens_generated_cltMinAggregateOutputType | null
    _max: Tokens_generated_cltMaxAggregateOutputType | null
  }

  export type Tokens_generated_cltMinAggregateOutputType = {
    id: string | null
    create_token_id: string | null
    user_id: string | null
    is_expired: boolean | null
    is_error: boolean | null
    is_confirmed: boolean | null
    is_closed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tokens_generated_cltMaxAggregateOutputType = {
    id: string | null
    create_token_id: string | null
    user_id: string | null
    is_expired: boolean | null
    is_error: boolean | null
    is_confirmed: boolean | null
    is_closed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tokens_generated_cltCountAggregateOutputType = {
    id: number
    create_token_id: number
    user_id: number
    is_expired: number
    is_error: number
    is_confirmed: number
    is_closed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tokens_generated_cltMinAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tokens_generated_cltMaxAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tokens_generated_cltCountAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tokens_generated_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens_generated_clt to aggregate.
     */
    where?: tokens_generated_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_clts to fetch.
     */
    orderBy?: tokens_generated_cltOrderByWithRelationInput | tokens_generated_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokens_generated_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokens_generated_clts
    **/
    _count?: true | Tokens_generated_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tokens_generated_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tokens_generated_cltMaxAggregateInputType
  }

  export type GetTokens_generated_cltAggregateType<T extends Tokens_generated_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateTokens_generated_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokens_generated_clt[P]>
      : GetScalarType<T[P], AggregateTokens_generated_clt[P]>
  }




  export type tokens_generated_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokens_generated_cltWhereInput
    orderBy?: tokens_generated_cltOrderByWithAggregationInput | tokens_generated_cltOrderByWithAggregationInput[]
    by: Tokens_generated_cltScalarFieldEnum[] | Tokens_generated_cltScalarFieldEnum
    having?: tokens_generated_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tokens_generated_cltCountAggregateInputType | true
    _min?: Tokens_generated_cltMinAggregateInputType
    _max?: Tokens_generated_cltMaxAggregateInputType
  }

  export type Tokens_generated_cltGroupByOutputType = {
    id: string
    create_token_id: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date
    updatedAt: Date
    _count: Tokens_generated_cltCountAggregateOutputType | null
    _min: Tokens_generated_cltMinAggregateOutputType | null
    _max: Tokens_generated_cltMaxAggregateOutputType | null
  }

  type GetTokens_generated_cltGroupByPayload<T extends tokens_generated_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tokens_generated_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tokens_generated_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tokens_generated_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Tokens_generated_cltGroupByOutputType[P]>
        }
      >
    >


  export type tokens_generated_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    create_token_id?: boolean
    user_id?: boolean
    is_expired?: boolean
    is_error?: boolean
    is_confirmed?: boolean
    is_closed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokens_generated_clt"]>



  export type tokens_generated_cltSelectScalar = {
    id?: boolean
    create_token_id?: boolean
    user_id?: boolean
    is_expired?: boolean
    is_error?: boolean
    is_confirmed?: boolean
    is_closed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tokens_generated_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "create_token_id" | "user_id" | "is_expired" | "is_error" | "is_confirmed" | "is_closed" | "createdAt" | "updatedAt", ExtArgs["result"]["tokens_generated_clt"]>
  export type tokens_generated_cltInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }

  export type $tokens_generated_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tokens_generated_clt"
    objects: {
      users_clt: Prisma.$users_cltPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      create_token_id: string | null
      user_id: string
      is_expired: boolean
      is_error: boolean
      is_confirmed: boolean
      is_closed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tokens_generated_clt"]>
    composites: {}
  }

  type tokens_generated_cltGetPayload<S extends boolean | null | undefined | tokens_generated_cltDefaultArgs> = $Result.GetResult<Prisma.$tokens_generated_cltPayload, S>

  type tokens_generated_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tokens_generated_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tokens_generated_cltCountAggregateInputType | true
    }

  export interface tokens_generated_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tokens_generated_clt'], meta: { name: 'tokens_generated_clt' } }
    /**
     * Find zero or one Tokens_generated_clt that matches the filter.
     * @param {tokens_generated_cltFindUniqueArgs} args - Arguments to find a Tokens_generated_clt
     * @example
     * // Get one Tokens_generated_clt
     * const tokens_generated_clt = await prisma.tokens_generated_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tokens_generated_cltFindUniqueArgs>(args: SelectSubset<T, tokens_generated_cltFindUniqueArgs<ExtArgs>>): Prisma__tokens_generated_cltClient<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tokens_generated_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tokens_generated_cltFindUniqueOrThrowArgs} args - Arguments to find a Tokens_generated_clt
     * @example
     * // Get one Tokens_generated_clt
     * const tokens_generated_clt = await prisma.tokens_generated_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tokens_generated_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, tokens_generated_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tokens_generated_cltClient<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens_generated_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_cltFindFirstArgs} args - Arguments to find a Tokens_generated_clt
     * @example
     * // Get one Tokens_generated_clt
     * const tokens_generated_clt = await prisma.tokens_generated_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tokens_generated_cltFindFirstArgs>(args?: SelectSubset<T, tokens_generated_cltFindFirstArgs<ExtArgs>>): Prisma__tokens_generated_cltClient<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens_generated_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_cltFindFirstOrThrowArgs} args - Arguments to find a Tokens_generated_clt
     * @example
     * // Get one Tokens_generated_clt
     * const tokens_generated_clt = await prisma.tokens_generated_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tokens_generated_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, tokens_generated_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__tokens_generated_cltClient<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens_generated_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens_generated_clts
     * const tokens_generated_clts = await prisma.tokens_generated_clt.findMany()
     * 
     * // Get first 10 Tokens_generated_clts
     * const tokens_generated_clts = await prisma.tokens_generated_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokens_generated_cltWithIdOnly = await prisma.tokens_generated_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tokens_generated_cltFindManyArgs>(args?: SelectSubset<T, tokens_generated_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tokens_generated_clt.
     * @param {tokens_generated_cltCreateArgs} args - Arguments to create a Tokens_generated_clt.
     * @example
     * // Create one Tokens_generated_clt
     * const Tokens_generated_clt = await prisma.tokens_generated_clt.create({
     *   data: {
     *     // ... data to create a Tokens_generated_clt
     *   }
     * })
     * 
     */
    create<T extends tokens_generated_cltCreateArgs>(args: SelectSubset<T, tokens_generated_cltCreateArgs<ExtArgs>>): Prisma__tokens_generated_cltClient<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens_generated_clts.
     * @param {tokens_generated_cltCreateManyArgs} args - Arguments to create many Tokens_generated_clts.
     * @example
     * // Create many Tokens_generated_clts
     * const tokens_generated_clt = await prisma.tokens_generated_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tokens_generated_cltCreateManyArgs>(args?: SelectSubset<T, tokens_generated_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tokens_generated_clt.
     * @param {tokens_generated_cltDeleteArgs} args - Arguments to delete one Tokens_generated_clt.
     * @example
     * // Delete one Tokens_generated_clt
     * const Tokens_generated_clt = await prisma.tokens_generated_clt.delete({
     *   where: {
     *     // ... filter to delete one Tokens_generated_clt
     *   }
     * })
     * 
     */
    delete<T extends tokens_generated_cltDeleteArgs>(args: SelectSubset<T, tokens_generated_cltDeleteArgs<ExtArgs>>): Prisma__tokens_generated_cltClient<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tokens_generated_clt.
     * @param {tokens_generated_cltUpdateArgs} args - Arguments to update one Tokens_generated_clt.
     * @example
     * // Update one Tokens_generated_clt
     * const tokens_generated_clt = await prisma.tokens_generated_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tokens_generated_cltUpdateArgs>(args: SelectSubset<T, tokens_generated_cltUpdateArgs<ExtArgs>>): Prisma__tokens_generated_cltClient<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens_generated_clts.
     * @param {tokens_generated_cltDeleteManyArgs} args - Arguments to filter Tokens_generated_clts to delete.
     * @example
     * // Delete a few Tokens_generated_clts
     * const { count } = await prisma.tokens_generated_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tokens_generated_cltDeleteManyArgs>(args?: SelectSubset<T, tokens_generated_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens_generated_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens_generated_clts
     * const tokens_generated_clt = await prisma.tokens_generated_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tokens_generated_cltUpdateManyArgs>(args: SelectSubset<T, tokens_generated_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tokens_generated_clt.
     * @param {tokens_generated_cltUpsertArgs} args - Arguments to update or create a Tokens_generated_clt.
     * @example
     * // Update or create a Tokens_generated_clt
     * const tokens_generated_clt = await prisma.tokens_generated_clt.upsert({
     *   create: {
     *     // ... data to create a Tokens_generated_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tokens_generated_clt we want to update
     *   }
     * })
     */
    upsert<T extends tokens_generated_cltUpsertArgs>(args: SelectSubset<T, tokens_generated_cltUpsertArgs<ExtArgs>>): Prisma__tokens_generated_cltClient<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens_generated_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_cltCountArgs} args - Arguments to filter Tokens_generated_clts to count.
     * @example
     * // Count the number of Tokens_generated_clts
     * const count = await prisma.tokens_generated_clt.count({
     *   where: {
     *     // ... the filter for the Tokens_generated_clts we want to count
     *   }
     * })
    **/
    count<T extends tokens_generated_cltCountArgs>(
      args?: Subset<T, tokens_generated_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tokens_generated_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tokens_generated_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tokens_generated_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tokens_generated_cltAggregateArgs>(args: Subset<T, Tokens_generated_cltAggregateArgs>): Prisma.PrismaPromise<GetTokens_generated_cltAggregateType<T>>

    /**
     * Group by Tokens_generated_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tokens_generated_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tokens_generated_cltGroupByArgs['orderBy'] }
        : { orderBy?: tokens_generated_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tokens_generated_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokens_generated_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tokens_generated_clt model
   */
  readonly fields: tokens_generated_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tokens_generated_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tokens_generated_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_clt<T extends users_cltDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_cltDefaultArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tokens_generated_clt model
   */
  interface tokens_generated_cltFieldRefs {
    readonly id: FieldRef<"tokens_generated_clt", 'String'>
    readonly create_token_id: FieldRef<"tokens_generated_clt", 'String'>
    readonly user_id: FieldRef<"tokens_generated_clt", 'String'>
    readonly is_expired: FieldRef<"tokens_generated_clt", 'Boolean'>
    readonly is_error: FieldRef<"tokens_generated_clt", 'Boolean'>
    readonly is_confirmed: FieldRef<"tokens_generated_clt", 'Boolean'>
    readonly is_closed: FieldRef<"tokens_generated_clt", 'Boolean'>
    readonly createdAt: FieldRef<"tokens_generated_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"tokens_generated_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tokens_generated_clt findUnique
   */
  export type tokens_generated_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_clt to fetch.
     */
    where: tokens_generated_cltWhereUniqueInput
  }

  /**
   * tokens_generated_clt findUniqueOrThrow
   */
  export type tokens_generated_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_clt to fetch.
     */
    where: tokens_generated_cltWhereUniqueInput
  }

  /**
   * tokens_generated_clt findFirst
   */
  export type tokens_generated_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_clt to fetch.
     */
    where?: tokens_generated_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_clts to fetch.
     */
    orderBy?: tokens_generated_cltOrderByWithRelationInput | tokens_generated_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens_generated_clts.
     */
    cursor?: tokens_generated_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens_generated_clts.
     */
    distinct?: Tokens_generated_cltScalarFieldEnum | Tokens_generated_cltScalarFieldEnum[]
  }

  /**
   * tokens_generated_clt findFirstOrThrow
   */
  export type tokens_generated_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_clt to fetch.
     */
    where?: tokens_generated_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_clts to fetch.
     */
    orderBy?: tokens_generated_cltOrderByWithRelationInput | tokens_generated_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens_generated_clts.
     */
    cursor?: tokens_generated_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens_generated_clts.
     */
    distinct?: Tokens_generated_cltScalarFieldEnum | Tokens_generated_cltScalarFieldEnum[]
  }

  /**
   * tokens_generated_clt findMany
   */
  export type tokens_generated_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_clts to fetch.
     */
    where?: tokens_generated_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_clts to fetch.
     */
    orderBy?: tokens_generated_cltOrderByWithRelationInput | tokens_generated_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokens_generated_clts.
     */
    cursor?: tokens_generated_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_clts.
     */
    skip?: number
    distinct?: Tokens_generated_cltScalarFieldEnum | Tokens_generated_cltScalarFieldEnum[]
  }

  /**
   * tokens_generated_clt create
   */
  export type tokens_generated_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * The data needed to create a tokens_generated_clt.
     */
    data: XOR<tokens_generated_cltCreateInput, tokens_generated_cltUncheckedCreateInput>
  }

  /**
   * tokens_generated_clt createMany
   */
  export type tokens_generated_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tokens_generated_clts.
     */
    data: tokens_generated_cltCreateManyInput | tokens_generated_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens_generated_clt update
   */
  export type tokens_generated_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * The data needed to update a tokens_generated_clt.
     */
    data: XOR<tokens_generated_cltUpdateInput, tokens_generated_cltUncheckedUpdateInput>
    /**
     * Choose, which tokens_generated_clt to update.
     */
    where: tokens_generated_cltWhereUniqueInput
  }

  /**
   * tokens_generated_clt updateMany
   */
  export type tokens_generated_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tokens_generated_clts.
     */
    data: XOR<tokens_generated_cltUpdateManyMutationInput, tokens_generated_cltUncheckedUpdateManyInput>
    /**
     * Filter which tokens_generated_clts to update
     */
    where?: tokens_generated_cltWhereInput
    /**
     * Limit how many tokens_generated_clts to update.
     */
    limit?: number
  }

  /**
   * tokens_generated_clt upsert
   */
  export type tokens_generated_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * The filter to search for the tokens_generated_clt to update in case it exists.
     */
    where: tokens_generated_cltWhereUniqueInput
    /**
     * In case the tokens_generated_clt found by the `where` argument doesn't exist, create a new tokens_generated_clt with this data.
     */
    create: XOR<tokens_generated_cltCreateInput, tokens_generated_cltUncheckedCreateInput>
    /**
     * In case the tokens_generated_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokens_generated_cltUpdateInput, tokens_generated_cltUncheckedUpdateInput>
  }

  /**
   * tokens_generated_clt delete
   */
  export type tokens_generated_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    /**
     * Filter which tokens_generated_clt to delete.
     */
    where: tokens_generated_cltWhereUniqueInput
  }

  /**
   * tokens_generated_clt deleteMany
   */
  export type tokens_generated_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens_generated_clts to delete
     */
    where?: tokens_generated_cltWhereInput
    /**
     * Limit how many tokens_generated_clts to delete.
     */
    limit?: number
  }

  /**
   * tokens_generated_clt without action
   */
  export type tokens_generated_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
  }


  /**
   * Model tokens_generated_goi
   */

  export type AggregateTokens_generated_goi = {
    _count: Tokens_generated_goiCountAggregateOutputType | null
    _min: Tokens_generated_goiMinAggregateOutputType | null
    _max: Tokens_generated_goiMaxAggregateOutputType | null
  }

  export type Tokens_generated_goiMinAggregateOutputType = {
    id: string | null
    create_token_id: string | null
    user_id: string | null
    is_expired: boolean | null
    is_error: boolean | null
    is_confirmed: boolean | null
    is_closed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tokens_generated_goiMaxAggregateOutputType = {
    id: string | null
    create_token_id: string | null
    user_id: string | null
    is_expired: boolean | null
    is_error: boolean | null
    is_confirmed: boolean | null
    is_closed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tokens_generated_goiCountAggregateOutputType = {
    id: number
    create_token_id: number
    user_id: number
    is_expired: number
    is_error: number
    is_confirmed: number
    is_closed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tokens_generated_goiMinAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tokens_generated_goiMaxAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tokens_generated_goiCountAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tokens_generated_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens_generated_goi to aggregate.
     */
    where?: tokens_generated_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_gois to fetch.
     */
    orderBy?: tokens_generated_goiOrderByWithRelationInput | tokens_generated_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokens_generated_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokens_generated_gois
    **/
    _count?: true | Tokens_generated_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tokens_generated_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tokens_generated_goiMaxAggregateInputType
  }

  export type GetTokens_generated_goiAggregateType<T extends Tokens_generated_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateTokens_generated_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokens_generated_goi[P]>
      : GetScalarType<T[P], AggregateTokens_generated_goi[P]>
  }




  export type tokens_generated_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokens_generated_goiWhereInput
    orderBy?: tokens_generated_goiOrderByWithAggregationInput | tokens_generated_goiOrderByWithAggregationInput[]
    by: Tokens_generated_goiScalarFieldEnum[] | Tokens_generated_goiScalarFieldEnum
    having?: tokens_generated_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tokens_generated_goiCountAggregateInputType | true
    _min?: Tokens_generated_goiMinAggregateInputType
    _max?: Tokens_generated_goiMaxAggregateInputType
  }

  export type Tokens_generated_goiGroupByOutputType = {
    id: string
    create_token_id: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date
    updatedAt: Date
    _count: Tokens_generated_goiCountAggregateOutputType | null
    _min: Tokens_generated_goiMinAggregateOutputType | null
    _max: Tokens_generated_goiMaxAggregateOutputType | null
  }

  type GetTokens_generated_goiGroupByPayload<T extends tokens_generated_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tokens_generated_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tokens_generated_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tokens_generated_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Tokens_generated_goiGroupByOutputType[P]>
        }
      >
    >


  export type tokens_generated_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    create_token_id?: boolean
    user_id?: boolean
    is_expired?: boolean
    is_error?: boolean
    is_confirmed?: boolean
    is_closed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokens_generated_goi"]>



  export type tokens_generated_goiSelectScalar = {
    id?: boolean
    create_token_id?: boolean
    user_id?: boolean
    is_expired?: boolean
    is_error?: boolean
    is_confirmed?: boolean
    is_closed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tokens_generated_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "create_token_id" | "user_id" | "is_expired" | "is_error" | "is_confirmed" | "is_closed" | "createdAt" | "updatedAt", ExtArgs["result"]["tokens_generated_goi"]>
  export type tokens_generated_goiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }

  export type $tokens_generated_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tokens_generated_goi"
    objects: {
      users_goi: Prisma.$users_goiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      create_token_id: string | null
      user_id: string
      is_expired: boolean
      is_error: boolean
      is_confirmed: boolean
      is_closed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tokens_generated_goi"]>
    composites: {}
  }

  type tokens_generated_goiGetPayload<S extends boolean | null | undefined | tokens_generated_goiDefaultArgs> = $Result.GetResult<Prisma.$tokens_generated_goiPayload, S>

  type tokens_generated_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tokens_generated_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tokens_generated_goiCountAggregateInputType | true
    }

  export interface tokens_generated_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tokens_generated_goi'], meta: { name: 'tokens_generated_goi' } }
    /**
     * Find zero or one Tokens_generated_goi that matches the filter.
     * @param {tokens_generated_goiFindUniqueArgs} args - Arguments to find a Tokens_generated_goi
     * @example
     * // Get one Tokens_generated_goi
     * const tokens_generated_goi = await prisma.tokens_generated_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tokens_generated_goiFindUniqueArgs>(args: SelectSubset<T, tokens_generated_goiFindUniqueArgs<ExtArgs>>): Prisma__tokens_generated_goiClient<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tokens_generated_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tokens_generated_goiFindUniqueOrThrowArgs} args - Arguments to find a Tokens_generated_goi
     * @example
     * // Get one Tokens_generated_goi
     * const tokens_generated_goi = await prisma.tokens_generated_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tokens_generated_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, tokens_generated_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tokens_generated_goiClient<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens_generated_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_goiFindFirstArgs} args - Arguments to find a Tokens_generated_goi
     * @example
     * // Get one Tokens_generated_goi
     * const tokens_generated_goi = await prisma.tokens_generated_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tokens_generated_goiFindFirstArgs>(args?: SelectSubset<T, tokens_generated_goiFindFirstArgs<ExtArgs>>): Prisma__tokens_generated_goiClient<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens_generated_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_goiFindFirstOrThrowArgs} args - Arguments to find a Tokens_generated_goi
     * @example
     * // Get one Tokens_generated_goi
     * const tokens_generated_goi = await prisma.tokens_generated_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tokens_generated_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, tokens_generated_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__tokens_generated_goiClient<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens_generated_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens_generated_gois
     * const tokens_generated_gois = await prisma.tokens_generated_goi.findMany()
     * 
     * // Get first 10 Tokens_generated_gois
     * const tokens_generated_gois = await prisma.tokens_generated_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokens_generated_goiWithIdOnly = await prisma.tokens_generated_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tokens_generated_goiFindManyArgs>(args?: SelectSubset<T, tokens_generated_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tokens_generated_goi.
     * @param {tokens_generated_goiCreateArgs} args - Arguments to create a Tokens_generated_goi.
     * @example
     * // Create one Tokens_generated_goi
     * const Tokens_generated_goi = await prisma.tokens_generated_goi.create({
     *   data: {
     *     // ... data to create a Tokens_generated_goi
     *   }
     * })
     * 
     */
    create<T extends tokens_generated_goiCreateArgs>(args: SelectSubset<T, tokens_generated_goiCreateArgs<ExtArgs>>): Prisma__tokens_generated_goiClient<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens_generated_gois.
     * @param {tokens_generated_goiCreateManyArgs} args - Arguments to create many Tokens_generated_gois.
     * @example
     * // Create many Tokens_generated_gois
     * const tokens_generated_goi = await prisma.tokens_generated_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tokens_generated_goiCreateManyArgs>(args?: SelectSubset<T, tokens_generated_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tokens_generated_goi.
     * @param {tokens_generated_goiDeleteArgs} args - Arguments to delete one Tokens_generated_goi.
     * @example
     * // Delete one Tokens_generated_goi
     * const Tokens_generated_goi = await prisma.tokens_generated_goi.delete({
     *   where: {
     *     // ... filter to delete one Tokens_generated_goi
     *   }
     * })
     * 
     */
    delete<T extends tokens_generated_goiDeleteArgs>(args: SelectSubset<T, tokens_generated_goiDeleteArgs<ExtArgs>>): Prisma__tokens_generated_goiClient<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tokens_generated_goi.
     * @param {tokens_generated_goiUpdateArgs} args - Arguments to update one Tokens_generated_goi.
     * @example
     * // Update one Tokens_generated_goi
     * const tokens_generated_goi = await prisma.tokens_generated_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tokens_generated_goiUpdateArgs>(args: SelectSubset<T, tokens_generated_goiUpdateArgs<ExtArgs>>): Prisma__tokens_generated_goiClient<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens_generated_gois.
     * @param {tokens_generated_goiDeleteManyArgs} args - Arguments to filter Tokens_generated_gois to delete.
     * @example
     * // Delete a few Tokens_generated_gois
     * const { count } = await prisma.tokens_generated_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tokens_generated_goiDeleteManyArgs>(args?: SelectSubset<T, tokens_generated_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens_generated_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens_generated_gois
     * const tokens_generated_goi = await prisma.tokens_generated_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tokens_generated_goiUpdateManyArgs>(args: SelectSubset<T, tokens_generated_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tokens_generated_goi.
     * @param {tokens_generated_goiUpsertArgs} args - Arguments to update or create a Tokens_generated_goi.
     * @example
     * // Update or create a Tokens_generated_goi
     * const tokens_generated_goi = await prisma.tokens_generated_goi.upsert({
     *   create: {
     *     // ... data to create a Tokens_generated_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tokens_generated_goi we want to update
     *   }
     * })
     */
    upsert<T extends tokens_generated_goiUpsertArgs>(args: SelectSubset<T, tokens_generated_goiUpsertArgs<ExtArgs>>): Prisma__tokens_generated_goiClient<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens_generated_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_goiCountArgs} args - Arguments to filter Tokens_generated_gois to count.
     * @example
     * // Count the number of Tokens_generated_gois
     * const count = await prisma.tokens_generated_goi.count({
     *   where: {
     *     // ... the filter for the Tokens_generated_gois we want to count
     *   }
     * })
    **/
    count<T extends tokens_generated_goiCountArgs>(
      args?: Subset<T, tokens_generated_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tokens_generated_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tokens_generated_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tokens_generated_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tokens_generated_goiAggregateArgs>(args: Subset<T, Tokens_generated_goiAggregateArgs>): Prisma.PrismaPromise<GetTokens_generated_goiAggregateType<T>>

    /**
     * Group by Tokens_generated_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tokens_generated_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tokens_generated_goiGroupByArgs['orderBy'] }
        : { orderBy?: tokens_generated_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tokens_generated_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokens_generated_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tokens_generated_goi model
   */
  readonly fields: tokens_generated_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tokens_generated_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tokens_generated_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_goi<T extends users_goiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_goiDefaultArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tokens_generated_goi model
   */
  interface tokens_generated_goiFieldRefs {
    readonly id: FieldRef<"tokens_generated_goi", 'String'>
    readonly create_token_id: FieldRef<"tokens_generated_goi", 'String'>
    readonly user_id: FieldRef<"tokens_generated_goi", 'String'>
    readonly is_expired: FieldRef<"tokens_generated_goi", 'Boolean'>
    readonly is_error: FieldRef<"tokens_generated_goi", 'Boolean'>
    readonly is_confirmed: FieldRef<"tokens_generated_goi", 'Boolean'>
    readonly is_closed: FieldRef<"tokens_generated_goi", 'Boolean'>
    readonly createdAt: FieldRef<"tokens_generated_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"tokens_generated_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tokens_generated_goi findUnique
   */
  export type tokens_generated_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_goi to fetch.
     */
    where: tokens_generated_goiWhereUniqueInput
  }

  /**
   * tokens_generated_goi findUniqueOrThrow
   */
  export type tokens_generated_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_goi to fetch.
     */
    where: tokens_generated_goiWhereUniqueInput
  }

  /**
   * tokens_generated_goi findFirst
   */
  export type tokens_generated_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_goi to fetch.
     */
    where?: tokens_generated_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_gois to fetch.
     */
    orderBy?: tokens_generated_goiOrderByWithRelationInput | tokens_generated_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens_generated_gois.
     */
    cursor?: tokens_generated_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens_generated_gois.
     */
    distinct?: Tokens_generated_goiScalarFieldEnum | Tokens_generated_goiScalarFieldEnum[]
  }

  /**
   * tokens_generated_goi findFirstOrThrow
   */
  export type tokens_generated_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_goi to fetch.
     */
    where?: tokens_generated_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_gois to fetch.
     */
    orderBy?: tokens_generated_goiOrderByWithRelationInput | tokens_generated_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens_generated_gois.
     */
    cursor?: tokens_generated_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens_generated_gois.
     */
    distinct?: Tokens_generated_goiScalarFieldEnum | Tokens_generated_goiScalarFieldEnum[]
  }

  /**
   * tokens_generated_goi findMany
   */
  export type tokens_generated_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_gois to fetch.
     */
    where?: tokens_generated_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_gois to fetch.
     */
    orderBy?: tokens_generated_goiOrderByWithRelationInput | tokens_generated_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokens_generated_gois.
     */
    cursor?: tokens_generated_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_gois.
     */
    skip?: number
    distinct?: Tokens_generated_goiScalarFieldEnum | Tokens_generated_goiScalarFieldEnum[]
  }

  /**
   * tokens_generated_goi create
   */
  export type tokens_generated_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * The data needed to create a tokens_generated_goi.
     */
    data: XOR<tokens_generated_goiCreateInput, tokens_generated_goiUncheckedCreateInput>
  }

  /**
   * tokens_generated_goi createMany
   */
  export type tokens_generated_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tokens_generated_gois.
     */
    data: tokens_generated_goiCreateManyInput | tokens_generated_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens_generated_goi update
   */
  export type tokens_generated_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * The data needed to update a tokens_generated_goi.
     */
    data: XOR<tokens_generated_goiUpdateInput, tokens_generated_goiUncheckedUpdateInput>
    /**
     * Choose, which tokens_generated_goi to update.
     */
    where: tokens_generated_goiWhereUniqueInput
  }

  /**
   * tokens_generated_goi updateMany
   */
  export type tokens_generated_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tokens_generated_gois.
     */
    data: XOR<tokens_generated_goiUpdateManyMutationInput, tokens_generated_goiUncheckedUpdateManyInput>
    /**
     * Filter which tokens_generated_gois to update
     */
    where?: tokens_generated_goiWhereInput
    /**
     * Limit how many tokens_generated_gois to update.
     */
    limit?: number
  }

  /**
   * tokens_generated_goi upsert
   */
  export type tokens_generated_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * The filter to search for the tokens_generated_goi to update in case it exists.
     */
    where: tokens_generated_goiWhereUniqueInput
    /**
     * In case the tokens_generated_goi found by the `where` argument doesn't exist, create a new tokens_generated_goi with this data.
     */
    create: XOR<tokens_generated_goiCreateInput, tokens_generated_goiUncheckedCreateInput>
    /**
     * In case the tokens_generated_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokens_generated_goiUpdateInput, tokens_generated_goiUncheckedUpdateInput>
  }

  /**
   * tokens_generated_goi delete
   */
  export type tokens_generated_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    /**
     * Filter which tokens_generated_goi to delete.
     */
    where: tokens_generated_goiWhereUniqueInput
  }

  /**
   * tokens_generated_goi deleteMany
   */
  export type tokens_generated_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens_generated_gois to delete
     */
    where?: tokens_generated_goiWhereInput
    /**
     * Limit how many tokens_generated_gois to delete.
     */
    limit?: number
  }

  /**
   * tokens_generated_goi without action
   */
  export type tokens_generated_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
  }


  /**
   * Model tokens_generated_spa
   */

  export type AggregateTokens_generated_spa = {
    _count: Tokens_generated_spaCountAggregateOutputType | null
    _min: Tokens_generated_spaMinAggregateOutputType | null
    _max: Tokens_generated_spaMaxAggregateOutputType | null
  }

  export type Tokens_generated_spaMinAggregateOutputType = {
    id: string | null
    create_token_id: string | null
    user_id: string | null
    is_expired: boolean | null
    is_error: boolean | null
    is_confirmed: boolean | null
    is_closed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tokens_generated_spaMaxAggregateOutputType = {
    id: string | null
    create_token_id: string | null
    user_id: string | null
    is_expired: boolean | null
    is_error: boolean | null
    is_confirmed: boolean | null
    is_closed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tokens_generated_spaCountAggregateOutputType = {
    id: number
    create_token_id: number
    user_id: number
    is_expired: number
    is_error: number
    is_confirmed: number
    is_closed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tokens_generated_spaMinAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tokens_generated_spaMaxAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tokens_generated_spaCountAggregateInputType = {
    id?: true
    create_token_id?: true
    user_id?: true
    is_expired?: true
    is_error?: true
    is_confirmed?: true
    is_closed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tokens_generated_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens_generated_spa to aggregate.
     */
    where?: tokens_generated_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_spas to fetch.
     */
    orderBy?: tokens_generated_spaOrderByWithRelationInput | tokens_generated_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokens_generated_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokens_generated_spas
    **/
    _count?: true | Tokens_generated_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tokens_generated_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tokens_generated_spaMaxAggregateInputType
  }

  export type GetTokens_generated_spaAggregateType<T extends Tokens_generated_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateTokens_generated_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokens_generated_spa[P]>
      : GetScalarType<T[P], AggregateTokens_generated_spa[P]>
  }




  export type tokens_generated_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokens_generated_spaWhereInput
    orderBy?: tokens_generated_spaOrderByWithAggregationInput | tokens_generated_spaOrderByWithAggregationInput[]
    by: Tokens_generated_spaScalarFieldEnum[] | Tokens_generated_spaScalarFieldEnum
    having?: tokens_generated_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tokens_generated_spaCountAggregateInputType | true
    _min?: Tokens_generated_spaMinAggregateInputType
    _max?: Tokens_generated_spaMaxAggregateInputType
  }

  export type Tokens_generated_spaGroupByOutputType = {
    id: string
    create_token_id: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date
    updatedAt: Date
    _count: Tokens_generated_spaCountAggregateOutputType | null
    _min: Tokens_generated_spaMinAggregateOutputType | null
    _max: Tokens_generated_spaMaxAggregateOutputType | null
  }

  type GetTokens_generated_spaGroupByPayload<T extends tokens_generated_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tokens_generated_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tokens_generated_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tokens_generated_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Tokens_generated_spaGroupByOutputType[P]>
        }
      >
    >


  export type tokens_generated_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    create_token_id?: boolean
    user_id?: boolean
    is_expired?: boolean
    is_error?: boolean
    is_confirmed?: boolean
    is_closed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokens_generated_spa"]>



  export type tokens_generated_spaSelectScalar = {
    id?: boolean
    create_token_id?: boolean
    user_id?: boolean
    is_expired?: boolean
    is_error?: boolean
    is_confirmed?: boolean
    is_closed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tokens_generated_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "create_token_id" | "user_id" | "is_expired" | "is_error" | "is_confirmed" | "is_closed" | "createdAt" | "updatedAt", ExtArgs["result"]["tokens_generated_spa"]>
  export type tokens_generated_spaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }

  export type $tokens_generated_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tokens_generated_spa"
    objects: {
      users_spa: Prisma.$users_spaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      create_token_id: string | null
      user_id: string
      is_expired: boolean
      is_error: boolean
      is_confirmed: boolean
      is_closed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tokens_generated_spa"]>
    composites: {}
  }

  type tokens_generated_spaGetPayload<S extends boolean | null | undefined | tokens_generated_spaDefaultArgs> = $Result.GetResult<Prisma.$tokens_generated_spaPayload, S>

  type tokens_generated_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tokens_generated_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tokens_generated_spaCountAggregateInputType | true
    }

  export interface tokens_generated_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tokens_generated_spa'], meta: { name: 'tokens_generated_spa' } }
    /**
     * Find zero or one Tokens_generated_spa that matches the filter.
     * @param {tokens_generated_spaFindUniqueArgs} args - Arguments to find a Tokens_generated_spa
     * @example
     * // Get one Tokens_generated_spa
     * const tokens_generated_spa = await prisma.tokens_generated_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tokens_generated_spaFindUniqueArgs>(args: SelectSubset<T, tokens_generated_spaFindUniqueArgs<ExtArgs>>): Prisma__tokens_generated_spaClient<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tokens_generated_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tokens_generated_spaFindUniqueOrThrowArgs} args - Arguments to find a Tokens_generated_spa
     * @example
     * // Get one Tokens_generated_spa
     * const tokens_generated_spa = await prisma.tokens_generated_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tokens_generated_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, tokens_generated_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tokens_generated_spaClient<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens_generated_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_spaFindFirstArgs} args - Arguments to find a Tokens_generated_spa
     * @example
     * // Get one Tokens_generated_spa
     * const tokens_generated_spa = await prisma.tokens_generated_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tokens_generated_spaFindFirstArgs>(args?: SelectSubset<T, tokens_generated_spaFindFirstArgs<ExtArgs>>): Prisma__tokens_generated_spaClient<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens_generated_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_spaFindFirstOrThrowArgs} args - Arguments to find a Tokens_generated_spa
     * @example
     * // Get one Tokens_generated_spa
     * const tokens_generated_spa = await prisma.tokens_generated_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tokens_generated_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, tokens_generated_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__tokens_generated_spaClient<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens_generated_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens_generated_spas
     * const tokens_generated_spas = await prisma.tokens_generated_spa.findMany()
     * 
     * // Get first 10 Tokens_generated_spas
     * const tokens_generated_spas = await prisma.tokens_generated_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokens_generated_spaWithIdOnly = await prisma.tokens_generated_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tokens_generated_spaFindManyArgs>(args?: SelectSubset<T, tokens_generated_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tokens_generated_spa.
     * @param {tokens_generated_spaCreateArgs} args - Arguments to create a Tokens_generated_spa.
     * @example
     * // Create one Tokens_generated_spa
     * const Tokens_generated_spa = await prisma.tokens_generated_spa.create({
     *   data: {
     *     // ... data to create a Tokens_generated_spa
     *   }
     * })
     * 
     */
    create<T extends tokens_generated_spaCreateArgs>(args: SelectSubset<T, tokens_generated_spaCreateArgs<ExtArgs>>): Prisma__tokens_generated_spaClient<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens_generated_spas.
     * @param {tokens_generated_spaCreateManyArgs} args - Arguments to create many Tokens_generated_spas.
     * @example
     * // Create many Tokens_generated_spas
     * const tokens_generated_spa = await prisma.tokens_generated_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tokens_generated_spaCreateManyArgs>(args?: SelectSubset<T, tokens_generated_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tokens_generated_spa.
     * @param {tokens_generated_spaDeleteArgs} args - Arguments to delete one Tokens_generated_spa.
     * @example
     * // Delete one Tokens_generated_spa
     * const Tokens_generated_spa = await prisma.tokens_generated_spa.delete({
     *   where: {
     *     // ... filter to delete one Tokens_generated_spa
     *   }
     * })
     * 
     */
    delete<T extends tokens_generated_spaDeleteArgs>(args: SelectSubset<T, tokens_generated_spaDeleteArgs<ExtArgs>>): Prisma__tokens_generated_spaClient<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tokens_generated_spa.
     * @param {tokens_generated_spaUpdateArgs} args - Arguments to update one Tokens_generated_spa.
     * @example
     * // Update one Tokens_generated_spa
     * const tokens_generated_spa = await prisma.tokens_generated_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tokens_generated_spaUpdateArgs>(args: SelectSubset<T, tokens_generated_spaUpdateArgs<ExtArgs>>): Prisma__tokens_generated_spaClient<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens_generated_spas.
     * @param {tokens_generated_spaDeleteManyArgs} args - Arguments to filter Tokens_generated_spas to delete.
     * @example
     * // Delete a few Tokens_generated_spas
     * const { count } = await prisma.tokens_generated_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tokens_generated_spaDeleteManyArgs>(args?: SelectSubset<T, tokens_generated_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens_generated_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens_generated_spas
     * const tokens_generated_spa = await prisma.tokens_generated_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tokens_generated_spaUpdateManyArgs>(args: SelectSubset<T, tokens_generated_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tokens_generated_spa.
     * @param {tokens_generated_spaUpsertArgs} args - Arguments to update or create a Tokens_generated_spa.
     * @example
     * // Update or create a Tokens_generated_spa
     * const tokens_generated_spa = await prisma.tokens_generated_spa.upsert({
     *   create: {
     *     // ... data to create a Tokens_generated_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tokens_generated_spa we want to update
     *   }
     * })
     */
    upsert<T extends tokens_generated_spaUpsertArgs>(args: SelectSubset<T, tokens_generated_spaUpsertArgs<ExtArgs>>): Prisma__tokens_generated_spaClient<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens_generated_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_spaCountArgs} args - Arguments to filter Tokens_generated_spas to count.
     * @example
     * // Count the number of Tokens_generated_spas
     * const count = await prisma.tokens_generated_spa.count({
     *   where: {
     *     // ... the filter for the Tokens_generated_spas we want to count
     *   }
     * })
    **/
    count<T extends tokens_generated_spaCountArgs>(
      args?: Subset<T, tokens_generated_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tokens_generated_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tokens_generated_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tokens_generated_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tokens_generated_spaAggregateArgs>(args: Subset<T, Tokens_generated_spaAggregateArgs>): Prisma.PrismaPromise<GetTokens_generated_spaAggregateType<T>>

    /**
     * Group by Tokens_generated_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokens_generated_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tokens_generated_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tokens_generated_spaGroupByArgs['orderBy'] }
        : { orderBy?: tokens_generated_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tokens_generated_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokens_generated_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tokens_generated_spa model
   */
  readonly fields: tokens_generated_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tokens_generated_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tokens_generated_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_spa<T extends users_spaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_spaDefaultArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tokens_generated_spa model
   */
  interface tokens_generated_spaFieldRefs {
    readonly id: FieldRef<"tokens_generated_spa", 'String'>
    readonly create_token_id: FieldRef<"tokens_generated_spa", 'String'>
    readonly user_id: FieldRef<"tokens_generated_spa", 'String'>
    readonly is_expired: FieldRef<"tokens_generated_spa", 'Boolean'>
    readonly is_error: FieldRef<"tokens_generated_spa", 'Boolean'>
    readonly is_confirmed: FieldRef<"tokens_generated_spa", 'Boolean'>
    readonly is_closed: FieldRef<"tokens_generated_spa", 'Boolean'>
    readonly createdAt: FieldRef<"tokens_generated_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"tokens_generated_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tokens_generated_spa findUnique
   */
  export type tokens_generated_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_spa to fetch.
     */
    where: tokens_generated_spaWhereUniqueInput
  }

  /**
   * tokens_generated_spa findUniqueOrThrow
   */
  export type tokens_generated_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_spa to fetch.
     */
    where: tokens_generated_spaWhereUniqueInput
  }

  /**
   * tokens_generated_spa findFirst
   */
  export type tokens_generated_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_spa to fetch.
     */
    where?: tokens_generated_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_spas to fetch.
     */
    orderBy?: tokens_generated_spaOrderByWithRelationInput | tokens_generated_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens_generated_spas.
     */
    cursor?: tokens_generated_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens_generated_spas.
     */
    distinct?: Tokens_generated_spaScalarFieldEnum | Tokens_generated_spaScalarFieldEnum[]
  }

  /**
   * tokens_generated_spa findFirstOrThrow
   */
  export type tokens_generated_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_spa to fetch.
     */
    where?: tokens_generated_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_spas to fetch.
     */
    orderBy?: tokens_generated_spaOrderByWithRelationInput | tokens_generated_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens_generated_spas.
     */
    cursor?: tokens_generated_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens_generated_spas.
     */
    distinct?: Tokens_generated_spaScalarFieldEnum | Tokens_generated_spaScalarFieldEnum[]
  }

  /**
   * tokens_generated_spa findMany
   */
  export type tokens_generated_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * Filter, which tokens_generated_spas to fetch.
     */
    where?: tokens_generated_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens_generated_spas to fetch.
     */
    orderBy?: tokens_generated_spaOrderByWithRelationInput | tokens_generated_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokens_generated_spas.
     */
    cursor?: tokens_generated_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens_generated_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens_generated_spas.
     */
    skip?: number
    distinct?: Tokens_generated_spaScalarFieldEnum | Tokens_generated_spaScalarFieldEnum[]
  }

  /**
   * tokens_generated_spa create
   */
  export type tokens_generated_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * The data needed to create a tokens_generated_spa.
     */
    data: XOR<tokens_generated_spaCreateInput, tokens_generated_spaUncheckedCreateInput>
  }

  /**
   * tokens_generated_spa createMany
   */
  export type tokens_generated_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tokens_generated_spas.
     */
    data: tokens_generated_spaCreateManyInput | tokens_generated_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens_generated_spa update
   */
  export type tokens_generated_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * The data needed to update a tokens_generated_spa.
     */
    data: XOR<tokens_generated_spaUpdateInput, tokens_generated_spaUncheckedUpdateInput>
    /**
     * Choose, which tokens_generated_spa to update.
     */
    where: tokens_generated_spaWhereUniqueInput
  }

  /**
   * tokens_generated_spa updateMany
   */
  export type tokens_generated_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tokens_generated_spas.
     */
    data: XOR<tokens_generated_spaUpdateManyMutationInput, tokens_generated_spaUncheckedUpdateManyInput>
    /**
     * Filter which tokens_generated_spas to update
     */
    where?: tokens_generated_spaWhereInput
    /**
     * Limit how many tokens_generated_spas to update.
     */
    limit?: number
  }

  /**
   * tokens_generated_spa upsert
   */
  export type tokens_generated_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * The filter to search for the tokens_generated_spa to update in case it exists.
     */
    where: tokens_generated_spaWhereUniqueInput
    /**
     * In case the tokens_generated_spa found by the `where` argument doesn't exist, create a new tokens_generated_spa with this data.
     */
    create: XOR<tokens_generated_spaCreateInput, tokens_generated_spaUncheckedCreateInput>
    /**
     * In case the tokens_generated_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokens_generated_spaUpdateInput, tokens_generated_spaUncheckedUpdateInput>
  }

  /**
   * tokens_generated_spa delete
   */
  export type tokens_generated_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    /**
     * Filter which tokens_generated_spa to delete.
     */
    where: tokens_generated_spaWhereUniqueInput
  }

  /**
   * tokens_generated_spa deleteMany
   */
  export type tokens_generated_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens_generated_spas to delete
     */
    where?: tokens_generated_spaWhereInput
    /**
     * Limit how many tokens_generated_spas to delete.
     */
    limit?: number
  }

  /**
   * tokens_generated_spa without action
   */
  export type tokens_generated_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
  }


  /**
   * Model trainings_links_aut
   */

  export type AggregateTrainings_links_aut = {
    _count: Trainings_links_autCountAggregateOutputType | null
    _min: Trainings_links_autMinAggregateOutputType | null
    _max: Trainings_links_autMaxAggregateOutputType | null
  }

  export type Trainings_links_autMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    training: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trainings_links_autMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    training: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trainings_links_autCountAggregateOutputType = {
    id: number
    user_id: number
    training: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Trainings_links_autMinAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trainings_links_autMaxAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trainings_links_autCountAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Trainings_links_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings_links_aut to aggregate.
     */
    where?: trainings_links_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_auts to fetch.
     */
    orderBy?: trainings_links_autOrderByWithRelationInput | trainings_links_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trainings_links_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trainings_links_auts
    **/
    _count?: true | Trainings_links_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trainings_links_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trainings_links_autMaxAggregateInputType
  }

  export type GetTrainings_links_autAggregateType<T extends Trainings_links_autAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainings_links_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainings_links_aut[P]>
      : GetScalarType<T[P], AggregateTrainings_links_aut[P]>
  }




  export type trainings_links_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainings_links_autWhereInput
    orderBy?: trainings_links_autOrderByWithAggregationInput | trainings_links_autOrderByWithAggregationInput[]
    by: Trainings_links_autScalarFieldEnum[] | Trainings_links_autScalarFieldEnum
    having?: trainings_links_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trainings_links_autCountAggregateInputType | true
    _min?: Trainings_links_autMinAggregateInputType
    _max?: Trainings_links_autMaxAggregateInputType
  }

  export type Trainings_links_autGroupByOutputType = {
    id: string
    user_id: string
    training: string
    createdAt: Date
    updatedAt: Date
    _count: Trainings_links_autCountAggregateOutputType | null
    _min: Trainings_links_autMinAggregateOutputType | null
    _max: Trainings_links_autMaxAggregateOutputType | null
  }

  type GetTrainings_links_autGroupByPayload<T extends trainings_links_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trainings_links_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trainings_links_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trainings_links_autGroupByOutputType[P]>
            : GetScalarType<T[P], Trainings_links_autGroupByOutputType[P]>
        }
      >
    >


  export type trainings_links_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    training?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainings_links_aut"]>



  export type trainings_links_autSelectScalar = {
    id?: boolean
    user_id?: boolean
    training?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type trainings_links_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "training" | "createdAt" | "updatedAt", ExtArgs["result"]["trainings_links_aut"]>
  export type trainings_links_autInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_aut?: boolean | users_autDefaultArgs<ExtArgs>
  }

  export type $trainings_links_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trainings_links_aut"
    objects: {
      users_aut: Prisma.$users_autPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      training: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainings_links_aut"]>
    composites: {}
  }

  type trainings_links_autGetPayload<S extends boolean | null | undefined | trainings_links_autDefaultArgs> = $Result.GetResult<Prisma.$trainings_links_autPayload, S>

  type trainings_links_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trainings_links_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trainings_links_autCountAggregateInputType | true
    }

  export interface trainings_links_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trainings_links_aut'], meta: { name: 'trainings_links_aut' } }
    /**
     * Find zero or one Trainings_links_aut that matches the filter.
     * @param {trainings_links_autFindUniqueArgs} args - Arguments to find a Trainings_links_aut
     * @example
     * // Get one Trainings_links_aut
     * const trainings_links_aut = await prisma.trainings_links_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trainings_links_autFindUniqueArgs>(args: SelectSubset<T, trainings_links_autFindUniqueArgs<ExtArgs>>): Prisma__trainings_links_autClient<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trainings_links_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trainings_links_autFindUniqueOrThrowArgs} args - Arguments to find a Trainings_links_aut
     * @example
     * // Get one Trainings_links_aut
     * const trainings_links_aut = await prisma.trainings_links_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trainings_links_autFindUniqueOrThrowArgs>(args: SelectSubset<T, trainings_links_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trainings_links_autClient<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings_links_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_autFindFirstArgs} args - Arguments to find a Trainings_links_aut
     * @example
     * // Get one Trainings_links_aut
     * const trainings_links_aut = await prisma.trainings_links_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trainings_links_autFindFirstArgs>(args?: SelectSubset<T, trainings_links_autFindFirstArgs<ExtArgs>>): Prisma__trainings_links_autClient<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings_links_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_autFindFirstOrThrowArgs} args - Arguments to find a Trainings_links_aut
     * @example
     * // Get one Trainings_links_aut
     * const trainings_links_aut = await prisma.trainings_links_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trainings_links_autFindFirstOrThrowArgs>(args?: SelectSubset<T, trainings_links_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__trainings_links_autClient<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trainings_links_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings_links_auts
     * const trainings_links_auts = await prisma.trainings_links_aut.findMany()
     * 
     * // Get first 10 Trainings_links_auts
     * const trainings_links_auts = await prisma.trainings_links_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainings_links_autWithIdOnly = await prisma.trainings_links_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trainings_links_autFindManyArgs>(args?: SelectSubset<T, trainings_links_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trainings_links_aut.
     * @param {trainings_links_autCreateArgs} args - Arguments to create a Trainings_links_aut.
     * @example
     * // Create one Trainings_links_aut
     * const Trainings_links_aut = await prisma.trainings_links_aut.create({
     *   data: {
     *     // ... data to create a Trainings_links_aut
     *   }
     * })
     * 
     */
    create<T extends trainings_links_autCreateArgs>(args: SelectSubset<T, trainings_links_autCreateArgs<ExtArgs>>): Prisma__trainings_links_autClient<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trainings_links_auts.
     * @param {trainings_links_autCreateManyArgs} args - Arguments to create many Trainings_links_auts.
     * @example
     * // Create many Trainings_links_auts
     * const trainings_links_aut = await prisma.trainings_links_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trainings_links_autCreateManyArgs>(args?: SelectSubset<T, trainings_links_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trainings_links_aut.
     * @param {trainings_links_autDeleteArgs} args - Arguments to delete one Trainings_links_aut.
     * @example
     * // Delete one Trainings_links_aut
     * const Trainings_links_aut = await prisma.trainings_links_aut.delete({
     *   where: {
     *     // ... filter to delete one Trainings_links_aut
     *   }
     * })
     * 
     */
    delete<T extends trainings_links_autDeleteArgs>(args: SelectSubset<T, trainings_links_autDeleteArgs<ExtArgs>>): Prisma__trainings_links_autClient<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trainings_links_aut.
     * @param {trainings_links_autUpdateArgs} args - Arguments to update one Trainings_links_aut.
     * @example
     * // Update one Trainings_links_aut
     * const trainings_links_aut = await prisma.trainings_links_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trainings_links_autUpdateArgs>(args: SelectSubset<T, trainings_links_autUpdateArgs<ExtArgs>>): Prisma__trainings_links_autClient<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trainings_links_auts.
     * @param {trainings_links_autDeleteManyArgs} args - Arguments to filter Trainings_links_auts to delete.
     * @example
     * // Delete a few Trainings_links_auts
     * const { count } = await prisma.trainings_links_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trainings_links_autDeleteManyArgs>(args?: SelectSubset<T, trainings_links_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings_links_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings_links_auts
     * const trainings_links_aut = await prisma.trainings_links_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trainings_links_autUpdateManyArgs>(args: SelectSubset<T, trainings_links_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trainings_links_aut.
     * @param {trainings_links_autUpsertArgs} args - Arguments to update or create a Trainings_links_aut.
     * @example
     * // Update or create a Trainings_links_aut
     * const trainings_links_aut = await prisma.trainings_links_aut.upsert({
     *   create: {
     *     // ... data to create a Trainings_links_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trainings_links_aut we want to update
     *   }
     * })
     */
    upsert<T extends trainings_links_autUpsertArgs>(args: SelectSubset<T, trainings_links_autUpsertArgs<ExtArgs>>): Prisma__trainings_links_autClient<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trainings_links_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_autCountArgs} args - Arguments to filter Trainings_links_auts to count.
     * @example
     * // Count the number of Trainings_links_auts
     * const count = await prisma.trainings_links_aut.count({
     *   where: {
     *     // ... the filter for the Trainings_links_auts we want to count
     *   }
     * })
    **/
    count<T extends trainings_links_autCountArgs>(
      args?: Subset<T, trainings_links_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trainings_links_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trainings_links_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trainings_links_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trainings_links_autAggregateArgs>(args: Subset<T, Trainings_links_autAggregateArgs>): Prisma.PrismaPromise<GetTrainings_links_autAggregateType<T>>

    /**
     * Group by Trainings_links_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trainings_links_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trainings_links_autGroupByArgs['orderBy'] }
        : { orderBy?: trainings_links_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trainings_links_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainings_links_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trainings_links_aut model
   */
  readonly fields: trainings_links_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trainings_links_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trainings_links_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_aut<T extends users_autDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_autDefaultArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trainings_links_aut model
   */
  interface trainings_links_autFieldRefs {
    readonly id: FieldRef<"trainings_links_aut", 'String'>
    readonly user_id: FieldRef<"trainings_links_aut", 'String'>
    readonly training: FieldRef<"trainings_links_aut", 'String'>
    readonly createdAt: FieldRef<"trainings_links_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"trainings_links_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trainings_links_aut findUnique
   */
  export type trainings_links_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_aut to fetch.
     */
    where: trainings_links_autWhereUniqueInput
  }

  /**
   * trainings_links_aut findUniqueOrThrow
   */
  export type trainings_links_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_aut to fetch.
     */
    where: trainings_links_autWhereUniqueInput
  }

  /**
   * trainings_links_aut findFirst
   */
  export type trainings_links_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_aut to fetch.
     */
    where?: trainings_links_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_auts to fetch.
     */
    orderBy?: trainings_links_autOrderByWithRelationInput | trainings_links_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings_links_auts.
     */
    cursor?: trainings_links_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings_links_auts.
     */
    distinct?: Trainings_links_autScalarFieldEnum | Trainings_links_autScalarFieldEnum[]
  }

  /**
   * trainings_links_aut findFirstOrThrow
   */
  export type trainings_links_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_aut to fetch.
     */
    where?: trainings_links_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_auts to fetch.
     */
    orderBy?: trainings_links_autOrderByWithRelationInput | trainings_links_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings_links_auts.
     */
    cursor?: trainings_links_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings_links_auts.
     */
    distinct?: Trainings_links_autScalarFieldEnum | Trainings_links_autScalarFieldEnum[]
  }

  /**
   * trainings_links_aut findMany
   */
  export type trainings_links_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_auts to fetch.
     */
    where?: trainings_links_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_auts to fetch.
     */
    orderBy?: trainings_links_autOrderByWithRelationInput | trainings_links_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trainings_links_auts.
     */
    cursor?: trainings_links_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_auts.
     */
    skip?: number
    distinct?: Trainings_links_autScalarFieldEnum | Trainings_links_autScalarFieldEnum[]
  }

  /**
   * trainings_links_aut create
   */
  export type trainings_links_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * The data needed to create a trainings_links_aut.
     */
    data: XOR<trainings_links_autCreateInput, trainings_links_autUncheckedCreateInput>
  }

  /**
   * trainings_links_aut createMany
   */
  export type trainings_links_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trainings_links_auts.
     */
    data: trainings_links_autCreateManyInput | trainings_links_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trainings_links_aut update
   */
  export type trainings_links_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * The data needed to update a trainings_links_aut.
     */
    data: XOR<trainings_links_autUpdateInput, trainings_links_autUncheckedUpdateInput>
    /**
     * Choose, which trainings_links_aut to update.
     */
    where: trainings_links_autWhereUniqueInput
  }

  /**
   * trainings_links_aut updateMany
   */
  export type trainings_links_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trainings_links_auts.
     */
    data: XOR<trainings_links_autUpdateManyMutationInput, trainings_links_autUncheckedUpdateManyInput>
    /**
     * Filter which trainings_links_auts to update
     */
    where?: trainings_links_autWhereInput
    /**
     * Limit how many trainings_links_auts to update.
     */
    limit?: number
  }

  /**
   * trainings_links_aut upsert
   */
  export type trainings_links_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * The filter to search for the trainings_links_aut to update in case it exists.
     */
    where: trainings_links_autWhereUniqueInput
    /**
     * In case the trainings_links_aut found by the `where` argument doesn't exist, create a new trainings_links_aut with this data.
     */
    create: XOR<trainings_links_autCreateInput, trainings_links_autUncheckedCreateInput>
    /**
     * In case the trainings_links_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trainings_links_autUpdateInput, trainings_links_autUncheckedUpdateInput>
  }

  /**
   * trainings_links_aut delete
   */
  export type trainings_links_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    /**
     * Filter which trainings_links_aut to delete.
     */
    where: trainings_links_autWhereUniqueInput
  }

  /**
   * trainings_links_aut deleteMany
   */
  export type trainings_links_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings_links_auts to delete
     */
    where?: trainings_links_autWhereInput
    /**
     * Limit how many trainings_links_auts to delete.
     */
    limit?: number
  }

  /**
   * trainings_links_aut without action
   */
  export type trainings_links_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
  }


  /**
   * Model trainings_links_clt
   */

  export type AggregateTrainings_links_clt = {
    _count: Trainings_links_cltCountAggregateOutputType | null
    _min: Trainings_links_cltMinAggregateOutputType | null
    _max: Trainings_links_cltMaxAggregateOutputType | null
  }

  export type Trainings_links_cltMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    training: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trainings_links_cltMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    training: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trainings_links_cltCountAggregateOutputType = {
    id: number
    user_id: number
    training: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Trainings_links_cltMinAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trainings_links_cltMaxAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trainings_links_cltCountAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Trainings_links_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings_links_clt to aggregate.
     */
    where?: trainings_links_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_clts to fetch.
     */
    orderBy?: trainings_links_cltOrderByWithRelationInput | trainings_links_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trainings_links_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trainings_links_clts
    **/
    _count?: true | Trainings_links_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trainings_links_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trainings_links_cltMaxAggregateInputType
  }

  export type GetTrainings_links_cltAggregateType<T extends Trainings_links_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainings_links_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainings_links_clt[P]>
      : GetScalarType<T[P], AggregateTrainings_links_clt[P]>
  }




  export type trainings_links_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainings_links_cltWhereInput
    orderBy?: trainings_links_cltOrderByWithAggregationInput | trainings_links_cltOrderByWithAggregationInput[]
    by: Trainings_links_cltScalarFieldEnum[] | Trainings_links_cltScalarFieldEnum
    having?: trainings_links_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trainings_links_cltCountAggregateInputType | true
    _min?: Trainings_links_cltMinAggregateInputType
    _max?: Trainings_links_cltMaxAggregateInputType
  }

  export type Trainings_links_cltGroupByOutputType = {
    id: string
    user_id: string
    training: string
    createdAt: Date
    updatedAt: Date
    _count: Trainings_links_cltCountAggregateOutputType | null
    _min: Trainings_links_cltMinAggregateOutputType | null
    _max: Trainings_links_cltMaxAggregateOutputType | null
  }

  type GetTrainings_links_cltGroupByPayload<T extends trainings_links_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trainings_links_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trainings_links_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trainings_links_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Trainings_links_cltGroupByOutputType[P]>
        }
      >
    >


  export type trainings_links_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    training?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainings_links_clt"]>



  export type trainings_links_cltSelectScalar = {
    id?: boolean
    user_id?: boolean
    training?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type trainings_links_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "training" | "createdAt" | "updatedAt", ExtArgs["result"]["trainings_links_clt"]>
  export type trainings_links_cltInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_clt?: boolean | users_cltDefaultArgs<ExtArgs>
  }

  export type $trainings_links_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trainings_links_clt"
    objects: {
      users_clt: Prisma.$users_cltPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      training: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainings_links_clt"]>
    composites: {}
  }

  type trainings_links_cltGetPayload<S extends boolean | null | undefined | trainings_links_cltDefaultArgs> = $Result.GetResult<Prisma.$trainings_links_cltPayload, S>

  type trainings_links_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trainings_links_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trainings_links_cltCountAggregateInputType | true
    }

  export interface trainings_links_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trainings_links_clt'], meta: { name: 'trainings_links_clt' } }
    /**
     * Find zero or one Trainings_links_clt that matches the filter.
     * @param {trainings_links_cltFindUniqueArgs} args - Arguments to find a Trainings_links_clt
     * @example
     * // Get one Trainings_links_clt
     * const trainings_links_clt = await prisma.trainings_links_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trainings_links_cltFindUniqueArgs>(args: SelectSubset<T, trainings_links_cltFindUniqueArgs<ExtArgs>>): Prisma__trainings_links_cltClient<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trainings_links_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trainings_links_cltFindUniqueOrThrowArgs} args - Arguments to find a Trainings_links_clt
     * @example
     * // Get one Trainings_links_clt
     * const trainings_links_clt = await prisma.trainings_links_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trainings_links_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, trainings_links_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trainings_links_cltClient<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings_links_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_cltFindFirstArgs} args - Arguments to find a Trainings_links_clt
     * @example
     * // Get one Trainings_links_clt
     * const trainings_links_clt = await prisma.trainings_links_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trainings_links_cltFindFirstArgs>(args?: SelectSubset<T, trainings_links_cltFindFirstArgs<ExtArgs>>): Prisma__trainings_links_cltClient<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings_links_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_cltFindFirstOrThrowArgs} args - Arguments to find a Trainings_links_clt
     * @example
     * // Get one Trainings_links_clt
     * const trainings_links_clt = await prisma.trainings_links_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trainings_links_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, trainings_links_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__trainings_links_cltClient<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trainings_links_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings_links_clts
     * const trainings_links_clts = await prisma.trainings_links_clt.findMany()
     * 
     * // Get first 10 Trainings_links_clts
     * const trainings_links_clts = await prisma.trainings_links_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainings_links_cltWithIdOnly = await prisma.trainings_links_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trainings_links_cltFindManyArgs>(args?: SelectSubset<T, trainings_links_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trainings_links_clt.
     * @param {trainings_links_cltCreateArgs} args - Arguments to create a Trainings_links_clt.
     * @example
     * // Create one Trainings_links_clt
     * const Trainings_links_clt = await prisma.trainings_links_clt.create({
     *   data: {
     *     // ... data to create a Trainings_links_clt
     *   }
     * })
     * 
     */
    create<T extends trainings_links_cltCreateArgs>(args: SelectSubset<T, trainings_links_cltCreateArgs<ExtArgs>>): Prisma__trainings_links_cltClient<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trainings_links_clts.
     * @param {trainings_links_cltCreateManyArgs} args - Arguments to create many Trainings_links_clts.
     * @example
     * // Create many Trainings_links_clts
     * const trainings_links_clt = await prisma.trainings_links_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trainings_links_cltCreateManyArgs>(args?: SelectSubset<T, trainings_links_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trainings_links_clt.
     * @param {trainings_links_cltDeleteArgs} args - Arguments to delete one Trainings_links_clt.
     * @example
     * // Delete one Trainings_links_clt
     * const Trainings_links_clt = await prisma.trainings_links_clt.delete({
     *   where: {
     *     // ... filter to delete one Trainings_links_clt
     *   }
     * })
     * 
     */
    delete<T extends trainings_links_cltDeleteArgs>(args: SelectSubset<T, trainings_links_cltDeleteArgs<ExtArgs>>): Prisma__trainings_links_cltClient<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trainings_links_clt.
     * @param {trainings_links_cltUpdateArgs} args - Arguments to update one Trainings_links_clt.
     * @example
     * // Update one Trainings_links_clt
     * const trainings_links_clt = await prisma.trainings_links_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trainings_links_cltUpdateArgs>(args: SelectSubset<T, trainings_links_cltUpdateArgs<ExtArgs>>): Prisma__trainings_links_cltClient<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trainings_links_clts.
     * @param {trainings_links_cltDeleteManyArgs} args - Arguments to filter Trainings_links_clts to delete.
     * @example
     * // Delete a few Trainings_links_clts
     * const { count } = await prisma.trainings_links_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trainings_links_cltDeleteManyArgs>(args?: SelectSubset<T, trainings_links_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings_links_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings_links_clts
     * const trainings_links_clt = await prisma.trainings_links_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trainings_links_cltUpdateManyArgs>(args: SelectSubset<T, trainings_links_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trainings_links_clt.
     * @param {trainings_links_cltUpsertArgs} args - Arguments to update or create a Trainings_links_clt.
     * @example
     * // Update or create a Trainings_links_clt
     * const trainings_links_clt = await prisma.trainings_links_clt.upsert({
     *   create: {
     *     // ... data to create a Trainings_links_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trainings_links_clt we want to update
     *   }
     * })
     */
    upsert<T extends trainings_links_cltUpsertArgs>(args: SelectSubset<T, trainings_links_cltUpsertArgs<ExtArgs>>): Prisma__trainings_links_cltClient<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trainings_links_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_cltCountArgs} args - Arguments to filter Trainings_links_clts to count.
     * @example
     * // Count the number of Trainings_links_clts
     * const count = await prisma.trainings_links_clt.count({
     *   where: {
     *     // ... the filter for the Trainings_links_clts we want to count
     *   }
     * })
    **/
    count<T extends trainings_links_cltCountArgs>(
      args?: Subset<T, trainings_links_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trainings_links_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trainings_links_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trainings_links_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trainings_links_cltAggregateArgs>(args: Subset<T, Trainings_links_cltAggregateArgs>): Prisma.PrismaPromise<GetTrainings_links_cltAggregateType<T>>

    /**
     * Group by Trainings_links_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trainings_links_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trainings_links_cltGroupByArgs['orderBy'] }
        : { orderBy?: trainings_links_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trainings_links_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainings_links_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trainings_links_clt model
   */
  readonly fields: trainings_links_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trainings_links_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trainings_links_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_clt<T extends users_cltDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_cltDefaultArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trainings_links_clt model
   */
  interface trainings_links_cltFieldRefs {
    readonly id: FieldRef<"trainings_links_clt", 'String'>
    readonly user_id: FieldRef<"trainings_links_clt", 'String'>
    readonly training: FieldRef<"trainings_links_clt", 'String'>
    readonly createdAt: FieldRef<"trainings_links_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"trainings_links_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trainings_links_clt findUnique
   */
  export type trainings_links_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_clt to fetch.
     */
    where: trainings_links_cltWhereUniqueInput
  }

  /**
   * trainings_links_clt findUniqueOrThrow
   */
  export type trainings_links_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_clt to fetch.
     */
    where: trainings_links_cltWhereUniqueInput
  }

  /**
   * trainings_links_clt findFirst
   */
  export type trainings_links_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_clt to fetch.
     */
    where?: trainings_links_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_clts to fetch.
     */
    orderBy?: trainings_links_cltOrderByWithRelationInput | trainings_links_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings_links_clts.
     */
    cursor?: trainings_links_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings_links_clts.
     */
    distinct?: Trainings_links_cltScalarFieldEnum | Trainings_links_cltScalarFieldEnum[]
  }

  /**
   * trainings_links_clt findFirstOrThrow
   */
  export type trainings_links_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_clt to fetch.
     */
    where?: trainings_links_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_clts to fetch.
     */
    orderBy?: trainings_links_cltOrderByWithRelationInput | trainings_links_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings_links_clts.
     */
    cursor?: trainings_links_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings_links_clts.
     */
    distinct?: Trainings_links_cltScalarFieldEnum | Trainings_links_cltScalarFieldEnum[]
  }

  /**
   * trainings_links_clt findMany
   */
  export type trainings_links_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_clts to fetch.
     */
    where?: trainings_links_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_clts to fetch.
     */
    orderBy?: trainings_links_cltOrderByWithRelationInput | trainings_links_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trainings_links_clts.
     */
    cursor?: trainings_links_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_clts.
     */
    skip?: number
    distinct?: Trainings_links_cltScalarFieldEnum | Trainings_links_cltScalarFieldEnum[]
  }

  /**
   * trainings_links_clt create
   */
  export type trainings_links_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * The data needed to create a trainings_links_clt.
     */
    data: XOR<trainings_links_cltCreateInput, trainings_links_cltUncheckedCreateInput>
  }

  /**
   * trainings_links_clt createMany
   */
  export type trainings_links_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trainings_links_clts.
     */
    data: trainings_links_cltCreateManyInput | trainings_links_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trainings_links_clt update
   */
  export type trainings_links_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * The data needed to update a trainings_links_clt.
     */
    data: XOR<trainings_links_cltUpdateInput, trainings_links_cltUncheckedUpdateInput>
    /**
     * Choose, which trainings_links_clt to update.
     */
    where: trainings_links_cltWhereUniqueInput
  }

  /**
   * trainings_links_clt updateMany
   */
  export type trainings_links_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trainings_links_clts.
     */
    data: XOR<trainings_links_cltUpdateManyMutationInput, trainings_links_cltUncheckedUpdateManyInput>
    /**
     * Filter which trainings_links_clts to update
     */
    where?: trainings_links_cltWhereInput
    /**
     * Limit how many trainings_links_clts to update.
     */
    limit?: number
  }

  /**
   * trainings_links_clt upsert
   */
  export type trainings_links_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * The filter to search for the trainings_links_clt to update in case it exists.
     */
    where: trainings_links_cltWhereUniqueInput
    /**
     * In case the trainings_links_clt found by the `where` argument doesn't exist, create a new trainings_links_clt with this data.
     */
    create: XOR<trainings_links_cltCreateInput, trainings_links_cltUncheckedCreateInput>
    /**
     * In case the trainings_links_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trainings_links_cltUpdateInput, trainings_links_cltUncheckedUpdateInput>
  }

  /**
   * trainings_links_clt delete
   */
  export type trainings_links_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    /**
     * Filter which trainings_links_clt to delete.
     */
    where: trainings_links_cltWhereUniqueInput
  }

  /**
   * trainings_links_clt deleteMany
   */
  export type trainings_links_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings_links_clts to delete
     */
    where?: trainings_links_cltWhereInput
    /**
     * Limit how many trainings_links_clts to delete.
     */
    limit?: number
  }

  /**
   * trainings_links_clt without action
   */
  export type trainings_links_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
  }


  /**
   * Model trainings_links_goi
   */

  export type AggregateTrainings_links_goi = {
    _count: Trainings_links_goiCountAggregateOutputType | null
    _min: Trainings_links_goiMinAggregateOutputType | null
    _max: Trainings_links_goiMaxAggregateOutputType | null
  }

  export type Trainings_links_goiMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    training: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trainings_links_goiMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    training: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trainings_links_goiCountAggregateOutputType = {
    id: number
    user_id: number
    training: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Trainings_links_goiMinAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trainings_links_goiMaxAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trainings_links_goiCountAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Trainings_links_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings_links_goi to aggregate.
     */
    where?: trainings_links_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_gois to fetch.
     */
    orderBy?: trainings_links_goiOrderByWithRelationInput | trainings_links_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trainings_links_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trainings_links_gois
    **/
    _count?: true | Trainings_links_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trainings_links_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trainings_links_goiMaxAggregateInputType
  }

  export type GetTrainings_links_goiAggregateType<T extends Trainings_links_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainings_links_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainings_links_goi[P]>
      : GetScalarType<T[P], AggregateTrainings_links_goi[P]>
  }




  export type trainings_links_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainings_links_goiWhereInput
    orderBy?: trainings_links_goiOrderByWithAggregationInput | trainings_links_goiOrderByWithAggregationInput[]
    by: Trainings_links_goiScalarFieldEnum[] | Trainings_links_goiScalarFieldEnum
    having?: trainings_links_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trainings_links_goiCountAggregateInputType | true
    _min?: Trainings_links_goiMinAggregateInputType
    _max?: Trainings_links_goiMaxAggregateInputType
  }

  export type Trainings_links_goiGroupByOutputType = {
    id: string
    user_id: string
    training: string
    createdAt: Date
    updatedAt: Date
    _count: Trainings_links_goiCountAggregateOutputType | null
    _min: Trainings_links_goiMinAggregateOutputType | null
    _max: Trainings_links_goiMaxAggregateOutputType | null
  }

  type GetTrainings_links_goiGroupByPayload<T extends trainings_links_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trainings_links_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trainings_links_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trainings_links_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Trainings_links_goiGroupByOutputType[P]>
        }
      >
    >


  export type trainings_links_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    training?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainings_links_goi"]>



  export type trainings_links_goiSelectScalar = {
    id?: boolean
    user_id?: boolean
    training?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type trainings_links_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "training" | "createdAt" | "updatedAt", ExtArgs["result"]["trainings_links_goi"]>
  export type trainings_links_goiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_goi?: boolean | users_goiDefaultArgs<ExtArgs>
  }

  export type $trainings_links_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trainings_links_goi"
    objects: {
      users_goi: Prisma.$users_goiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      training: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainings_links_goi"]>
    composites: {}
  }

  type trainings_links_goiGetPayload<S extends boolean | null | undefined | trainings_links_goiDefaultArgs> = $Result.GetResult<Prisma.$trainings_links_goiPayload, S>

  type trainings_links_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trainings_links_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trainings_links_goiCountAggregateInputType | true
    }

  export interface trainings_links_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trainings_links_goi'], meta: { name: 'trainings_links_goi' } }
    /**
     * Find zero or one Trainings_links_goi that matches the filter.
     * @param {trainings_links_goiFindUniqueArgs} args - Arguments to find a Trainings_links_goi
     * @example
     * // Get one Trainings_links_goi
     * const trainings_links_goi = await prisma.trainings_links_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trainings_links_goiFindUniqueArgs>(args: SelectSubset<T, trainings_links_goiFindUniqueArgs<ExtArgs>>): Prisma__trainings_links_goiClient<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trainings_links_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trainings_links_goiFindUniqueOrThrowArgs} args - Arguments to find a Trainings_links_goi
     * @example
     * // Get one Trainings_links_goi
     * const trainings_links_goi = await prisma.trainings_links_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trainings_links_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, trainings_links_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trainings_links_goiClient<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings_links_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_goiFindFirstArgs} args - Arguments to find a Trainings_links_goi
     * @example
     * // Get one Trainings_links_goi
     * const trainings_links_goi = await prisma.trainings_links_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trainings_links_goiFindFirstArgs>(args?: SelectSubset<T, trainings_links_goiFindFirstArgs<ExtArgs>>): Prisma__trainings_links_goiClient<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings_links_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_goiFindFirstOrThrowArgs} args - Arguments to find a Trainings_links_goi
     * @example
     * // Get one Trainings_links_goi
     * const trainings_links_goi = await prisma.trainings_links_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trainings_links_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, trainings_links_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__trainings_links_goiClient<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trainings_links_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings_links_gois
     * const trainings_links_gois = await prisma.trainings_links_goi.findMany()
     * 
     * // Get first 10 Trainings_links_gois
     * const trainings_links_gois = await prisma.trainings_links_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainings_links_goiWithIdOnly = await prisma.trainings_links_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trainings_links_goiFindManyArgs>(args?: SelectSubset<T, trainings_links_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trainings_links_goi.
     * @param {trainings_links_goiCreateArgs} args - Arguments to create a Trainings_links_goi.
     * @example
     * // Create one Trainings_links_goi
     * const Trainings_links_goi = await prisma.trainings_links_goi.create({
     *   data: {
     *     // ... data to create a Trainings_links_goi
     *   }
     * })
     * 
     */
    create<T extends trainings_links_goiCreateArgs>(args: SelectSubset<T, trainings_links_goiCreateArgs<ExtArgs>>): Prisma__trainings_links_goiClient<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trainings_links_gois.
     * @param {trainings_links_goiCreateManyArgs} args - Arguments to create many Trainings_links_gois.
     * @example
     * // Create many Trainings_links_gois
     * const trainings_links_goi = await prisma.trainings_links_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trainings_links_goiCreateManyArgs>(args?: SelectSubset<T, trainings_links_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trainings_links_goi.
     * @param {trainings_links_goiDeleteArgs} args - Arguments to delete one Trainings_links_goi.
     * @example
     * // Delete one Trainings_links_goi
     * const Trainings_links_goi = await prisma.trainings_links_goi.delete({
     *   where: {
     *     // ... filter to delete one Trainings_links_goi
     *   }
     * })
     * 
     */
    delete<T extends trainings_links_goiDeleteArgs>(args: SelectSubset<T, trainings_links_goiDeleteArgs<ExtArgs>>): Prisma__trainings_links_goiClient<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trainings_links_goi.
     * @param {trainings_links_goiUpdateArgs} args - Arguments to update one Trainings_links_goi.
     * @example
     * // Update one Trainings_links_goi
     * const trainings_links_goi = await prisma.trainings_links_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trainings_links_goiUpdateArgs>(args: SelectSubset<T, trainings_links_goiUpdateArgs<ExtArgs>>): Prisma__trainings_links_goiClient<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trainings_links_gois.
     * @param {trainings_links_goiDeleteManyArgs} args - Arguments to filter Trainings_links_gois to delete.
     * @example
     * // Delete a few Trainings_links_gois
     * const { count } = await prisma.trainings_links_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trainings_links_goiDeleteManyArgs>(args?: SelectSubset<T, trainings_links_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings_links_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings_links_gois
     * const trainings_links_goi = await prisma.trainings_links_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trainings_links_goiUpdateManyArgs>(args: SelectSubset<T, trainings_links_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trainings_links_goi.
     * @param {trainings_links_goiUpsertArgs} args - Arguments to update or create a Trainings_links_goi.
     * @example
     * // Update or create a Trainings_links_goi
     * const trainings_links_goi = await prisma.trainings_links_goi.upsert({
     *   create: {
     *     // ... data to create a Trainings_links_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trainings_links_goi we want to update
     *   }
     * })
     */
    upsert<T extends trainings_links_goiUpsertArgs>(args: SelectSubset<T, trainings_links_goiUpsertArgs<ExtArgs>>): Prisma__trainings_links_goiClient<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trainings_links_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_goiCountArgs} args - Arguments to filter Trainings_links_gois to count.
     * @example
     * // Count the number of Trainings_links_gois
     * const count = await prisma.trainings_links_goi.count({
     *   where: {
     *     // ... the filter for the Trainings_links_gois we want to count
     *   }
     * })
    **/
    count<T extends trainings_links_goiCountArgs>(
      args?: Subset<T, trainings_links_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trainings_links_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trainings_links_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trainings_links_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trainings_links_goiAggregateArgs>(args: Subset<T, Trainings_links_goiAggregateArgs>): Prisma.PrismaPromise<GetTrainings_links_goiAggregateType<T>>

    /**
     * Group by Trainings_links_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trainings_links_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trainings_links_goiGroupByArgs['orderBy'] }
        : { orderBy?: trainings_links_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trainings_links_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainings_links_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trainings_links_goi model
   */
  readonly fields: trainings_links_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trainings_links_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trainings_links_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_goi<T extends users_goiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_goiDefaultArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trainings_links_goi model
   */
  interface trainings_links_goiFieldRefs {
    readonly id: FieldRef<"trainings_links_goi", 'String'>
    readonly user_id: FieldRef<"trainings_links_goi", 'String'>
    readonly training: FieldRef<"trainings_links_goi", 'String'>
    readonly createdAt: FieldRef<"trainings_links_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"trainings_links_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trainings_links_goi findUnique
   */
  export type trainings_links_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_goi to fetch.
     */
    where: trainings_links_goiWhereUniqueInput
  }

  /**
   * trainings_links_goi findUniqueOrThrow
   */
  export type trainings_links_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_goi to fetch.
     */
    where: trainings_links_goiWhereUniqueInput
  }

  /**
   * trainings_links_goi findFirst
   */
  export type trainings_links_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_goi to fetch.
     */
    where?: trainings_links_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_gois to fetch.
     */
    orderBy?: trainings_links_goiOrderByWithRelationInput | trainings_links_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings_links_gois.
     */
    cursor?: trainings_links_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings_links_gois.
     */
    distinct?: Trainings_links_goiScalarFieldEnum | Trainings_links_goiScalarFieldEnum[]
  }

  /**
   * trainings_links_goi findFirstOrThrow
   */
  export type trainings_links_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_goi to fetch.
     */
    where?: trainings_links_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_gois to fetch.
     */
    orderBy?: trainings_links_goiOrderByWithRelationInput | trainings_links_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings_links_gois.
     */
    cursor?: trainings_links_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings_links_gois.
     */
    distinct?: Trainings_links_goiScalarFieldEnum | Trainings_links_goiScalarFieldEnum[]
  }

  /**
   * trainings_links_goi findMany
   */
  export type trainings_links_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_gois to fetch.
     */
    where?: trainings_links_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_gois to fetch.
     */
    orderBy?: trainings_links_goiOrderByWithRelationInput | trainings_links_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trainings_links_gois.
     */
    cursor?: trainings_links_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_gois.
     */
    skip?: number
    distinct?: Trainings_links_goiScalarFieldEnum | Trainings_links_goiScalarFieldEnum[]
  }

  /**
   * trainings_links_goi create
   */
  export type trainings_links_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * The data needed to create a trainings_links_goi.
     */
    data: XOR<trainings_links_goiCreateInput, trainings_links_goiUncheckedCreateInput>
  }

  /**
   * trainings_links_goi createMany
   */
  export type trainings_links_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trainings_links_gois.
     */
    data: trainings_links_goiCreateManyInput | trainings_links_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trainings_links_goi update
   */
  export type trainings_links_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * The data needed to update a trainings_links_goi.
     */
    data: XOR<trainings_links_goiUpdateInput, trainings_links_goiUncheckedUpdateInput>
    /**
     * Choose, which trainings_links_goi to update.
     */
    where: trainings_links_goiWhereUniqueInput
  }

  /**
   * trainings_links_goi updateMany
   */
  export type trainings_links_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trainings_links_gois.
     */
    data: XOR<trainings_links_goiUpdateManyMutationInput, trainings_links_goiUncheckedUpdateManyInput>
    /**
     * Filter which trainings_links_gois to update
     */
    where?: trainings_links_goiWhereInput
    /**
     * Limit how many trainings_links_gois to update.
     */
    limit?: number
  }

  /**
   * trainings_links_goi upsert
   */
  export type trainings_links_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * The filter to search for the trainings_links_goi to update in case it exists.
     */
    where: trainings_links_goiWhereUniqueInput
    /**
     * In case the trainings_links_goi found by the `where` argument doesn't exist, create a new trainings_links_goi with this data.
     */
    create: XOR<trainings_links_goiCreateInput, trainings_links_goiUncheckedCreateInput>
    /**
     * In case the trainings_links_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trainings_links_goiUpdateInput, trainings_links_goiUncheckedUpdateInput>
  }

  /**
   * trainings_links_goi delete
   */
  export type trainings_links_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    /**
     * Filter which trainings_links_goi to delete.
     */
    where: trainings_links_goiWhereUniqueInput
  }

  /**
   * trainings_links_goi deleteMany
   */
  export type trainings_links_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings_links_gois to delete
     */
    where?: trainings_links_goiWhereInput
    /**
     * Limit how many trainings_links_gois to delete.
     */
    limit?: number
  }

  /**
   * trainings_links_goi without action
   */
  export type trainings_links_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
  }


  /**
   * Model trainings_links_spa
   */

  export type AggregateTrainings_links_spa = {
    _count: Trainings_links_spaCountAggregateOutputType | null
    _min: Trainings_links_spaMinAggregateOutputType | null
    _max: Trainings_links_spaMaxAggregateOutputType | null
  }

  export type Trainings_links_spaMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    training: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trainings_links_spaMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    training: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Trainings_links_spaCountAggregateOutputType = {
    id: number
    user_id: number
    training: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Trainings_links_spaMinAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trainings_links_spaMaxAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Trainings_links_spaCountAggregateInputType = {
    id?: true
    user_id?: true
    training?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Trainings_links_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings_links_spa to aggregate.
     */
    where?: trainings_links_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_spas to fetch.
     */
    orderBy?: trainings_links_spaOrderByWithRelationInput | trainings_links_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trainings_links_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trainings_links_spas
    **/
    _count?: true | Trainings_links_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trainings_links_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trainings_links_spaMaxAggregateInputType
  }

  export type GetTrainings_links_spaAggregateType<T extends Trainings_links_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainings_links_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainings_links_spa[P]>
      : GetScalarType<T[P], AggregateTrainings_links_spa[P]>
  }




  export type trainings_links_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainings_links_spaWhereInput
    orderBy?: trainings_links_spaOrderByWithAggregationInput | trainings_links_spaOrderByWithAggregationInput[]
    by: Trainings_links_spaScalarFieldEnum[] | Trainings_links_spaScalarFieldEnum
    having?: trainings_links_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trainings_links_spaCountAggregateInputType | true
    _min?: Trainings_links_spaMinAggregateInputType
    _max?: Trainings_links_spaMaxAggregateInputType
  }

  export type Trainings_links_spaGroupByOutputType = {
    id: string
    user_id: string
    training: string
    createdAt: Date
    updatedAt: Date
    _count: Trainings_links_spaCountAggregateOutputType | null
    _min: Trainings_links_spaMinAggregateOutputType | null
    _max: Trainings_links_spaMaxAggregateOutputType | null
  }

  type GetTrainings_links_spaGroupByPayload<T extends trainings_links_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trainings_links_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trainings_links_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trainings_links_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Trainings_links_spaGroupByOutputType[P]>
        }
      >
    >


  export type trainings_links_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    training?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainings_links_spa"]>



  export type trainings_links_spaSelectScalar = {
    id?: boolean
    user_id?: boolean
    training?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type trainings_links_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "training" | "createdAt" | "updatedAt", ExtArgs["result"]["trainings_links_spa"]>
  export type trainings_links_spaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_spa?: boolean | users_spaDefaultArgs<ExtArgs>
  }

  export type $trainings_links_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trainings_links_spa"
    objects: {
      users_spa: Prisma.$users_spaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      training: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainings_links_spa"]>
    composites: {}
  }

  type trainings_links_spaGetPayload<S extends boolean | null | undefined | trainings_links_spaDefaultArgs> = $Result.GetResult<Prisma.$trainings_links_spaPayload, S>

  type trainings_links_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trainings_links_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trainings_links_spaCountAggregateInputType | true
    }

  export interface trainings_links_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trainings_links_spa'], meta: { name: 'trainings_links_spa' } }
    /**
     * Find zero or one Trainings_links_spa that matches the filter.
     * @param {trainings_links_spaFindUniqueArgs} args - Arguments to find a Trainings_links_spa
     * @example
     * // Get one Trainings_links_spa
     * const trainings_links_spa = await prisma.trainings_links_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trainings_links_spaFindUniqueArgs>(args: SelectSubset<T, trainings_links_spaFindUniqueArgs<ExtArgs>>): Prisma__trainings_links_spaClient<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trainings_links_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trainings_links_spaFindUniqueOrThrowArgs} args - Arguments to find a Trainings_links_spa
     * @example
     * // Get one Trainings_links_spa
     * const trainings_links_spa = await prisma.trainings_links_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trainings_links_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, trainings_links_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trainings_links_spaClient<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings_links_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_spaFindFirstArgs} args - Arguments to find a Trainings_links_spa
     * @example
     * // Get one Trainings_links_spa
     * const trainings_links_spa = await prisma.trainings_links_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trainings_links_spaFindFirstArgs>(args?: SelectSubset<T, trainings_links_spaFindFirstArgs<ExtArgs>>): Prisma__trainings_links_spaClient<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings_links_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_spaFindFirstOrThrowArgs} args - Arguments to find a Trainings_links_spa
     * @example
     * // Get one Trainings_links_spa
     * const trainings_links_spa = await prisma.trainings_links_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trainings_links_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, trainings_links_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__trainings_links_spaClient<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trainings_links_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings_links_spas
     * const trainings_links_spas = await prisma.trainings_links_spa.findMany()
     * 
     * // Get first 10 Trainings_links_spas
     * const trainings_links_spas = await prisma.trainings_links_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainings_links_spaWithIdOnly = await prisma.trainings_links_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trainings_links_spaFindManyArgs>(args?: SelectSubset<T, trainings_links_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trainings_links_spa.
     * @param {trainings_links_spaCreateArgs} args - Arguments to create a Trainings_links_spa.
     * @example
     * // Create one Trainings_links_spa
     * const Trainings_links_spa = await prisma.trainings_links_spa.create({
     *   data: {
     *     // ... data to create a Trainings_links_spa
     *   }
     * })
     * 
     */
    create<T extends trainings_links_spaCreateArgs>(args: SelectSubset<T, trainings_links_spaCreateArgs<ExtArgs>>): Prisma__trainings_links_spaClient<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trainings_links_spas.
     * @param {trainings_links_spaCreateManyArgs} args - Arguments to create many Trainings_links_spas.
     * @example
     * // Create many Trainings_links_spas
     * const trainings_links_spa = await prisma.trainings_links_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trainings_links_spaCreateManyArgs>(args?: SelectSubset<T, trainings_links_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trainings_links_spa.
     * @param {trainings_links_spaDeleteArgs} args - Arguments to delete one Trainings_links_spa.
     * @example
     * // Delete one Trainings_links_spa
     * const Trainings_links_spa = await prisma.trainings_links_spa.delete({
     *   where: {
     *     // ... filter to delete one Trainings_links_spa
     *   }
     * })
     * 
     */
    delete<T extends trainings_links_spaDeleteArgs>(args: SelectSubset<T, trainings_links_spaDeleteArgs<ExtArgs>>): Prisma__trainings_links_spaClient<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trainings_links_spa.
     * @param {trainings_links_spaUpdateArgs} args - Arguments to update one Trainings_links_spa.
     * @example
     * // Update one Trainings_links_spa
     * const trainings_links_spa = await prisma.trainings_links_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trainings_links_spaUpdateArgs>(args: SelectSubset<T, trainings_links_spaUpdateArgs<ExtArgs>>): Prisma__trainings_links_spaClient<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trainings_links_spas.
     * @param {trainings_links_spaDeleteManyArgs} args - Arguments to filter Trainings_links_spas to delete.
     * @example
     * // Delete a few Trainings_links_spas
     * const { count } = await prisma.trainings_links_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trainings_links_spaDeleteManyArgs>(args?: SelectSubset<T, trainings_links_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings_links_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings_links_spas
     * const trainings_links_spa = await prisma.trainings_links_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trainings_links_spaUpdateManyArgs>(args: SelectSubset<T, trainings_links_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trainings_links_spa.
     * @param {trainings_links_spaUpsertArgs} args - Arguments to update or create a Trainings_links_spa.
     * @example
     * // Update or create a Trainings_links_spa
     * const trainings_links_spa = await prisma.trainings_links_spa.upsert({
     *   create: {
     *     // ... data to create a Trainings_links_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trainings_links_spa we want to update
     *   }
     * })
     */
    upsert<T extends trainings_links_spaUpsertArgs>(args: SelectSubset<T, trainings_links_spaUpsertArgs<ExtArgs>>): Prisma__trainings_links_spaClient<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trainings_links_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_spaCountArgs} args - Arguments to filter Trainings_links_spas to count.
     * @example
     * // Count the number of Trainings_links_spas
     * const count = await prisma.trainings_links_spa.count({
     *   where: {
     *     // ... the filter for the Trainings_links_spas we want to count
     *   }
     * })
    **/
    count<T extends trainings_links_spaCountArgs>(
      args?: Subset<T, trainings_links_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trainings_links_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trainings_links_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trainings_links_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trainings_links_spaAggregateArgs>(args: Subset<T, Trainings_links_spaAggregateArgs>): Prisma.PrismaPromise<GetTrainings_links_spaAggregateType<T>>

    /**
     * Group by Trainings_links_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainings_links_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trainings_links_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trainings_links_spaGroupByArgs['orderBy'] }
        : { orderBy?: trainings_links_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trainings_links_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainings_links_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trainings_links_spa model
   */
  readonly fields: trainings_links_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trainings_links_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trainings_links_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_spa<T extends users_spaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_spaDefaultArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trainings_links_spa model
   */
  interface trainings_links_spaFieldRefs {
    readonly id: FieldRef<"trainings_links_spa", 'String'>
    readonly user_id: FieldRef<"trainings_links_spa", 'String'>
    readonly training: FieldRef<"trainings_links_spa", 'String'>
    readonly createdAt: FieldRef<"trainings_links_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"trainings_links_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trainings_links_spa findUnique
   */
  export type trainings_links_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_spa to fetch.
     */
    where: trainings_links_spaWhereUniqueInput
  }

  /**
   * trainings_links_spa findUniqueOrThrow
   */
  export type trainings_links_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_spa to fetch.
     */
    where: trainings_links_spaWhereUniqueInput
  }

  /**
   * trainings_links_spa findFirst
   */
  export type trainings_links_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_spa to fetch.
     */
    where?: trainings_links_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_spas to fetch.
     */
    orderBy?: trainings_links_spaOrderByWithRelationInput | trainings_links_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings_links_spas.
     */
    cursor?: trainings_links_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings_links_spas.
     */
    distinct?: Trainings_links_spaScalarFieldEnum | Trainings_links_spaScalarFieldEnum[]
  }

  /**
   * trainings_links_spa findFirstOrThrow
   */
  export type trainings_links_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_spa to fetch.
     */
    where?: trainings_links_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_spas to fetch.
     */
    orderBy?: trainings_links_spaOrderByWithRelationInput | trainings_links_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings_links_spas.
     */
    cursor?: trainings_links_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings_links_spas.
     */
    distinct?: Trainings_links_spaScalarFieldEnum | Trainings_links_spaScalarFieldEnum[]
  }

  /**
   * trainings_links_spa findMany
   */
  export type trainings_links_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * Filter, which trainings_links_spas to fetch.
     */
    where?: trainings_links_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings_links_spas to fetch.
     */
    orderBy?: trainings_links_spaOrderByWithRelationInput | trainings_links_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trainings_links_spas.
     */
    cursor?: trainings_links_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings_links_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings_links_spas.
     */
    skip?: number
    distinct?: Trainings_links_spaScalarFieldEnum | Trainings_links_spaScalarFieldEnum[]
  }

  /**
   * trainings_links_spa create
   */
  export type trainings_links_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * The data needed to create a trainings_links_spa.
     */
    data: XOR<trainings_links_spaCreateInput, trainings_links_spaUncheckedCreateInput>
  }

  /**
   * trainings_links_spa createMany
   */
  export type trainings_links_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trainings_links_spas.
     */
    data: trainings_links_spaCreateManyInput | trainings_links_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trainings_links_spa update
   */
  export type trainings_links_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * The data needed to update a trainings_links_spa.
     */
    data: XOR<trainings_links_spaUpdateInput, trainings_links_spaUncheckedUpdateInput>
    /**
     * Choose, which trainings_links_spa to update.
     */
    where: trainings_links_spaWhereUniqueInput
  }

  /**
   * trainings_links_spa updateMany
   */
  export type trainings_links_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trainings_links_spas.
     */
    data: XOR<trainings_links_spaUpdateManyMutationInput, trainings_links_spaUncheckedUpdateManyInput>
    /**
     * Filter which trainings_links_spas to update
     */
    where?: trainings_links_spaWhereInput
    /**
     * Limit how many trainings_links_spas to update.
     */
    limit?: number
  }

  /**
   * trainings_links_spa upsert
   */
  export type trainings_links_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * The filter to search for the trainings_links_spa to update in case it exists.
     */
    where: trainings_links_spaWhereUniqueInput
    /**
     * In case the trainings_links_spa found by the `where` argument doesn't exist, create a new trainings_links_spa with this data.
     */
    create: XOR<trainings_links_spaCreateInput, trainings_links_spaUncheckedCreateInput>
    /**
     * In case the trainings_links_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trainings_links_spaUpdateInput, trainings_links_spaUncheckedUpdateInput>
  }

  /**
   * trainings_links_spa delete
   */
  export type trainings_links_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    /**
     * Filter which trainings_links_spa to delete.
     */
    where: trainings_links_spaWhereUniqueInput
  }

  /**
   * trainings_links_spa deleteMany
   */
  export type trainings_links_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings_links_spas to delete
     */
    where?: trainings_links_spaWhereInput
    /**
     * Limit how many trainings_links_spas to delete.
     */
    limit?: number
  }

  /**
   * trainings_links_spa without action
   */
  export type trainings_links_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
  }


  /**
   * Model users_aut
   */

  export type AggregateUsers_aut = {
    _count: Users_autCountAggregateOutputType | null
    _avg: Users_autAvgAggregateOutputType | null
    _sum: Users_autSumAggregateOutputType | null
    _min: Users_autMinAggregateOutputType | null
    _max: Users_autMaxAggregateOutputType | null
  }

  export type Users_autAvgAggregateOutputType = {
    phone_number: number | null
  }

  export type Users_autSumAggregateOutputType = {
    phone_number: bigint | null
  }

  export type Users_autMinAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    last_session_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_autMaxAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    last_session_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_autCountAggregateOutputType = {
    id: number
    phone_number: number
    last_session_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Users_autAvgAggregateInputType = {
    phone_number?: true
  }

  export type Users_autSumAggregateInputType = {
    phone_number?: true
  }

  export type Users_autMinAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_autMaxAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_autCountAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Users_autAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_aut to aggregate.
     */
    where?: users_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_auts to fetch.
     */
    orderBy?: users_autOrderByWithRelationInput | users_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_auts
    **/
    _count?: true | Users_autCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_autAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_autSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_autMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_autMaxAggregateInputType
  }

  export type GetUsers_autAggregateType<T extends Users_autAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_aut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_aut[P]>
      : GetScalarType<T[P], AggregateUsers_aut[P]>
  }




  export type users_autGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_autWhereInput
    orderBy?: users_autOrderByWithAggregationInput | users_autOrderByWithAggregationInput[]
    by: Users_autScalarFieldEnum[] | Users_autScalarFieldEnum
    having?: users_autScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_autCountAggregateInputType | true
    _avg?: Users_autAvgAggregateInputType
    _sum?: Users_autSumAggregateInputType
    _min?: Users_autMinAggregateInputType
    _max?: Users_autMaxAggregateInputType
  }

  export type Users_autGroupByOutputType = {
    id: string
    phone_number: bigint
    last_session_id: string | null
    createdAt: Date
    updatedAt: Date
    _count: Users_autCountAggregateOutputType | null
    _avg: Users_autAvgAggregateOutputType | null
    _sum: Users_autSumAggregateOutputType | null
    _min: Users_autMinAggregateOutputType | null
    _max: Users_autMaxAggregateOutputType | null
  }

  type GetUsers_autGroupByPayload<T extends users_autGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_autGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_autGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_autGroupByOutputType[P]>
            : GetScalarType<T[P], Users_autGroupByOutputType[P]>
        }
      >
    >


  export type users_autSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    last_session_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget_consults_aut?: boolean | users_aut$budget_consults_autArgs<ExtArgs>
    cpf_consults_aut?: boolean | users_aut$cpf_consults_autArgs<ExtArgs>
    quote_calculations_aut?: boolean | users_aut$quote_calculations_autArgs<ExtArgs>
    sessions_aut?: boolean | users_aut$sessions_autArgs<ExtArgs>
    threads_aut?: boolean | users_aut$threads_autArgs<ExtArgs>
    tokens_generated_aut?: boolean | users_aut$tokens_generated_autArgs<ExtArgs>
    trainings_links_aut?: boolean | users_aut$trainings_links_autArgs<ExtArgs>
    _count?: boolean | Users_autCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_aut"]>



  export type users_autSelectScalar = {
    id?: boolean
    phone_number?: boolean
    last_session_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type users_autOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "last_session_id" | "createdAt" | "updatedAt", ExtArgs["result"]["users_aut"]>
  export type users_autInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_consults_aut?: boolean | users_aut$budget_consults_autArgs<ExtArgs>
    cpf_consults_aut?: boolean | users_aut$cpf_consults_autArgs<ExtArgs>
    quote_calculations_aut?: boolean | users_aut$quote_calculations_autArgs<ExtArgs>
    sessions_aut?: boolean | users_aut$sessions_autArgs<ExtArgs>
    threads_aut?: boolean | users_aut$threads_autArgs<ExtArgs>
    tokens_generated_aut?: boolean | users_aut$tokens_generated_autArgs<ExtArgs>
    trainings_links_aut?: boolean | users_aut$trainings_links_autArgs<ExtArgs>
    _count?: boolean | Users_autCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $users_autPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users_aut"
    objects: {
      budget_consults_aut: Prisma.$budget_consults_autPayload<ExtArgs>[]
      cpf_consults_aut: Prisma.$cpf_consults_autPayload<ExtArgs>[]
      quote_calculations_aut: Prisma.$quote_calculations_autPayload<ExtArgs>[]
      sessions_aut: Prisma.$sessions_autPayload<ExtArgs>[]
      threads_aut: Prisma.$threads_autPayload<ExtArgs>[]
      tokens_generated_aut: Prisma.$tokens_generated_autPayload<ExtArgs>[]
      trainings_links_aut: Prisma.$trainings_links_autPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: bigint
      last_session_id: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users_aut"]>
    composites: {}
  }

  type users_autGetPayload<S extends boolean | null | undefined | users_autDefaultArgs> = $Result.GetResult<Prisma.$users_autPayload, S>

  type users_autCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<users_autFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Users_autCountAggregateInputType | true
    }

  export interface users_autDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_aut'], meta: { name: 'users_aut' } }
    /**
     * Find zero or one Users_aut that matches the filter.
     * @param {users_autFindUniqueArgs} args - Arguments to find a Users_aut
     * @example
     * // Get one Users_aut
     * const users_aut = await prisma.users_aut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends users_autFindUniqueArgs>(args: SelectSubset<T, users_autFindUniqueArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users_aut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {users_autFindUniqueOrThrowArgs} args - Arguments to find a Users_aut
     * @example
     * // Get one Users_aut
     * const users_aut = await prisma.users_aut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends users_autFindUniqueOrThrowArgs>(args: SelectSubset<T, users_autFindUniqueOrThrowArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_aut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_autFindFirstArgs} args - Arguments to find a Users_aut
     * @example
     * // Get one Users_aut
     * const users_aut = await prisma.users_aut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends users_autFindFirstArgs>(args?: SelectSubset<T, users_autFindFirstArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_aut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_autFindFirstOrThrowArgs} args - Arguments to find a Users_aut
     * @example
     * // Get one Users_aut
     * const users_aut = await prisma.users_aut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends users_autFindFirstOrThrowArgs>(args?: SelectSubset<T, users_autFindFirstOrThrowArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users_auts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_autFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_auts
     * const users_auts = await prisma.users_aut.findMany()
     * 
     * // Get first 10 Users_auts
     * const users_auts = await prisma.users_aut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_autWithIdOnly = await prisma.users_aut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends users_autFindManyArgs>(args?: SelectSubset<T, users_autFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users_aut.
     * @param {users_autCreateArgs} args - Arguments to create a Users_aut.
     * @example
     * // Create one Users_aut
     * const Users_aut = await prisma.users_aut.create({
     *   data: {
     *     // ... data to create a Users_aut
     *   }
     * })
     * 
     */
    create<T extends users_autCreateArgs>(args: SelectSubset<T, users_autCreateArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users_auts.
     * @param {users_autCreateManyArgs} args - Arguments to create many Users_auts.
     * @example
     * // Create many Users_auts
     * const users_aut = await prisma.users_aut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends users_autCreateManyArgs>(args?: SelectSubset<T, users_autCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_aut.
     * @param {users_autDeleteArgs} args - Arguments to delete one Users_aut.
     * @example
     * // Delete one Users_aut
     * const Users_aut = await prisma.users_aut.delete({
     *   where: {
     *     // ... filter to delete one Users_aut
     *   }
     * })
     * 
     */
    delete<T extends users_autDeleteArgs>(args: SelectSubset<T, users_autDeleteArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users_aut.
     * @param {users_autUpdateArgs} args - Arguments to update one Users_aut.
     * @example
     * // Update one Users_aut
     * const users_aut = await prisma.users_aut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends users_autUpdateArgs>(args: SelectSubset<T, users_autUpdateArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users_auts.
     * @param {users_autDeleteManyArgs} args - Arguments to filter Users_auts to delete.
     * @example
     * // Delete a few Users_auts
     * const { count } = await prisma.users_aut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends users_autDeleteManyArgs>(args?: SelectSubset<T, users_autDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_autUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_auts
     * const users_aut = await prisma.users_aut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends users_autUpdateManyArgs>(args: SelectSubset<T, users_autUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_aut.
     * @param {users_autUpsertArgs} args - Arguments to update or create a Users_aut.
     * @example
     * // Update or create a Users_aut
     * const users_aut = await prisma.users_aut.upsert({
     *   create: {
     *     // ... data to create a Users_aut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_aut we want to update
     *   }
     * })
     */
    upsert<T extends users_autUpsertArgs>(args: SelectSubset<T, users_autUpsertArgs<ExtArgs>>): Prisma__users_autClient<$Result.GetResult<Prisma.$users_autPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users_auts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_autCountArgs} args - Arguments to filter Users_auts to count.
     * @example
     * // Count the number of Users_auts
     * const count = await prisma.users_aut.count({
     *   where: {
     *     // ... the filter for the Users_auts we want to count
     *   }
     * })
    **/
    count<T extends users_autCountArgs>(
      args?: Subset<T, users_autCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_autCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_autAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_autAggregateArgs>(args: Subset<T, Users_autAggregateArgs>): Prisma.PrismaPromise<GetUsers_autAggregateType<T>>

    /**
     * Group by Users_aut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_autGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_autGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_autGroupByArgs['orderBy'] }
        : { orderBy?: users_autGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_autGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_autGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_aut model
   */
  readonly fields: users_autFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_aut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users_autClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget_consults_aut<T extends users_aut$budget_consults_autArgs<ExtArgs> = {}>(args?: Subset<T, users_aut$budget_consults_autArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_consults_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cpf_consults_aut<T extends users_aut$cpf_consults_autArgs<ExtArgs> = {}>(args?: Subset<T, users_aut$cpf_consults_autArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cpf_consults_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quote_calculations_aut<T extends users_aut$quote_calculations_autArgs<ExtArgs> = {}>(args?: Subset<T, users_aut$quote_calculations_autArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_calculations_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions_aut<T extends users_aut$sessions_autArgs<ExtArgs> = {}>(args?: Subset<T, users_aut$sessions_autArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessions_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    threads_aut<T extends users_aut$threads_autArgs<ExtArgs> = {}>(args?: Subset<T, users_aut$threads_autArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$threads_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens_generated_aut<T extends users_aut$tokens_generated_autArgs<ExtArgs> = {}>(args?: Subset<T, users_aut$tokens_generated_autArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokens_generated_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainings_links_aut<T extends users_aut$trainings_links_autArgs<ExtArgs> = {}>(args?: Subset<T, users_aut$trainings_links_autArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainings_links_autPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users_aut model
   */
  interface users_autFieldRefs {
    readonly id: FieldRef<"users_aut", 'String'>
    readonly phone_number: FieldRef<"users_aut", 'BigInt'>
    readonly last_session_id: FieldRef<"users_aut", 'String'>
    readonly createdAt: FieldRef<"users_aut", 'DateTime'>
    readonly updatedAt: FieldRef<"users_aut", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users_aut findUnique
   */
  export type users_autFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * Filter, which users_aut to fetch.
     */
    where: users_autWhereUniqueInput
  }

  /**
   * users_aut findUniqueOrThrow
   */
  export type users_autFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * Filter, which users_aut to fetch.
     */
    where: users_autWhereUniqueInput
  }

  /**
   * users_aut findFirst
   */
  export type users_autFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * Filter, which users_aut to fetch.
     */
    where?: users_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_auts to fetch.
     */
    orderBy?: users_autOrderByWithRelationInput | users_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_auts.
     */
    cursor?: users_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_auts.
     */
    distinct?: Users_autScalarFieldEnum | Users_autScalarFieldEnum[]
  }

  /**
   * users_aut findFirstOrThrow
   */
  export type users_autFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * Filter, which users_aut to fetch.
     */
    where?: users_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_auts to fetch.
     */
    orderBy?: users_autOrderByWithRelationInput | users_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_auts.
     */
    cursor?: users_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_auts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_auts.
     */
    distinct?: Users_autScalarFieldEnum | Users_autScalarFieldEnum[]
  }

  /**
   * users_aut findMany
   */
  export type users_autFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * Filter, which users_auts to fetch.
     */
    where?: users_autWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_auts to fetch.
     */
    orderBy?: users_autOrderByWithRelationInput | users_autOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_auts.
     */
    cursor?: users_autWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_auts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_auts.
     */
    skip?: number
    distinct?: Users_autScalarFieldEnum | Users_autScalarFieldEnum[]
  }

  /**
   * users_aut create
   */
  export type users_autCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * The data needed to create a users_aut.
     */
    data: XOR<users_autCreateInput, users_autUncheckedCreateInput>
  }

  /**
   * users_aut createMany
   */
  export type users_autCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_auts.
     */
    data: users_autCreateManyInput | users_autCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users_aut update
   */
  export type users_autUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * The data needed to update a users_aut.
     */
    data: XOR<users_autUpdateInput, users_autUncheckedUpdateInput>
    /**
     * Choose, which users_aut to update.
     */
    where: users_autWhereUniqueInput
  }

  /**
   * users_aut updateMany
   */
  export type users_autUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_auts.
     */
    data: XOR<users_autUpdateManyMutationInput, users_autUncheckedUpdateManyInput>
    /**
     * Filter which users_auts to update
     */
    where?: users_autWhereInput
    /**
     * Limit how many users_auts to update.
     */
    limit?: number
  }

  /**
   * users_aut upsert
   */
  export type users_autUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * The filter to search for the users_aut to update in case it exists.
     */
    where: users_autWhereUniqueInput
    /**
     * In case the users_aut found by the `where` argument doesn't exist, create a new users_aut with this data.
     */
    create: XOR<users_autCreateInput, users_autUncheckedCreateInput>
    /**
     * In case the users_aut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_autUpdateInput, users_autUncheckedUpdateInput>
  }

  /**
   * users_aut delete
   */
  export type users_autDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
    /**
     * Filter which users_aut to delete.
     */
    where: users_autWhereUniqueInput
  }

  /**
   * users_aut deleteMany
   */
  export type users_autDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_auts to delete
     */
    where?: users_autWhereInput
    /**
     * Limit how many users_auts to delete.
     */
    limit?: number
  }

  /**
   * users_aut.budget_consults_aut
   */
  export type users_aut$budget_consults_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_aut
     */
    select?: budget_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_aut
     */
    omit?: budget_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_autInclude<ExtArgs> | null
    where?: budget_consults_autWhereInput
    orderBy?: budget_consults_autOrderByWithRelationInput | budget_consults_autOrderByWithRelationInput[]
    cursor?: budget_consults_autWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Budget_consults_autScalarFieldEnum | Budget_consults_autScalarFieldEnum[]
  }

  /**
   * users_aut.cpf_consults_aut
   */
  export type users_aut$cpf_consults_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_aut
     */
    select?: cpf_consults_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_aut
     */
    omit?: cpf_consults_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_autInclude<ExtArgs> | null
    where?: cpf_consults_autWhereInput
    orderBy?: cpf_consults_autOrderByWithRelationInput | cpf_consults_autOrderByWithRelationInput[]
    cursor?: cpf_consults_autWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cpf_consults_autScalarFieldEnum | Cpf_consults_autScalarFieldEnum[]
  }

  /**
   * users_aut.quote_calculations_aut
   */
  export type users_aut$quote_calculations_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_aut
     */
    select?: quote_calculations_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_aut
     */
    omit?: quote_calculations_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_autInclude<ExtArgs> | null
    where?: quote_calculations_autWhereInput
    orderBy?: quote_calculations_autOrderByWithRelationInput | quote_calculations_autOrderByWithRelationInput[]
    cursor?: quote_calculations_autWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quote_calculations_autScalarFieldEnum | Quote_calculations_autScalarFieldEnum[]
  }

  /**
   * users_aut.sessions_aut
   */
  export type users_aut$sessions_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_aut
     */
    select?: sessions_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_aut
     */
    omit?: sessions_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_autInclude<ExtArgs> | null
    where?: sessions_autWhereInput
    orderBy?: sessions_autOrderByWithRelationInput | sessions_autOrderByWithRelationInput[]
    cursor?: sessions_autWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sessions_autScalarFieldEnum | Sessions_autScalarFieldEnum[]
  }

  /**
   * users_aut.threads_aut
   */
  export type users_aut$threads_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_aut
     */
    select?: threads_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_aut
     */
    omit?: threads_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_autInclude<ExtArgs> | null
    where?: threads_autWhereInput
    orderBy?: threads_autOrderByWithRelationInput | threads_autOrderByWithRelationInput[]
    cursor?: threads_autWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Threads_autScalarFieldEnum | Threads_autScalarFieldEnum[]
  }

  /**
   * users_aut.tokens_generated_aut
   */
  export type users_aut$tokens_generated_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_aut
     */
    select?: tokens_generated_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_aut
     */
    omit?: tokens_generated_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_autInclude<ExtArgs> | null
    where?: tokens_generated_autWhereInput
    orderBy?: tokens_generated_autOrderByWithRelationInput | tokens_generated_autOrderByWithRelationInput[]
    cursor?: tokens_generated_autWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tokens_generated_autScalarFieldEnum | Tokens_generated_autScalarFieldEnum[]
  }

  /**
   * users_aut.trainings_links_aut
   */
  export type users_aut$trainings_links_autArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_aut
     */
    select?: trainings_links_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_aut
     */
    omit?: trainings_links_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_autInclude<ExtArgs> | null
    where?: trainings_links_autWhereInput
    orderBy?: trainings_links_autOrderByWithRelationInput | trainings_links_autOrderByWithRelationInput[]
    cursor?: trainings_links_autWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Trainings_links_autScalarFieldEnum | Trainings_links_autScalarFieldEnum[]
  }

  /**
   * users_aut without action
   */
  export type users_autDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_aut
     */
    select?: users_autSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_aut
     */
    omit?: users_autOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_autInclude<ExtArgs> | null
  }


  /**
   * Model users_clt
   */

  export type AggregateUsers_clt = {
    _count: Users_cltCountAggregateOutputType | null
    _avg: Users_cltAvgAggregateOutputType | null
    _sum: Users_cltSumAggregateOutputType | null
    _min: Users_cltMinAggregateOutputType | null
    _max: Users_cltMaxAggregateOutputType | null
  }

  export type Users_cltAvgAggregateOutputType = {
    phone_number: number | null
  }

  export type Users_cltSumAggregateOutputType = {
    phone_number: bigint | null
  }

  export type Users_cltMinAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    last_session_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_cltMaxAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    last_session_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_cltCountAggregateOutputType = {
    id: number
    phone_number: number
    last_session_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Users_cltAvgAggregateInputType = {
    phone_number?: true
  }

  export type Users_cltSumAggregateInputType = {
    phone_number?: true
  }

  export type Users_cltMinAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_cltMaxAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_cltCountAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Users_cltAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_clt to aggregate.
     */
    where?: users_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_clts to fetch.
     */
    orderBy?: users_cltOrderByWithRelationInput | users_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_clts
    **/
    _count?: true | Users_cltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_cltAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_cltSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_cltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_cltMaxAggregateInputType
  }

  export type GetUsers_cltAggregateType<T extends Users_cltAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_clt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_clt[P]>
      : GetScalarType<T[P], AggregateUsers_clt[P]>
  }




  export type users_cltGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_cltWhereInput
    orderBy?: users_cltOrderByWithAggregationInput | users_cltOrderByWithAggregationInput[]
    by: Users_cltScalarFieldEnum[] | Users_cltScalarFieldEnum
    having?: users_cltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_cltCountAggregateInputType | true
    _avg?: Users_cltAvgAggregateInputType
    _sum?: Users_cltSumAggregateInputType
    _min?: Users_cltMinAggregateInputType
    _max?: Users_cltMaxAggregateInputType
  }

  export type Users_cltGroupByOutputType = {
    id: string
    phone_number: bigint
    last_session_id: string | null
    createdAt: Date
    updatedAt: Date
    _count: Users_cltCountAggregateOutputType | null
    _avg: Users_cltAvgAggregateOutputType | null
    _sum: Users_cltSumAggregateOutputType | null
    _min: Users_cltMinAggregateOutputType | null
    _max: Users_cltMaxAggregateOutputType | null
  }

  type GetUsers_cltGroupByPayload<T extends users_cltGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_cltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_cltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_cltGroupByOutputType[P]>
            : GetScalarType<T[P], Users_cltGroupByOutputType[P]>
        }
      >
    >


  export type users_cltSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    last_session_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget_consults_clt?: boolean | users_clt$budget_consults_cltArgs<ExtArgs>
    cpf_consults_clt?: boolean | users_clt$cpf_consults_cltArgs<ExtArgs>
    quote_calculations_clt?: boolean | users_clt$quote_calculations_cltArgs<ExtArgs>
    sessions_clt?: boolean | users_clt$sessions_cltArgs<ExtArgs>
    threads_clt?: boolean | users_clt$threads_cltArgs<ExtArgs>
    tokens_generated_clt?: boolean | users_clt$tokens_generated_cltArgs<ExtArgs>
    trainings_links_clt?: boolean | users_clt$trainings_links_cltArgs<ExtArgs>
    _count?: boolean | Users_cltCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_clt"]>



  export type users_cltSelectScalar = {
    id?: boolean
    phone_number?: boolean
    last_session_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type users_cltOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "last_session_id" | "createdAt" | "updatedAt", ExtArgs["result"]["users_clt"]>
  export type users_cltInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_consults_clt?: boolean | users_clt$budget_consults_cltArgs<ExtArgs>
    cpf_consults_clt?: boolean | users_clt$cpf_consults_cltArgs<ExtArgs>
    quote_calculations_clt?: boolean | users_clt$quote_calculations_cltArgs<ExtArgs>
    sessions_clt?: boolean | users_clt$sessions_cltArgs<ExtArgs>
    threads_clt?: boolean | users_clt$threads_cltArgs<ExtArgs>
    tokens_generated_clt?: boolean | users_clt$tokens_generated_cltArgs<ExtArgs>
    trainings_links_clt?: boolean | users_clt$trainings_links_cltArgs<ExtArgs>
    _count?: boolean | Users_cltCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $users_cltPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users_clt"
    objects: {
      budget_consults_clt: Prisma.$budget_consults_cltPayload<ExtArgs>[]
      cpf_consults_clt: Prisma.$cpf_consults_cltPayload<ExtArgs>[]
      quote_calculations_clt: Prisma.$quote_calculations_cltPayload<ExtArgs>[]
      sessions_clt: Prisma.$sessions_cltPayload<ExtArgs>[]
      threads_clt: Prisma.$threads_cltPayload<ExtArgs>[]
      tokens_generated_clt: Prisma.$tokens_generated_cltPayload<ExtArgs>[]
      trainings_links_clt: Prisma.$trainings_links_cltPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: bigint
      last_session_id: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users_clt"]>
    composites: {}
  }

  type users_cltGetPayload<S extends boolean | null | undefined | users_cltDefaultArgs> = $Result.GetResult<Prisma.$users_cltPayload, S>

  type users_cltCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<users_cltFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Users_cltCountAggregateInputType | true
    }

  export interface users_cltDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_clt'], meta: { name: 'users_clt' } }
    /**
     * Find zero or one Users_clt that matches the filter.
     * @param {users_cltFindUniqueArgs} args - Arguments to find a Users_clt
     * @example
     * // Get one Users_clt
     * const users_clt = await prisma.users_clt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends users_cltFindUniqueArgs>(args: SelectSubset<T, users_cltFindUniqueArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users_clt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {users_cltFindUniqueOrThrowArgs} args - Arguments to find a Users_clt
     * @example
     * // Get one Users_clt
     * const users_clt = await prisma.users_clt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends users_cltFindUniqueOrThrowArgs>(args: SelectSubset<T, users_cltFindUniqueOrThrowArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_clt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_cltFindFirstArgs} args - Arguments to find a Users_clt
     * @example
     * // Get one Users_clt
     * const users_clt = await prisma.users_clt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends users_cltFindFirstArgs>(args?: SelectSubset<T, users_cltFindFirstArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_clt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_cltFindFirstOrThrowArgs} args - Arguments to find a Users_clt
     * @example
     * // Get one Users_clt
     * const users_clt = await prisma.users_clt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends users_cltFindFirstOrThrowArgs>(args?: SelectSubset<T, users_cltFindFirstOrThrowArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users_clts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_cltFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_clts
     * const users_clts = await prisma.users_clt.findMany()
     * 
     * // Get first 10 Users_clts
     * const users_clts = await prisma.users_clt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_cltWithIdOnly = await prisma.users_clt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends users_cltFindManyArgs>(args?: SelectSubset<T, users_cltFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users_clt.
     * @param {users_cltCreateArgs} args - Arguments to create a Users_clt.
     * @example
     * // Create one Users_clt
     * const Users_clt = await prisma.users_clt.create({
     *   data: {
     *     // ... data to create a Users_clt
     *   }
     * })
     * 
     */
    create<T extends users_cltCreateArgs>(args: SelectSubset<T, users_cltCreateArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users_clts.
     * @param {users_cltCreateManyArgs} args - Arguments to create many Users_clts.
     * @example
     * // Create many Users_clts
     * const users_clt = await prisma.users_clt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends users_cltCreateManyArgs>(args?: SelectSubset<T, users_cltCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_clt.
     * @param {users_cltDeleteArgs} args - Arguments to delete one Users_clt.
     * @example
     * // Delete one Users_clt
     * const Users_clt = await prisma.users_clt.delete({
     *   where: {
     *     // ... filter to delete one Users_clt
     *   }
     * })
     * 
     */
    delete<T extends users_cltDeleteArgs>(args: SelectSubset<T, users_cltDeleteArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users_clt.
     * @param {users_cltUpdateArgs} args - Arguments to update one Users_clt.
     * @example
     * // Update one Users_clt
     * const users_clt = await prisma.users_clt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends users_cltUpdateArgs>(args: SelectSubset<T, users_cltUpdateArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users_clts.
     * @param {users_cltDeleteManyArgs} args - Arguments to filter Users_clts to delete.
     * @example
     * // Delete a few Users_clts
     * const { count } = await prisma.users_clt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends users_cltDeleteManyArgs>(args?: SelectSubset<T, users_cltDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_cltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_clts
     * const users_clt = await prisma.users_clt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends users_cltUpdateManyArgs>(args: SelectSubset<T, users_cltUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_clt.
     * @param {users_cltUpsertArgs} args - Arguments to update or create a Users_clt.
     * @example
     * // Update or create a Users_clt
     * const users_clt = await prisma.users_clt.upsert({
     *   create: {
     *     // ... data to create a Users_clt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_clt we want to update
     *   }
     * })
     */
    upsert<T extends users_cltUpsertArgs>(args: SelectSubset<T, users_cltUpsertArgs<ExtArgs>>): Prisma__users_cltClient<$Result.GetResult<Prisma.$users_cltPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users_clts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_cltCountArgs} args - Arguments to filter Users_clts to count.
     * @example
     * // Count the number of Users_clts
     * const count = await prisma.users_clt.count({
     *   where: {
     *     // ... the filter for the Users_clts we want to count
     *   }
     * })
    **/
    count<T extends users_cltCountArgs>(
      args?: Subset<T, users_cltCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_cltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_cltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_cltAggregateArgs>(args: Subset<T, Users_cltAggregateArgs>): Prisma.PrismaPromise<GetUsers_cltAggregateType<T>>

    /**
     * Group by Users_clt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_cltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_cltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_cltGroupByArgs['orderBy'] }
        : { orderBy?: users_cltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_cltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_cltGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_clt model
   */
  readonly fields: users_cltFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_clt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users_cltClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget_consults_clt<T extends users_clt$budget_consults_cltArgs<ExtArgs> = {}>(args?: Subset<T, users_clt$budget_consults_cltArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_consults_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cpf_consults_clt<T extends users_clt$cpf_consults_cltArgs<ExtArgs> = {}>(args?: Subset<T, users_clt$cpf_consults_cltArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cpf_consults_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quote_calculations_clt<T extends users_clt$quote_calculations_cltArgs<ExtArgs> = {}>(args?: Subset<T, users_clt$quote_calculations_cltArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_calculations_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions_clt<T extends users_clt$sessions_cltArgs<ExtArgs> = {}>(args?: Subset<T, users_clt$sessions_cltArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessions_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    threads_clt<T extends users_clt$threads_cltArgs<ExtArgs> = {}>(args?: Subset<T, users_clt$threads_cltArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$threads_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens_generated_clt<T extends users_clt$tokens_generated_cltArgs<ExtArgs> = {}>(args?: Subset<T, users_clt$tokens_generated_cltArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokens_generated_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainings_links_clt<T extends users_clt$trainings_links_cltArgs<ExtArgs> = {}>(args?: Subset<T, users_clt$trainings_links_cltArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainings_links_cltPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users_clt model
   */
  interface users_cltFieldRefs {
    readonly id: FieldRef<"users_clt", 'String'>
    readonly phone_number: FieldRef<"users_clt", 'BigInt'>
    readonly last_session_id: FieldRef<"users_clt", 'String'>
    readonly createdAt: FieldRef<"users_clt", 'DateTime'>
    readonly updatedAt: FieldRef<"users_clt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users_clt findUnique
   */
  export type users_cltFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * Filter, which users_clt to fetch.
     */
    where: users_cltWhereUniqueInput
  }

  /**
   * users_clt findUniqueOrThrow
   */
  export type users_cltFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * Filter, which users_clt to fetch.
     */
    where: users_cltWhereUniqueInput
  }

  /**
   * users_clt findFirst
   */
  export type users_cltFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * Filter, which users_clt to fetch.
     */
    where?: users_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_clts to fetch.
     */
    orderBy?: users_cltOrderByWithRelationInput | users_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_clts.
     */
    cursor?: users_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_clts.
     */
    distinct?: Users_cltScalarFieldEnum | Users_cltScalarFieldEnum[]
  }

  /**
   * users_clt findFirstOrThrow
   */
  export type users_cltFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * Filter, which users_clt to fetch.
     */
    where?: users_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_clts to fetch.
     */
    orderBy?: users_cltOrderByWithRelationInput | users_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_clts.
     */
    cursor?: users_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_clts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_clts.
     */
    distinct?: Users_cltScalarFieldEnum | Users_cltScalarFieldEnum[]
  }

  /**
   * users_clt findMany
   */
  export type users_cltFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * Filter, which users_clts to fetch.
     */
    where?: users_cltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_clts to fetch.
     */
    orderBy?: users_cltOrderByWithRelationInput | users_cltOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_clts.
     */
    cursor?: users_cltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_clts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_clts.
     */
    skip?: number
    distinct?: Users_cltScalarFieldEnum | Users_cltScalarFieldEnum[]
  }

  /**
   * users_clt create
   */
  export type users_cltCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * The data needed to create a users_clt.
     */
    data: XOR<users_cltCreateInput, users_cltUncheckedCreateInput>
  }

  /**
   * users_clt createMany
   */
  export type users_cltCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_clts.
     */
    data: users_cltCreateManyInput | users_cltCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users_clt update
   */
  export type users_cltUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * The data needed to update a users_clt.
     */
    data: XOR<users_cltUpdateInput, users_cltUncheckedUpdateInput>
    /**
     * Choose, which users_clt to update.
     */
    where: users_cltWhereUniqueInput
  }

  /**
   * users_clt updateMany
   */
  export type users_cltUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_clts.
     */
    data: XOR<users_cltUpdateManyMutationInput, users_cltUncheckedUpdateManyInput>
    /**
     * Filter which users_clts to update
     */
    where?: users_cltWhereInput
    /**
     * Limit how many users_clts to update.
     */
    limit?: number
  }

  /**
   * users_clt upsert
   */
  export type users_cltUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * The filter to search for the users_clt to update in case it exists.
     */
    where: users_cltWhereUniqueInput
    /**
     * In case the users_clt found by the `where` argument doesn't exist, create a new users_clt with this data.
     */
    create: XOR<users_cltCreateInput, users_cltUncheckedCreateInput>
    /**
     * In case the users_clt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_cltUpdateInput, users_cltUncheckedUpdateInput>
  }

  /**
   * users_clt delete
   */
  export type users_cltDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
    /**
     * Filter which users_clt to delete.
     */
    where: users_cltWhereUniqueInput
  }

  /**
   * users_clt deleteMany
   */
  export type users_cltDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_clts to delete
     */
    where?: users_cltWhereInput
    /**
     * Limit how many users_clts to delete.
     */
    limit?: number
  }

  /**
   * users_clt.budget_consults_clt
   */
  export type users_clt$budget_consults_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_clt
     */
    select?: budget_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_clt
     */
    omit?: budget_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_cltInclude<ExtArgs> | null
    where?: budget_consults_cltWhereInput
    orderBy?: budget_consults_cltOrderByWithRelationInput | budget_consults_cltOrderByWithRelationInput[]
    cursor?: budget_consults_cltWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Budget_consults_cltScalarFieldEnum | Budget_consults_cltScalarFieldEnum[]
  }

  /**
   * users_clt.cpf_consults_clt
   */
  export type users_clt$cpf_consults_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_clt
     */
    select?: cpf_consults_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_clt
     */
    omit?: cpf_consults_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_cltInclude<ExtArgs> | null
    where?: cpf_consults_cltWhereInput
    orderBy?: cpf_consults_cltOrderByWithRelationInput | cpf_consults_cltOrderByWithRelationInput[]
    cursor?: cpf_consults_cltWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cpf_consults_cltScalarFieldEnum | Cpf_consults_cltScalarFieldEnum[]
  }

  /**
   * users_clt.quote_calculations_clt
   */
  export type users_clt$quote_calculations_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_clt
     */
    select?: quote_calculations_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_clt
     */
    omit?: quote_calculations_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_cltInclude<ExtArgs> | null
    where?: quote_calculations_cltWhereInput
    orderBy?: quote_calculations_cltOrderByWithRelationInput | quote_calculations_cltOrderByWithRelationInput[]
    cursor?: quote_calculations_cltWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quote_calculations_cltScalarFieldEnum | Quote_calculations_cltScalarFieldEnum[]
  }

  /**
   * users_clt.sessions_clt
   */
  export type users_clt$sessions_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_clt
     */
    select?: sessions_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_clt
     */
    omit?: sessions_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_cltInclude<ExtArgs> | null
    where?: sessions_cltWhereInput
    orderBy?: sessions_cltOrderByWithRelationInput | sessions_cltOrderByWithRelationInput[]
    cursor?: sessions_cltWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sessions_cltScalarFieldEnum | Sessions_cltScalarFieldEnum[]
  }

  /**
   * users_clt.threads_clt
   */
  export type users_clt$threads_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_clt
     */
    select?: threads_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_clt
     */
    omit?: threads_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_cltInclude<ExtArgs> | null
    where?: threads_cltWhereInput
    orderBy?: threads_cltOrderByWithRelationInput | threads_cltOrderByWithRelationInput[]
    cursor?: threads_cltWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Threads_cltScalarFieldEnum | Threads_cltScalarFieldEnum[]
  }

  /**
   * users_clt.tokens_generated_clt
   */
  export type users_clt$tokens_generated_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_clt
     */
    select?: tokens_generated_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_clt
     */
    omit?: tokens_generated_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_cltInclude<ExtArgs> | null
    where?: tokens_generated_cltWhereInput
    orderBy?: tokens_generated_cltOrderByWithRelationInput | tokens_generated_cltOrderByWithRelationInput[]
    cursor?: tokens_generated_cltWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tokens_generated_cltScalarFieldEnum | Tokens_generated_cltScalarFieldEnum[]
  }

  /**
   * users_clt.trainings_links_clt
   */
  export type users_clt$trainings_links_cltArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_clt
     */
    select?: trainings_links_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_clt
     */
    omit?: trainings_links_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_cltInclude<ExtArgs> | null
    where?: trainings_links_cltWhereInput
    orderBy?: trainings_links_cltOrderByWithRelationInput | trainings_links_cltOrderByWithRelationInput[]
    cursor?: trainings_links_cltWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Trainings_links_cltScalarFieldEnum | Trainings_links_cltScalarFieldEnum[]
  }

  /**
   * users_clt without action
   */
  export type users_cltDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_clt
     */
    select?: users_cltSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_clt
     */
    omit?: users_cltOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_cltInclude<ExtArgs> | null
  }


  /**
   * Model users_goi
   */

  export type AggregateUsers_goi = {
    _count: Users_goiCountAggregateOutputType | null
    _avg: Users_goiAvgAggregateOutputType | null
    _sum: Users_goiSumAggregateOutputType | null
    _min: Users_goiMinAggregateOutputType | null
    _max: Users_goiMaxAggregateOutputType | null
  }

  export type Users_goiAvgAggregateOutputType = {
    phone_number: number | null
  }

  export type Users_goiSumAggregateOutputType = {
    phone_number: bigint | null
  }

  export type Users_goiMinAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    last_session_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_goiMaxAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    last_session_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_goiCountAggregateOutputType = {
    id: number
    phone_number: number
    last_session_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Users_goiAvgAggregateInputType = {
    phone_number?: true
  }

  export type Users_goiSumAggregateInputType = {
    phone_number?: true
  }

  export type Users_goiMinAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_goiMaxAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_goiCountAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Users_goiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_goi to aggregate.
     */
    where?: users_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_gois to fetch.
     */
    orderBy?: users_goiOrderByWithRelationInput | users_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_gois
    **/
    _count?: true | Users_goiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_goiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_goiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_goiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_goiMaxAggregateInputType
  }

  export type GetUsers_goiAggregateType<T extends Users_goiAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_goi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_goi[P]>
      : GetScalarType<T[P], AggregateUsers_goi[P]>
  }




  export type users_goiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_goiWhereInput
    orderBy?: users_goiOrderByWithAggregationInput | users_goiOrderByWithAggregationInput[]
    by: Users_goiScalarFieldEnum[] | Users_goiScalarFieldEnum
    having?: users_goiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_goiCountAggregateInputType | true
    _avg?: Users_goiAvgAggregateInputType
    _sum?: Users_goiSumAggregateInputType
    _min?: Users_goiMinAggregateInputType
    _max?: Users_goiMaxAggregateInputType
  }

  export type Users_goiGroupByOutputType = {
    id: string
    phone_number: bigint
    last_session_id: string | null
    createdAt: Date
    updatedAt: Date
    _count: Users_goiCountAggregateOutputType | null
    _avg: Users_goiAvgAggregateOutputType | null
    _sum: Users_goiSumAggregateOutputType | null
    _min: Users_goiMinAggregateOutputType | null
    _max: Users_goiMaxAggregateOutputType | null
  }

  type GetUsers_goiGroupByPayload<T extends users_goiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_goiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_goiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_goiGroupByOutputType[P]>
            : GetScalarType<T[P], Users_goiGroupByOutputType[P]>
        }
      >
    >


  export type users_goiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    last_session_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget_consults_goi?: boolean | users_goi$budget_consults_goiArgs<ExtArgs>
    cpf_consults_goi?: boolean | users_goi$cpf_consults_goiArgs<ExtArgs>
    quote_calculations_goi?: boolean | users_goi$quote_calculations_goiArgs<ExtArgs>
    sessions_goi?: boolean | users_goi$sessions_goiArgs<ExtArgs>
    threads_goi?: boolean | users_goi$threads_goiArgs<ExtArgs>
    tokens_generated_goi?: boolean | users_goi$tokens_generated_goiArgs<ExtArgs>
    trainings_links_goi?: boolean | users_goi$trainings_links_goiArgs<ExtArgs>
    _count?: boolean | Users_goiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_goi"]>



  export type users_goiSelectScalar = {
    id?: boolean
    phone_number?: boolean
    last_session_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type users_goiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "last_session_id" | "createdAt" | "updatedAt", ExtArgs["result"]["users_goi"]>
  export type users_goiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_consults_goi?: boolean | users_goi$budget_consults_goiArgs<ExtArgs>
    cpf_consults_goi?: boolean | users_goi$cpf_consults_goiArgs<ExtArgs>
    quote_calculations_goi?: boolean | users_goi$quote_calculations_goiArgs<ExtArgs>
    sessions_goi?: boolean | users_goi$sessions_goiArgs<ExtArgs>
    threads_goi?: boolean | users_goi$threads_goiArgs<ExtArgs>
    tokens_generated_goi?: boolean | users_goi$tokens_generated_goiArgs<ExtArgs>
    trainings_links_goi?: boolean | users_goi$trainings_links_goiArgs<ExtArgs>
    _count?: boolean | Users_goiCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $users_goiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users_goi"
    objects: {
      budget_consults_goi: Prisma.$budget_consults_goiPayload<ExtArgs>[]
      cpf_consults_goi: Prisma.$cpf_consults_goiPayload<ExtArgs>[]
      quote_calculations_goi: Prisma.$quote_calculations_goiPayload<ExtArgs>[]
      sessions_goi: Prisma.$sessions_goiPayload<ExtArgs>[]
      threads_goi: Prisma.$threads_goiPayload<ExtArgs>[]
      tokens_generated_goi: Prisma.$tokens_generated_goiPayload<ExtArgs>[]
      trainings_links_goi: Prisma.$trainings_links_goiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: bigint
      last_session_id: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users_goi"]>
    composites: {}
  }

  type users_goiGetPayload<S extends boolean | null | undefined | users_goiDefaultArgs> = $Result.GetResult<Prisma.$users_goiPayload, S>

  type users_goiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<users_goiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Users_goiCountAggregateInputType | true
    }

  export interface users_goiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_goi'], meta: { name: 'users_goi' } }
    /**
     * Find zero or one Users_goi that matches the filter.
     * @param {users_goiFindUniqueArgs} args - Arguments to find a Users_goi
     * @example
     * // Get one Users_goi
     * const users_goi = await prisma.users_goi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends users_goiFindUniqueArgs>(args: SelectSubset<T, users_goiFindUniqueArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users_goi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {users_goiFindUniqueOrThrowArgs} args - Arguments to find a Users_goi
     * @example
     * // Get one Users_goi
     * const users_goi = await prisma.users_goi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends users_goiFindUniqueOrThrowArgs>(args: SelectSubset<T, users_goiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_goi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_goiFindFirstArgs} args - Arguments to find a Users_goi
     * @example
     * // Get one Users_goi
     * const users_goi = await prisma.users_goi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends users_goiFindFirstArgs>(args?: SelectSubset<T, users_goiFindFirstArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_goi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_goiFindFirstOrThrowArgs} args - Arguments to find a Users_goi
     * @example
     * // Get one Users_goi
     * const users_goi = await prisma.users_goi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends users_goiFindFirstOrThrowArgs>(args?: SelectSubset<T, users_goiFindFirstOrThrowArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users_gois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_goiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_gois
     * const users_gois = await prisma.users_goi.findMany()
     * 
     * // Get first 10 Users_gois
     * const users_gois = await prisma.users_goi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_goiWithIdOnly = await prisma.users_goi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends users_goiFindManyArgs>(args?: SelectSubset<T, users_goiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users_goi.
     * @param {users_goiCreateArgs} args - Arguments to create a Users_goi.
     * @example
     * // Create one Users_goi
     * const Users_goi = await prisma.users_goi.create({
     *   data: {
     *     // ... data to create a Users_goi
     *   }
     * })
     * 
     */
    create<T extends users_goiCreateArgs>(args: SelectSubset<T, users_goiCreateArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users_gois.
     * @param {users_goiCreateManyArgs} args - Arguments to create many Users_gois.
     * @example
     * // Create many Users_gois
     * const users_goi = await prisma.users_goi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends users_goiCreateManyArgs>(args?: SelectSubset<T, users_goiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_goi.
     * @param {users_goiDeleteArgs} args - Arguments to delete one Users_goi.
     * @example
     * // Delete one Users_goi
     * const Users_goi = await prisma.users_goi.delete({
     *   where: {
     *     // ... filter to delete one Users_goi
     *   }
     * })
     * 
     */
    delete<T extends users_goiDeleteArgs>(args: SelectSubset<T, users_goiDeleteArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users_goi.
     * @param {users_goiUpdateArgs} args - Arguments to update one Users_goi.
     * @example
     * // Update one Users_goi
     * const users_goi = await prisma.users_goi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends users_goiUpdateArgs>(args: SelectSubset<T, users_goiUpdateArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users_gois.
     * @param {users_goiDeleteManyArgs} args - Arguments to filter Users_gois to delete.
     * @example
     * // Delete a few Users_gois
     * const { count } = await prisma.users_goi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends users_goiDeleteManyArgs>(args?: SelectSubset<T, users_goiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_goiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_gois
     * const users_goi = await prisma.users_goi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends users_goiUpdateManyArgs>(args: SelectSubset<T, users_goiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_goi.
     * @param {users_goiUpsertArgs} args - Arguments to update or create a Users_goi.
     * @example
     * // Update or create a Users_goi
     * const users_goi = await prisma.users_goi.upsert({
     *   create: {
     *     // ... data to create a Users_goi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_goi we want to update
     *   }
     * })
     */
    upsert<T extends users_goiUpsertArgs>(args: SelectSubset<T, users_goiUpsertArgs<ExtArgs>>): Prisma__users_goiClient<$Result.GetResult<Prisma.$users_goiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users_gois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_goiCountArgs} args - Arguments to filter Users_gois to count.
     * @example
     * // Count the number of Users_gois
     * const count = await prisma.users_goi.count({
     *   where: {
     *     // ... the filter for the Users_gois we want to count
     *   }
     * })
    **/
    count<T extends users_goiCountArgs>(
      args?: Subset<T, users_goiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_goiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_goiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_goiAggregateArgs>(args: Subset<T, Users_goiAggregateArgs>): Prisma.PrismaPromise<GetUsers_goiAggregateType<T>>

    /**
     * Group by Users_goi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_goiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_goiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_goiGroupByArgs['orderBy'] }
        : { orderBy?: users_goiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_goiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_goiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_goi model
   */
  readonly fields: users_goiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_goi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users_goiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget_consults_goi<T extends users_goi$budget_consults_goiArgs<ExtArgs> = {}>(args?: Subset<T, users_goi$budget_consults_goiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_consults_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cpf_consults_goi<T extends users_goi$cpf_consults_goiArgs<ExtArgs> = {}>(args?: Subset<T, users_goi$cpf_consults_goiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cpf_consults_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quote_calculations_goi<T extends users_goi$quote_calculations_goiArgs<ExtArgs> = {}>(args?: Subset<T, users_goi$quote_calculations_goiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_calculations_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions_goi<T extends users_goi$sessions_goiArgs<ExtArgs> = {}>(args?: Subset<T, users_goi$sessions_goiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessions_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    threads_goi<T extends users_goi$threads_goiArgs<ExtArgs> = {}>(args?: Subset<T, users_goi$threads_goiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$threads_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens_generated_goi<T extends users_goi$tokens_generated_goiArgs<ExtArgs> = {}>(args?: Subset<T, users_goi$tokens_generated_goiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokens_generated_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainings_links_goi<T extends users_goi$trainings_links_goiArgs<ExtArgs> = {}>(args?: Subset<T, users_goi$trainings_links_goiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainings_links_goiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users_goi model
   */
  interface users_goiFieldRefs {
    readonly id: FieldRef<"users_goi", 'String'>
    readonly phone_number: FieldRef<"users_goi", 'BigInt'>
    readonly last_session_id: FieldRef<"users_goi", 'String'>
    readonly createdAt: FieldRef<"users_goi", 'DateTime'>
    readonly updatedAt: FieldRef<"users_goi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users_goi findUnique
   */
  export type users_goiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * Filter, which users_goi to fetch.
     */
    where: users_goiWhereUniqueInput
  }

  /**
   * users_goi findUniqueOrThrow
   */
  export type users_goiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * Filter, which users_goi to fetch.
     */
    where: users_goiWhereUniqueInput
  }

  /**
   * users_goi findFirst
   */
  export type users_goiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * Filter, which users_goi to fetch.
     */
    where?: users_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_gois to fetch.
     */
    orderBy?: users_goiOrderByWithRelationInput | users_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_gois.
     */
    cursor?: users_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_gois.
     */
    distinct?: Users_goiScalarFieldEnum | Users_goiScalarFieldEnum[]
  }

  /**
   * users_goi findFirstOrThrow
   */
  export type users_goiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * Filter, which users_goi to fetch.
     */
    where?: users_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_gois to fetch.
     */
    orderBy?: users_goiOrderByWithRelationInput | users_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_gois.
     */
    cursor?: users_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_gois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_gois.
     */
    distinct?: Users_goiScalarFieldEnum | Users_goiScalarFieldEnum[]
  }

  /**
   * users_goi findMany
   */
  export type users_goiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * Filter, which users_gois to fetch.
     */
    where?: users_goiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_gois to fetch.
     */
    orderBy?: users_goiOrderByWithRelationInput | users_goiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_gois.
     */
    cursor?: users_goiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_gois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_gois.
     */
    skip?: number
    distinct?: Users_goiScalarFieldEnum | Users_goiScalarFieldEnum[]
  }

  /**
   * users_goi create
   */
  export type users_goiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * The data needed to create a users_goi.
     */
    data: XOR<users_goiCreateInput, users_goiUncheckedCreateInput>
  }

  /**
   * users_goi createMany
   */
  export type users_goiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_gois.
     */
    data: users_goiCreateManyInput | users_goiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users_goi update
   */
  export type users_goiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * The data needed to update a users_goi.
     */
    data: XOR<users_goiUpdateInput, users_goiUncheckedUpdateInput>
    /**
     * Choose, which users_goi to update.
     */
    where: users_goiWhereUniqueInput
  }

  /**
   * users_goi updateMany
   */
  export type users_goiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_gois.
     */
    data: XOR<users_goiUpdateManyMutationInput, users_goiUncheckedUpdateManyInput>
    /**
     * Filter which users_gois to update
     */
    where?: users_goiWhereInput
    /**
     * Limit how many users_gois to update.
     */
    limit?: number
  }

  /**
   * users_goi upsert
   */
  export type users_goiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * The filter to search for the users_goi to update in case it exists.
     */
    where: users_goiWhereUniqueInput
    /**
     * In case the users_goi found by the `where` argument doesn't exist, create a new users_goi with this data.
     */
    create: XOR<users_goiCreateInput, users_goiUncheckedCreateInput>
    /**
     * In case the users_goi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_goiUpdateInput, users_goiUncheckedUpdateInput>
  }

  /**
   * users_goi delete
   */
  export type users_goiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
    /**
     * Filter which users_goi to delete.
     */
    where: users_goiWhereUniqueInput
  }

  /**
   * users_goi deleteMany
   */
  export type users_goiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_gois to delete
     */
    where?: users_goiWhereInput
    /**
     * Limit how many users_gois to delete.
     */
    limit?: number
  }

  /**
   * users_goi.budget_consults_goi
   */
  export type users_goi$budget_consults_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_goi
     */
    select?: budget_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_goi
     */
    omit?: budget_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_goiInclude<ExtArgs> | null
    where?: budget_consults_goiWhereInput
    orderBy?: budget_consults_goiOrderByWithRelationInput | budget_consults_goiOrderByWithRelationInput[]
    cursor?: budget_consults_goiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Budget_consults_goiScalarFieldEnum | Budget_consults_goiScalarFieldEnum[]
  }

  /**
   * users_goi.cpf_consults_goi
   */
  export type users_goi$cpf_consults_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_goi
     */
    select?: cpf_consults_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_goi
     */
    omit?: cpf_consults_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_goiInclude<ExtArgs> | null
    where?: cpf_consults_goiWhereInput
    orderBy?: cpf_consults_goiOrderByWithRelationInput | cpf_consults_goiOrderByWithRelationInput[]
    cursor?: cpf_consults_goiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cpf_consults_goiScalarFieldEnum | Cpf_consults_goiScalarFieldEnum[]
  }

  /**
   * users_goi.quote_calculations_goi
   */
  export type users_goi$quote_calculations_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_goi
     */
    select?: quote_calculations_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_goi
     */
    omit?: quote_calculations_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_goiInclude<ExtArgs> | null
    where?: quote_calculations_goiWhereInput
    orderBy?: quote_calculations_goiOrderByWithRelationInput | quote_calculations_goiOrderByWithRelationInput[]
    cursor?: quote_calculations_goiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quote_calculations_goiScalarFieldEnum | Quote_calculations_goiScalarFieldEnum[]
  }

  /**
   * users_goi.sessions_goi
   */
  export type users_goi$sessions_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_goi
     */
    select?: sessions_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_goi
     */
    omit?: sessions_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_goiInclude<ExtArgs> | null
    where?: sessions_goiWhereInput
    orderBy?: sessions_goiOrderByWithRelationInput | sessions_goiOrderByWithRelationInput[]
    cursor?: sessions_goiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sessions_goiScalarFieldEnum | Sessions_goiScalarFieldEnum[]
  }

  /**
   * users_goi.threads_goi
   */
  export type users_goi$threads_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_goi
     */
    select?: threads_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_goi
     */
    omit?: threads_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_goiInclude<ExtArgs> | null
    where?: threads_goiWhereInput
    orderBy?: threads_goiOrderByWithRelationInput | threads_goiOrderByWithRelationInput[]
    cursor?: threads_goiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Threads_goiScalarFieldEnum | Threads_goiScalarFieldEnum[]
  }

  /**
   * users_goi.tokens_generated_goi
   */
  export type users_goi$tokens_generated_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_goi
     */
    select?: tokens_generated_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_goi
     */
    omit?: tokens_generated_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_goiInclude<ExtArgs> | null
    where?: tokens_generated_goiWhereInput
    orderBy?: tokens_generated_goiOrderByWithRelationInput | tokens_generated_goiOrderByWithRelationInput[]
    cursor?: tokens_generated_goiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tokens_generated_goiScalarFieldEnum | Tokens_generated_goiScalarFieldEnum[]
  }

  /**
   * users_goi.trainings_links_goi
   */
  export type users_goi$trainings_links_goiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_goi
     */
    select?: trainings_links_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_goi
     */
    omit?: trainings_links_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_goiInclude<ExtArgs> | null
    where?: trainings_links_goiWhereInput
    orderBy?: trainings_links_goiOrderByWithRelationInput | trainings_links_goiOrderByWithRelationInput[]
    cursor?: trainings_links_goiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Trainings_links_goiScalarFieldEnum | Trainings_links_goiScalarFieldEnum[]
  }

  /**
   * users_goi without action
   */
  export type users_goiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_goi
     */
    select?: users_goiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_goi
     */
    omit?: users_goiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_goiInclude<ExtArgs> | null
  }


  /**
   * Model users_spa
   */

  export type AggregateUsers_spa = {
    _count: Users_spaCountAggregateOutputType | null
    _avg: Users_spaAvgAggregateOutputType | null
    _sum: Users_spaSumAggregateOutputType | null
    _min: Users_spaMinAggregateOutputType | null
    _max: Users_spaMaxAggregateOutputType | null
  }

  export type Users_spaAvgAggregateOutputType = {
    phone_number: number | null
  }

  export type Users_spaSumAggregateOutputType = {
    phone_number: bigint | null
  }

  export type Users_spaMinAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    last_session_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_spaMaxAggregateOutputType = {
    id: string | null
    phone_number: bigint | null
    last_session_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Users_spaCountAggregateOutputType = {
    id: number
    phone_number: number
    last_session_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Users_spaAvgAggregateInputType = {
    phone_number?: true
  }

  export type Users_spaSumAggregateInputType = {
    phone_number?: true
  }

  export type Users_spaMinAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_spaMaxAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Users_spaCountAggregateInputType = {
    id?: true
    phone_number?: true
    last_session_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Users_spaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_spa to aggregate.
     */
    where?: users_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_spas to fetch.
     */
    orderBy?: users_spaOrderByWithRelationInput | users_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_spas
    **/
    _count?: true | Users_spaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_spaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_spaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_spaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_spaMaxAggregateInputType
  }

  export type GetUsers_spaAggregateType<T extends Users_spaAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_spa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_spa[P]>
      : GetScalarType<T[P], AggregateUsers_spa[P]>
  }




  export type users_spaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_spaWhereInput
    orderBy?: users_spaOrderByWithAggregationInput | users_spaOrderByWithAggregationInput[]
    by: Users_spaScalarFieldEnum[] | Users_spaScalarFieldEnum
    having?: users_spaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_spaCountAggregateInputType | true
    _avg?: Users_spaAvgAggregateInputType
    _sum?: Users_spaSumAggregateInputType
    _min?: Users_spaMinAggregateInputType
    _max?: Users_spaMaxAggregateInputType
  }

  export type Users_spaGroupByOutputType = {
    id: string
    phone_number: bigint
    last_session_id: string | null
    createdAt: Date
    updatedAt: Date
    _count: Users_spaCountAggregateOutputType | null
    _avg: Users_spaAvgAggregateOutputType | null
    _sum: Users_spaSumAggregateOutputType | null
    _min: Users_spaMinAggregateOutputType | null
    _max: Users_spaMaxAggregateOutputType | null
  }

  type GetUsers_spaGroupByPayload<T extends users_spaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_spaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_spaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_spaGroupByOutputType[P]>
            : GetScalarType<T[P], Users_spaGroupByOutputType[P]>
        }
      >
    >


  export type users_spaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    last_session_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget_consults_spa?: boolean | users_spa$budget_consults_spaArgs<ExtArgs>
    cpf_consults_spa?: boolean | users_spa$cpf_consults_spaArgs<ExtArgs>
    quote_calculations_spa?: boolean | users_spa$quote_calculations_spaArgs<ExtArgs>
    sessions_spa?: boolean | users_spa$sessions_spaArgs<ExtArgs>
    threads_spa?: boolean | users_spa$threads_spaArgs<ExtArgs>
    tokens_generated_spa?: boolean | users_spa$tokens_generated_spaArgs<ExtArgs>
    trainings_links_spa?: boolean | users_spa$trainings_links_spaArgs<ExtArgs>
    _count?: boolean | Users_spaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_spa"]>



  export type users_spaSelectScalar = {
    id?: boolean
    phone_number?: boolean
    last_session_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type users_spaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "last_session_id" | "createdAt" | "updatedAt", ExtArgs["result"]["users_spa"]>
  export type users_spaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_consults_spa?: boolean | users_spa$budget_consults_spaArgs<ExtArgs>
    cpf_consults_spa?: boolean | users_spa$cpf_consults_spaArgs<ExtArgs>
    quote_calculations_spa?: boolean | users_spa$quote_calculations_spaArgs<ExtArgs>
    sessions_spa?: boolean | users_spa$sessions_spaArgs<ExtArgs>
    threads_spa?: boolean | users_spa$threads_spaArgs<ExtArgs>
    tokens_generated_spa?: boolean | users_spa$tokens_generated_spaArgs<ExtArgs>
    trainings_links_spa?: boolean | users_spa$trainings_links_spaArgs<ExtArgs>
    _count?: boolean | Users_spaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $users_spaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users_spa"
    objects: {
      budget_consults_spa: Prisma.$budget_consults_spaPayload<ExtArgs>[]
      cpf_consults_spa: Prisma.$cpf_consults_spaPayload<ExtArgs>[]
      quote_calculations_spa: Prisma.$quote_calculations_spaPayload<ExtArgs>[]
      sessions_spa: Prisma.$sessions_spaPayload<ExtArgs>[]
      threads_spa: Prisma.$threads_spaPayload<ExtArgs>[]
      tokens_generated_spa: Prisma.$tokens_generated_spaPayload<ExtArgs>[]
      trainings_links_spa: Prisma.$trainings_links_spaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: bigint
      last_session_id: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users_spa"]>
    composites: {}
  }

  type users_spaGetPayload<S extends boolean | null | undefined | users_spaDefaultArgs> = $Result.GetResult<Prisma.$users_spaPayload, S>

  type users_spaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<users_spaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Users_spaCountAggregateInputType | true
    }

  export interface users_spaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_spa'], meta: { name: 'users_spa' } }
    /**
     * Find zero or one Users_spa that matches the filter.
     * @param {users_spaFindUniqueArgs} args - Arguments to find a Users_spa
     * @example
     * // Get one Users_spa
     * const users_spa = await prisma.users_spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends users_spaFindUniqueArgs>(args: SelectSubset<T, users_spaFindUniqueArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users_spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {users_spaFindUniqueOrThrowArgs} args - Arguments to find a Users_spa
     * @example
     * // Get one Users_spa
     * const users_spa = await prisma.users_spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends users_spaFindUniqueOrThrowArgs>(args: SelectSubset<T, users_spaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_spaFindFirstArgs} args - Arguments to find a Users_spa
     * @example
     * // Get one Users_spa
     * const users_spa = await prisma.users_spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends users_spaFindFirstArgs>(args?: SelectSubset<T, users_spaFindFirstArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_spaFindFirstOrThrowArgs} args - Arguments to find a Users_spa
     * @example
     * // Get one Users_spa
     * const users_spa = await prisma.users_spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends users_spaFindFirstOrThrowArgs>(args?: SelectSubset<T, users_spaFindFirstOrThrowArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users_spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_spaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_spas
     * const users_spas = await prisma.users_spa.findMany()
     * 
     * // Get first 10 Users_spas
     * const users_spas = await prisma.users_spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_spaWithIdOnly = await prisma.users_spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends users_spaFindManyArgs>(args?: SelectSubset<T, users_spaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users_spa.
     * @param {users_spaCreateArgs} args - Arguments to create a Users_spa.
     * @example
     * // Create one Users_spa
     * const Users_spa = await prisma.users_spa.create({
     *   data: {
     *     // ... data to create a Users_spa
     *   }
     * })
     * 
     */
    create<T extends users_spaCreateArgs>(args: SelectSubset<T, users_spaCreateArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users_spas.
     * @param {users_spaCreateManyArgs} args - Arguments to create many Users_spas.
     * @example
     * // Create many Users_spas
     * const users_spa = await prisma.users_spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends users_spaCreateManyArgs>(args?: SelectSubset<T, users_spaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_spa.
     * @param {users_spaDeleteArgs} args - Arguments to delete one Users_spa.
     * @example
     * // Delete one Users_spa
     * const Users_spa = await prisma.users_spa.delete({
     *   where: {
     *     // ... filter to delete one Users_spa
     *   }
     * })
     * 
     */
    delete<T extends users_spaDeleteArgs>(args: SelectSubset<T, users_spaDeleteArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users_spa.
     * @param {users_spaUpdateArgs} args - Arguments to update one Users_spa.
     * @example
     * // Update one Users_spa
     * const users_spa = await prisma.users_spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends users_spaUpdateArgs>(args: SelectSubset<T, users_spaUpdateArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users_spas.
     * @param {users_spaDeleteManyArgs} args - Arguments to filter Users_spas to delete.
     * @example
     * // Delete a few Users_spas
     * const { count } = await prisma.users_spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends users_spaDeleteManyArgs>(args?: SelectSubset<T, users_spaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_spaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_spas
     * const users_spa = await prisma.users_spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends users_spaUpdateManyArgs>(args: SelectSubset<T, users_spaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_spa.
     * @param {users_spaUpsertArgs} args - Arguments to update or create a Users_spa.
     * @example
     * // Update or create a Users_spa
     * const users_spa = await prisma.users_spa.upsert({
     *   create: {
     *     // ... data to create a Users_spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_spa we want to update
     *   }
     * })
     */
    upsert<T extends users_spaUpsertArgs>(args: SelectSubset<T, users_spaUpsertArgs<ExtArgs>>): Prisma__users_spaClient<$Result.GetResult<Prisma.$users_spaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users_spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_spaCountArgs} args - Arguments to filter Users_spas to count.
     * @example
     * // Count the number of Users_spas
     * const count = await prisma.users_spa.count({
     *   where: {
     *     // ... the filter for the Users_spas we want to count
     *   }
     * })
    **/
    count<T extends users_spaCountArgs>(
      args?: Subset<T, users_spaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_spaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_spaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_spaAggregateArgs>(args: Subset<T, Users_spaAggregateArgs>): Prisma.PrismaPromise<GetUsers_spaAggregateType<T>>

    /**
     * Group by Users_spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_spaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_spaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_spaGroupByArgs['orderBy'] }
        : { orderBy?: users_spaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_spaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_spaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_spa model
   */
  readonly fields: users_spaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users_spaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget_consults_spa<T extends users_spa$budget_consults_spaArgs<ExtArgs> = {}>(args?: Subset<T, users_spa$budget_consults_spaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_consults_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cpf_consults_spa<T extends users_spa$cpf_consults_spaArgs<ExtArgs> = {}>(args?: Subset<T, users_spa$cpf_consults_spaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cpf_consults_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quote_calculations_spa<T extends users_spa$quote_calculations_spaArgs<ExtArgs> = {}>(args?: Subset<T, users_spa$quote_calculations_spaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quote_calculations_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions_spa<T extends users_spa$sessions_spaArgs<ExtArgs> = {}>(args?: Subset<T, users_spa$sessions_spaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessions_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    threads_spa<T extends users_spa$threads_spaArgs<ExtArgs> = {}>(args?: Subset<T, users_spa$threads_spaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$threads_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens_generated_spa<T extends users_spa$tokens_generated_spaArgs<ExtArgs> = {}>(args?: Subset<T, users_spa$tokens_generated_spaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokens_generated_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainings_links_spa<T extends users_spa$trainings_links_spaArgs<ExtArgs> = {}>(args?: Subset<T, users_spa$trainings_links_spaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainings_links_spaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users_spa model
   */
  interface users_spaFieldRefs {
    readonly id: FieldRef<"users_spa", 'String'>
    readonly phone_number: FieldRef<"users_spa", 'BigInt'>
    readonly last_session_id: FieldRef<"users_spa", 'String'>
    readonly createdAt: FieldRef<"users_spa", 'DateTime'>
    readonly updatedAt: FieldRef<"users_spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users_spa findUnique
   */
  export type users_spaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * Filter, which users_spa to fetch.
     */
    where: users_spaWhereUniqueInput
  }

  /**
   * users_spa findUniqueOrThrow
   */
  export type users_spaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * Filter, which users_spa to fetch.
     */
    where: users_spaWhereUniqueInput
  }

  /**
   * users_spa findFirst
   */
  export type users_spaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * Filter, which users_spa to fetch.
     */
    where?: users_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_spas to fetch.
     */
    orderBy?: users_spaOrderByWithRelationInput | users_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_spas.
     */
    cursor?: users_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_spas.
     */
    distinct?: Users_spaScalarFieldEnum | Users_spaScalarFieldEnum[]
  }

  /**
   * users_spa findFirstOrThrow
   */
  export type users_spaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * Filter, which users_spa to fetch.
     */
    where?: users_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_spas to fetch.
     */
    orderBy?: users_spaOrderByWithRelationInput | users_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_spas.
     */
    cursor?: users_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_spas.
     */
    distinct?: Users_spaScalarFieldEnum | Users_spaScalarFieldEnum[]
  }

  /**
   * users_spa findMany
   */
  export type users_spaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * Filter, which users_spas to fetch.
     */
    where?: users_spaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_spas to fetch.
     */
    orderBy?: users_spaOrderByWithRelationInput | users_spaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_spas.
     */
    cursor?: users_spaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_spas.
     */
    skip?: number
    distinct?: Users_spaScalarFieldEnum | Users_spaScalarFieldEnum[]
  }

  /**
   * users_spa create
   */
  export type users_spaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * The data needed to create a users_spa.
     */
    data: XOR<users_spaCreateInput, users_spaUncheckedCreateInput>
  }

  /**
   * users_spa createMany
   */
  export type users_spaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_spas.
     */
    data: users_spaCreateManyInput | users_spaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users_spa update
   */
  export type users_spaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * The data needed to update a users_spa.
     */
    data: XOR<users_spaUpdateInput, users_spaUncheckedUpdateInput>
    /**
     * Choose, which users_spa to update.
     */
    where: users_spaWhereUniqueInput
  }

  /**
   * users_spa updateMany
   */
  export type users_spaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_spas.
     */
    data: XOR<users_spaUpdateManyMutationInput, users_spaUncheckedUpdateManyInput>
    /**
     * Filter which users_spas to update
     */
    where?: users_spaWhereInput
    /**
     * Limit how many users_spas to update.
     */
    limit?: number
  }

  /**
   * users_spa upsert
   */
  export type users_spaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * The filter to search for the users_spa to update in case it exists.
     */
    where: users_spaWhereUniqueInput
    /**
     * In case the users_spa found by the `where` argument doesn't exist, create a new users_spa with this data.
     */
    create: XOR<users_spaCreateInput, users_spaUncheckedCreateInput>
    /**
     * In case the users_spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_spaUpdateInput, users_spaUncheckedUpdateInput>
  }

  /**
   * users_spa delete
   */
  export type users_spaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
    /**
     * Filter which users_spa to delete.
     */
    where: users_spaWhereUniqueInput
  }

  /**
   * users_spa deleteMany
   */
  export type users_spaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_spas to delete
     */
    where?: users_spaWhereInput
    /**
     * Limit how many users_spas to delete.
     */
    limit?: number
  }

  /**
   * users_spa.budget_consults_spa
   */
  export type users_spa$budget_consults_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_consults_spa
     */
    select?: budget_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_consults_spa
     */
    omit?: budget_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_consults_spaInclude<ExtArgs> | null
    where?: budget_consults_spaWhereInput
    orderBy?: budget_consults_spaOrderByWithRelationInput | budget_consults_spaOrderByWithRelationInput[]
    cursor?: budget_consults_spaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Budget_consults_spaScalarFieldEnum | Budget_consults_spaScalarFieldEnum[]
  }

  /**
   * users_spa.cpf_consults_spa
   */
  export type users_spa$cpf_consults_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cpf_consults_spa
     */
    select?: cpf_consults_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cpf_consults_spa
     */
    omit?: cpf_consults_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cpf_consults_spaInclude<ExtArgs> | null
    where?: cpf_consults_spaWhereInput
    orderBy?: cpf_consults_spaOrderByWithRelationInput | cpf_consults_spaOrderByWithRelationInput[]
    cursor?: cpf_consults_spaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cpf_consults_spaScalarFieldEnum | Cpf_consults_spaScalarFieldEnum[]
  }

  /**
   * users_spa.quote_calculations_spa
   */
  export type users_spa$quote_calculations_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quote_calculations_spa
     */
    select?: quote_calculations_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quote_calculations_spa
     */
    omit?: quote_calculations_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quote_calculations_spaInclude<ExtArgs> | null
    where?: quote_calculations_spaWhereInput
    orderBy?: quote_calculations_spaOrderByWithRelationInput | quote_calculations_spaOrderByWithRelationInput[]
    cursor?: quote_calculations_spaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quote_calculations_spaScalarFieldEnum | Quote_calculations_spaScalarFieldEnum[]
  }

  /**
   * users_spa.sessions_spa
   */
  export type users_spa$sessions_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions_spa
     */
    select?: sessions_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions_spa
     */
    omit?: sessions_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessions_spaInclude<ExtArgs> | null
    where?: sessions_spaWhereInput
    orderBy?: sessions_spaOrderByWithRelationInput | sessions_spaOrderByWithRelationInput[]
    cursor?: sessions_spaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sessions_spaScalarFieldEnum | Sessions_spaScalarFieldEnum[]
  }

  /**
   * users_spa.threads_spa
   */
  export type users_spa$threads_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the threads_spa
     */
    select?: threads_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the threads_spa
     */
    omit?: threads_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: threads_spaInclude<ExtArgs> | null
    where?: threads_spaWhereInput
    orderBy?: threads_spaOrderByWithRelationInput | threads_spaOrderByWithRelationInput[]
    cursor?: threads_spaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Threads_spaScalarFieldEnum | Threads_spaScalarFieldEnum[]
  }

  /**
   * users_spa.tokens_generated_spa
   */
  export type users_spa$tokens_generated_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens_generated_spa
     */
    select?: tokens_generated_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens_generated_spa
     */
    omit?: tokens_generated_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokens_generated_spaInclude<ExtArgs> | null
    where?: tokens_generated_spaWhereInput
    orderBy?: tokens_generated_spaOrderByWithRelationInput | tokens_generated_spaOrderByWithRelationInput[]
    cursor?: tokens_generated_spaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tokens_generated_spaScalarFieldEnum | Tokens_generated_spaScalarFieldEnum[]
  }

  /**
   * users_spa.trainings_links_spa
   */
  export type users_spa$trainings_links_spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings_links_spa
     */
    select?: trainings_links_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings_links_spa
     */
    omit?: trainings_links_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainings_links_spaInclude<ExtArgs> | null
    where?: trainings_links_spaWhereInput
    orderBy?: trainings_links_spaOrderByWithRelationInput | trainings_links_spaOrderByWithRelationInput[]
    cursor?: trainings_links_spaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Trainings_links_spaScalarFieldEnum | Trainings_links_spaScalarFieldEnum[]
  }

  /**
   * users_spa without action
   */
  export type users_spaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_spa
     */
    select?: users_spaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_spa
     */
    omit?: users_spaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_spaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SequelizeMetaScalarFieldEnum: {
    name: 'name'
  };

  export type SequelizeMetaScalarFieldEnum = (typeof SequelizeMetaScalarFieldEnum)[keyof typeof SequelizeMetaScalarFieldEnum]


  export const Accommodation_quotationsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Accommodation_quotationsScalarFieldEnum = (typeof Accommodation_quotationsScalarFieldEnum)[keyof typeof Accommodation_quotationsScalarFieldEnum]


  export const AttendantScalarFieldEnum: {
    id: 'id',
    jid: 'jid',
    name: 'name',
    password: 'password',
    token: 'token',
    isAdmin: 'isAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendantScalarFieldEnum = (typeof AttendantScalarFieldEnum)[keyof typeof AttendantScalarFieldEnum]


  export const Attendant_callsScalarFieldEnum: {
    id: 'id',
    jid: 'jid',
    mainProblem: 'mainProblem',
    detailsProblem: 'detailsProblem',
    pushName: 'pushName',
    attendantId: 'attendantId',
    isResolved: 'isResolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Attendant_callsScalarFieldEnum = (typeof Attendant_callsScalarFieldEnum)[keyof typeof Attendant_callsScalarFieldEnum]


  export const AttendantsScalarFieldEnum: {
    id: 'id',
    jid: 'jid',
    name: 'name',
    isAdmin: 'isAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendantsScalarFieldEnum = (typeof AttendantsScalarFieldEnum)[keyof typeof AttendantsScalarFieldEnum]


  export const Budget_consults_autScalarFieldEnum: {
    id: 'id',
    budget_code: 'budget_code',
    is_error: 'is_error',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Budget_consults_autScalarFieldEnum = (typeof Budget_consults_autScalarFieldEnum)[keyof typeof Budget_consults_autScalarFieldEnum]


  export const Budget_consults_cltScalarFieldEnum: {
    id: 'id',
    budget_code: 'budget_code',
    is_error: 'is_error',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Budget_consults_cltScalarFieldEnum = (typeof Budget_consults_cltScalarFieldEnum)[keyof typeof Budget_consults_cltScalarFieldEnum]


  export const Budget_consults_goiScalarFieldEnum: {
    id: 'id',
    budget_code: 'budget_code',
    is_error: 'is_error',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Budget_consults_goiScalarFieldEnum = (typeof Budget_consults_goiScalarFieldEnum)[keyof typeof Budget_consults_goiScalarFieldEnum]


  export const Budget_consults_spaScalarFieldEnum: {
    id: 'id',
    budget_code: 'budget_code',
    is_error: 'is_error',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Budget_consults_spaScalarFieldEnum = (typeof Budget_consults_spaScalarFieldEnum)[keyof typeof Budget_consults_spaScalarFieldEnum]


  export const CallsScalarFieldEnum: {
    id: 'id',
    jid: 'jid',
    mainProblem: 'mainProblem',
    detailsProblem: 'detailsProblem',
    pushName: 'pushName',
    attendantId: 'attendantId',
    isResolved: 'isResolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CallsScalarFieldEnum = (typeof CallsScalarFieldEnum)[keyof typeof CallsScalarFieldEnum]


  export const Cities_quotationsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Cities_quotationsScalarFieldEnum = (typeof Cities_quotationsScalarFieldEnum)[keyof typeof Cities_quotationsScalarFieldEnum]


  export const Configs_bot_autScalarFieldEnum: {
    id: 'id',
    tag: 'tag',
    is_actived: 'is_actived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Configs_bot_autScalarFieldEnum = (typeof Configs_bot_autScalarFieldEnum)[keyof typeof Configs_bot_autScalarFieldEnum]


  export const Configs_bot_cltScalarFieldEnum: {
    id: 'id',
    tag: 'tag',
    is_actived: 'is_actived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Configs_bot_cltScalarFieldEnum = (typeof Configs_bot_cltScalarFieldEnum)[keyof typeof Configs_bot_cltScalarFieldEnum]


  export const Configs_bot_goiScalarFieldEnum: {
    id: 'id',
    tag: 'tag',
    is_actived: 'is_actived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Configs_bot_goiScalarFieldEnum = (typeof Configs_bot_goiScalarFieldEnum)[keyof typeof Configs_bot_goiScalarFieldEnum]


  export const Configs_bot_spaScalarFieldEnum: {
    id: 'id',
    tag: 'tag',
    is_actived: 'is_actived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Configs_bot_spaScalarFieldEnum = (typeof Configs_bot_spaScalarFieldEnum)[keyof typeof Configs_bot_spaScalarFieldEnum]


  export const Coparticipation_type_quotationsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Coparticipation_type_quotationsScalarFieldEnum = (typeof Coparticipation_type_quotationsScalarFieldEnum)[keyof typeof Coparticipation_type_quotationsScalarFieldEnum]


  export const Cpf_consults_autScalarFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    user_id: 'user_id',
    is_error: 'is_error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Cpf_consults_autScalarFieldEnum = (typeof Cpf_consults_autScalarFieldEnum)[keyof typeof Cpf_consults_autScalarFieldEnum]


  export const Cpf_consults_cltScalarFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    user_id: 'user_id',
    is_error: 'is_error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Cpf_consults_cltScalarFieldEnum = (typeof Cpf_consults_cltScalarFieldEnum)[keyof typeof Cpf_consults_cltScalarFieldEnum]


  export const Cpf_consults_goiScalarFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    user_id: 'user_id',
    is_error: 'is_error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Cpf_consults_goiScalarFieldEnum = (typeof Cpf_consults_goiScalarFieldEnum)[keyof typeof Cpf_consults_goiScalarFieldEnum]


  export const Cpf_consults_spaScalarFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    user_id: 'user_id',
    is_error: 'is_error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Cpf_consults_spaScalarFieldEnum = (typeof Cpf_consults_spaScalarFieldEnum)[keyof typeof Cpf_consults_spaScalarFieldEnum]


  export const FilesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    data: 'data',
    mimetype: 'mimetype',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FilesScalarFieldEnum = (typeof FilesScalarFieldEnum)[keyof typeof FilesScalarFieldEnum]


  export const Maintenance_commandsScalarFieldEnum: {
    id: 'id',
    bot_type: 'bot_type',
    option: 'option',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Maintenance_commandsScalarFieldEnum = (typeof Maintenance_commandsScalarFieldEnum)[keyof typeof Maintenance_commandsScalarFieldEnum]


  export const Messages_logScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    message: 'message',
    is_attendant: 'is_attendant',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Messages_logScalarFieldEnum = (typeof Messages_logScalarFieldEnum)[keyof typeof Messages_logScalarFieldEnum]


  export const Modality_assistance_quotationsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Modality_assistance_quotationsScalarFieldEnum = (typeof Modality_assistance_quotationsScalarFieldEnum)[keyof typeof Modality_assistance_quotationsScalarFieldEnum]


  export const Plan_group_quotationsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Plan_group_quotationsScalarFieldEnum = (typeof Plan_group_quotationsScalarFieldEnum)[keyof typeof Plan_group_quotationsScalarFieldEnum]


  export const Plan_type_quotationsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Plan_type_quotationsScalarFieldEnum = (typeof Plan_type_quotationsScalarFieldEnum)[keyof typeof Plan_type_quotationsScalarFieldEnum]


  export const Problems_cltScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    problem: 'problem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Problems_cltScalarFieldEnum = (typeof Problems_cltScalarFieldEnum)[keyof typeof Problems_cltScalarFieldEnum]


  export const QuotationScalarFieldEnum: {
    id: 'id',
    plano_grupo: 'plano_grupo',
    estado: 'estado',
    coparticipacao_tipo: 'coparticipacao_tipo',
    segmentacao: 'segmentacao',
    acomodacao: 'acomodacao',
    assistencia_modalidade: 'assistencia_modalidade',
    codigo_interno: 'codigo_interno',
    registro_ans: 'registro_ans',
    cidade: 'cidade',
    validade_valores: 'validade_valores',
    tipo_plano: 'tipo_plano',
    preco_00_a_18_anos: 'preco_00_a_18_anos',
    preco_19_a_23_anos: 'preco_19_a_23_anos',
    preco_24_a_28_anos: 'preco_24_a_28_anos',
    preco_29_a_33_anos: 'preco_29_a_33_anos',
    preco_34_a_38_anos: 'preco_34_a_38_anos',
    preco_39_a_43_anos: 'preco_39_a_43_anos',
    preco_44_a_48_anos: 'preco_44_a_48_anos',
    preco_49_a_53_anos: 'preco_49_a_53_anos',
    preco_54_a_58_anos: 'preco_54_a_58_anos',
    preco_59_anos_ou_mais: 'preco_59_anos_ou_mais',
    preco_todas_idades: 'preco_todas_idades',
    consultas_eletivas: 'consultas_eletivas',
    consultas_urgencia: 'consultas_urgencia',
    exames_simples: 'exames_simples',
    exames_complexos: 'exames_complexos',
    terapias_neurologicas: 'terapias_neurologicas',
    demais_terapias: 'demais_terapias',
    desconto_vidas: 'desconto_vidas',
    desconto_familiares: 'desconto_familiares',
    quantidade_de_familiares: 'quantidade_de_familiares',
    campo_vigencia: 'campo_vigencia'
  };

  export type QuotationScalarFieldEnum = (typeof QuotationScalarFieldEnum)[keyof typeof QuotationScalarFieldEnum]


  export const Quote_calculations_autScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_name: 'client_name',
    consultant_name: 'consultant_name',
    ages: 'ages',
    accommodation: 'accommodation',
    plan_type: 'plan_type',
    square: 'square',
    is_odonto: 'is_odonto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Quote_calculations_autScalarFieldEnum = (typeof Quote_calculations_autScalarFieldEnum)[keyof typeof Quote_calculations_autScalarFieldEnum]


  export const Quote_calculations_cltScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_name: 'client_name',
    consultant_name: 'consultant_name',
    ages: 'ages',
    accommodation: 'accommodation',
    plan_type: 'plan_type',
    square: 'square',
    is_odonto: 'is_odonto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Quote_calculations_cltScalarFieldEnum = (typeof Quote_calculations_cltScalarFieldEnum)[keyof typeof Quote_calculations_cltScalarFieldEnum]


  export const Quote_calculations_goiScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_name: 'client_name',
    consultant_name: 'consultant_name',
    ages: 'ages',
    accommodation: 'accommodation',
    plan_type: 'plan_type',
    square: 'square',
    is_odonto: 'is_odonto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Quote_calculations_goiScalarFieldEnum = (typeof Quote_calculations_goiScalarFieldEnum)[keyof typeof Quote_calculations_goiScalarFieldEnum]


  export const Quote_calculations_spaScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_name: 'client_name',
    consultant_name: 'consultant_name',
    ages: 'ages',
    accommodation: 'accommodation',
    plan_type: 'plan_type',
    square: 'square',
    is_odonto: 'is_odonto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Quote_calculations_spaScalarFieldEnum = (typeof Quote_calculations_spaScalarFieldEnum)[keyof typeof Quote_calculations_spaScalarFieldEnum]


  export const Register_partners_autScalarFieldEnum: {
    id: 'id',
    complete_name: 'complete_name',
    phone_number: 'phone_number',
    email: 'email',
    birth_date: 'birth_date',
    city: 'city',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    obs: 'obs'
  };

  export type Register_partners_autScalarFieldEnum = (typeof Register_partners_autScalarFieldEnum)[keyof typeof Register_partners_autScalarFieldEnum]


  export const Register_partners_spaScalarFieldEnum: {
    id: 'id',
    complete_name: 'complete_name',
    phone_number: 'phone_number',
    email: 'email',
    birth_date: 'birth_date',
    city: 'city',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Register_partners_spaScalarFieldEnum = (typeof Register_partners_spaScalarFieldEnum)[keyof typeof Register_partners_spaScalarFieldEnum]


  export const Rh_callsScalarFieldEnum: {
    id: 'id',
    jid: 'jid',
    name: 'name',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rhNumberId: 'rhNumberId'
  };

  export type Rh_callsScalarFieldEnum = (typeof Rh_callsScalarFieldEnum)[keyof typeof Rh_callsScalarFieldEnum]


  export const Rh_numbersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone_number: 'phone_number',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Rh_numbersScalarFieldEnum = (typeof Rh_numbersScalarFieldEnum)[keyof typeof Rh_numbersScalarFieldEnum]


  export const Seller_codesScalarFieldEnum: {
    id: 'id',
    code: 'code',
    square: 'square',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Seller_codesScalarFieldEnum = (typeof Seller_codesScalarFieldEnum)[keyof typeof Seller_codesScalarFieldEnum]


  export const Sessions_autScalarFieldEnum: {
    id: 'id',
    entrace_option: 'entrace_option',
    is_finished: 'is_finished',
    is_timeout: 'is_timeout',
    is_error: 'is_error',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Sessions_autScalarFieldEnum = (typeof Sessions_autScalarFieldEnum)[keyof typeof Sessions_autScalarFieldEnum]


  export const Sessions_cltScalarFieldEnum: {
    id: 'id',
    entrace_option: 'entrace_option',
    is_finished: 'is_finished',
    is_timeout: 'is_timeout',
    is_error: 'is_error',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Sessions_cltScalarFieldEnum = (typeof Sessions_cltScalarFieldEnum)[keyof typeof Sessions_cltScalarFieldEnum]


  export const Sessions_goiScalarFieldEnum: {
    id: 'id',
    entrace_option: 'entrace_option',
    is_finished: 'is_finished',
    is_timeout: 'is_timeout',
    is_error: 'is_error',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Sessions_goiScalarFieldEnum = (typeof Sessions_goiScalarFieldEnum)[keyof typeof Sessions_goiScalarFieldEnum]


  export const Sessions_spaScalarFieldEnum: {
    id: 'id',
    entrace_option: 'entrace_option',
    is_finished: 'is_finished',
    is_timeout: 'is_timeout',
    is_error: 'is_error',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Sessions_spaScalarFieldEnum = (typeof Sessions_spaScalarFieldEnum)[keyof typeof Sessions_spaScalarFieldEnum]


  export const Supervisor_register_partnersScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Supervisor_register_partnersScalarFieldEnum = (typeof Supervisor_register_partnersScalarFieldEnum)[keyof typeof Supervisor_register_partnersScalarFieldEnum]


  export const Testers_autScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Testers_autScalarFieldEnum = (typeof Testers_autScalarFieldEnum)[keyof typeof Testers_autScalarFieldEnum]


  export const Testers_cltScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Testers_cltScalarFieldEnum = (typeof Testers_cltScalarFieldEnum)[keyof typeof Testers_cltScalarFieldEnum]


  export const Testers_goiScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Testers_goiScalarFieldEnum = (typeof Testers_goiScalarFieldEnum)[keyof typeof Testers_goiScalarFieldEnum]


  export const Testers_spaScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Testers_spaScalarFieldEnum = (typeof Testers_spaScalarFieldEnum)[keyof typeof Testers_spaScalarFieldEnum]


  export const Threads_autScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    thread: 'thread',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Threads_autScalarFieldEnum = (typeof Threads_autScalarFieldEnum)[keyof typeof Threads_autScalarFieldEnum]


  export const Threads_cltScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    thread: 'thread',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Threads_cltScalarFieldEnum = (typeof Threads_cltScalarFieldEnum)[keyof typeof Threads_cltScalarFieldEnum]


  export const Threads_goiScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    thread: 'thread',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Threads_goiScalarFieldEnum = (typeof Threads_goiScalarFieldEnum)[keyof typeof Threads_goiScalarFieldEnum]


  export const Threads_spaScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    thread: 'thread',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Threads_spaScalarFieldEnum = (typeof Threads_spaScalarFieldEnum)[keyof typeof Threads_spaScalarFieldEnum]


  export const Tokens_generated_autScalarFieldEnum: {
    id: 'id',
    create_token_id: 'create_token_id',
    user_id: 'user_id',
    is_expired: 'is_expired',
    is_error: 'is_error',
    is_confirmed: 'is_confirmed',
    is_closed: 'is_closed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tokens_generated_autScalarFieldEnum = (typeof Tokens_generated_autScalarFieldEnum)[keyof typeof Tokens_generated_autScalarFieldEnum]


  export const Tokens_generated_cltScalarFieldEnum: {
    id: 'id',
    create_token_id: 'create_token_id',
    user_id: 'user_id',
    is_expired: 'is_expired',
    is_error: 'is_error',
    is_confirmed: 'is_confirmed',
    is_closed: 'is_closed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tokens_generated_cltScalarFieldEnum = (typeof Tokens_generated_cltScalarFieldEnum)[keyof typeof Tokens_generated_cltScalarFieldEnum]


  export const Tokens_generated_goiScalarFieldEnum: {
    id: 'id',
    create_token_id: 'create_token_id',
    user_id: 'user_id',
    is_expired: 'is_expired',
    is_error: 'is_error',
    is_confirmed: 'is_confirmed',
    is_closed: 'is_closed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tokens_generated_goiScalarFieldEnum = (typeof Tokens_generated_goiScalarFieldEnum)[keyof typeof Tokens_generated_goiScalarFieldEnum]


  export const Tokens_generated_spaScalarFieldEnum: {
    id: 'id',
    create_token_id: 'create_token_id',
    user_id: 'user_id',
    is_expired: 'is_expired',
    is_error: 'is_error',
    is_confirmed: 'is_confirmed',
    is_closed: 'is_closed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tokens_generated_spaScalarFieldEnum = (typeof Tokens_generated_spaScalarFieldEnum)[keyof typeof Tokens_generated_spaScalarFieldEnum]


  export const Trainings_links_autScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training: 'training',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Trainings_links_autScalarFieldEnum = (typeof Trainings_links_autScalarFieldEnum)[keyof typeof Trainings_links_autScalarFieldEnum]


  export const Trainings_links_cltScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training: 'training',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Trainings_links_cltScalarFieldEnum = (typeof Trainings_links_cltScalarFieldEnum)[keyof typeof Trainings_links_cltScalarFieldEnum]


  export const Trainings_links_goiScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training: 'training',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Trainings_links_goiScalarFieldEnum = (typeof Trainings_links_goiScalarFieldEnum)[keyof typeof Trainings_links_goiScalarFieldEnum]


  export const Trainings_links_spaScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training: 'training',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Trainings_links_spaScalarFieldEnum = (typeof Trainings_links_spaScalarFieldEnum)[keyof typeof Trainings_links_spaScalarFieldEnum]


  export const Users_autScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    last_session_id: 'last_session_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Users_autScalarFieldEnum = (typeof Users_autScalarFieldEnum)[keyof typeof Users_autScalarFieldEnum]


  export const Users_cltScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    last_session_id: 'last_session_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Users_cltScalarFieldEnum = (typeof Users_cltScalarFieldEnum)[keyof typeof Users_cltScalarFieldEnum]


  export const Users_goiScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    last_session_id: 'last_session_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Users_goiScalarFieldEnum = (typeof Users_goiScalarFieldEnum)[keyof typeof Users_goiScalarFieldEnum]


  export const Users_spaScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    last_session_id: 'last_session_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Users_spaScalarFieldEnum = (typeof Users_spaScalarFieldEnum)[keyof typeof Users_spaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SequelizeMetaOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type SequelizeMetaOrderByRelevanceFieldEnum = (typeof SequelizeMetaOrderByRelevanceFieldEnum)[keyof typeof SequelizeMetaOrderByRelevanceFieldEnum]


  export const accommodation_quotationsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type accommodation_quotationsOrderByRelevanceFieldEnum = (typeof accommodation_quotationsOrderByRelevanceFieldEnum)[keyof typeof accommodation_quotationsOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const attendantOrderByRelevanceFieldEnum: {
    id: 'id',
    jid: 'jid',
    name: 'name',
    password: 'password',
    token: 'token'
  };

  export type attendantOrderByRelevanceFieldEnum = (typeof attendantOrderByRelevanceFieldEnum)[keyof typeof attendantOrderByRelevanceFieldEnum]


  export const attendant_callsOrderByRelevanceFieldEnum: {
    id: 'id',
    jid: 'jid',
    mainProblem: 'mainProblem',
    detailsProblem: 'detailsProblem',
    pushName: 'pushName',
    attendantId: 'attendantId'
  };

  export type attendant_callsOrderByRelevanceFieldEnum = (typeof attendant_callsOrderByRelevanceFieldEnum)[keyof typeof attendant_callsOrderByRelevanceFieldEnum]


  export const attendantsOrderByRelevanceFieldEnum: {
    id: 'id',
    jid: 'jid',
    name: 'name'
  };

  export type attendantsOrderByRelevanceFieldEnum = (typeof attendantsOrderByRelevanceFieldEnum)[keyof typeof attendantsOrderByRelevanceFieldEnum]


  export const budget_consults_autOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type budget_consults_autOrderByRelevanceFieldEnum = (typeof budget_consults_autOrderByRelevanceFieldEnum)[keyof typeof budget_consults_autOrderByRelevanceFieldEnum]


  export const budget_consults_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type budget_consults_cltOrderByRelevanceFieldEnum = (typeof budget_consults_cltOrderByRelevanceFieldEnum)[keyof typeof budget_consults_cltOrderByRelevanceFieldEnum]


  export const budget_consults_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type budget_consults_goiOrderByRelevanceFieldEnum = (typeof budget_consults_goiOrderByRelevanceFieldEnum)[keyof typeof budget_consults_goiOrderByRelevanceFieldEnum]


  export const budget_consults_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type budget_consults_spaOrderByRelevanceFieldEnum = (typeof budget_consults_spaOrderByRelevanceFieldEnum)[keyof typeof budget_consults_spaOrderByRelevanceFieldEnum]


  export const callsOrderByRelevanceFieldEnum: {
    id: 'id',
    jid: 'jid',
    mainProblem: 'mainProblem',
    detailsProblem: 'detailsProblem',
    pushName: 'pushName',
    attendantId: 'attendantId'
  };

  export type callsOrderByRelevanceFieldEnum = (typeof callsOrderByRelevanceFieldEnum)[keyof typeof callsOrderByRelevanceFieldEnum]


  export const cities_quotationsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type cities_quotationsOrderByRelevanceFieldEnum = (typeof cities_quotationsOrderByRelevanceFieldEnum)[keyof typeof cities_quotationsOrderByRelevanceFieldEnum]


  export const configs_bot_autOrderByRelevanceFieldEnum: {
    id: 'id',
    tag: 'tag'
  };

  export type configs_bot_autOrderByRelevanceFieldEnum = (typeof configs_bot_autOrderByRelevanceFieldEnum)[keyof typeof configs_bot_autOrderByRelevanceFieldEnum]


  export const configs_bot_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    tag: 'tag'
  };

  export type configs_bot_cltOrderByRelevanceFieldEnum = (typeof configs_bot_cltOrderByRelevanceFieldEnum)[keyof typeof configs_bot_cltOrderByRelevanceFieldEnum]


  export const configs_bot_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    tag: 'tag'
  };

  export type configs_bot_goiOrderByRelevanceFieldEnum = (typeof configs_bot_goiOrderByRelevanceFieldEnum)[keyof typeof configs_bot_goiOrderByRelevanceFieldEnum]


  export const configs_bot_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    tag: 'tag'
  };

  export type configs_bot_spaOrderByRelevanceFieldEnum = (typeof configs_bot_spaOrderByRelevanceFieldEnum)[keyof typeof configs_bot_spaOrderByRelevanceFieldEnum]


  export const coparticipation_type_quotationsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type coparticipation_type_quotationsOrderByRelevanceFieldEnum = (typeof coparticipation_type_quotationsOrderByRelevanceFieldEnum)[keyof typeof coparticipation_type_quotationsOrderByRelevanceFieldEnum]


  export const cpf_consults_autOrderByRelevanceFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    user_id: 'user_id'
  };

  export type cpf_consults_autOrderByRelevanceFieldEnum = (typeof cpf_consults_autOrderByRelevanceFieldEnum)[keyof typeof cpf_consults_autOrderByRelevanceFieldEnum]


  export const cpf_consults_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    user_id: 'user_id'
  };

  export type cpf_consults_cltOrderByRelevanceFieldEnum = (typeof cpf_consults_cltOrderByRelevanceFieldEnum)[keyof typeof cpf_consults_cltOrderByRelevanceFieldEnum]


  export const cpf_consults_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    user_id: 'user_id'
  };

  export type cpf_consults_goiOrderByRelevanceFieldEnum = (typeof cpf_consults_goiOrderByRelevanceFieldEnum)[keyof typeof cpf_consults_goiOrderByRelevanceFieldEnum]


  export const cpf_consults_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    user_id: 'user_id'
  };

  export type cpf_consults_spaOrderByRelevanceFieldEnum = (typeof cpf_consults_spaOrderByRelevanceFieldEnum)[keyof typeof cpf_consults_spaOrderByRelevanceFieldEnum]


  export const filesOrderByRelevanceFieldEnum: {
    name: 'name',
    mimetype: 'mimetype'
  };

  export type filesOrderByRelevanceFieldEnum = (typeof filesOrderByRelevanceFieldEnum)[keyof typeof filesOrderByRelevanceFieldEnum]


  export const maintenance_commandsOrderByRelevanceFieldEnum: {
    id: 'id',
    bot_type: 'bot_type'
  };

  export type maintenance_commandsOrderByRelevanceFieldEnum = (typeof maintenance_commandsOrderByRelevanceFieldEnum)[keyof typeof maintenance_commandsOrderByRelevanceFieldEnum]


  export const messages_logOrderByRelevanceFieldEnum: {
    id: 'id',
    message: 'message'
  };

  export type messages_logOrderByRelevanceFieldEnum = (typeof messages_logOrderByRelevanceFieldEnum)[keyof typeof messages_logOrderByRelevanceFieldEnum]


  export const modality_assistance_quotationsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type modality_assistance_quotationsOrderByRelevanceFieldEnum = (typeof modality_assistance_quotationsOrderByRelevanceFieldEnum)[keyof typeof modality_assistance_quotationsOrderByRelevanceFieldEnum]


  export const plan_group_quotationsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type plan_group_quotationsOrderByRelevanceFieldEnum = (typeof plan_group_quotationsOrderByRelevanceFieldEnum)[keyof typeof plan_group_quotationsOrderByRelevanceFieldEnum]


  export const plan_type_quotationsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type plan_type_quotationsOrderByRelevanceFieldEnum = (typeof plan_type_quotationsOrderByRelevanceFieldEnum)[keyof typeof plan_type_quotationsOrderByRelevanceFieldEnum]


  export const problems_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    problem: 'problem'
  };

  export type problems_cltOrderByRelevanceFieldEnum = (typeof problems_cltOrderByRelevanceFieldEnum)[keyof typeof problems_cltOrderByRelevanceFieldEnum]


  export const QuotationOrderByRelevanceFieldEnum: {
    plano_grupo: 'plano_grupo',
    estado: 'estado',
    coparticipacao_tipo: 'coparticipacao_tipo',
    segmentacao: 'segmentacao',
    acomodacao: 'acomodacao',
    assistencia_modalidade: 'assistencia_modalidade',
    codigo_interno: 'codigo_interno',
    registro_ans: 'registro_ans',
    cidade: 'cidade',
    validade_valores: 'validade_valores',
    tipo_plano: 'tipo_plano',
    desconto_familiares: 'desconto_familiares',
    quantidade_de_familiares: 'quantidade_de_familiares',
    campo_vigencia: 'campo_vigencia'
  };

  export type QuotationOrderByRelevanceFieldEnum = (typeof QuotationOrderByRelevanceFieldEnum)[keyof typeof QuotationOrderByRelevanceFieldEnum]


  export const quote_calculations_autOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_name: 'client_name',
    consultant_name: 'consultant_name',
    ages: 'ages',
    accommodation: 'accommodation',
    plan_type: 'plan_type',
    square: 'square'
  };

  export type quote_calculations_autOrderByRelevanceFieldEnum = (typeof quote_calculations_autOrderByRelevanceFieldEnum)[keyof typeof quote_calculations_autOrderByRelevanceFieldEnum]


  export const quote_calculations_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_name: 'client_name',
    consultant_name: 'consultant_name',
    ages: 'ages',
    accommodation: 'accommodation',
    plan_type: 'plan_type',
    square: 'square'
  };

  export type quote_calculations_cltOrderByRelevanceFieldEnum = (typeof quote_calculations_cltOrderByRelevanceFieldEnum)[keyof typeof quote_calculations_cltOrderByRelevanceFieldEnum]


  export const quote_calculations_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_name: 'client_name',
    consultant_name: 'consultant_name',
    ages: 'ages',
    accommodation: 'accommodation',
    plan_type: 'plan_type',
    square: 'square'
  };

  export type quote_calculations_goiOrderByRelevanceFieldEnum = (typeof quote_calculations_goiOrderByRelevanceFieldEnum)[keyof typeof quote_calculations_goiOrderByRelevanceFieldEnum]


  export const quote_calculations_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_name: 'client_name',
    consultant_name: 'consultant_name',
    ages: 'ages',
    accommodation: 'accommodation',
    plan_type: 'plan_type',
    square: 'square'
  };

  export type quote_calculations_spaOrderByRelevanceFieldEnum = (typeof quote_calculations_spaOrderByRelevanceFieldEnum)[keyof typeof quote_calculations_spaOrderByRelevanceFieldEnum]


  export const register_partners_autOrderByRelevanceFieldEnum: {
    id: 'id',
    complete_name: 'complete_name',
    phone_number: 'phone_number',
    email: 'email',
    birth_date: 'birth_date',
    city: 'city',
    obs: 'obs'
  };

  export type register_partners_autOrderByRelevanceFieldEnum = (typeof register_partners_autOrderByRelevanceFieldEnum)[keyof typeof register_partners_autOrderByRelevanceFieldEnum]


  export const register_partners_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    complete_name: 'complete_name',
    phone_number: 'phone_number',
    email: 'email',
    birth_date: 'birth_date',
    city: 'city'
  };

  export type register_partners_spaOrderByRelevanceFieldEnum = (typeof register_partners_spaOrderByRelevanceFieldEnum)[keyof typeof register_partners_spaOrderByRelevanceFieldEnum]


  export const rh_callsOrderByRelevanceFieldEnum: {
    id: 'id',
    jid: 'jid',
    name: 'name',
    message: 'message',
    rhNumberId: 'rhNumberId'
  };

  export type rh_callsOrderByRelevanceFieldEnum = (typeof rh_callsOrderByRelevanceFieldEnum)[keyof typeof rh_callsOrderByRelevanceFieldEnum]


  export const rh_numbersOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    phone_number: 'phone_number'
  };

  export type rh_numbersOrderByRelevanceFieldEnum = (typeof rh_numbersOrderByRelevanceFieldEnum)[keyof typeof rh_numbersOrderByRelevanceFieldEnum]


  export const seller_codesOrderByRelevanceFieldEnum: {
    id: 'id',
    square: 'square'
  };

  export type seller_codesOrderByRelevanceFieldEnum = (typeof seller_codesOrderByRelevanceFieldEnum)[keyof typeof seller_codesOrderByRelevanceFieldEnum]


  export const sessions_autOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type sessions_autOrderByRelevanceFieldEnum = (typeof sessions_autOrderByRelevanceFieldEnum)[keyof typeof sessions_autOrderByRelevanceFieldEnum]


  export const sessions_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type sessions_cltOrderByRelevanceFieldEnum = (typeof sessions_cltOrderByRelevanceFieldEnum)[keyof typeof sessions_cltOrderByRelevanceFieldEnum]


  export const sessions_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type sessions_goiOrderByRelevanceFieldEnum = (typeof sessions_goiOrderByRelevanceFieldEnum)[keyof typeof sessions_goiOrderByRelevanceFieldEnum]


  export const sessions_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type sessions_spaOrderByRelevanceFieldEnum = (typeof sessions_spaOrderByRelevanceFieldEnum)[keyof typeof sessions_spaOrderByRelevanceFieldEnum]


  export const supervisor_register_partnersOrderByRelevanceFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    name: 'name'
  };

  export type supervisor_register_partnersOrderByRelevanceFieldEnum = (typeof supervisor_register_partnersOrderByRelevanceFieldEnum)[keyof typeof supervisor_register_partnersOrderByRelevanceFieldEnum]


  export const testers_autOrderByRelevanceFieldEnum: {
    id: 'id',
    phone_number: 'phone_number'
  };

  export type testers_autOrderByRelevanceFieldEnum = (typeof testers_autOrderByRelevanceFieldEnum)[keyof typeof testers_autOrderByRelevanceFieldEnum]


  export const testers_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    phone_number: 'phone_number'
  };

  export type testers_cltOrderByRelevanceFieldEnum = (typeof testers_cltOrderByRelevanceFieldEnum)[keyof typeof testers_cltOrderByRelevanceFieldEnum]


  export const testers_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    phone_number: 'phone_number'
  };

  export type testers_goiOrderByRelevanceFieldEnum = (typeof testers_goiOrderByRelevanceFieldEnum)[keyof typeof testers_goiOrderByRelevanceFieldEnum]


  export const testers_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    phone_number: 'phone_number'
  };

  export type testers_spaOrderByRelevanceFieldEnum = (typeof testers_spaOrderByRelevanceFieldEnum)[keyof typeof testers_spaOrderByRelevanceFieldEnum]


  export const threads_autOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    thread: 'thread'
  };

  export type threads_autOrderByRelevanceFieldEnum = (typeof threads_autOrderByRelevanceFieldEnum)[keyof typeof threads_autOrderByRelevanceFieldEnum]


  export const threads_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    thread: 'thread'
  };

  export type threads_cltOrderByRelevanceFieldEnum = (typeof threads_cltOrderByRelevanceFieldEnum)[keyof typeof threads_cltOrderByRelevanceFieldEnum]


  export const threads_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    thread: 'thread'
  };

  export type threads_goiOrderByRelevanceFieldEnum = (typeof threads_goiOrderByRelevanceFieldEnum)[keyof typeof threads_goiOrderByRelevanceFieldEnum]


  export const threads_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    thread: 'thread'
  };

  export type threads_spaOrderByRelevanceFieldEnum = (typeof threads_spaOrderByRelevanceFieldEnum)[keyof typeof threads_spaOrderByRelevanceFieldEnum]


  export const tokens_generated_autOrderByRelevanceFieldEnum: {
    id: 'id',
    create_token_id: 'create_token_id',
    user_id: 'user_id'
  };

  export type tokens_generated_autOrderByRelevanceFieldEnum = (typeof tokens_generated_autOrderByRelevanceFieldEnum)[keyof typeof tokens_generated_autOrderByRelevanceFieldEnum]


  export const tokens_generated_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    create_token_id: 'create_token_id',
    user_id: 'user_id'
  };

  export type tokens_generated_cltOrderByRelevanceFieldEnum = (typeof tokens_generated_cltOrderByRelevanceFieldEnum)[keyof typeof tokens_generated_cltOrderByRelevanceFieldEnum]


  export const tokens_generated_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    create_token_id: 'create_token_id',
    user_id: 'user_id'
  };

  export type tokens_generated_goiOrderByRelevanceFieldEnum = (typeof tokens_generated_goiOrderByRelevanceFieldEnum)[keyof typeof tokens_generated_goiOrderByRelevanceFieldEnum]


  export const tokens_generated_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    create_token_id: 'create_token_id',
    user_id: 'user_id'
  };

  export type tokens_generated_spaOrderByRelevanceFieldEnum = (typeof tokens_generated_spaOrderByRelevanceFieldEnum)[keyof typeof tokens_generated_spaOrderByRelevanceFieldEnum]


  export const trainings_links_autOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training: 'training'
  };

  export type trainings_links_autOrderByRelevanceFieldEnum = (typeof trainings_links_autOrderByRelevanceFieldEnum)[keyof typeof trainings_links_autOrderByRelevanceFieldEnum]


  export const trainings_links_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training: 'training'
  };

  export type trainings_links_cltOrderByRelevanceFieldEnum = (typeof trainings_links_cltOrderByRelevanceFieldEnum)[keyof typeof trainings_links_cltOrderByRelevanceFieldEnum]


  export const trainings_links_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training: 'training'
  };

  export type trainings_links_goiOrderByRelevanceFieldEnum = (typeof trainings_links_goiOrderByRelevanceFieldEnum)[keyof typeof trainings_links_goiOrderByRelevanceFieldEnum]


  export const trainings_links_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training: 'training'
  };

  export type trainings_links_spaOrderByRelevanceFieldEnum = (typeof trainings_links_spaOrderByRelevanceFieldEnum)[keyof typeof trainings_links_spaOrderByRelevanceFieldEnum]


  export const users_autOrderByRelevanceFieldEnum: {
    id: 'id',
    last_session_id: 'last_session_id'
  };

  export type users_autOrderByRelevanceFieldEnum = (typeof users_autOrderByRelevanceFieldEnum)[keyof typeof users_autOrderByRelevanceFieldEnum]


  export const users_cltOrderByRelevanceFieldEnum: {
    id: 'id',
    last_session_id: 'last_session_id'
  };

  export type users_cltOrderByRelevanceFieldEnum = (typeof users_cltOrderByRelevanceFieldEnum)[keyof typeof users_cltOrderByRelevanceFieldEnum]


  export const users_goiOrderByRelevanceFieldEnum: {
    id: 'id',
    last_session_id: 'last_session_id'
  };

  export type users_goiOrderByRelevanceFieldEnum = (typeof users_goiOrderByRelevanceFieldEnum)[keyof typeof users_goiOrderByRelevanceFieldEnum]


  export const users_spaOrderByRelevanceFieldEnum: {
    id: 'id',
    last_session_id: 'last_session_id'
  };

  export type users_spaOrderByRelevanceFieldEnum = (typeof users_spaOrderByRelevanceFieldEnum)[keyof typeof users_spaOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type SequelizeMetaWhereInput = {
    AND?: SequelizeMetaWhereInput | SequelizeMetaWhereInput[]
    OR?: SequelizeMetaWhereInput[]
    NOT?: SequelizeMetaWhereInput | SequelizeMetaWhereInput[]
    name?: StringFilter<"SequelizeMeta"> | string
  }

  export type SequelizeMetaOrderByWithRelationInput = {
    name?: SortOrder
    _relevance?: SequelizeMetaOrderByRelevanceInput
  }

  export type SequelizeMetaWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: SequelizeMetaWhereInput | SequelizeMetaWhereInput[]
    OR?: SequelizeMetaWhereInput[]
    NOT?: SequelizeMetaWhereInput | SequelizeMetaWhereInput[]
  }, "name" | "name">

  export type SequelizeMetaOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: SequelizeMetaCountOrderByAggregateInput
    _max?: SequelizeMetaMaxOrderByAggregateInput
    _min?: SequelizeMetaMinOrderByAggregateInput
  }

  export type SequelizeMetaScalarWhereWithAggregatesInput = {
    AND?: SequelizeMetaScalarWhereWithAggregatesInput | SequelizeMetaScalarWhereWithAggregatesInput[]
    OR?: SequelizeMetaScalarWhereWithAggregatesInput[]
    NOT?: SequelizeMetaScalarWhereWithAggregatesInput | SequelizeMetaScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"SequelizeMeta"> | string
  }

  export type accommodation_quotationsWhereInput = {
    AND?: accommodation_quotationsWhereInput | accommodation_quotationsWhereInput[]
    OR?: accommodation_quotationsWhereInput[]
    NOT?: accommodation_quotationsWhereInput | accommodation_quotationsWhereInput[]
    id?: BigIntFilter<"accommodation_quotations"> | bigint | number
    name?: StringFilter<"accommodation_quotations"> | string
  }

  export type accommodation_quotationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    _relevance?: accommodation_quotationsOrderByRelevanceInput
  }

  export type accommodation_quotationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: accommodation_quotationsWhereInput | accommodation_quotationsWhereInput[]
    OR?: accommodation_quotationsWhereInput[]
    NOT?: accommodation_quotationsWhereInput | accommodation_quotationsWhereInput[]
    name?: StringFilter<"accommodation_quotations"> | string
  }, "id">

  export type accommodation_quotationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: accommodation_quotationsCountOrderByAggregateInput
    _avg?: accommodation_quotationsAvgOrderByAggregateInput
    _max?: accommodation_quotationsMaxOrderByAggregateInput
    _min?: accommodation_quotationsMinOrderByAggregateInput
    _sum?: accommodation_quotationsSumOrderByAggregateInput
  }

  export type accommodation_quotationsScalarWhereWithAggregatesInput = {
    AND?: accommodation_quotationsScalarWhereWithAggregatesInput | accommodation_quotationsScalarWhereWithAggregatesInput[]
    OR?: accommodation_quotationsScalarWhereWithAggregatesInput[]
    NOT?: accommodation_quotationsScalarWhereWithAggregatesInput | accommodation_quotationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"accommodation_quotations"> | bigint | number
    name?: StringWithAggregatesFilter<"accommodation_quotations"> | string
  }

  export type attendantWhereInput = {
    AND?: attendantWhereInput | attendantWhereInput[]
    OR?: attendantWhereInput[]
    NOT?: attendantWhereInput | attendantWhereInput[]
    id?: StringFilter<"attendant"> | string
    jid?: StringFilter<"attendant"> | string
    name?: StringFilter<"attendant"> | string
    password?: StringFilter<"attendant"> | string
    token?: StringNullableFilter<"attendant"> | string | null
    isAdmin?: BoolFilter<"attendant"> | boolean
    createdAt?: DateTimeFilter<"attendant"> | Date | string
    updatedAt?: DateTimeFilter<"attendant"> | Date | string
    calls?: CallsListRelationFilter
  }

  export type attendantOrderByWithRelationInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    password?: SortOrder
    token?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calls?: callsOrderByRelationAggregateInput
    _relevance?: attendantOrderByRelevanceInput
  }

  export type attendantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jid?: string
    AND?: attendantWhereInput | attendantWhereInput[]
    OR?: attendantWhereInput[]
    NOT?: attendantWhereInput | attendantWhereInput[]
    name?: StringFilter<"attendant"> | string
    password?: StringFilter<"attendant"> | string
    token?: StringNullableFilter<"attendant"> | string | null
    isAdmin?: BoolFilter<"attendant"> | boolean
    createdAt?: DateTimeFilter<"attendant"> | Date | string
    updatedAt?: DateTimeFilter<"attendant"> | Date | string
    calls?: CallsListRelationFilter
  }, "id" | "jid">

  export type attendantOrderByWithAggregationInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    password?: SortOrder
    token?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: attendantCountOrderByAggregateInput
    _max?: attendantMaxOrderByAggregateInput
    _min?: attendantMinOrderByAggregateInput
  }

  export type attendantScalarWhereWithAggregatesInput = {
    AND?: attendantScalarWhereWithAggregatesInput | attendantScalarWhereWithAggregatesInput[]
    OR?: attendantScalarWhereWithAggregatesInput[]
    NOT?: attendantScalarWhereWithAggregatesInput | attendantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"attendant"> | string
    jid?: StringWithAggregatesFilter<"attendant"> | string
    name?: StringWithAggregatesFilter<"attendant"> | string
    password?: StringWithAggregatesFilter<"attendant"> | string
    token?: StringNullableWithAggregatesFilter<"attendant"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"attendant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"attendant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"attendant"> | Date | string
  }

  export type attendant_callsWhereInput = {
    AND?: attendant_callsWhereInput | attendant_callsWhereInput[]
    OR?: attendant_callsWhereInput[]
    NOT?: attendant_callsWhereInput | attendant_callsWhereInput[]
    id?: StringFilter<"attendant_calls"> | string
    jid?: StringFilter<"attendant_calls"> | string
    mainProblem?: StringFilter<"attendant_calls"> | string
    detailsProblem?: StringFilter<"attendant_calls"> | string
    pushName?: StringFilter<"attendant_calls"> | string
    attendantId?: StringNullableFilter<"attendant_calls"> | string | null
    isResolved?: BoolFilter<"attendant_calls"> | boolean
    createdAt?: DateTimeFilter<"attendant_calls"> | Date | string
    updatedAt?: DateTimeFilter<"attendant_calls"> | Date | string
    attendants?: XOR<AttendantsNullableScalarRelationFilter, attendantsWhereInput> | null
  }

  export type attendant_callsOrderByWithRelationInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attendants?: attendantsOrderByWithRelationInput
    _relevance?: attendant_callsOrderByRelevanceInput
  }

  export type attendant_callsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: attendant_callsWhereInput | attendant_callsWhereInput[]
    OR?: attendant_callsWhereInput[]
    NOT?: attendant_callsWhereInput | attendant_callsWhereInput[]
    jid?: StringFilter<"attendant_calls"> | string
    mainProblem?: StringFilter<"attendant_calls"> | string
    detailsProblem?: StringFilter<"attendant_calls"> | string
    pushName?: StringFilter<"attendant_calls"> | string
    attendantId?: StringNullableFilter<"attendant_calls"> | string | null
    isResolved?: BoolFilter<"attendant_calls"> | boolean
    createdAt?: DateTimeFilter<"attendant_calls"> | Date | string
    updatedAt?: DateTimeFilter<"attendant_calls"> | Date | string
    attendants?: XOR<AttendantsNullableScalarRelationFilter, attendantsWhereInput> | null
  }, "id">

  export type attendant_callsOrderByWithAggregationInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: attendant_callsCountOrderByAggregateInput
    _max?: attendant_callsMaxOrderByAggregateInput
    _min?: attendant_callsMinOrderByAggregateInput
  }

  export type attendant_callsScalarWhereWithAggregatesInput = {
    AND?: attendant_callsScalarWhereWithAggregatesInput | attendant_callsScalarWhereWithAggregatesInput[]
    OR?: attendant_callsScalarWhereWithAggregatesInput[]
    NOT?: attendant_callsScalarWhereWithAggregatesInput | attendant_callsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"attendant_calls"> | string
    jid?: StringWithAggregatesFilter<"attendant_calls"> | string
    mainProblem?: StringWithAggregatesFilter<"attendant_calls"> | string
    detailsProblem?: StringWithAggregatesFilter<"attendant_calls"> | string
    pushName?: StringWithAggregatesFilter<"attendant_calls"> | string
    attendantId?: StringNullableWithAggregatesFilter<"attendant_calls"> | string | null
    isResolved?: BoolWithAggregatesFilter<"attendant_calls"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"attendant_calls"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"attendant_calls"> | Date | string
  }

  export type attendantsWhereInput = {
    AND?: attendantsWhereInput | attendantsWhereInput[]
    OR?: attendantsWhereInput[]
    NOT?: attendantsWhereInput | attendantsWhereInput[]
    id?: StringFilter<"attendants"> | string
    jid?: StringFilter<"attendants"> | string
    name?: StringFilter<"attendants"> | string
    isAdmin?: BoolFilter<"attendants"> | boolean
    createdAt?: DateTimeFilter<"attendants"> | Date | string
    updatedAt?: DateTimeFilter<"attendants"> | Date | string
    attendant_calls?: Attendant_callsListRelationFilter
  }

  export type attendantsOrderByWithRelationInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attendant_calls?: attendant_callsOrderByRelationAggregateInput
    _relevance?: attendantsOrderByRelevanceInput
  }

  export type attendantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jid?: string
    AND?: attendantsWhereInput | attendantsWhereInput[]
    OR?: attendantsWhereInput[]
    NOT?: attendantsWhereInput | attendantsWhereInput[]
    name?: StringFilter<"attendants"> | string
    isAdmin?: BoolFilter<"attendants"> | boolean
    createdAt?: DateTimeFilter<"attendants"> | Date | string
    updatedAt?: DateTimeFilter<"attendants"> | Date | string
    attendant_calls?: Attendant_callsListRelationFilter
  }, "id" | "jid">

  export type attendantsOrderByWithAggregationInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: attendantsCountOrderByAggregateInput
    _max?: attendantsMaxOrderByAggregateInput
    _min?: attendantsMinOrderByAggregateInput
  }

  export type attendantsScalarWhereWithAggregatesInput = {
    AND?: attendantsScalarWhereWithAggregatesInput | attendantsScalarWhereWithAggregatesInput[]
    OR?: attendantsScalarWhereWithAggregatesInput[]
    NOT?: attendantsScalarWhereWithAggregatesInput | attendantsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"attendants"> | string
    jid?: StringWithAggregatesFilter<"attendants"> | string
    name?: StringWithAggregatesFilter<"attendants"> | string
    isAdmin?: BoolWithAggregatesFilter<"attendants"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"attendants"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"attendants"> | Date | string
  }

  export type budget_consults_autWhereInput = {
    AND?: budget_consults_autWhereInput | budget_consults_autWhereInput[]
    OR?: budget_consults_autWhereInput[]
    NOT?: budget_consults_autWhereInput | budget_consults_autWhereInput[]
    id?: StringFilter<"budget_consults_aut"> | string
    budget_code?: IntFilter<"budget_consults_aut"> | number
    is_error?: BoolFilter<"budget_consults_aut"> | boolean
    user_id?: StringFilter<"budget_consults_aut"> | string
    createdAt?: DateTimeFilter<"budget_consults_aut"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }

  export type budget_consults_autOrderByWithRelationInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_aut?: users_autOrderByWithRelationInput
    _relevance?: budget_consults_autOrderByRelevanceInput
  }

  export type budget_consults_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: budget_consults_autWhereInput | budget_consults_autWhereInput[]
    OR?: budget_consults_autWhereInput[]
    NOT?: budget_consults_autWhereInput | budget_consults_autWhereInput[]
    budget_code?: IntFilter<"budget_consults_aut"> | number
    is_error?: BoolFilter<"budget_consults_aut"> | boolean
    user_id?: StringFilter<"budget_consults_aut"> | string
    createdAt?: DateTimeFilter<"budget_consults_aut"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }, "id">

  export type budget_consults_autOrderByWithAggregationInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: budget_consults_autCountOrderByAggregateInput
    _avg?: budget_consults_autAvgOrderByAggregateInput
    _max?: budget_consults_autMaxOrderByAggregateInput
    _min?: budget_consults_autMinOrderByAggregateInput
    _sum?: budget_consults_autSumOrderByAggregateInput
  }

  export type budget_consults_autScalarWhereWithAggregatesInput = {
    AND?: budget_consults_autScalarWhereWithAggregatesInput | budget_consults_autScalarWhereWithAggregatesInput[]
    OR?: budget_consults_autScalarWhereWithAggregatesInput[]
    NOT?: budget_consults_autScalarWhereWithAggregatesInput | budget_consults_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"budget_consults_aut"> | string
    budget_code?: IntWithAggregatesFilter<"budget_consults_aut"> | number
    is_error?: BoolWithAggregatesFilter<"budget_consults_aut"> | boolean
    user_id?: StringWithAggregatesFilter<"budget_consults_aut"> | string
    createdAt?: DateTimeWithAggregatesFilter<"budget_consults_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"budget_consults_aut"> | Date | string
  }

  export type budget_consults_cltWhereInput = {
    AND?: budget_consults_cltWhereInput | budget_consults_cltWhereInput[]
    OR?: budget_consults_cltWhereInput[]
    NOT?: budget_consults_cltWhereInput | budget_consults_cltWhereInput[]
    id?: StringFilter<"budget_consults_clt"> | string
    budget_code?: IntFilter<"budget_consults_clt"> | number
    is_error?: BoolFilter<"budget_consults_clt"> | boolean
    user_id?: StringFilter<"budget_consults_clt"> | string
    createdAt?: DateTimeFilter<"budget_consults_clt"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }

  export type budget_consults_cltOrderByWithRelationInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_clt?: users_cltOrderByWithRelationInput
    _relevance?: budget_consults_cltOrderByRelevanceInput
  }

  export type budget_consults_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: budget_consults_cltWhereInput | budget_consults_cltWhereInput[]
    OR?: budget_consults_cltWhereInput[]
    NOT?: budget_consults_cltWhereInput | budget_consults_cltWhereInput[]
    budget_code?: IntFilter<"budget_consults_clt"> | number
    is_error?: BoolFilter<"budget_consults_clt"> | boolean
    user_id?: StringFilter<"budget_consults_clt"> | string
    createdAt?: DateTimeFilter<"budget_consults_clt"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }, "id">

  export type budget_consults_cltOrderByWithAggregationInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: budget_consults_cltCountOrderByAggregateInput
    _avg?: budget_consults_cltAvgOrderByAggregateInput
    _max?: budget_consults_cltMaxOrderByAggregateInput
    _min?: budget_consults_cltMinOrderByAggregateInput
    _sum?: budget_consults_cltSumOrderByAggregateInput
  }

  export type budget_consults_cltScalarWhereWithAggregatesInput = {
    AND?: budget_consults_cltScalarWhereWithAggregatesInput | budget_consults_cltScalarWhereWithAggregatesInput[]
    OR?: budget_consults_cltScalarWhereWithAggregatesInput[]
    NOT?: budget_consults_cltScalarWhereWithAggregatesInput | budget_consults_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"budget_consults_clt"> | string
    budget_code?: IntWithAggregatesFilter<"budget_consults_clt"> | number
    is_error?: BoolWithAggregatesFilter<"budget_consults_clt"> | boolean
    user_id?: StringWithAggregatesFilter<"budget_consults_clt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"budget_consults_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"budget_consults_clt"> | Date | string
  }

  export type budget_consults_goiWhereInput = {
    AND?: budget_consults_goiWhereInput | budget_consults_goiWhereInput[]
    OR?: budget_consults_goiWhereInput[]
    NOT?: budget_consults_goiWhereInput | budget_consults_goiWhereInput[]
    id?: StringFilter<"budget_consults_goi"> | string
    budget_code?: IntFilter<"budget_consults_goi"> | number
    is_error?: BoolFilter<"budget_consults_goi"> | boolean
    user_id?: StringFilter<"budget_consults_goi"> | string
    createdAt?: DateTimeFilter<"budget_consults_goi"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }

  export type budget_consults_goiOrderByWithRelationInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_goi?: users_goiOrderByWithRelationInput
    _relevance?: budget_consults_goiOrderByRelevanceInput
  }

  export type budget_consults_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: budget_consults_goiWhereInput | budget_consults_goiWhereInput[]
    OR?: budget_consults_goiWhereInput[]
    NOT?: budget_consults_goiWhereInput | budget_consults_goiWhereInput[]
    budget_code?: IntFilter<"budget_consults_goi"> | number
    is_error?: BoolFilter<"budget_consults_goi"> | boolean
    user_id?: StringFilter<"budget_consults_goi"> | string
    createdAt?: DateTimeFilter<"budget_consults_goi"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }, "id">

  export type budget_consults_goiOrderByWithAggregationInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: budget_consults_goiCountOrderByAggregateInput
    _avg?: budget_consults_goiAvgOrderByAggregateInput
    _max?: budget_consults_goiMaxOrderByAggregateInput
    _min?: budget_consults_goiMinOrderByAggregateInput
    _sum?: budget_consults_goiSumOrderByAggregateInput
  }

  export type budget_consults_goiScalarWhereWithAggregatesInput = {
    AND?: budget_consults_goiScalarWhereWithAggregatesInput | budget_consults_goiScalarWhereWithAggregatesInput[]
    OR?: budget_consults_goiScalarWhereWithAggregatesInput[]
    NOT?: budget_consults_goiScalarWhereWithAggregatesInput | budget_consults_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"budget_consults_goi"> | string
    budget_code?: IntWithAggregatesFilter<"budget_consults_goi"> | number
    is_error?: BoolWithAggregatesFilter<"budget_consults_goi"> | boolean
    user_id?: StringWithAggregatesFilter<"budget_consults_goi"> | string
    createdAt?: DateTimeWithAggregatesFilter<"budget_consults_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"budget_consults_goi"> | Date | string
  }

  export type budget_consults_spaWhereInput = {
    AND?: budget_consults_spaWhereInput | budget_consults_spaWhereInput[]
    OR?: budget_consults_spaWhereInput[]
    NOT?: budget_consults_spaWhereInput | budget_consults_spaWhereInput[]
    id?: StringFilter<"budget_consults_spa"> | string
    budget_code?: IntFilter<"budget_consults_spa"> | number
    is_error?: BoolFilter<"budget_consults_spa"> | boolean
    user_id?: StringFilter<"budget_consults_spa"> | string
    createdAt?: DateTimeFilter<"budget_consults_spa"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }

  export type budget_consults_spaOrderByWithRelationInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_spa?: users_spaOrderByWithRelationInput
    _relevance?: budget_consults_spaOrderByRelevanceInput
  }

  export type budget_consults_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: budget_consults_spaWhereInput | budget_consults_spaWhereInput[]
    OR?: budget_consults_spaWhereInput[]
    NOT?: budget_consults_spaWhereInput | budget_consults_spaWhereInput[]
    budget_code?: IntFilter<"budget_consults_spa"> | number
    is_error?: BoolFilter<"budget_consults_spa"> | boolean
    user_id?: StringFilter<"budget_consults_spa"> | string
    createdAt?: DateTimeFilter<"budget_consults_spa"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }, "id">

  export type budget_consults_spaOrderByWithAggregationInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: budget_consults_spaCountOrderByAggregateInput
    _avg?: budget_consults_spaAvgOrderByAggregateInput
    _max?: budget_consults_spaMaxOrderByAggregateInput
    _min?: budget_consults_spaMinOrderByAggregateInput
    _sum?: budget_consults_spaSumOrderByAggregateInput
  }

  export type budget_consults_spaScalarWhereWithAggregatesInput = {
    AND?: budget_consults_spaScalarWhereWithAggregatesInput | budget_consults_spaScalarWhereWithAggregatesInput[]
    OR?: budget_consults_spaScalarWhereWithAggregatesInput[]
    NOT?: budget_consults_spaScalarWhereWithAggregatesInput | budget_consults_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"budget_consults_spa"> | string
    budget_code?: IntWithAggregatesFilter<"budget_consults_spa"> | number
    is_error?: BoolWithAggregatesFilter<"budget_consults_spa"> | boolean
    user_id?: StringWithAggregatesFilter<"budget_consults_spa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"budget_consults_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"budget_consults_spa"> | Date | string
  }

  export type callsWhereInput = {
    AND?: callsWhereInput | callsWhereInput[]
    OR?: callsWhereInput[]
    NOT?: callsWhereInput | callsWhereInput[]
    id?: StringFilter<"calls"> | string
    jid?: StringFilter<"calls"> | string
    mainProblem?: StringFilter<"calls"> | string
    detailsProblem?: StringFilter<"calls"> | string
    pushName?: StringFilter<"calls"> | string
    attendantId?: StringNullableFilter<"calls"> | string | null
    isResolved?: BoolFilter<"calls"> | boolean
    createdAt?: DateTimeFilter<"calls"> | Date | string
    updatedAt?: DateTimeFilter<"calls"> | Date | string
    attendant?: XOR<AttendantNullableScalarRelationFilter, attendantWhereInput> | null
  }

  export type callsOrderByWithRelationInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attendant?: attendantOrderByWithRelationInput
    _relevance?: callsOrderByRelevanceInput
  }

  export type callsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: callsWhereInput | callsWhereInput[]
    OR?: callsWhereInput[]
    NOT?: callsWhereInput | callsWhereInput[]
    jid?: StringFilter<"calls"> | string
    mainProblem?: StringFilter<"calls"> | string
    detailsProblem?: StringFilter<"calls"> | string
    pushName?: StringFilter<"calls"> | string
    attendantId?: StringNullableFilter<"calls"> | string | null
    isResolved?: BoolFilter<"calls"> | boolean
    createdAt?: DateTimeFilter<"calls"> | Date | string
    updatedAt?: DateTimeFilter<"calls"> | Date | string
    attendant?: XOR<AttendantNullableScalarRelationFilter, attendantWhereInput> | null
  }, "id">

  export type callsOrderByWithAggregationInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: callsCountOrderByAggregateInput
    _max?: callsMaxOrderByAggregateInput
    _min?: callsMinOrderByAggregateInput
  }

  export type callsScalarWhereWithAggregatesInput = {
    AND?: callsScalarWhereWithAggregatesInput | callsScalarWhereWithAggregatesInput[]
    OR?: callsScalarWhereWithAggregatesInput[]
    NOT?: callsScalarWhereWithAggregatesInput | callsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"calls"> | string
    jid?: StringWithAggregatesFilter<"calls"> | string
    mainProblem?: StringWithAggregatesFilter<"calls"> | string
    detailsProblem?: StringWithAggregatesFilter<"calls"> | string
    pushName?: StringWithAggregatesFilter<"calls"> | string
    attendantId?: StringNullableWithAggregatesFilter<"calls"> | string | null
    isResolved?: BoolWithAggregatesFilter<"calls"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"calls"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"calls"> | Date | string
  }

  export type cities_quotationsWhereInput = {
    AND?: cities_quotationsWhereInput | cities_quotationsWhereInput[]
    OR?: cities_quotationsWhereInput[]
    NOT?: cities_quotationsWhereInput | cities_quotationsWhereInput[]
    id?: BigIntFilter<"cities_quotations"> | bigint | number
    name?: StringFilter<"cities_quotations"> | string
  }

  export type cities_quotationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    _relevance?: cities_quotationsOrderByRelevanceInput
  }

  export type cities_quotationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: cities_quotationsWhereInput | cities_quotationsWhereInput[]
    OR?: cities_quotationsWhereInput[]
    NOT?: cities_quotationsWhereInput | cities_quotationsWhereInput[]
    name?: StringFilter<"cities_quotations"> | string
  }, "id">

  export type cities_quotationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: cities_quotationsCountOrderByAggregateInput
    _avg?: cities_quotationsAvgOrderByAggregateInput
    _max?: cities_quotationsMaxOrderByAggregateInput
    _min?: cities_quotationsMinOrderByAggregateInput
    _sum?: cities_quotationsSumOrderByAggregateInput
  }

  export type cities_quotationsScalarWhereWithAggregatesInput = {
    AND?: cities_quotationsScalarWhereWithAggregatesInput | cities_quotationsScalarWhereWithAggregatesInput[]
    OR?: cities_quotationsScalarWhereWithAggregatesInput[]
    NOT?: cities_quotationsScalarWhereWithAggregatesInput | cities_quotationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"cities_quotations"> | bigint | number
    name?: StringWithAggregatesFilter<"cities_quotations"> | string
  }

  export type configs_bot_autWhereInput = {
    AND?: configs_bot_autWhereInput | configs_bot_autWhereInput[]
    OR?: configs_bot_autWhereInput[]
    NOT?: configs_bot_autWhereInput | configs_bot_autWhereInput[]
    id?: StringFilter<"configs_bot_aut"> | string
    tag?: StringFilter<"configs_bot_aut"> | string
    is_actived?: BoolFilter<"configs_bot_aut"> | boolean
    createdAt?: DateTimeFilter<"configs_bot_aut"> | Date | string
    updatedAt?: DateTimeFilter<"configs_bot_aut"> | Date | string
  }

  export type configs_bot_autOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: configs_bot_autOrderByRelevanceInput
  }

  export type configs_bot_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag?: string
    AND?: configs_bot_autWhereInput | configs_bot_autWhereInput[]
    OR?: configs_bot_autWhereInput[]
    NOT?: configs_bot_autWhereInput | configs_bot_autWhereInput[]
    is_actived?: BoolFilter<"configs_bot_aut"> | boolean
    createdAt?: DateTimeFilter<"configs_bot_aut"> | Date | string
    updatedAt?: DateTimeFilter<"configs_bot_aut"> | Date | string
  }, "id" | "tag">

  export type configs_bot_autOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: configs_bot_autCountOrderByAggregateInput
    _max?: configs_bot_autMaxOrderByAggregateInput
    _min?: configs_bot_autMinOrderByAggregateInput
  }

  export type configs_bot_autScalarWhereWithAggregatesInput = {
    AND?: configs_bot_autScalarWhereWithAggregatesInput | configs_bot_autScalarWhereWithAggregatesInput[]
    OR?: configs_bot_autScalarWhereWithAggregatesInput[]
    NOT?: configs_bot_autScalarWhereWithAggregatesInput | configs_bot_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"configs_bot_aut"> | string
    tag?: StringWithAggregatesFilter<"configs_bot_aut"> | string
    is_actived?: BoolWithAggregatesFilter<"configs_bot_aut"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"configs_bot_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"configs_bot_aut"> | Date | string
  }

  export type configs_bot_cltWhereInput = {
    AND?: configs_bot_cltWhereInput | configs_bot_cltWhereInput[]
    OR?: configs_bot_cltWhereInput[]
    NOT?: configs_bot_cltWhereInput | configs_bot_cltWhereInput[]
    id?: StringFilter<"configs_bot_clt"> | string
    tag?: StringFilter<"configs_bot_clt"> | string
    is_actived?: BoolFilter<"configs_bot_clt"> | boolean
    createdAt?: DateTimeFilter<"configs_bot_clt"> | Date | string
    updatedAt?: DateTimeFilter<"configs_bot_clt"> | Date | string
  }

  export type configs_bot_cltOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: configs_bot_cltOrderByRelevanceInput
  }

  export type configs_bot_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag?: string
    AND?: configs_bot_cltWhereInput | configs_bot_cltWhereInput[]
    OR?: configs_bot_cltWhereInput[]
    NOT?: configs_bot_cltWhereInput | configs_bot_cltWhereInput[]
    is_actived?: BoolFilter<"configs_bot_clt"> | boolean
    createdAt?: DateTimeFilter<"configs_bot_clt"> | Date | string
    updatedAt?: DateTimeFilter<"configs_bot_clt"> | Date | string
  }, "id" | "tag">

  export type configs_bot_cltOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: configs_bot_cltCountOrderByAggregateInput
    _max?: configs_bot_cltMaxOrderByAggregateInput
    _min?: configs_bot_cltMinOrderByAggregateInput
  }

  export type configs_bot_cltScalarWhereWithAggregatesInput = {
    AND?: configs_bot_cltScalarWhereWithAggregatesInput | configs_bot_cltScalarWhereWithAggregatesInput[]
    OR?: configs_bot_cltScalarWhereWithAggregatesInput[]
    NOT?: configs_bot_cltScalarWhereWithAggregatesInput | configs_bot_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"configs_bot_clt"> | string
    tag?: StringWithAggregatesFilter<"configs_bot_clt"> | string
    is_actived?: BoolWithAggregatesFilter<"configs_bot_clt"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"configs_bot_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"configs_bot_clt"> | Date | string
  }

  export type configs_bot_goiWhereInput = {
    AND?: configs_bot_goiWhereInput | configs_bot_goiWhereInput[]
    OR?: configs_bot_goiWhereInput[]
    NOT?: configs_bot_goiWhereInput | configs_bot_goiWhereInput[]
    id?: StringFilter<"configs_bot_goi"> | string
    tag?: StringFilter<"configs_bot_goi"> | string
    is_actived?: BoolFilter<"configs_bot_goi"> | boolean
    createdAt?: DateTimeFilter<"configs_bot_goi"> | Date | string
    updatedAt?: DateTimeFilter<"configs_bot_goi"> | Date | string
  }

  export type configs_bot_goiOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: configs_bot_goiOrderByRelevanceInput
  }

  export type configs_bot_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag?: string
    AND?: configs_bot_goiWhereInput | configs_bot_goiWhereInput[]
    OR?: configs_bot_goiWhereInput[]
    NOT?: configs_bot_goiWhereInput | configs_bot_goiWhereInput[]
    is_actived?: BoolFilter<"configs_bot_goi"> | boolean
    createdAt?: DateTimeFilter<"configs_bot_goi"> | Date | string
    updatedAt?: DateTimeFilter<"configs_bot_goi"> | Date | string
  }, "id" | "tag">

  export type configs_bot_goiOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: configs_bot_goiCountOrderByAggregateInput
    _max?: configs_bot_goiMaxOrderByAggregateInput
    _min?: configs_bot_goiMinOrderByAggregateInput
  }

  export type configs_bot_goiScalarWhereWithAggregatesInput = {
    AND?: configs_bot_goiScalarWhereWithAggregatesInput | configs_bot_goiScalarWhereWithAggregatesInput[]
    OR?: configs_bot_goiScalarWhereWithAggregatesInput[]
    NOT?: configs_bot_goiScalarWhereWithAggregatesInput | configs_bot_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"configs_bot_goi"> | string
    tag?: StringWithAggregatesFilter<"configs_bot_goi"> | string
    is_actived?: BoolWithAggregatesFilter<"configs_bot_goi"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"configs_bot_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"configs_bot_goi"> | Date | string
  }

  export type configs_bot_spaWhereInput = {
    AND?: configs_bot_spaWhereInput | configs_bot_spaWhereInput[]
    OR?: configs_bot_spaWhereInput[]
    NOT?: configs_bot_spaWhereInput | configs_bot_spaWhereInput[]
    id?: StringFilter<"configs_bot_spa"> | string
    tag?: StringFilter<"configs_bot_spa"> | string
    is_actived?: BoolFilter<"configs_bot_spa"> | boolean
    createdAt?: DateTimeFilter<"configs_bot_spa"> | Date | string
    updatedAt?: DateTimeFilter<"configs_bot_spa"> | Date | string
  }

  export type configs_bot_spaOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: configs_bot_spaOrderByRelevanceInput
  }

  export type configs_bot_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag?: string
    AND?: configs_bot_spaWhereInput | configs_bot_spaWhereInput[]
    OR?: configs_bot_spaWhereInput[]
    NOT?: configs_bot_spaWhereInput | configs_bot_spaWhereInput[]
    is_actived?: BoolFilter<"configs_bot_spa"> | boolean
    createdAt?: DateTimeFilter<"configs_bot_spa"> | Date | string
    updatedAt?: DateTimeFilter<"configs_bot_spa"> | Date | string
  }, "id" | "tag">

  export type configs_bot_spaOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: configs_bot_spaCountOrderByAggregateInput
    _max?: configs_bot_spaMaxOrderByAggregateInput
    _min?: configs_bot_spaMinOrderByAggregateInput
  }

  export type configs_bot_spaScalarWhereWithAggregatesInput = {
    AND?: configs_bot_spaScalarWhereWithAggregatesInput | configs_bot_spaScalarWhereWithAggregatesInput[]
    OR?: configs_bot_spaScalarWhereWithAggregatesInput[]
    NOT?: configs_bot_spaScalarWhereWithAggregatesInput | configs_bot_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"configs_bot_spa"> | string
    tag?: StringWithAggregatesFilter<"configs_bot_spa"> | string
    is_actived?: BoolWithAggregatesFilter<"configs_bot_spa"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"configs_bot_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"configs_bot_spa"> | Date | string
  }

  export type coparticipation_type_quotationsWhereInput = {
    AND?: coparticipation_type_quotationsWhereInput | coparticipation_type_quotationsWhereInput[]
    OR?: coparticipation_type_quotationsWhereInput[]
    NOT?: coparticipation_type_quotationsWhereInput | coparticipation_type_quotationsWhereInput[]
    id?: BigIntFilter<"coparticipation_type_quotations"> | bigint | number
    name?: StringFilter<"coparticipation_type_quotations"> | string
  }

  export type coparticipation_type_quotationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    _relevance?: coparticipation_type_quotationsOrderByRelevanceInput
  }

  export type coparticipation_type_quotationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: coparticipation_type_quotationsWhereInput | coparticipation_type_quotationsWhereInput[]
    OR?: coparticipation_type_quotationsWhereInput[]
    NOT?: coparticipation_type_quotationsWhereInput | coparticipation_type_quotationsWhereInput[]
    name?: StringFilter<"coparticipation_type_quotations"> | string
  }, "id">

  export type coparticipation_type_quotationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: coparticipation_type_quotationsCountOrderByAggregateInput
    _avg?: coparticipation_type_quotationsAvgOrderByAggregateInput
    _max?: coparticipation_type_quotationsMaxOrderByAggregateInput
    _min?: coparticipation_type_quotationsMinOrderByAggregateInput
    _sum?: coparticipation_type_quotationsSumOrderByAggregateInput
  }

  export type coparticipation_type_quotationsScalarWhereWithAggregatesInput = {
    AND?: coparticipation_type_quotationsScalarWhereWithAggregatesInput | coparticipation_type_quotationsScalarWhereWithAggregatesInput[]
    OR?: coparticipation_type_quotationsScalarWhereWithAggregatesInput[]
    NOT?: coparticipation_type_quotationsScalarWhereWithAggregatesInput | coparticipation_type_quotationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"coparticipation_type_quotations"> | bigint | number
    name?: StringWithAggregatesFilter<"coparticipation_type_quotations"> | string
  }

  export type cpf_consults_autWhereInput = {
    AND?: cpf_consults_autWhereInput | cpf_consults_autWhereInput[]
    OR?: cpf_consults_autWhereInput[]
    NOT?: cpf_consults_autWhereInput | cpf_consults_autWhereInput[]
    id?: StringFilter<"cpf_consults_aut"> | string
    cpf?: StringFilter<"cpf_consults_aut"> | string
    user_id?: StringFilter<"cpf_consults_aut"> | string
    is_error?: BoolFilter<"cpf_consults_aut"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_aut"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }

  export type cpf_consults_autOrderByWithRelationInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_aut?: users_autOrderByWithRelationInput
    _relevance?: cpf_consults_autOrderByRelevanceInput
  }

  export type cpf_consults_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cpf_consults_autWhereInput | cpf_consults_autWhereInput[]
    OR?: cpf_consults_autWhereInput[]
    NOT?: cpf_consults_autWhereInput | cpf_consults_autWhereInput[]
    cpf?: StringFilter<"cpf_consults_aut"> | string
    user_id?: StringFilter<"cpf_consults_aut"> | string
    is_error?: BoolFilter<"cpf_consults_aut"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_aut"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }, "id">

  export type cpf_consults_autOrderByWithAggregationInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: cpf_consults_autCountOrderByAggregateInput
    _max?: cpf_consults_autMaxOrderByAggregateInput
    _min?: cpf_consults_autMinOrderByAggregateInput
  }

  export type cpf_consults_autScalarWhereWithAggregatesInput = {
    AND?: cpf_consults_autScalarWhereWithAggregatesInput | cpf_consults_autScalarWhereWithAggregatesInput[]
    OR?: cpf_consults_autScalarWhereWithAggregatesInput[]
    NOT?: cpf_consults_autScalarWhereWithAggregatesInput | cpf_consults_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cpf_consults_aut"> | string
    cpf?: StringWithAggregatesFilter<"cpf_consults_aut"> | string
    user_id?: StringWithAggregatesFilter<"cpf_consults_aut"> | string
    is_error?: BoolWithAggregatesFilter<"cpf_consults_aut"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"cpf_consults_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cpf_consults_aut"> | Date | string
  }

  export type cpf_consults_cltWhereInput = {
    AND?: cpf_consults_cltWhereInput | cpf_consults_cltWhereInput[]
    OR?: cpf_consults_cltWhereInput[]
    NOT?: cpf_consults_cltWhereInput | cpf_consults_cltWhereInput[]
    id?: StringFilter<"cpf_consults_clt"> | string
    cpf?: StringFilter<"cpf_consults_clt"> | string
    user_id?: StringFilter<"cpf_consults_clt"> | string
    is_error?: BoolFilter<"cpf_consults_clt"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_clt"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }

  export type cpf_consults_cltOrderByWithRelationInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_clt?: users_cltOrderByWithRelationInput
    _relevance?: cpf_consults_cltOrderByRelevanceInput
  }

  export type cpf_consults_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cpf_consults_cltWhereInput | cpf_consults_cltWhereInput[]
    OR?: cpf_consults_cltWhereInput[]
    NOT?: cpf_consults_cltWhereInput | cpf_consults_cltWhereInput[]
    cpf?: StringFilter<"cpf_consults_clt"> | string
    user_id?: StringFilter<"cpf_consults_clt"> | string
    is_error?: BoolFilter<"cpf_consults_clt"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_clt"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }, "id">

  export type cpf_consults_cltOrderByWithAggregationInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: cpf_consults_cltCountOrderByAggregateInput
    _max?: cpf_consults_cltMaxOrderByAggregateInput
    _min?: cpf_consults_cltMinOrderByAggregateInput
  }

  export type cpf_consults_cltScalarWhereWithAggregatesInput = {
    AND?: cpf_consults_cltScalarWhereWithAggregatesInput | cpf_consults_cltScalarWhereWithAggregatesInput[]
    OR?: cpf_consults_cltScalarWhereWithAggregatesInput[]
    NOT?: cpf_consults_cltScalarWhereWithAggregatesInput | cpf_consults_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cpf_consults_clt"> | string
    cpf?: StringWithAggregatesFilter<"cpf_consults_clt"> | string
    user_id?: StringWithAggregatesFilter<"cpf_consults_clt"> | string
    is_error?: BoolWithAggregatesFilter<"cpf_consults_clt"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"cpf_consults_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cpf_consults_clt"> | Date | string
  }

  export type cpf_consults_goiWhereInput = {
    AND?: cpf_consults_goiWhereInput | cpf_consults_goiWhereInput[]
    OR?: cpf_consults_goiWhereInput[]
    NOT?: cpf_consults_goiWhereInput | cpf_consults_goiWhereInput[]
    id?: StringFilter<"cpf_consults_goi"> | string
    cpf?: StringFilter<"cpf_consults_goi"> | string
    user_id?: StringFilter<"cpf_consults_goi"> | string
    is_error?: BoolFilter<"cpf_consults_goi"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_goi"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }

  export type cpf_consults_goiOrderByWithRelationInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_goi?: users_goiOrderByWithRelationInput
    _relevance?: cpf_consults_goiOrderByRelevanceInput
  }

  export type cpf_consults_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cpf_consults_goiWhereInput | cpf_consults_goiWhereInput[]
    OR?: cpf_consults_goiWhereInput[]
    NOT?: cpf_consults_goiWhereInput | cpf_consults_goiWhereInput[]
    cpf?: StringFilter<"cpf_consults_goi"> | string
    user_id?: StringFilter<"cpf_consults_goi"> | string
    is_error?: BoolFilter<"cpf_consults_goi"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_goi"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }, "id">

  export type cpf_consults_goiOrderByWithAggregationInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: cpf_consults_goiCountOrderByAggregateInput
    _max?: cpf_consults_goiMaxOrderByAggregateInput
    _min?: cpf_consults_goiMinOrderByAggregateInput
  }

  export type cpf_consults_goiScalarWhereWithAggregatesInput = {
    AND?: cpf_consults_goiScalarWhereWithAggregatesInput | cpf_consults_goiScalarWhereWithAggregatesInput[]
    OR?: cpf_consults_goiScalarWhereWithAggregatesInput[]
    NOT?: cpf_consults_goiScalarWhereWithAggregatesInput | cpf_consults_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cpf_consults_goi"> | string
    cpf?: StringWithAggregatesFilter<"cpf_consults_goi"> | string
    user_id?: StringWithAggregatesFilter<"cpf_consults_goi"> | string
    is_error?: BoolWithAggregatesFilter<"cpf_consults_goi"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"cpf_consults_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cpf_consults_goi"> | Date | string
  }

  export type cpf_consults_spaWhereInput = {
    AND?: cpf_consults_spaWhereInput | cpf_consults_spaWhereInput[]
    OR?: cpf_consults_spaWhereInput[]
    NOT?: cpf_consults_spaWhereInput | cpf_consults_spaWhereInput[]
    id?: StringFilter<"cpf_consults_spa"> | string
    cpf?: StringFilter<"cpf_consults_spa"> | string
    user_id?: StringFilter<"cpf_consults_spa"> | string
    is_error?: BoolFilter<"cpf_consults_spa"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_spa"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }

  export type cpf_consults_spaOrderByWithRelationInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_spa?: users_spaOrderByWithRelationInput
    _relevance?: cpf_consults_spaOrderByRelevanceInput
  }

  export type cpf_consults_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cpf_consults_spaWhereInput | cpf_consults_spaWhereInput[]
    OR?: cpf_consults_spaWhereInput[]
    NOT?: cpf_consults_spaWhereInput | cpf_consults_spaWhereInput[]
    cpf?: StringFilter<"cpf_consults_spa"> | string
    user_id?: StringFilter<"cpf_consults_spa"> | string
    is_error?: BoolFilter<"cpf_consults_spa"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_spa"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }, "id">

  export type cpf_consults_spaOrderByWithAggregationInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: cpf_consults_spaCountOrderByAggregateInput
    _max?: cpf_consults_spaMaxOrderByAggregateInput
    _min?: cpf_consults_spaMinOrderByAggregateInput
  }

  export type cpf_consults_spaScalarWhereWithAggregatesInput = {
    AND?: cpf_consults_spaScalarWhereWithAggregatesInput | cpf_consults_spaScalarWhereWithAggregatesInput[]
    OR?: cpf_consults_spaScalarWhereWithAggregatesInput[]
    NOT?: cpf_consults_spaScalarWhereWithAggregatesInput | cpf_consults_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cpf_consults_spa"> | string
    cpf?: StringWithAggregatesFilter<"cpf_consults_spa"> | string
    user_id?: StringWithAggregatesFilter<"cpf_consults_spa"> | string
    is_error?: BoolWithAggregatesFilter<"cpf_consults_spa"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"cpf_consults_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cpf_consults_spa"> | Date | string
  }

  export type filesWhereInput = {
    AND?: filesWhereInput | filesWhereInput[]
    OR?: filesWhereInput[]
    NOT?: filesWhereInput | filesWhereInput[]
    id?: BigIntFilter<"files"> | bigint | number
    name?: StringFilter<"files"> | string
    data?: BytesFilter<"files"> | Uint8Array
    mimetype?: StringFilter<"files"> | string
    created_at?: DateTimeNullableFilter<"files"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"files"> | Date | string | null
  }

  export type filesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    mimetype?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: filesOrderByRelevanceInput
  }

  export type filesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: filesWhereInput | filesWhereInput[]
    OR?: filesWhereInput[]
    NOT?: filesWhereInput | filesWhereInput[]
    name?: StringFilter<"files"> | string
    data?: BytesFilter<"files"> | Uint8Array
    mimetype?: StringFilter<"files"> | string
    created_at?: DateTimeNullableFilter<"files"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"files"> | Date | string | null
  }, "id">

  export type filesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    mimetype?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: filesCountOrderByAggregateInput
    _avg?: filesAvgOrderByAggregateInput
    _max?: filesMaxOrderByAggregateInput
    _min?: filesMinOrderByAggregateInput
    _sum?: filesSumOrderByAggregateInput
  }

  export type filesScalarWhereWithAggregatesInput = {
    AND?: filesScalarWhereWithAggregatesInput | filesScalarWhereWithAggregatesInput[]
    OR?: filesScalarWhereWithAggregatesInput[]
    NOT?: filesScalarWhereWithAggregatesInput | filesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"files"> | bigint | number
    name?: StringWithAggregatesFilter<"files"> | string
    data?: BytesWithAggregatesFilter<"files"> | Uint8Array
    mimetype?: StringWithAggregatesFilter<"files"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"files"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"files"> | Date | string | null
  }

  export type maintenance_commandsWhereInput = {
    AND?: maintenance_commandsWhereInput | maintenance_commandsWhereInput[]
    OR?: maintenance_commandsWhereInput[]
    NOT?: maintenance_commandsWhereInput | maintenance_commandsWhereInput[]
    id?: StringFilter<"maintenance_commands"> | string
    bot_type?: StringFilter<"maintenance_commands"> | string
    option?: IntFilter<"maintenance_commands"> | number
    createdAt?: DateTimeFilter<"maintenance_commands"> | Date | string
    updatedAt?: DateTimeFilter<"maintenance_commands"> | Date | string
  }

  export type maintenance_commandsOrderByWithRelationInput = {
    id?: SortOrder
    bot_type?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: maintenance_commandsOrderByRelevanceInput
  }

  export type maintenance_commandsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: maintenance_commandsWhereInput | maintenance_commandsWhereInput[]
    OR?: maintenance_commandsWhereInput[]
    NOT?: maintenance_commandsWhereInput | maintenance_commandsWhereInput[]
    bot_type?: StringFilter<"maintenance_commands"> | string
    option?: IntFilter<"maintenance_commands"> | number
    createdAt?: DateTimeFilter<"maintenance_commands"> | Date | string
    updatedAt?: DateTimeFilter<"maintenance_commands"> | Date | string
  }, "id">

  export type maintenance_commandsOrderByWithAggregationInput = {
    id?: SortOrder
    bot_type?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: maintenance_commandsCountOrderByAggregateInput
    _avg?: maintenance_commandsAvgOrderByAggregateInput
    _max?: maintenance_commandsMaxOrderByAggregateInput
    _min?: maintenance_commandsMinOrderByAggregateInput
    _sum?: maintenance_commandsSumOrderByAggregateInput
  }

  export type maintenance_commandsScalarWhereWithAggregatesInput = {
    AND?: maintenance_commandsScalarWhereWithAggregatesInput | maintenance_commandsScalarWhereWithAggregatesInput[]
    OR?: maintenance_commandsScalarWhereWithAggregatesInput[]
    NOT?: maintenance_commandsScalarWhereWithAggregatesInput | maintenance_commandsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"maintenance_commands"> | string
    bot_type?: StringWithAggregatesFilter<"maintenance_commands"> | string
    option?: IntWithAggregatesFilter<"maintenance_commands"> | number
    createdAt?: DateTimeWithAggregatesFilter<"maintenance_commands"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"maintenance_commands"> | Date | string
  }

  export type messages_logWhereInput = {
    AND?: messages_logWhereInput | messages_logWhereInput[]
    OR?: messages_logWhereInput[]
    NOT?: messages_logWhereInput | messages_logWhereInput[]
    id?: StringFilter<"messages_log"> | string
    phone_number?: BigIntFilter<"messages_log"> | bigint | number
    message?: StringFilter<"messages_log"> | string
    is_attendant?: BoolFilter<"messages_log"> | boolean
    createdAt?: DateTimeFilter<"messages_log"> | Date | string
    updatedAt?: DateTimeFilter<"messages_log"> | Date | string
  }

  export type messages_logOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    is_attendant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: messages_logOrderByRelevanceInput
  }

  export type messages_logWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: messages_logWhereInput | messages_logWhereInput[]
    OR?: messages_logWhereInput[]
    NOT?: messages_logWhereInput | messages_logWhereInput[]
    phone_number?: BigIntFilter<"messages_log"> | bigint | number
    message?: StringFilter<"messages_log"> | string
    is_attendant?: BoolFilter<"messages_log"> | boolean
    createdAt?: DateTimeFilter<"messages_log"> | Date | string
    updatedAt?: DateTimeFilter<"messages_log"> | Date | string
  }, "id">

  export type messages_logOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    is_attendant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: messages_logCountOrderByAggregateInput
    _avg?: messages_logAvgOrderByAggregateInput
    _max?: messages_logMaxOrderByAggregateInput
    _min?: messages_logMinOrderByAggregateInput
    _sum?: messages_logSumOrderByAggregateInput
  }

  export type messages_logScalarWhereWithAggregatesInput = {
    AND?: messages_logScalarWhereWithAggregatesInput | messages_logScalarWhereWithAggregatesInput[]
    OR?: messages_logScalarWhereWithAggregatesInput[]
    NOT?: messages_logScalarWhereWithAggregatesInput | messages_logScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"messages_log"> | string
    phone_number?: BigIntWithAggregatesFilter<"messages_log"> | bigint | number
    message?: StringWithAggregatesFilter<"messages_log"> | string
    is_attendant?: BoolWithAggregatesFilter<"messages_log"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"messages_log"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"messages_log"> | Date | string
  }

  export type modality_assistance_quotationsWhereInput = {
    AND?: modality_assistance_quotationsWhereInput | modality_assistance_quotationsWhereInput[]
    OR?: modality_assistance_quotationsWhereInput[]
    NOT?: modality_assistance_quotationsWhereInput | modality_assistance_quotationsWhereInput[]
    id?: BigIntFilter<"modality_assistance_quotations"> | bigint | number
    name?: StringFilter<"modality_assistance_quotations"> | string
  }

  export type modality_assistance_quotationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    _relevance?: modality_assistance_quotationsOrderByRelevanceInput
  }

  export type modality_assistance_quotationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: modality_assistance_quotationsWhereInput | modality_assistance_quotationsWhereInput[]
    OR?: modality_assistance_quotationsWhereInput[]
    NOT?: modality_assistance_quotationsWhereInput | modality_assistance_quotationsWhereInput[]
    name?: StringFilter<"modality_assistance_quotations"> | string
  }, "id">

  export type modality_assistance_quotationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: modality_assistance_quotationsCountOrderByAggregateInput
    _avg?: modality_assistance_quotationsAvgOrderByAggregateInput
    _max?: modality_assistance_quotationsMaxOrderByAggregateInput
    _min?: modality_assistance_quotationsMinOrderByAggregateInput
    _sum?: modality_assistance_quotationsSumOrderByAggregateInput
  }

  export type modality_assistance_quotationsScalarWhereWithAggregatesInput = {
    AND?: modality_assistance_quotationsScalarWhereWithAggregatesInput | modality_assistance_quotationsScalarWhereWithAggregatesInput[]
    OR?: modality_assistance_quotationsScalarWhereWithAggregatesInput[]
    NOT?: modality_assistance_quotationsScalarWhereWithAggregatesInput | modality_assistance_quotationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"modality_assistance_quotations"> | bigint | number
    name?: StringWithAggregatesFilter<"modality_assistance_quotations"> | string
  }

  export type plan_group_quotationsWhereInput = {
    AND?: plan_group_quotationsWhereInput | plan_group_quotationsWhereInput[]
    OR?: plan_group_quotationsWhereInput[]
    NOT?: plan_group_quotationsWhereInput | plan_group_quotationsWhereInput[]
    id?: BigIntFilter<"plan_group_quotations"> | bigint | number
    name?: StringFilter<"plan_group_quotations"> | string
  }

  export type plan_group_quotationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    _relevance?: plan_group_quotationsOrderByRelevanceInput
  }

  export type plan_group_quotationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: plan_group_quotationsWhereInput | plan_group_quotationsWhereInput[]
    OR?: plan_group_quotationsWhereInput[]
    NOT?: plan_group_quotationsWhereInput | plan_group_quotationsWhereInput[]
    name?: StringFilter<"plan_group_quotations"> | string
  }, "id">

  export type plan_group_quotationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: plan_group_quotationsCountOrderByAggregateInput
    _avg?: plan_group_quotationsAvgOrderByAggregateInput
    _max?: plan_group_quotationsMaxOrderByAggregateInput
    _min?: plan_group_quotationsMinOrderByAggregateInput
    _sum?: plan_group_quotationsSumOrderByAggregateInput
  }

  export type plan_group_quotationsScalarWhereWithAggregatesInput = {
    AND?: plan_group_quotationsScalarWhereWithAggregatesInput | plan_group_quotationsScalarWhereWithAggregatesInput[]
    OR?: plan_group_quotationsScalarWhereWithAggregatesInput[]
    NOT?: plan_group_quotationsScalarWhereWithAggregatesInput | plan_group_quotationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"plan_group_quotations"> | bigint | number
    name?: StringWithAggregatesFilter<"plan_group_quotations"> | string
  }

  export type plan_type_quotationsWhereInput = {
    AND?: plan_type_quotationsWhereInput | plan_type_quotationsWhereInput[]
    OR?: plan_type_quotationsWhereInput[]
    NOT?: plan_type_quotationsWhereInput | plan_type_quotationsWhereInput[]
    id?: BigIntFilter<"plan_type_quotations"> | bigint | number
    name?: StringFilter<"plan_type_quotations"> | string
  }

  export type plan_type_quotationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    _relevance?: plan_type_quotationsOrderByRelevanceInput
  }

  export type plan_type_quotationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: plan_type_quotationsWhereInput | plan_type_quotationsWhereInput[]
    OR?: plan_type_quotationsWhereInput[]
    NOT?: plan_type_quotationsWhereInput | plan_type_quotationsWhereInput[]
    name?: StringFilter<"plan_type_quotations"> | string
  }, "id">

  export type plan_type_quotationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: plan_type_quotationsCountOrderByAggregateInput
    _avg?: plan_type_quotationsAvgOrderByAggregateInput
    _max?: plan_type_quotationsMaxOrderByAggregateInput
    _min?: plan_type_quotationsMinOrderByAggregateInput
    _sum?: plan_type_quotationsSumOrderByAggregateInput
  }

  export type plan_type_quotationsScalarWhereWithAggregatesInput = {
    AND?: plan_type_quotationsScalarWhereWithAggregatesInput | plan_type_quotationsScalarWhereWithAggregatesInput[]
    OR?: plan_type_quotationsScalarWhereWithAggregatesInput[]
    NOT?: plan_type_quotationsScalarWhereWithAggregatesInput | plan_type_quotationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"plan_type_quotations"> | bigint | number
    name?: StringWithAggregatesFilter<"plan_type_quotations"> | string
  }

  export type problems_cltWhereInput = {
    AND?: problems_cltWhereInput | problems_cltWhereInput[]
    OR?: problems_cltWhereInput[]
    NOT?: problems_cltWhereInput | problems_cltWhereInput[]
    id?: StringFilter<"problems_clt"> | string
    user_id?: StringFilter<"problems_clt"> | string
    problem?: StringFilter<"problems_clt"> | string
    createdAt?: DateTimeFilter<"problems_clt"> | Date | string
    updatedAt?: DateTimeFilter<"problems_clt"> | Date | string
  }

  export type problems_cltOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: problems_cltOrderByRelevanceInput
  }

  export type problems_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: problems_cltWhereInput | problems_cltWhereInput[]
    OR?: problems_cltWhereInput[]
    NOT?: problems_cltWhereInput | problems_cltWhereInput[]
    user_id?: StringFilter<"problems_clt"> | string
    problem?: StringFilter<"problems_clt"> | string
    createdAt?: DateTimeFilter<"problems_clt"> | Date | string
    updatedAt?: DateTimeFilter<"problems_clt"> | Date | string
  }, "id">

  export type problems_cltOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: problems_cltCountOrderByAggregateInput
    _max?: problems_cltMaxOrderByAggregateInput
    _min?: problems_cltMinOrderByAggregateInput
  }

  export type problems_cltScalarWhereWithAggregatesInput = {
    AND?: problems_cltScalarWhereWithAggregatesInput | problems_cltScalarWhereWithAggregatesInput[]
    OR?: problems_cltScalarWhereWithAggregatesInput[]
    NOT?: problems_cltScalarWhereWithAggregatesInput | problems_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"problems_clt"> | string
    user_id?: StringWithAggregatesFilter<"problems_clt"> | string
    problem?: StringWithAggregatesFilter<"problems_clt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"problems_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"problems_clt"> | Date | string
  }

  export type QuotationWhereInput = {
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    id?: BigIntFilter<"Quotation"> | bigint | number
    plano_grupo?: StringFilter<"Quotation"> | string
    estado?: StringFilter<"Quotation"> | string
    coparticipacao_tipo?: StringFilter<"Quotation"> | string
    segmentacao?: StringNullableFilter<"Quotation"> | string | null
    acomodacao?: StringFilter<"Quotation"> | string
    assistencia_modalidade?: StringFilter<"Quotation"> | string
    codigo_interno?: StringNullableFilter<"Quotation"> | string | null
    registro_ans?: StringNullableFilter<"Quotation"> | string | null
    cidade?: StringFilter<"Quotation"> | string
    validade_valores?: StringNullableFilter<"Quotation"> | string | null
    tipo_plano?: StringFilter<"Quotation"> | string
    preco_00_a_18_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    exames_simples?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    exames_complexos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    demais_terapias?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: IntNullableFilter<"Quotation"> | number | null
    desconto_familiares?: StringNullableFilter<"Quotation"> | string | null
    quantidade_de_familiares?: StringNullableFilter<"Quotation"> | string | null
    campo_vigencia?: StringNullableFilter<"Quotation"> | string | null
  }

  export type QuotationOrderByWithRelationInput = {
    id?: SortOrder
    plano_grupo?: SortOrder
    estado?: SortOrder
    coparticipacao_tipo?: SortOrder
    segmentacao?: SortOrderInput | SortOrder
    acomodacao?: SortOrder
    assistencia_modalidade?: SortOrder
    codigo_interno?: SortOrderInput | SortOrder
    registro_ans?: SortOrderInput | SortOrder
    cidade?: SortOrder
    validade_valores?: SortOrderInput | SortOrder
    tipo_plano?: SortOrder
    preco_00_a_18_anos?: SortOrderInput | SortOrder
    preco_19_a_23_anos?: SortOrderInput | SortOrder
    preco_24_a_28_anos?: SortOrderInput | SortOrder
    preco_29_a_33_anos?: SortOrderInput | SortOrder
    preco_34_a_38_anos?: SortOrderInput | SortOrder
    preco_39_a_43_anos?: SortOrderInput | SortOrder
    preco_44_a_48_anos?: SortOrderInput | SortOrder
    preco_49_a_53_anos?: SortOrderInput | SortOrder
    preco_54_a_58_anos?: SortOrderInput | SortOrder
    preco_59_anos_ou_mais?: SortOrderInput | SortOrder
    preco_todas_idades?: SortOrderInput | SortOrder
    consultas_eletivas?: SortOrderInput | SortOrder
    consultas_urgencia?: SortOrderInput | SortOrder
    exames_simples?: SortOrderInput | SortOrder
    exames_complexos?: SortOrderInput | SortOrder
    terapias_neurologicas?: SortOrderInput | SortOrder
    demais_terapias?: SortOrderInput | SortOrder
    desconto_vidas?: SortOrderInput | SortOrder
    desconto_familiares?: SortOrderInput | SortOrder
    quantidade_de_familiares?: SortOrderInput | SortOrder
    campo_vigencia?: SortOrderInput | SortOrder
    _relevance?: QuotationOrderByRelevanceInput
  }

  export type QuotationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    plano_grupo?: StringFilter<"Quotation"> | string
    estado?: StringFilter<"Quotation"> | string
    coparticipacao_tipo?: StringFilter<"Quotation"> | string
    segmentacao?: StringNullableFilter<"Quotation"> | string | null
    acomodacao?: StringFilter<"Quotation"> | string
    assistencia_modalidade?: StringFilter<"Quotation"> | string
    codigo_interno?: StringNullableFilter<"Quotation"> | string | null
    registro_ans?: StringNullableFilter<"Quotation"> | string | null
    cidade?: StringFilter<"Quotation"> | string
    validade_valores?: StringNullableFilter<"Quotation"> | string | null
    tipo_plano?: StringFilter<"Quotation"> | string
    preco_00_a_18_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    exames_simples?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    exames_complexos?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    demais_terapias?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: IntNullableFilter<"Quotation"> | number | null
    desconto_familiares?: StringNullableFilter<"Quotation"> | string | null
    quantidade_de_familiares?: StringNullableFilter<"Quotation"> | string | null
    campo_vigencia?: StringNullableFilter<"Quotation"> | string | null
  }, "id">

  export type QuotationOrderByWithAggregationInput = {
    id?: SortOrder
    plano_grupo?: SortOrder
    estado?: SortOrder
    coparticipacao_tipo?: SortOrder
    segmentacao?: SortOrderInput | SortOrder
    acomodacao?: SortOrder
    assistencia_modalidade?: SortOrder
    codigo_interno?: SortOrderInput | SortOrder
    registro_ans?: SortOrderInput | SortOrder
    cidade?: SortOrder
    validade_valores?: SortOrderInput | SortOrder
    tipo_plano?: SortOrder
    preco_00_a_18_anos?: SortOrderInput | SortOrder
    preco_19_a_23_anos?: SortOrderInput | SortOrder
    preco_24_a_28_anos?: SortOrderInput | SortOrder
    preco_29_a_33_anos?: SortOrderInput | SortOrder
    preco_34_a_38_anos?: SortOrderInput | SortOrder
    preco_39_a_43_anos?: SortOrderInput | SortOrder
    preco_44_a_48_anos?: SortOrderInput | SortOrder
    preco_49_a_53_anos?: SortOrderInput | SortOrder
    preco_54_a_58_anos?: SortOrderInput | SortOrder
    preco_59_anos_ou_mais?: SortOrderInput | SortOrder
    preco_todas_idades?: SortOrderInput | SortOrder
    consultas_eletivas?: SortOrderInput | SortOrder
    consultas_urgencia?: SortOrderInput | SortOrder
    exames_simples?: SortOrderInput | SortOrder
    exames_complexos?: SortOrderInput | SortOrder
    terapias_neurologicas?: SortOrderInput | SortOrder
    demais_terapias?: SortOrderInput | SortOrder
    desconto_vidas?: SortOrderInput | SortOrder
    desconto_familiares?: SortOrderInput | SortOrder
    quantidade_de_familiares?: SortOrderInput | SortOrder
    campo_vigencia?: SortOrderInput | SortOrder
    _count?: QuotationCountOrderByAggregateInput
    _avg?: QuotationAvgOrderByAggregateInput
    _max?: QuotationMaxOrderByAggregateInput
    _min?: QuotationMinOrderByAggregateInput
    _sum?: QuotationSumOrderByAggregateInput
  }

  export type QuotationScalarWhereWithAggregatesInput = {
    AND?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    OR?: QuotationScalarWhereWithAggregatesInput[]
    NOT?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Quotation"> | bigint | number
    plano_grupo?: StringWithAggregatesFilter<"Quotation"> | string
    estado?: StringWithAggregatesFilter<"Quotation"> | string
    coparticipacao_tipo?: StringWithAggregatesFilter<"Quotation"> | string
    segmentacao?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    acomodacao?: StringWithAggregatesFilter<"Quotation"> | string
    assistencia_modalidade?: StringWithAggregatesFilter<"Quotation"> | string
    codigo_interno?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    registro_ans?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    cidade?: StringWithAggregatesFilter<"Quotation"> | string
    validade_valores?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    tipo_plano?: StringWithAggregatesFilter<"Quotation"> | string
    preco_00_a_18_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    exames_simples?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    exames_complexos?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    demais_terapias?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: IntNullableWithAggregatesFilter<"Quotation"> | number | null
    desconto_familiares?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    quantidade_de_familiares?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    campo_vigencia?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
  }

  export type quote_calculations_autWhereInput = {
    AND?: quote_calculations_autWhereInput | quote_calculations_autWhereInput[]
    OR?: quote_calculations_autWhereInput[]
    NOT?: quote_calculations_autWhereInput | quote_calculations_autWhereInput[]
    id?: StringFilter<"quote_calculations_aut"> | string
    user_id?: StringFilter<"quote_calculations_aut"> | string
    client_name?: StringFilter<"quote_calculations_aut"> | string
    consultant_name?: StringFilter<"quote_calculations_aut"> | string
    ages?: StringFilter<"quote_calculations_aut"> | string
    accommodation?: StringFilter<"quote_calculations_aut"> | string
    plan_type?: StringFilter<"quote_calculations_aut"> | string
    square?: StringFilter<"quote_calculations_aut"> | string
    is_odonto?: BoolFilter<"quote_calculations_aut"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_aut"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }

  export type quote_calculations_autOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_aut?: users_autOrderByWithRelationInput
    _relevance?: quote_calculations_autOrderByRelevanceInput
  }

  export type quote_calculations_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: quote_calculations_autWhereInput | quote_calculations_autWhereInput[]
    OR?: quote_calculations_autWhereInput[]
    NOT?: quote_calculations_autWhereInput | quote_calculations_autWhereInput[]
    user_id?: StringFilter<"quote_calculations_aut"> | string
    client_name?: StringFilter<"quote_calculations_aut"> | string
    consultant_name?: StringFilter<"quote_calculations_aut"> | string
    ages?: StringFilter<"quote_calculations_aut"> | string
    accommodation?: StringFilter<"quote_calculations_aut"> | string
    plan_type?: StringFilter<"quote_calculations_aut"> | string
    square?: StringFilter<"quote_calculations_aut"> | string
    is_odonto?: BoolFilter<"quote_calculations_aut"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_aut"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }, "id">

  export type quote_calculations_autOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: quote_calculations_autCountOrderByAggregateInput
    _max?: quote_calculations_autMaxOrderByAggregateInput
    _min?: quote_calculations_autMinOrderByAggregateInput
  }

  export type quote_calculations_autScalarWhereWithAggregatesInput = {
    AND?: quote_calculations_autScalarWhereWithAggregatesInput | quote_calculations_autScalarWhereWithAggregatesInput[]
    OR?: quote_calculations_autScalarWhereWithAggregatesInput[]
    NOT?: quote_calculations_autScalarWhereWithAggregatesInput | quote_calculations_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"quote_calculations_aut"> | string
    user_id?: StringWithAggregatesFilter<"quote_calculations_aut"> | string
    client_name?: StringWithAggregatesFilter<"quote_calculations_aut"> | string
    consultant_name?: StringWithAggregatesFilter<"quote_calculations_aut"> | string
    ages?: StringWithAggregatesFilter<"quote_calculations_aut"> | string
    accommodation?: StringWithAggregatesFilter<"quote_calculations_aut"> | string
    plan_type?: StringWithAggregatesFilter<"quote_calculations_aut"> | string
    square?: StringWithAggregatesFilter<"quote_calculations_aut"> | string
    is_odonto?: BoolWithAggregatesFilter<"quote_calculations_aut"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"quote_calculations_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"quote_calculations_aut"> | Date | string
  }

  export type quote_calculations_cltWhereInput = {
    AND?: quote_calculations_cltWhereInput | quote_calculations_cltWhereInput[]
    OR?: quote_calculations_cltWhereInput[]
    NOT?: quote_calculations_cltWhereInput | quote_calculations_cltWhereInput[]
    id?: StringFilter<"quote_calculations_clt"> | string
    user_id?: StringFilter<"quote_calculations_clt"> | string
    client_name?: StringFilter<"quote_calculations_clt"> | string
    consultant_name?: StringFilter<"quote_calculations_clt"> | string
    ages?: StringFilter<"quote_calculations_clt"> | string
    accommodation?: StringFilter<"quote_calculations_clt"> | string
    plan_type?: StringFilter<"quote_calculations_clt"> | string
    square?: StringFilter<"quote_calculations_clt"> | string
    is_odonto?: BoolFilter<"quote_calculations_clt"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_clt"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }

  export type quote_calculations_cltOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_clt?: users_cltOrderByWithRelationInput
    _relevance?: quote_calculations_cltOrderByRelevanceInput
  }

  export type quote_calculations_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: quote_calculations_cltWhereInput | quote_calculations_cltWhereInput[]
    OR?: quote_calculations_cltWhereInput[]
    NOT?: quote_calculations_cltWhereInput | quote_calculations_cltWhereInput[]
    user_id?: StringFilter<"quote_calculations_clt"> | string
    client_name?: StringFilter<"quote_calculations_clt"> | string
    consultant_name?: StringFilter<"quote_calculations_clt"> | string
    ages?: StringFilter<"quote_calculations_clt"> | string
    accommodation?: StringFilter<"quote_calculations_clt"> | string
    plan_type?: StringFilter<"quote_calculations_clt"> | string
    square?: StringFilter<"quote_calculations_clt"> | string
    is_odonto?: BoolFilter<"quote_calculations_clt"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_clt"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }, "id">

  export type quote_calculations_cltOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: quote_calculations_cltCountOrderByAggregateInput
    _max?: quote_calculations_cltMaxOrderByAggregateInput
    _min?: quote_calculations_cltMinOrderByAggregateInput
  }

  export type quote_calculations_cltScalarWhereWithAggregatesInput = {
    AND?: quote_calculations_cltScalarWhereWithAggregatesInput | quote_calculations_cltScalarWhereWithAggregatesInput[]
    OR?: quote_calculations_cltScalarWhereWithAggregatesInput[]
    NOT?: quote_calculations_cltScalarWhereWithAggregatesInput | quote_calculations_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"quote_calculations_clt"> | string
    user_id?: StringWithAggregatesFilter<"quote_calculations_clt"> | string
    client_name?: StringWithAggregatesFilter<"quote_calculations_clt"> | string
    consultant_name?: StringWithAggregatesFilter<"quote_calculations_clt"> | string
    ages?: StringWithAggregatesFilter<"quote_calculations_clt"> | string
    accommodation?: StringWithAggregatesFilter<"quote_calculations_clt"> | string
    plan_type?: StringWithAggregatesFilter<"quote_calculations_clt"> | string
    square?: StringWithAggregatesFilter<"quote_calculations_clt"> | string
    is_odonto?: BoolWithAggregatesFilter<"quote_calculations_clt"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"quote_calculations_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"quote_calculations_clt"> | Date | string
  }

  export type quote_calculations_goiWhereInput = {
    AND?: quote_calculations_goiWhereInput | quote_calculations_goiWhereInput[]
    OR?: quote_calculations_goiWhereInput[]
    NOT?: quote_calculations_goiWhereInput | quote_calculations_goiWhereInput[]
    id?: StringFilter<"quote_calculations_goi"> | string
    user_id?: StringFilter<"quote_calculations_goi"> | string
    client_name?: StringFilter<"quote_calculations_goi"> | string
    consultant_name?: StringFilter<"quote_calculations_goi"> | string
    ages?: StringFilter<"quote_calculations_goi"> | string
    accommodation?: StringFilter<"quote_calculations_goi"> | string
    plan_type?: StringFilter<"quote_calculations_goi"> | string
    square?: StringFilter<"quote_calculations_goi"> | string
    is_odonto?: BoolFilter<"quote_calculations_goi"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_goi"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }

  export type quote_calculations_goiOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_goi?: users_goiOrderByWithRelationInput
    _relevance?: quote_calculations_goiOrderByRelevanceInput
  }

  export type quote_calculations_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: quote_calculations_goiWhereInput | quote_calculations_goiWhereInput[]
    OR?: quote_calculations_goiWhereInput[]
    NOT?: quote_calculations_goiWhereInput | quote_calculations_goiWhereInput[]
    user_id?: StringFilter<"quote_calculations_goi"> | string
    client_name?: StringFilter<"quote_calculations_goi"> | string
    consultant_name?: StringFilter<"quote_calculations_goi"> | string
    ages?: StringFilter<"quote_calculations_goi"> | string
    accommodation?: StringFilter<"quote_calculations_goi"> | string
    plan_type?: StringFilter<"quote_calculations_goi"> | string
    square?: StringFilter<"quote_calculations_goi"> | string
    is_odonto?: BoolFilter<"quote_calculations_goi"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_goi"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }, "id">

  export type quote_calculations_goiOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: quote_calculations_goiCountOrderByAggregateInput
    _max?: quote_calculations_goiMaxOrderByAggregateInput
    _min?: quote_calculations_goiMinOrderByAggregateInput
  }

  export type quote_calculations_goiScalarWhereWithAggregatesInput = {
    AND?: quote_calculations_goiScalarWhereWithAggregatesInput | quote_calculations_goiScalarWhereWithAggregatesInput[]
    OR?: quote_calculations_goiScalarWhereWithAggregatesInput[]
    NOT?: quote_calculations_goiScalarWhereWithAggregatesInput | quote_calculations_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"quote_calculations_goi"> | string
    user_id?: StringWithAggregatesFilter<"quote_calculations_goi"> | string
    client_name?: StringWithAggregatesFilter<"quote_calculations_goi"> | string
    consultant_name?: StringWithAggregatesFilter<"quote_calculations_goi"> | string
    ages?: StringWithAggregatesFilter<"quote_calculations_goi"> | string
    accommodation?: StringWithAggregatesFilter<"quote_calculations_goi"> | string
    plan_type?: StringWithAggregatesFilter<"quote_calculations_goi"> | string
    square?: StringWithAggregatesFilter<"quote_calculations_goi"> | string
    is_odonto?: BoolWithAggregatesFilter<"quote_calculations_goi"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"quote_calculations_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"quote_calculations_goi"> | Date | string
  }

  export type quote_calculations_spaWhereInput = {
    AND?: quote_calculations_spaWhereInput | quote_calculations_spaWhereInput[]
    OR?: quote_calculations_spaWhereInput[]
    NOT?: quote_calculations_spaWhereInput | quote_calculations_spaWhereInput[]
    id?: StringFilter<"quote_calculations_spa"> | string
    user_id?: StringFilter<"quote_calculations_spa"> | string
    client_name?: StringFilter<"quote_calculations_spa"> | string
    consultant_name?: StringFilter<"quote_calculations_spa"> | string
    ages?: StringFilter<"quote_calculations_spa"> | string
    accommodation?: StringFilter<"quote_calculations_spa"> | string
    plan_type?: StringFilter<"quote_calculations_spa"> | string
    square?: StringFilter<"quote_calculations_spa"> | string
    is_odonto?: BoolFilter<"quote_calculations_spa"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_spa"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }

  export type quote_calculations_spaOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_spa?: users_spaOrderByWithRelationInput
    _relevance?: quote_calculations_spaOrderByRelevanceInput
  }

  export type quote_calculations_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: quote_calculations_spaWhereInput | quote_calculations_spaWhereInput[]
    OR?: quote_calculations_spaWhereInput[]
    NOT?: quote_calculations_spaWhereInput | quote_calculations_spaWhereInput[]
    user_id?: StringFilter<"quote_calculations_spa"> | string
    client_name?: StringFilter<"quote_calculations_spa"> | string
    consultant_name?: StringFilter<"quote_calculations_spa"> | string
    ages?: StringFilter<"quote_calculations_spa"> | string
    accommodation?: StringFilter<"quote_calculations_spa"> | string
    plan_type?: StringFilter<"quote_calculations_spa"> | string
    square?: StringFilter<"quote_calculations_spa"> | string
    is_odonto?: BoolFilter<"quote_calculations_spa"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_spa"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }, "id">

  export type quote_calculations_spaOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: quote_calculations_spaCountOrderByAggregateInput
    _max?: quote_calculations_spaMaxOrderByAggregateInput
    _min?: quote_calculations_spaMinOrderByAggregateInput
  }

  export type quote_calculations_spaScalarWhereWithAggregatesInput = {
    AND?: quote_calculations_spaScalarWhereWithAggregatesInput | quote_calculations_spaScalarWhereWithAggregatesInput[]
    OR?: quote_calculations_spaScalarWhereWithAggregatesInput[]
    NOT?: quote_calculations_spaScalarWhereWithAggregatesInput | quote_calculations_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"quote_calculations_spa"> | string
    user_id?: StringWithAggregatesFilter<"quote_calculations_spa"> | string
    client_name?: StringWithAggregatesFilter<"quote_calculations_spa"> | string
    consultant_name?: StringWithAggregatesFilter<"quote_calculations_spa"> | string
    ages?: StringWithAggregatesFilter<"quote_calculations_spa"> | string
    accommodation?: StringWithAggregatesFilter<"quote_calculations_spa"> | string
    plan_type?: StringWithAggregatesFilter<"quote_calculations_spa"> | string
    square?: StringWithAggregatesFilter<"quote_calculations_spa"> | string
    is_odonto?: BoolWithAggregatesFilter<"quote_calculations_spa"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"quote_calculations_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"quote_calculations_spa"> | Date | string
  }

  export type register_partners_autWhereInput = {
    AND?: register_partners_autWhereInput | register_partners_autWhereInput[]
    OR?: register_partners_autWhereInput[]
    NOT?: register_partners_autWhereInput | register_partners_autWhereInput[]
    id?: StringFilter<"register_partners_aut"> | string
    complete_name?: StringFilter<"register_partners_aut"> | string
    phone_number?: StringFilter<"register_partners_aut"> | string
    email?: StringFilter<"register_partners_aut"> | string
    birth_date?: StringFilter<"register_partners_aut"> | string
    city?: StringFilter<"register_partners_aut"> | string
    createdAt?: DateTimeFilter<"register_partners_aut"> | Date | string
    updatedAt?: DateTimeFilter<"register_partners_aut"> | Date | string
    obs?: StringNullableFilter<"register_partners_aut"> | string | null
  }

  export type register_partners_autOrderByWithRelationInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obs?: SortOrderInput | SortOrder
    _relevance?: register_partners_autOrderByRelevanceInput
  }

  export type register_partners_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: register_partners_autWhereInput | register_partners_autWhereInput[]
    OR?: register_partners_autWhereInput[]
    NOT?: register_partners_autWhereInput | register_partners_autWhereInput[]
    complete_name?: StringFilter<"register_partners_aut"> | string
    phone_number?: StringFilter<"register_partners_aut"> | string
    email?: StringFilter<"register_partners_aut"> | string
    birth_date?: StringFilter<"register_partners_aut"> | string
    city?: StringFilter<"register_partners_aut"> | string
    createdAt?: DateTimeFilter<"register_partners_aut"> | Date | string
    updatedAt?: DateTimeFilter<"register_partners_aut"> | Date | string
    obs?: StringNullableFilter<"register_partners_aut"> | string | null
  }, "id">

  export type register_partners_autOrderByWithAggregationInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obs?: SortOrderInput | SortOrder
    _count?: register_partners_autCountOrderByAggregateInput
    _max?: register_partners_autMaxOrderByAggregateInput
    _min?: register_partners_autMinOrderByAggregateInput
  }

  export type register_partners_autScalarWhereWithAggregatesInput = {
    AND?: register_partners_autScalarWhereWithAggregatesInput | register_partners_autScalarWhereWithAggregatesInput[]
    OR?: register_partners_autScalarWhereWithAggregatesInput[]
    NOT?: register_partners_autScalarWhereWithAggregatesInput | register_partners_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"register_partners_aut"> | string
    complete_name?: StringWithAggregatesFilter<"register_partners_aut"> | string
    phone_number?: StringWithAggregatesFilter<"register_partners_aut"> | string
    email?: StringWithAggregatesFilter<"register_partners_aut"> | string
    birth_date?: StringWithAggregatesFilter<"register_partners_aut"> | string
    city?: StringWithAggregatesFilter<"register_partners_aut"> | string
    createdAt?: DateTimeWithAggregatesFilter<"register_partners_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"register_partners_aut"> | Date | string
    obs?: StringNullableWithAggregatesFilter<"register_partners_aut"> | string | null
  }

  export type register_partners_spaWhereInput = {
    AND?: register_partners_spaWhereInput | register_partners_spaWhereInput[]
    OR?: register_partners_spaWhereInput[]
    NOT?: register_partners_spaWhereInput | register_partners_spaWhereInput[]
    id?: StringFilter<"register_partners_spa"> | string
    complete_name?: StringFilter<"register_partners_spa"> | string
    phone_number?: StringFilter<"register_partners_spa"> | string
    email?: StringFilter<"register_partners_spa"> | string
    birth_date?: StringFilter<"register_partners_spa"> | string
    city?: StringFilter<"register_partners_spa"> | string
    createdAt?: DateTimeFilter<"register_partners_spa"> | Date | string
    updatedAt?: DateTimeFilter<"register_partners_spa"> | Date | string
  }

  export type register_partners_spaOrderByWithRelationInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: register_partners_spaOrderByRelevanceInput
  }

  export type register_partners_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: register_partners_spaWhereInput | register_partners_spaWhereInput[]
    OR?: register_partners_spaWhereInput[]
    NOT?: register_partners_spaWhereInput | register_partners_spaWhereInput[]
    complete_name?: StringFilter<"register_partners_spa"> | string
    phone_number?: StringFilter<"register_partners_spa"> | string
    email?: StringFilter<"register_partners_spa"> | string
    birth_date?: StringFilter<"register_partners_spa"> | string
    city?: StringFilter<"register_partners_spa"> | string
    createdAt?: DateTimeFilter<"register_partners_spa"> | Date | string
    updatedAt?: DateTimeFilter<"register_partners_spa"> | Date | string
  }, "id">

  export type register_partners_spaOrderByWithAggregationInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: register_partners_spaCountOrderByAggregateInput
    _max?: register_partners_spaMaxOrderByAggregateInput
    _min?: register_partners_spaMinOrderByAggregateInput
  }

  export type register_partners_spaScalarWhereWithAggregatesInput = {
    AND?: register_partners_spaScalarWhereWithAggregatesInput | register_partners_spaScalarWhereWithAggregatesInput[]
    OR?: register_partners_spaScalarWhereWithAggregatesInput[]
    NOT?: register_partners_spaScalarWhereWithAggregatesInput | register_partners_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"register_partners_spa"> | string
    complete_name?: StringWithAggregatesFilter<"register_partners_spa"> | string
    phone_number?: StringWithAggregatesFilter<"register_partners_spa"> | string
    email?: StringWithAggregatesFilter<"register_partners_spa"> | string
    birth_date?: StringWithAggregatesFilter<"register_partners_spa"> | string
    city?: StringWithAggregatesFilter<"register_partners_spa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"register_partners_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"register_partners_spa"> | Date | string
  }

  export type rh_callsWhereInput = {
    AND?: rh_callsWhereInput | rh_callsWhereInput[]
    OR?: rh_callsWhereInput[]
    NOT?: rh_callsWhereInput | rh_callsWhereInput[]
    id?: StringFilter<"rh_calls"> | string
    jid?: StringFilter<"rh_calls"> | string
    name?: StringFilter<"rh_calls"> | string
    message?: StringFilter<"rh_calls"> | string
    createdAt?: DateTimeFilter<"rh_calls"> | Date | string
    updatedAt?: DateTimeFilter<"rh_calls"> | Date | string
    rhNumberId?: StringNullableFilter<"rh_calls"> | string | null
    rh_numbers?: XOR<Rh_numbersNullableScalarRelationFilter, rh_numbersWhereInput> | null
  }

  export type rh_callsOrderByWithRelationInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rhNumberId?: SortOrderInput | SortOrder
    rh_numbers?: rh_numbersOrderByWithRelationInput
    _relevance?: rh_callsOrderByRelevanceInput
  }

  export type rh_callsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rh_callsWhereInput | rh_callsWhereInput[]
    OR?: rh_callsWhereInput[]
    NOT?: rh_callsWhereInput | rh_callsWhereInput[]
    jid?: StringFilter<"rh_calls"> | string
    name?: StringFilter<"rh_calls"> | string
    message?: StringFilter<"rh_calls"> | string
    createdAt?: DateTimeFilter<"rh_calls"> | Date | string
    updatedAt?: DateTimeFilter<"rh_calls"> | Date | string
    rhNumberId?: StringNullableFilter<"rh_calls"> | string | null
    rh_numbers?: XOR<Rh_numbersNullableScalarRelationFilter, rh_numbersWhereInput> | null
  }, "id">

  export type rh_callsOrderByWithAggregationInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rhNumberId?: SortOrderInput | SortOrder
    _count?: rh_callsCountOrderByAggregateInput
    _max?: rh_callsMaxOrderByAggregateInput
    _min?: rh_callsMinOrderByAggregateInput
  }

  export type rh_callsScalarWhereWithAggregatesInput = {
    AND?: rh_callsScalarWhereWithAggregatesInput | rh_callsScalarWhereWithAggregatesInput[]
    OR?: rh_callsScalarWhereWithAggregatesInput[]
    NOT?: rh_callsScalarWhereWithAggregatesInput | rh_callsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"rh_calls"> | string
    jid?: StringWithAggregatesFilter<"rh_calls"> | string
    name?: StringWithAggregatesFilter<"rh_calls"> | string
    message?: StringWithAggregatesFilter<"rh_calls"> | string
    createdAt?: DateTimeWithAggregatesFilter<"rh_calls"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"rh_calls"> | Date | string
    rhNumberId?: StringNullableWithAggregatesFilter<"rh_calls"> | string | null
  }

  export type rh_numbersWhereInput = {
    AND?: rh_numbersWhereInput | rh_numbersWhereInput[]
    OR?: rh_numbersWhereInput[]
    NOT?: rh_numbersWhereInput | rh_numbersWhereInput[]
    id?: StringFilter<"rh_numbers"> | string
    name?: StringFilter<"rh_numbers"> | string
    phone_number?: StringFilter<"rh_numbers"> | string
    createdAt?: DateTimeFilter<"rh_numbers"> | Date | string
    updatedAt?: DateTimeFilter<"rh_numbers"> | Date | string
    rh_calls?: Rh_callsListRelationFilter
  }

  export type rh_numbersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rh_calls?: rh_callsOrderByRelationAggregateInput
    _relevance?: rh_numbersOrderByRelevanceInput
  }

  export type rh_numbersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rh_numbersWhereInput | rh_numbersWhereInput[]
    OR?: rh_numbersWhereInput[]
    NOT?: rh_numbersWhereInput | rh_numbersWhereInput[]
    name?: StringFilter<"rh_numbers"> | string
    phone_number?: StringFilter<"rh_numbers"> | string
    createdAt?: DateTimeFilter<"rh_numbers"> | Date | string
    updatedAt?: DateTimeFilter<"rh_numbers"> | Date | string
    rh_calls?: Rh_callsListRelationFilter
  }, "id">

  export type rh_numbersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: rh_numbersCountOrderByAggregateInput
    _max?: rh_numbersMaxOrderByAggregateInput
    _min?: rh_numbersMinOrderByAggregateInput
  }

  export type rh_numbersScalarWhereWithAggregatesInput = {
    AND?: rh_numbersScalarWhereWithAggregatesInput | rh_numbersScalarWhereWithAggregatesInput[]
    OR?: rh_numbersScalarWhereWithAggregatesInput[]
    NOT?: rh_numbersScalarWhereWithAggregatesInput | rh_numbersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"rh_numbers"> | string
    name?: StringWithAggregatesFilter<"rh_numbers"> | string
    phone_number?: StringWithAggregatesFilter<"rh_numbers"> | string
    createdAt?: DateTimeWithAggregatesFilter<"rh_numbers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"rh_numbers"> | Date | string
  }

  export type seller_codesWhereInput = {
    AND?: seller_codesWhereInput | seller_codesWhereInput[]
    OR?: seller_codesWhereInput[]
    NOT?: seller_codesWhereInput | seller_codesWhereInput[]
    id?: StringFilter<"seller_codes"> | string
    code?: IntFilter<"seller_codes"> | number
    square?: StringFilter<"seller_codes"> | string
    createdAt?: DateTimeFilter<"seller_codes"> | Date | string
    updatedAt?: DateTimeFilter<"seller_codes"> | Date | string
  }

  export type seller_codesOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    square?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: seller_codesOrderByRelevanceInput
  }

  export type seller_codesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: seller_codesWhereInput | seller_codesWhereInput[]
    OR?: seller_codesWhereInput[]
    NOT?: seller_codesWhereInput | seller_codesWhereInput[]
    code?: IntFilter<"seller_codes"> | number
    square?: StringFilter<"seller_codes"> | string
    createdAt?: DateTimeFilter<"seller_codes"> | Date | string
    updatedAt?: DateTimeFilter<"seller_codes"> | Date | string
  }, "id">

  export type seller_codesOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    square?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: seller_codesCountOrderByAggregateInput
    _avg?: seller_codesAvgOrderByAggregateInput
    _max?: seller_codesMaxOrderByAggregateInput
    _min?: seller_codesMinOrderByAggregateInput
    _sum?: seller_codesSumOrderByAggregateInput
  }

  export type seller_codesScalarWhereWithAggregatesInput = {
    AND?: seller_codesScalarWhereWithAggregatesInput | seller_codesScalarWhereWithAggregatesInput[]
    OR?: seller_codesScalarWhereWithAggregatesInput[]
    NOT?: seller_codesScalarWhereWithAggregatesInput | seller_codesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"seller_codes"> | string
    code?: IntWithAggregatesFilter<"seller_codes"> | number
    square?: StringWithAggregatesFilter<"seller_codes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"seller_codes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"seller_codes"> | Date | string
  }

  export type sessions_autWhereInput = {
    AND?: sessions_autWhereInput | sessions_autWhereInput[]
    OR?: sessions_autWhereInput[]
    NOT?: sessions_autWhereInput | sessions_autWhereInput[]
    id?: StringFilter<"sessions_aut"> | string
    entrace_option?: IntNullableFilter<"sessions_aut"> | number | null
    is_finished?: BoolFilter<"sessions_aut"> | boolean
    is_timeout?: BoolFilter<"sessions_aut"> | boolean
    is_error?: BoolFilter<"sessions_aut"> | boolean
    user_id?: StringFilter<"sessions_aut"> | string
    createdAt?: DateTimeFilter<"sessions_aut"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }

  export type sessions_autOrderByWithRelationInput = {
    id?: SortOrder
    entrace_option?: SortOrderInput | SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_aut?: users_autOrderByWithRelationInput
    _relevance?: sessions_autOrderByRelevanceInput
  }

  export type sessions_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessions_autWhereInput | sessions_autWhereInput[]
    OR?: sessions_autWhereInput[]
    NOT?: sessions_autWhereInput | sessions_autWhereInput[]
    entrace_option?: IntNullableFilter<"sessions_aut"> | number | null
    is_finished?: BoolFilter<"sessions_aut"> | boolean
    is_timeout?: BoolFilter<"sessions_aut"> | boolean
    is_error?: BoolFilter<"sessions_aut"> | boolean
    user_id?: StringFilter<"sessions_aut"> | string
    createdAt?: DateTimeFilter<"sessions_aut"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }, "id">

  export type sessions_autOrderByWithAggregationInput = {
    id?: SortOrder
    entrace_option?: SortOrderInput | SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: sessions_autCountOrderByAggregateInput
    _avg?: sessions_autAvgOrderByAggregateInput
    _max?: sessions_autMaxOrderByAggregateInput
    _min?: sessions_autMinOrderByAggregateInput
    _sum?: sessions_autSumOrderByAggregateInput
  }

  export type sessions_autScalarWhereWithAggregatesInput = {
    AND?: sessions_autScalarWhereWithAggregatesInput | sessions_autScalarWhereWithAggregatesInput[]
    OR?: sessions_autScalarWhereWithAggregatesInput[]
    NOT?: sessions_autScalarWhereWithAggregatesInput | sessions_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions_aut"> | string
    entrace_option?: IntNullableWithAggregatesFilter<"sessions_aut"> | number | null
    is_finished?: BoolWithAggregatesFilter<"sessions_aut"> | boolean
    is_timeout?: BoolWithAggregatesFilter<"sessions_aut"> | boolean
    is_error?: BoolWithAggregatesFilter<"sessions_aut"> | boolean
    user_id?: StringWithAggregatesFilter<"sessions_aut"> | string
    createdAt?: DateTimeWithAggregatesFilter<"sessions_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"sessions_aut"> | Date | string
  }

  export type sessions_cltWhereInput = {
    AND?: sessions_cltWhereInput | sessions_cltWhereInput[]
    OR?: sessions_cltWhereInput[]
    NOT?: sessions_cltWhereInput | sessions_cltWhereInput[]
    id?: StringFilter<"sessions_clt"> | string
    entrace_option?: IntNullableFilter<"sessions_clt"> | number | null
    is_finished?: BoolFilter<"sessions_clt"> | boolean
    is_timeout?: BoolFilter<"sessions_clt"> | boolean
    is_error?: BoolFilter<"sessions_clt"> | boolean
    user_id?: StringFilter<"sessions_clt"> | string
    createdAt?: DateTimeFilter<"sessions_clt"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }

  export type sessions_cltOrderByWithRelationInput = {
    id?: SortOrder
    entrace_option?: SortOrderInput | SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_clt?: users_cltOrderByWithRelationInput
    _relevance?: sessions_cltOrderByRelevanceInput
  }

  export type sessions_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessions_cltWhereInput | sessions_cltWhereInput[]
    OR?: sessions_cltWhereInput[]
    NOT?: sessions_cltWhereInput | sessions_cltWhereInput[]
    entrace_option?: IntNullableFilter<"sessions_clt"> | number | null
    is_finished?: BoolFilter<"sessions_clt"> | boolean
    is_timeout?: BoolFilter<"sessions_clt"> | boolean
    is_error?: BoolFilter<"sessions_clt"> | boolean
    user_id?: StringFilter<"sessions_clt"> | string
    createdAt?: DateTimeFilter<"sessions_clt"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }, "id">

  export type sessions_cltOrderByWithAggregationInput = {
    id?: SortOrder
    entrace_option?: SortOrderInput | SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: sessions_cltCountOrderByAggregateInput
    _avg?: sessions_cltAvgOrderByAggregateInput
    _max?: sessions_cltMaxOrderByAggregateInput
    _min?: sessions_cltMinOrderByAggregateInput
    _sum?: sessions_cltSumOrderByAggregateInput
  }

  export type sessions_cltScalarWhereWithAggregatesInput = {
    AND?: sessions_cltScalarWhereWithAggregatesInput | sessions_cltScalarWhereWithAggregatesInput[]
    OR?: sessions_cltScalarWhereWithAggregatesInput[]
    NOT?: sessions_cltScalarWhereWithAggregatesInput | sessions_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions_clt"> | string
    entrace_option?: IntNullableWithAggregatesFilter<"sessions_clt"> | number | null
    is_finished?: BoolWithAggregatesFilter<"sessions_clt"> | boolean
    is_timeout?: BoolWithAggregatesFilter<"sessions_clt"> | boolean
    is_error?: BoolWithAggregatesFilter<"sessions_clt"> | boolean
    user_id?: StringWithAggregatesFilter<"sessions_clt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"sessions_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"sessions_clt"> | Date | string
  }

  export type sessions_goiWhereInput = {
    AND?: sessions_goiWhereInput | sessions_goiWhereInput[]
    OR?: sessions_goiWhereInput[]
    NOT?: sessions_goiWhereInput | sessions_goiWhereInput[]
    id?: StringFilter<"sessions_goi"> | string
    entrace_option?: IntNullableFilter<"sessions_goi"> | number | null
    is_finished?: BoolFilter<"sessions_goi"> | boolean
    is_timeout?: BoolFilter<"sessions_goi"> | boolean
    is_error?: BoolFilter<"sessions_goi"> | boolean
    user_id?: StringFilter<"sessions_goi"> | string
    createdAt?: DateTimeFilter<"sessions_goi"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }

  export type sessions_goiOrderByWithRelationInput = {
    id?: SortOrder
    entrace_option?: SortOrderInput | SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_goi?: users_goiOrderByWithRelationInput
    _relevance?: sessions_goiOrderByRelevanceInput
  }

  export type sessions_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessions_goiWhereInput | sessions_goiWhereInput[]
    OR?: sessions_goiWhereInput[]
    NOT?: sessions_goiWhereInput | sessions_goiWhereInput[]
    entrace_option?: IntNullableFilter<"sessions_goi"> | number | null
    is_finished?: BoolFilter<"sessions_goi"> | boolean
    is_timeout?: BoolFilter<"sessions_goi"> | boolean
    is_error?: BoolFilter<"sessions_goi"> | boolean
    user_id?: StringFilter<"sessions_goi"> | string
    createdAt?: DateTimeFilter<"sessions_goi"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }, "id">

  export type sessions_goiOrderByWithAggregationInput = {
    id?: SortOrder
    entrace_option?: SortOrderInput | SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: sessions_goiCountOrderByAggregateInput
    _avg?: sessions_goiAvgOrderByAggregateInput
    _max?: sessions_goiMaxOrderByAggregateInput
    _min?: sessions_goiMinOrderByAggregateInput
    _sum?: sessions_goiSumOrderByAggregateInput
  }

  export type sessions_goiScalarWhereWithAggregatesInput = {
    AND?: sessions_goiScalarWhereWithAggregatesInput | sessions_goiScalarWhereWithAggregatesInput[]
    OR?: sessions_goiScalarWhereWithAggregatesInput[]
    NOT?: sessions_goiScalarWhereWithAggregatesInput | sessions_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions_goi"> | string
    entrace_option?: IntNullableWithAggregatesFilter<"sessions_goi"> | number | null
    is_finished?: BoolWithAggregatesFilter<"sessions_goi"> | boolean
    is_timeout?: BoolWithAggregatesFilter<"sessions_goi"> | boolean
    is_error?: BoolWithAggregatesFilter<"sessions_goi"> | boolean
    user_id?: StringWithAggregatesFilter<"sessions_goi"> | string
    createdAt?: DateTimeWithAggregatesFilter<"sessions_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"sessions_goi"> | Date | string
  }

  export type sessions_spaWhereInput = {
    AND?: sessions_spaWhereInput | sessions_spaWhereInput[]
    OR?: sessions_spaWhereInput[]
    NOT?: sessions_spaWhereInput | sessions_spaWhereInput[]
    id?: StringFilter<"sessions_spa"> | string
    entrace_option?: IntNullableFilter<"sessions_spa"> | number | null
    is_finished?: BoolFilter<"sessions_spa"> | boolean
    is_timeout?: BoolFilter<"sessions_spa"> | boolean
    is_error?: BoolFilter<"sessions_spa"> | boolean
    user_id?: StringFilter<"sessions_spa"> | string
    createdAt?: DateTimeFilter<"sessions_spa"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }

  export type sessions_spaOrderByWithRelationInput = {
    id?: SortOrder
    entrace_option?: SortOrderInput | SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_spa?: users_spaOrderByWithRelationInput
    _relevance?: sessions_spaOrderByRelevanceInput
  }

  export type sessions_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessions_spaWhereInput | sessions_spaWhereInput[]
    OR?: sessions_spaWhereInput[]
    NOT?: sessions_spaWhereInput | sessions_spaWhereInput[]
    entrace_option?: IntNullableFilter<"sessions_spa"> | number | null
    is_finished?: BoolFilter<"sessions_spa"> | boolean
    is_timeout?: BoolFilter<"sessions_spa"> | boolean
    is_error?: BoolFilter<"sessions_spa"> | boolean
    user_id?: StringFilter<"sessions_spa"> | string
    createdAt?: DateTimeFilter<"sessions_spa"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }, "id">

  export type sessions_spaOrderByWithAggregationInput = {
    id?: SortOrder
    entrace_option?: SortOrderInput | SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: sessions_spaCountOrderByAggregateInput
    _avg?: sessions_spaAvgOrderByAggregateInput
    _max?: sessions_spaMaxOrderByAggregateInput
    _min?: sessions_spaMinOrderByAggregateInput
    _sum?: sessions_spaSumOrderByAggregateInput
  }

  export type sessions_spaScalarWhereWithAggregatesInput = {
    AND?: sessions_spaScalarWhereWithAggregatesInput | sessions_spaScalarWhereWithAggregatesInput[]
    OR?: sessions_spaScalarWhereWithAggregatesInput[]
    NOT?: sessions_spaScalarWhereWithAggregatesInput | sessions_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions_spa"> | string
    entrace_option?: IntNullableWithAggregatesFilter<"sessions_spa"> | number | null
    is_finished?: BoolWithAggregatesFilter<"sessions_spa"> | boolean
    is_timeout?: BoolWithAggregatesFilter<"sessions_spa"> | boolean
    is_error?: BoolWithAggregatesFilter<"sessions_spa"> | boolean
    user_id?: StringWithAggregatesFilter<"sessions_spa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"sessions_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"sessions_spa"> | Date | string
  }

  export type supervisor_register_partnersWhereInput = {
    AND?: supervisor_register_partnersWhereInput | supervisor_register_partnersWhereInput[]
    OR?: supervisor_register_partnersWhereInput[]
    NOT?: supervisor_register_partnersWhereInput | supervisor_register_partnersWhereInput[]
    id?: StringFilter<"supervisor_register_partners"> | string
    phone_number?: StringNullableFilter<"supervisor_register_partners"> | string | null
    name?: StringNullableFilter<"supervisor_register_partners"> | string | null
    createdAt?: DateTimeNullableFilter<"supervisor_register_partners"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"supervisor_register_partners"> | Date | string | null
  }

  export type supervisor_register_partnersOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: supervisor_register_partnersOrderByRelevanceInput
  }

  export type supervisor_register_partnersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: supervisor_register_partnersWhereInput | supervisor_register_partnersWhereInput[]
    OR?: supervisor_register_partnersWhereInput[]
    NOT?: supervisor_register_partnersWhereInput | supervisor_register_partnersWhereInput[]
    phone_number?: StringNullableFilter<"supervisor_register_partners"> | string | null
    name?: StringNullableFilter<"supervisor_register_partners"> | string | null
    createdAt?: DateTimeNullableFilter<"supervisor_register_partners"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"supervisor_register_partners"> | Date | string | null
  }, "id">

  export type supervisor_register_partnersOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: supervisor_register_partnersCountOrderByAggregateInput
    _max?: supervisor_register_partnersMaxOrderByAggregateInput
    _min?: supervisor_register_partnersMinOrderByAggregateInput
  }

  export type supervisor_register_partnersScalarWhereWithAggregatesInput = {
    AND?: supervisor_register_partnersScalarWhereWithAggregatesInput | supervisor_register_partnersScalarWhereWithAggregatesInput[]
    OR?: supervisor_register_partnersScalarWhereWithAggregatesInput[]
    NOT?: supervisor_register_partnersScalarWhereWithAggregatesInput | supervisor_register_partnersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"supervisor_register_partners"> | string
    phone_number?: StringNullableWithAggregatesFilter<"supervisor_register_partners"> | string | null
    name?: StringNullableWithAggregatesFilter<"supervisor_register_partners"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"supervisor_register_partners"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"supervisor_register_partners"> | Date | string | null
  }

  export type testers_autWhereInput = {
    AND?: testers_autWhereInput | testers_autWhereInput[]
    OR?: testers_autWhereInput[]
    NOT?: testers_autWhereInput | testers_autWhereInput[]
    id?: StringFilter<"testers_aut"> | string
    phone_number?: StringFilter<"testers_aut"> | string
    createdAt?: DateTimeFilter<"testers_aut"> | Date | string
    updatedAt?: DateTimeFilter<"testers_aut"> | Date | string
  }

  export type testers_autOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: testers_autOrderByRelevanceInput
  }

  export type testers_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: testers_autWhereInput | testers_autWhereInput[]
    OR?: testers_autWhereInput[]
    NOT?: testers_autWhereInput | testers_autWhereInput[]
    phone_number?: StringFilter<"testers_aut"> | string
    createdAt?: DateTimeFilter<"testers_aut"> | Date | string
    updatedAt?: DateTimeFilter<"testers_aut"> | Date | string
  }, "id">

  export type testers_autOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: testers_autCountOrderByAggregateInput
    _max?: testers_autMaxOrderByAggregateInput
    _min?: testers_autMinOrderByAggregateInput
  }

  export type testers_autScalarWhereWithAggregatesInput = {
    AND?: testers_autScalarWhereWithAggregatesInput | testers_autScalarWhereWithAggregatesInput[]
    OR?: testers_autScalarWhereWithAggregatesInput[]
    NOT?: testers_autScalarWhereWithAggregatesInput | testers_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"testers_aut"> | string
    phone_number?: StringWithAggregatesFilter<"testers_aut"> | string
    createdAt?: DateTimeWithAggregatesFilter<"testers_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"testers_aut"> | Date | string
  }

  export type testers_cltWhereInput = {
    AND?: testers_cltWhereInput | testers_cltWhereInput[]
    OR?: testers_cltWhereInput[]
    NOT?: testers_cltWhereInput | testers_cltWhereInput[]
    id?: StringFilter<"testers_clt"> | string
    phone_number?: StringFilter<"testers_clt"> | string
    createdAt?: DateTimeFilter<"testers_clt"> | Date | string
    updatedAt?: DateTimeFilter<"testers_clt"> | Date | string
  }

  export type testers_cltOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: testers_cltOrderByRelevanceInput
  }

  export type testers_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: testers_cltWhereInput | testers_cltWhereInput[]
    OR?: testers_cltWhereInput[]
    NOT?: testers_cltWhereInput | testers_cltWhereInput[]
    phone_number?: StringFilter<"testers_clt"> | string
    createdAt?: DateTimeFilter<"testers_clt"> | Date | string
    updatedAt?: DateTimeFilter<"testers_clt"> | Date | string
  }, "id">

  export type testers_cltOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: testers_cltCountOrderByAggregateInput
    _max?: testers_cltMaxOrderByAggregateInput
    _min?: testers_cltMinOrderByAggregateInput
  }

  export type testers_cltScalarWhereWithAggregatesInput = {
    AND?: testers_cltScalarWhereWithAggregatesInput | testers_cltScalarWhereWithAggregatesInput[]
    OR?: testers_cltScalarWhereWithAggregatesInput[]
    NOT?: testers_cltScalarWhereWithAggregatesInput | testers_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"testers_clt"> | string
    phone_number?: StringWithAggregatesFilter<"testers_clt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"testers_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"testers_clt"> | Date | string
  }

  export type testers_goiWhereInput = {
    AND?: testers_goiWhereInput | testers_goiWhereInput[]
    OR?: testers_goiWhereInput[]
    NOT?: testers_goiWhereInput | testers_goiWhereInput[]
    id?: StringFilter<"testers_goi"> | string
    phone_number?: StringFilter<"testers_goi"> | string
    createdAt?: DateTimeFilter<"testers_goi"> | Date | string
    updatedAt?: DateTimeFilter<"testers_goi"> | Date | string
  }

  export type testers_goiOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: testers_goiOrderByRelevanceInput
  }

  export type testers_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: testers_goiWhereInput | testers_goiWhereInput[]
    OR?: testers_goiWhereInput[]
    NOT?: testers_goiWhereInput | testers_goiWhereInput[]
    phone_number?: StringFilter<"testers_goi"> | string
    createdAt?: DateTimeFilter<"testers_goi"> | Date | string
    updatedAt?: DateTimeFilter<"testers_goi"> | Date | string
  }, "id">

  export type testers_goiOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: testers_goiCountOrderByAggregateInput
    _max?: testers_goiMaxOrderByAggregateInput
    _min?: testers_goiMinOrderByAggregateInput
  }

  export type testers_goiScalarWhereWithAggregatesInput = {
    AND?: testers_goiScalarWhereWithAggregatesInput | testers_goiScalarWhereWithAggregatesInput[]
    OR?: testers_goiScalarWhereWithAggregatesInput[]
    NOT?: testers_goiScalarWhereWithAggregatesInput | testers_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"testers_goi"> | string
    phone_number?: StringWithAggregatesFilter<"testers_goi"> | string
    createdAt?: DateTimeWithAggregatesFilter<"testers_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"testers_goi"> | Date | string
  }

  export type testers_spaWhereInput = {
    AND?: testers_spaWhereInput | testers_spaWhereInput[]
    OR?: testers_spaWhereInput[]
    NOT?: testers_spaWhereInput | testers_spaWhereInput[]
    id?: StringFilter<"testers_spa"> | string
    phone_number?: StringFilter<"testers_spa"> | string
    createdAt?: DateTimeFilter<"testers_spa"> | Date | string
    updatedAt?: DateTimeFilter<"testers_spa"> | Date | string
  }

  export type testers_spaOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: testers_spaOrderByRelevanceInput
  }

  export type testers_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: testers_spaWhereInput | testers_spaWhereInput[]
    OR?: testers_spaWhereInput[]
    NOT?: testers_spaWhereInput | testers_spaWhereInput[]
    phone_number?: StringFilter<"testers_spa"> | string
    createdAt?: DateTimeFilter<"testers_spa"> | Date | string
    updatedAt?: DateTimeFilter<"testers_spa"> | Date | string
  }, "id">

  export type testers_spaOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: testers_spaCountOrderByAggregateInput
    _max?: testers_spaMaxOrderByAggregateInput
    _min?: testers_spaMinOrderByAggregateInput
  }

  export type testers_spaScalarWhereWithAggregatesInput = {
    AND?: testers_spaScalarWhereWithAggregatesInput | testers_spaScalarWhereWithAggregatesInput[]
    OR?: testers_spaScalarWhereWithAggregatesInput[]
    NOT?: testers_spaScalarWhereWithAggregatesInput | testers_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"testers_spa"> | string
    phone_number?: StringWithAggregatesFilter<"testers_spa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"testers_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"testers_spa"> | Date | string
  }

  export type threads_autWhereInput = {
    AND?: threads_autWhereInput | threads_autWhereInput[]
    OR?: threads_autWhereInput[]
    NOT?: threads_autWhereInput | threads_autWhereInput[]
    id?: StringFilter<"threads_aut"> | string
    user_id?: StringFilter<"threads_aut"> | string
    thread?: StringFilter<"threads_aut"> | string
    createdAt?: DateTimeFilter<"threads_aut"> | Date | string
    updatedAt?: DateTimeFilter<"threads_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }

  export type threads_autOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_aut?: users_autOrderByWithRelationInput
    _relevance?: threads_autOrderByRelevanceInput
  }

  export type threads_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    thread?: string
    AND?: threads_autWhereInput | threads_autWhereInput[]
    OR?: threads_autWhereInput[]
    NOT?: threads_autWhereInput | threads_autWhereInput[]
    user_id?: StringFilter<"threads_aut"> | string
    createdAt?: DateTimeFilter<"threads_aut"> | Date | string
    updatedAt?: DateTimeFilter<"threads_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }, "id" | "thread">

  export type threads_autOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: threads_autCountOrderByAggregateInput
    _max?: threads_autMaxOrderByAggregateInput
    _min?: threads_autMinOrderByAggregateInput
  }

  export type threads_autScalarWhereWithAggregatesInput = {
    AND?: threads_autScalarWhereWithAggregatesInput | threads_autScalarWhereWithAggregatesInput[]
    OR?: threads_autScalarWhereWithAggregatesInput[]
    NOT?: threads_autScalarWhereWithAggregatesInput | threads_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"threads_aut"> | string
    user_id?: StringWithAggregatesFilter<"threads_aut"> | string
    thread?: StringWithAggregatesFilter<"threads_aut"> | string
    createdAt?: DateTimeWithAggregatesFilter<"threads_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"threads_aut"> | Date | string
  }

  export type threads_cltWhereInput = {
    AND?: threads_cltWhereInput | threads_cltWhereInput[]
    OR?: threads_cltWhereInput[]
    NOT?: threads_cltWhereInput | threads_cltWhereInput[]
    id?: StringFilter<"threads_clt"> | string
    user_id?: StringFilter<"threads_clt"> | string
    thread?: StringFilter<"threads_clt"> | string
    createdAt?: DateTimeFilter<"threads_clt"> | Date | string
    updatedAt?: DateTimeFilter<"threads_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }

  export type threads_cltOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_clt?: users_cltOrderByWithRelationInput
    _relevance?: threads_cltOrderByRelevanceInput
  }

  export type threads_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    thread?: string
    AND?: threads_cltWhereInput | threads_cltWhereInput[]
    OR?: threads_cltWhereInput[]
    NOT?: threads_cltWhereInput | threads_cltWhereInput[]
    user_id?: StringFilter<"threads_clt"> | string
    createdAt?: DateTimeFilter<"threads_clt"> | Date | string
    updatedAt?: DateTimeFilter<"threads_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }, "id" | "thread">

  export type threads_cltOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: threads_cltCountOrderByAggregateInput
    _max?: threads_cltMaxOrderByAggregateInput
    _min?: threads_cltMinOrderByAggregateInput
  }

  export type threads_cltScalarWhereWithAggregatesInput = {
    AND?: threads_cltScalarWhereWithAggregatesInput | threads_cltScalarWhereWithAggregatesInput[]
    OR?: threads_cltScalarWhereWithAggregatesInput[]
    NOT?: threads_cltScalarWhereWithAggregatesInput | threads_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"threads_clt"> | string
    user_id?: StringWithAggregatesFilter<"threads_clt"> | string
    thread?: StringWithAggregatesFilter<"threads_clt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"threads_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"threads_clt"> | Date | string
  }

  export type threads_goiWhereInput = {
    AND?: threads_goiWhereInput | threads_goiWhereInput[]
    OR?: threads_goiWhereInput[]
    NOT?: threads_goiWhereInput | threads_goiWhereInput[]
    id?: StringFilter<"threads_goi"> | string
    user_id?: StringFilter<"threads_goi"> | string
    thread?: StringFilter<"threads_goi"> | string
    createdAt?: DateTimeFilter<"threads_goi"> | Date | string
    updatedAt?: DateTimeFilter<"threads_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }

  export type threads_goiOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_goi?: users_goiOrderByWithRelationInput
    _relevance?: threads_goiOrderByRelevanceInput
  }

  export type threads_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    thread?: string
    AND?: threads_goiWhereInput | threads_goiWhereInput[]
    OR?: threads_goiWhereInput[]
    NOT?: threads_goiWhereInput | threads_goiWhereInput[]
    user_id?: StringFilter<"threads_goi"> | string
    createdAt?: DateTimeFilter<"threads_goi"> | Date | string
    updatedAt?: DateTimeFilter<"threads_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }, "id" | "thread">

  export type threads_goiOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: threads_goiCountOrderByAggregateInput
    _max?: threads_goiMaxOrderByAggregateInput
    _min?: threads_goiMinOrderByAggregateInput
  }

  export type threads_goiScalarWhereWithAggregatesInput = {
    AND?: threads_goiScalarWhereWithAggregatesInput | threads_goiScalarWhereWithAggregatesInput[]
    OR?: threads_goiScalarWhereWithAggregatesInput[]
    NOT?: threads_goiScalarWhereWithAggregatesInput | threads_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"threads_goi"> | string
    user_id?: StringWithAggregatesFilter<"threads_goi"> | string
    thread?: StringWithAggregatesFilter<"threads_goi"> | string
    createdAt?: DateTimeWithAggregatesFilter<"threads_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"threads_goi"> | Date | string
  }

  export type threads_spaWhereInput = {
    AND?: threads_spaWhereInput | threads_spaWhereInput[]
    OR?: threads_spaWhereInput[]
    NOT?: threads_spaWhereInput | threads_spaWhereInput[]
    id?: StringFilter<"threads_spa"> | string
    user_id?: StringFilter<"threads_spa"> | string
    thread?: StringFilter<"threads_spa"> | string
    createdAt?: DateTimeFilter<"threads_spa"> | Date | string
    updatedAt?: DateTimeFilter<"threads_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }

  export type threads_spaOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_spa?: users_spaOrderByWithRelationInput
    _relevance?: threads_spaOrderByRelevanceInput
  }

  export type threads_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    thread?: string
    AND?: threads_spaWhereInput | threads_spaWhereInput[]
    OR?: threads_spaWhereInput[]
    NOT?: threads_spaWhereInput | threads_spaWhereInput[]
    user_id?: StringFilter<"threads_spa"> | string
    createdAt?: DateTimeFilter<"threads_spa"> | Date | string
    updatedAt?: DateTimeFilter<"threads_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }, "id" | "thread">

  export type threads_spaOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: threads_spaCountOrderByAggregateInput
    _max?: threads_spaMaxOrderByAggregateInput
    _min?: threads_spaMinOrderByAggregateInput
  }

  export type threads_spaScalarWhereWithAggregatesInput = {
    AND?: threads_spaScalarWhereWithAggregatesInput | threads_spaScalarWhereWithAggregatesInput[]
    OR?: threads_spaScalarWhereWithAggregatesInput[]
    NOT?: threads_spaScalarWhereWithAggregatesInput | threads_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"threads_spa"> | string
    user_id?: StringWithAggregatesFilter<"threads_spa"> | string
    thread?: StringWithAggregatesFilter<"threads_spa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"threads_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"threads_spa"> | Date | string
  }

  export type tokens_generated_autWhereInput = {
    AND?: tokens_generated_autWhereInput | tokens_generated_autWhereInput[]
    OR?: tokens_generated_autWhereInput[]
    NOT?: tokens_generated_autWhereInput | tokens_generated_autWhereInput[]
    id?: StringFilter<"tokens_generated_aut"> | string
    create_token_id?: StringNullableFilter<"tokens_generated_aut"> | string | null
    user_id?: StringFilter<"tokens_generated_aut"> | string
    is_expired?: BoolFilter<"tokens_generated_aut"> | boolean
    is_error?: BoolFilter<"tokens_generated_aut"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_aut"> | boolean
    is_closed?: BoolFilter<"tokens_generated_aut"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_aut"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }

  export type tokens_generated_autOrderByWithRelationInput = {
    id?: SortOrder
    create_token_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_aut?: users_autOrderByWithRelationInput
    _relevance?: tokens_generated_autOrderByRelevanceInput
  }

  export type tokens_generated_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    create_token_id?: string
    AND?: tokens_generated_autWhereInput | tokens_generated_autWhereInput[]
    OR?: tokens_generated_autWhereInput[]
    NOT?: tokens_generated_autWhereInput | tokens_generated_autWhereInput[]
    user_id?: StringFilter<"tokens_generated_aut"> | string
    is_expired?: BoolFilter<"tokens_generated_aut"> | boolean
    is_error?: BoolFilter<"tokens_generated_aut"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_aut"> | boolean
    is_closed?: BoolFilter<"tokens_generated_aut"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_aut"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }, "id" | "create_token_id">

  export type tokens_generated_autOrderByWithAggregationInput = {
    id?: SortOrder
    create_token_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tokens_generated_autCountOrderByAggregateInput
    _max?: tokens_generated_autMaxOrderByAggregateInput
    _min?: tokens_generated_autMinOrderByAggregateInput
  }

  export type tokens_generated_autScalarWhereWithAggregatesInput = {
    AND?: tokens_generated_autScalarWhereWithAggregatesInput | tokens_generated_autScalarWhereWithAggregatesInput[]
    OR?: tokens_generated_autScalarWhereWithAggregatesInput[]
    NOT?: tokens_generated_autScalarWhereWithAggregatesInput | tokens_generated_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tokens_generated_aut"> | string
    create_token_id?: StringNullableWithAggregatesFilter<"tokens_generated_aut"> | string | null
    user_id?: StringWithAggregatesFilter<"tokens_generated_aut"> | string
    is_expired?: BoolWithAggregatesFilter<"tokens_generated_aut"> | boolean
    is_error?: BoolWithAggregatesFilter<"tokens_generated_aut"> | boolean
    is_confirmed?: BoolWithAggregatesFilter<"tokens_generated_aut"> | boolean
    is_closed?: BoolWithAggregatesFilter<"tokens_generated_aut"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tokens_generated_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tokens_generated_aut"> | Date | string
  }

  export type tokens_generated_cltWhereInput = {
    AND?: tokens_generated_cltWhereInput | tokens_generated_cltWhereInput[]
    OR?: tokens_generated_cltWhereInput[]
    NOT?: tokens_generated_cltWhereInput | tokens_generated_cltWhereInput[]
    id?: StringFilter<"tokens_generated_clt"> | string
    create_token_id?: StringNullableFilter<"tokens_generated_clt"> | string | null
    user_id?: StringFilter<"tokens_generated_clt"> | string
    is_expired?: BoolFilter<"tokens_generated_clt"> | boolean
    is_error?: BoolFilter<"tokens_generated_clt"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_clt"> | boolean
    is_closed?: BoolFilter<"tokens_generated_clt"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_clt"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }

  export type tokens_generated_cltOrderByWithRelationInput = {
    id?: SortOrder
    create_token_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_clt?: users_cltOrderByWithRelationInput
    _relevance?: tokens_generated_cltOrderByRelevanceInput
  }

  export type tokens_generated_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    create_token_id?: string
    AND?: tokens_generated_cltWhereInput | tokens_generated_cltWhereInput[]
    OR?: tokens_generated_cltWhereInput[]
    NOT?: tokens_generated_cltWhereInput | tokens_generated_cltWhereInput[]
    user_id?: StringFilter<"tokens_generated_clt"> | string
    is_expired?: BoolFilter<"tokens_generated_clt"> | boolean
    is_error?: BoolFilter<"tokens_generated_clt"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_clt"> | boolean
    is_closed?: BoolFilter<"tokens_generated_clt"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_clt"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }, "id" | "create_token_id">

  export type tokens_generated_cltOrderByWithAggregationInput = {
    id?: SortOrder
    create_token_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tokens_generated_cltCountOrderByAggregateInput
    _max?: tokens_generated_cltMaxOrderByAggregateInput
    _min?: tokens_generated_cltMinOrderByAggregateInput
  }

  export type tokens_generated_cltScalarWhereWithAggregatesInput = {
    AND?: tokens_generated_cltScalarWhereWithAggregatesInput | tokens_generated_cltScalarWhereWithAggregatesInput[]
    OR?: tokens_generated_cltScalarWhereWithAggregatesInput[]
    NOT?: tokens_generated_cltScalarWhereWithAggregatesInput | tokens_generated_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tokens_generated_clt"> | string
    create_token_id?: StringNullableWithAggregatesFilter<"tokens_generated_clt"> | string | null
    user_id?: StringWithAggregatesFilter<"tokens_generated_clt"> | string
    is_expired?: BoolWithAggregatesFilter<"tokens_generated_clt"> | boolean
    is_error?: BoolWithAggregatesFilter<"tokens_generated_clt"> | boolean
    is_confirmed?: BoolWithAggregatesFilter<"tokens_generated_clt"> | boolean
    is_closed?: BoolWithAggregatesFilter<"tokens_generated_clt"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tokens_generated_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tokens_generated_clt"> | Date | string
  }

  export type tokens_generated_goiWhereInput = {
    AND?: tokens_generated_goiWhereInput | tokens_generated_goiWhereInput[]
    OR?: tokens_generated_goiWhereInput[]
    NOT?: tokens_generated_goiWhereInput | tokens_generated_goiWhereInput[]
    id?: StringFilter<"tokens_generated_goi"> | string
    create_token_id?: StringNullableFilter<"tokens_generated_goi"> | string | null
    user_id?: StringFilter<"tokens_generated_goi"> | string
    is_expired?: BoolFilter<"tokens_generated_goi"> | boolean
    is_error?: BoolFilter<"tokens_generated_goi"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_goi"> | boolean
    is_closed?: BoolFilter<"tokens_generated_goi"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_goi"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }

  export type tokens_generated_goiOrderByWithRelationInput = {
    id?: SortOrder
    create_token_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_goi?: users_goiOrderByWithRelationInput
    _relevance?: tokens_generated_goiOrderByRelevanceInput
  }

  export type tokens_generated_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    create_token_id?: string
    AND?: tokens_generated_goiWhereInput | tokens_generated_goiWhereInput[]
    OR?: tokens_generated_goiWhereInput[]
    NOT?: tokens_generated_goiWhereInput | tokens_generated_goiWhereInput[]
    user_id?: StringFilter<"tokens_generated_goi"> | string
    is_expired?: BoolFilter<"tokens_generated_goi"> | boolean
    is_error?: BoolFilter<"tokens_generated_goi"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_goi"> | boolean
    is_closed?: BoolFilter<"tokens_generated_goi"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_goi"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }, "id" | "create_token_id">

  export type tokens_generated_goiOrderByWithAggregationInput = {
    id?: SortOrder
    create_token_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tokens_generated_goiCountOrderByAggregateInput
    _max?: tokens_generated_goiMaxOrderByAggregateInput
    _min?: tokens_generated_goiMinOrderByAggregateInput
  }

  export type tokens_generated_goiScalarWhereWithAggregatesInput = {
    AND?: tokens_generated_goiScalarWhereWithAggregatesInput | tokens_generated_goiScalarWhereWithAggregatesInput[]
    OR?: tokens_generated_goiScalarWhereWithAggregatesInput[]
    NOT?: tokens_generated_goiScalarWhereWithAggregatesInput | tokens_generated_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tokens_generated_goi"> | string
    create_token_id?: StringNullableWithAggregatesFilter<"tokens_generated_goi"> | string | null
    user_id?: StringWithAggregatesFilter<"tokens_generated_goi"> | string
    is_expired?: BoolWithAggregatesFilter<"tokens_generated_goi"> | boolean
    is_error?: BoolWithAggregatesFilter<"tokens_generated_goi"> | boolean
    is_confirmed?: BoolWithAggregatesFilter<"tokens_generated_goi"> | boolean
    is_closed?: BoolWithAggregatesFilter<"tokens_generated_goi"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tokens_generated_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tokens_generated_goi"> | Date | string
  }

  export type tokens_generated_spaWhereInput = {
    AND?: tokens_generated_spaWhereInput | tokens_generated_spaWhereInput[]
    OR?: tokens_generated_spaWhereInput[]
    NOT?: tokens_generated_spaWhereInput | tokens_generated_spaWhereInput[]
    id?: StringFilter<"tokens_generated_spa"> | string
    create_token_id?: StringNullableFilter<"tokens_generated_spa"> | string | null
    user_id?: StringFilter<"tokens_generated_spa"> | string
    is_expired?: BoolFilter<"tokens_generated_spa"> | boolean
    is_error?: BoolFilter<"tokens_generated_spa"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_spa"> | boolean
    is_closed?: BoolFilter<"tokens_generated_spa"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_spa"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }

  export type tokens_generated_spaOrderByWithRelationInput = {
    id?: SortOrder
    create_token_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_spa?: users_spaOrderByWithRelationInput
    _relevance?: tokens_generated_spaOrderByRelevanceInput
  }

  export type tokens_generated_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    create_token_id?: string
    AND?: tokens_generated_spaWhereInput | tokens_generated_spaWhereInput[]
    OR?: tokens_generated_spaWhereInput[]
    NOT?: tokens_generated_spaWhereInput | tokens_generated_spaWhereInput[]
    user_id?: StringFilter<"tokens_generated_spa"> | string
    is_expired?: BoolFilter<"tokens_generated_spa"> | boolean
    is_error?: BoolFilter<"tokens_generated_spa"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_spa"> | boolean
    is_closed?: BoolFilter<"tokens_generated_spa"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_spa"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }, "id" | "create_token_id">

  export type tokens_generated_spaOrderByWithAggregationInput = {
    id?: SortOrder
    create_token_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tokens_generated_spaCountOrderByAggregateInput
    _max?: tokens_generated_spaMaxOrderByAggregateInput
    _min?: tokens_generated_spaMinOrderByAggregateInput
  }

  export type tokens_generated_spaScalarWhereWithAggregatesInput = {
    AND?: tokens_generated_spaScalarWhereWithAggregatesInput | tokens_generated_spaScalarWhereWithAggregatesInput[]
    OR?: tokens_generated_spaScalarWhereWithAggregatesInput[]
    NOT?: tokens_generated_spaScalarWhereWithAggregatesInput | tokens_generated_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tokens_generated_spa"> | string
    create_token_id?: StringNullableWithAggregatesFilter<"tokens_generated_spa"> | string | null
    user_id?: StringWithAggregatesFilter<"tokens_generated_spa"> | string
    is_expired?: BoolWithAggregatesFilter<"tokens_generated_spa"> | boolean
    is_error?: BoolWithAggregatesFilter<"tokens_generated_spa"> | boolean
    is_confirmed?: BoolWithAggregatesFilter<"tokens_generated_spa"> | boolean
    is_closed?: BoolWithAggregatesFilter<"tokens_generated_spa"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tokens_generated_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tokens_generated_spa"> | Date | string
  }

  export type trainings_links_autWhereInput = {
    AND?: trainings_links_autWhereInput | trainings_links_autWhereInput[]
    OR?: trainings_links_autWhereInput[]
    NOT?: trainings_links_autWhereInput | trainings_links_autWhereInput[]
    id?: StringFilter<"trainings_links_aut"> | string
    user_id?: StringFilter<"trainings_links_aut"> | string
    training?: StringFilter<"trainings_links_aut"> | string
    createdAt?: DateTimeFilter<"trainings_links_aut"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }

  export type trainings_links_autOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_aut?: users_autOrderByWithRelationInput
    _relevance?: trainings_links_autOrderByRelevanceInput
  }

  export type trainings_links_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: trainings_links_autWhereInput | trainings_links_autWhereInput[]
    OR?: trainings_links_autWhereInput[]
    NOT?: trainings_links_autWhereInput | trainings_links_autWhereInput[]
    user_id?: StringFilter<"trainings_links_aut"> | string
    training?: StringFilter<"trainings_links_aut"> | string
    createdAt?: DateTimeFilter<"trainings_links_aut"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_aut"> | Date | string
    users_aut?: XOR<Users_autScalarRelationFilter, users_autWhereInput>
  }, "id">

  export type trainings_links_autOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: trainings_links_autCountOrderByAggregateInput
    _max?: trainings_links_autMaxOrderByAggregateInput
    _min?: trainings_links_autMinOrderByAggregateInput
  }

  export type trainings_links_autScalarWhereWithAggregatesInput = {
    AND?: trainings_links_autScalarWhereWithAggregatesInput | trainings_links_autScalarWhereWithAggregatesInput[]
    OR?: trainings_links_autScalarWhereWithAggregatesInput[]
    NOT?: trainings_links_autScalarWhereWithAggregatesInput | trainings_links_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"trainings_links_aut"> | string
    user_id?: StringWithAggregatesFilter<"trainings_links_aut"> | string
    training?: StringWithAggregatesFilter<"trainings_links_aut"> | string
    createdAt?: DateTimeWithAggregatesFilter<"trainings_links_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"trainings_links_aut"> | Date | string
  }

  export type trainings_links_cltWhereInput = {
    AND?: trainings_links_cltWhereInput | trainings_links_cltWhereInput[]
    OR?: trainings_links_cltWhereInput[]
    NOT?: trainings_links_cltWhereInput | trainings_links_cltWhereInput[]
    id?: StringFilter<"trainings_links_clt"> | string
    user_id?: StringFilter<"trainings_links_clt"> | string
    training?: StringFilter<"trainings_links_clt"> | string
    createdAt?: DateTimeFilter<"trainings_links_clt"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }

  export type trainings_links_cltOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_clt?: users_cltOrderByWithRelationInput
    _relevance?: trainings_links_cltOrderByRelevanceInput
  }

  export type trainings_links_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: trainings_links_cltWhereInput | trainings_links_cltWhereInput[]
    OR?: trainings_links_cltWhereInput[]
    NOT?: trainings_links_cltWhereInput | trainings_links_cltWhereInput[]
    user_id?: StringFilter<"trainings_links_clt"> | string
    training?: StringFilter<"trainings_links_clt"> | string
    createdAt?: DateTimeFilter<"trainings_links_clt"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_clt"> | Date | string
    users_clt?: XOR<Users_cltScalarRelationFilter, users_cltWhereInput>
  }, "id">

  export type trainings_links_cltOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: trainings_links_cltCountOrderByAggregateInput
    _max?: trainings_links_cltMaxOrderByAggregateInput
    _min?: trainings_links_cltMinOrderByAggregateInput
  }

  export type trainings_links_cltScalarWhereWithAggregatesInput = {
    AND?: trainings_links_cltScalarWhereWithAggregatesInput | trainings_links_cltScalarWhereWithAggregatesInput[]
    OR?: trainings_links_cltScalarWhereWithAggregatesInput[]
    NOT?: trainings_links_cltScalarWhereWithAggregatesInput | trainings_links_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"trainings_links_clt"> | string
    user_id?: StringWithAggregatesFilter<"trainings_links_clt"> | string
    training?: StringWithAggregatesFilter<"trainings_links_clt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"trainings_links_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"trainings_links_clt"> | Date | string
  }

  export type trainings_links_goiWhereInput = {
    AND?: trainings_links_goiWhereInput | trainings_links_goiWhereInput[]
    OR?: trainings_links_goiWhereInput[]
    NOT?: trainings_links_goiWhereInput | trainings_links_goiWhereInput[]
    id?: StringFilter<"trainings_links_goi"> | string
    user_id?: StringFilter<"trainings_links_goi"> | string
    training?: StringFilter<"trainings_links_goi"> | string
    createdAt?: DateTimeFilter<"trainings_links_goi"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }

  export type trainings_links_goiOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_goi?: users_goiOrderByWithRelationInput
    _relevance?: trainings_links_goiOrderByRelevanceInput
  }

  export type trainings_links_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: trainings_links_goiWhereInput | trainings_links_goiWhereInput[]
    OR?: trainings_links_goiWhereInput[]
    NOT?: trainings_links_goiWhereInput | trainings_links_goiWhereInput[]
    user_id?: StringFilter<"trainings_links_goi"> | string
    training?: StringFilter<"trainings_links_goi"> | string
    createdAt?: DateTimeFilter<"trainings_links_goi"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_goi"> | Date | string
    users_goi?: XOR<Users_goiScalarRelationFilter, users_goiWhereInput>
  }, "id">

  export type trainings_links_goiOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: trainings_links_goiCountOrderByAggregateInput
    _max?: trainings_links_goiMaxOrderByAggregateInput
    _min?: trainings_links_goiMinOrderByAggregateInput
  }

  export type trainings_links_goiScalarWhereWithAggregatesInput = {
    AND?: trainings_links_goiScalarWhereWithAggregatesInput | trainings_links_goiScalarWhereWithAggregatesInput[]
    OR?: trainings_links_goiScalarWhereWithAggregatesInput[]
    NOT?: trainings_links_goiScalarWhereWithAggregatesInput | trainings_links_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"trainings_links_goi"> | string
    user_id?: StringWithAggregatesFilter<"trainings_links_goi"> | string
    training?: StringWithAggregatesFilter<"trainings_links_goi"> | string
    createdAt?: DateTimeWithAggregatesFilter<"trainings_links_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"trainings_links_goi"> | Date | string
  }

  export type trainings_links_spaWhereInput = {
    AND?: trainings_links_spaWhereInput | trainings_links_spaWhereInput[]
    OR?: trainings_links_spaWhereInput[]
    NOT?: trainings_links_spaWhereInput | trainings_links_spaWhereInput[]
    id?: StringFilter<"trainings_links_spa"> | string
    user_id?: StringFilter<"trainings_links_spa"> | string
    training?: StringFilter<"trainings_links_spa"> | string
    createdAt?: DateTimeFilter<"trainings_links_spa"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }

  export type trainings_links_spaOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_spa?: users_spaOrderByWithRelationInput
    _relevance?: trainings_links_spaOrderByRelevanceInput
  }

  export type trainings_links_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: trainings_links_spaWhereInput | trainings_links_spaWhereInput[]
    OR?: trainings_links_spaWhereInput[]
    NOT?: trainings_links_spaWhereInput | trainings_links_spaWhereInput[]
    user_id?: StringFilter<"trainings_links_spa"> | string
    training?: StringFilter<"trainings_links_spa"> | string
    createdAt?: DateTimeFilter<"trainings_links_spa"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_spa"> | Date | string
    users_spa?: XOR<Users_spaScalarRelationFilter, users_spaWhereInput>
  }, "id">

  export type trainings_links_spaOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: trainings_links_spaCountOrderByAggregateInput
    _max?: trainings_links_spaMaxOrderByAggregateInput
    _min?: trainings_links_spaMinOrderByAggregateInput
  }

  export type trainings_links_spaScalarWhereWithAggregatesInput = {
    AND?: trainings_links_spaScalarWhereWithAggregatesInput | trainings_links_spaScalarWhereWithAggregatesInput[]
    OR?: trainings_links_spaScalarWhereWithAggregatesInput[]
    NOT?: trainings_links_spaScalarWhereWithAggregatesInput | trainings_links_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"trainings_links_spa"> | string
    user_id?: StringWithAggregatesFilter<"trainings_links_spa"> | string
    training?: StringWithAggregatesFilter<"trainings_links_spa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"trainings_links_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"trainings_links_spa"> | Date | string
  }

  export type users_autWhereInput = {
    AND?: users_autWhereInput | users_autWhereInput[]
    OR?: users_autWhereInput[]
    NOT?: users_autWhereInput | users_autWhereInput[]
    id?: StringFilter<"users_aut"> | string
    phone_number?: BigIntFilter<"users_aut"> | bigint | number
    last_session_id?: StringNullableFilter<"users_aut"> | string | null
    createdAt?: DateTimeFilter<"users_aut"> | Date | string
    updatedAt?: DateTimeFilter<"users_aut"> | Date | string
    budget_consults_aut?: Budget_consults_autListRelationFilter
    cpf_consults_aut?: Cpf_consults_autListRelationFilter
    quote_calculations_aut?: Quote_calculations_autListRelationFilter
    sessions_aut?: Sessions_autListRelationFilter
    threads_aut?: Threads_autListRelationFilter
    tokens_generated_aut?: Tokens_generated_autListRelationFilter
    trainings_links_aut?: Trainings_links_autListRelationFilter
  }

  export type users_autOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budget_consults_aut?: budget_consults_autOrderByRelationAggregateInput
    cpf_consults_aut?: cpf_consults_autOrderByRelationAggregateInput
    quote_calculations_aut?: quote_calculations_autOrderByRelationAggregateInput
    sessions_aut?: sessions_autOrderByRelationAggregateInput
    threads_aut?: threads_autOrderByRelationAggregateInput
    tokens_generated_aut?: tokens_generated_autOrderByRelationAggregateInput
    trainings_links_aut?: trainings_links_autOrderByRelationAggregateInput
    _relevance?: users_autOrderByRelevanceInput
  }

  export type users_autWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: users_autWhereInput | users_autWhereInput[]
    OR?: users_autWhereInput[]
    NOT?: users_autWhereInput | users_autWhereInput[]
    phone_number?: BigIntFilter<"users_aut"> | bigint | number
    last_session_id?: StringNullableFilter<"users_aut"> | string | null
    createdAt?: DateTimeFilter<"users_aut"> | Date | string
    updatedAt?: DateTimeFilter<"users_aut"> | Date | string
    budget_consults_aut?: Budget_consults_autListRelationFilter
    cpf_consults_aut?: Cpf_consults_autListRelationFilter
    quote_calculations_aut?: Quote_calculations_autListRelationFilter
    sessions_aut?: Sessions_autListRelationFilter
    threads_aut?: Threads_autListRelationFilter
    tokens_generated_aut?: Tokens_generated_autListRelationFilter
    trainings_links_aut?: Trainings_links_autListRelationFilter
  }, "id">

  export type users_autOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: users_autCountOrderByAggregateInput
    _avg?: users_autAvgOrderByAggregateInput
    _max?: users_autMaxOrderByAggregateInput
    _min?: users_autMinOrderByAggregateInput
    _sum?: users_autSumOrderByAggregateInput
  }

  export type users_autScalarWhereWithAggregatesInput = {
    AND?: users_autScalarWhereWithAggregatesInput | users_autScalarWhereWithAggregatesInput[]
    OR?: users_autScalarWhereWithAggregatesInput[]
    NOT?: users_autScalarWhereWithAggregatesInput | users_autScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users_aut"> | string
    phone_number?: BigIntWithAggregatesFilter<"users_aut"> | bigint | number
    last_session_id?: StringNullableWithAggregatesFilter<"users_aut"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users_aut"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users_aut"> | Date | string
  }

  export type users_cltWhereInput = {
    AND?: users_cltWhereInput | users_cltWhereInput[]
    OR?: users_cltWhereInput[]
    NOT?: users_cltWhereInput | users_cltWhereInput[]
    id?: StringFilter<"users_clt"> | string
    phone_number?: BigIntFilter<"users_clt"> | bigint | number
    last_session_id?: StringNullableFilter<"users_clt"> | string | null
    createdAt?: DateTimeFilter<"users_clt"> | Date | string
    updatedAt?: DateTimeFilter<"users_clt"> | Date | string
    budget_consults_clt?: Budget_consults_cltListRelationFilter
    cpf_consults_clt?: Cpf_consults_cltListRelationFilter
    quote_calculations_clt?: Quote_calculations_cltListRelationFilter
    sessions_clt?: Sessions_cltListRelationFilter
    threads_clt?: Threads_cltListRelationFilter
    tokens_generated_clt?: Tokens_generated_cltListRelationFilter
    trainings_links_clt?: Trainings_links_cltListRelationFilter
  }

  export type users_cltOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budget_consults_clt?: budget_consults_cltOrderByRelationAggregateInput
    cpf_consults_clt?: cpf_consults_cltOrderByRelationAggregateInput
    quote_calculations_clt?: quote_calculations_cltOrderByRelationAggregateInput
    sessions_clt?: sessions_cltOrderByRelationAggregateInput
    threads_clt?: threads_cltOrderByRelationAggregateInput
    tokens_generated_clt?: tokens_generated_cltOrderByRelationAggregateInput
    trainings_links_clt?: trainings_links_cltOrderByRelationAggregateInput
    _relevance?: users_cltOrderByRelevanceInput
  }

  export type users_cltWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: users_cltWhereInput | users_cltWhereInput[]
    OR?: users_cltWhereInput[]
    NOT?: users_cltWhereInput | users_cltWhereInput[]
    phone_number?: BigIntFilter<"users_clt"> | bigint | number
    last_session_id?: StringNullableFilter<"users_clt"> | string | null
    createdAt?: DateTimeFilter<"users_clt"> | Date | string
    updatedAt?: DateTimeFilter<"users_clt"> | Date | string
    budget_consults_clt?: Budget_consults_cltListRelationFilter
    cpf_consults_clt?: Cpf_consults_cltListRelationFilter
    quote_calculations_clt?: Quote_calculations_cltListRelationFilter
    sessions_clt?: Sessions_cltListRelationFilter
    threads_clt?: Threads_cltListRelationFilter
    tokens_generated_clt?: Tokens_generated_cltListRelationFilter
    trainings_links_clt?: Trainings_links_cltListRelationFilter
  }, "id">

  export type users_cltOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: users_cltCountOrderByAggregateInput
    _avg?: users_cltAvgOrderByAggregateInput
    _max?: users_cltMaxOrderByAggregateInput
    _min?: users_cltMinOrderByAggregateInput
    _sum?: users_cltSumOrderByAggregateInput
  }

  export type users_cltScalarWhereWithAggregatesInput = {
    AND?: users_cltScalarWhereWithAggregatesInput | users_cltScalarWhereWithAggregatesInput[]
    OR?: users_cltScalarWhereWithAggregatesInput[]
    NOT?: users_cltScalarWhereWithAggregatesInput | users_cltScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users_clt"> | string
    phone_number?: BigIntWithAggregatesFilter<"users_clt"> | bigint | number
    last_session_id?: StringNullableWithAggregatesFilter<"users_clt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users_clt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users_clt"> | Date | string
  }

  export type users_goiWhereInput = {
    AND?: users_goiWhereInput | users_goiWhereInput[]
    OR?: users_goiWhereInput[]
    NOT?: users_goiWhereInput | users_goiWhereInput[]
    id?: StringFilter<"users_goi"> | string
    phone_number?: BigIntFilter<"users_goi"> | bigint | number
    last_session_id?: StringNullableFilter<"users_goi"> | string | null
    createdAt?: DateTimeFilter<"users_goi"> | Date | string
    updatedAt?: DateTimeFilter<"users_goi"> | Date | string
    budget_consults_goi?: Budget_consults_goiListRelationFilter
    cpf_consults_goi?: Cpf_consults_goiListRelationFilter
    quote_calculations_goi?: Quote_calculations_goiListRelationFilter
    sessions_goi?: Sessions_goiListRelationFilter
    threads_goi?: Threads_goiListRelationFilter
    tokens_generated_goi?: Tokens_generated_goiListRelationFilter
    trainings_links_goi?: Trainings_links_goiListRelationFilter
  }

  export type users_goiOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budget_consults_goi?: budget_consults_goiOrderByRelationAggregateInput
    cpf_consults_goi?: cpf_consults_goiOrderByRelationAggregateInput
    quote_calculations_goi?: quote_calculations_goiOrderByRelationAggregateInput
    sessions_goi?: sessions_goiOrderByRelationAggregateInput
    threads_goi?: threads_goiOrderByRelationAggregateInput
    tokens_generated_goi?: tokens_generated_goiOrderByRelationAggregateInput
    trainings_links_goi?: trainings_links_goiOrderByRelationAggregateInput
    _relevance?: users_goiOrderByRelevanceInput
  }

  export type users_goiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: users_goiWhereInput | users_goiWhereInput[]
    OR?: users_goiWhereInput[]
    NOT?: users_goiWhereInput | users_goiWhereInput[]
    phone_number?: BigIntFilter<"users_goi"> | bigint | number
    last_session_id?: StringNullableFilter<"users_goi"> | string | null
    createdAt?: DateTimeFilter<"users_goi"> | Date | string
    updatedAt?: DateTimeFilter<"users_goi"> | Date | string
    budget_consults_goi?: Budget_consults_goiListRelationFilter
    cpf_consults_goi?: Cpf_consults_goiListRelationFilter
    quote_calculations_goi?: Quote_calculations_goiListRelationFilter
    sessions_goi?: Sessions_goiListRelationFilter
    threads_goi?: Threads_goiListRelationFilter
    tokens_generated_goi?: Tokens_generated_goiListRelationFilter
    trainings_links_goi?: Trainings_links_goiListRelationFilter
  }, "id">

  export type users_goiOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: users_goiCountOrderByAggregateInput
    _avg?: users_goiAvgOrderByAggregateInput
    _max?: users_goiMaxOrderByAggregateInput
    _min?: users_goiMinOrderByAggregateInput
    _sum?: users_goiSumOrderByAggregateInput
  }

  export type users_goiScalarWhereWithAggregatesInput = {
    AND?: users_goiScalarWhereWithAggregatesInput | users_goiScalarWhereWithAggregatesInput[]
    OR?: users_goiScalarWhereWithAggregatesInput[]
    NOT?: users_goiScalarWhereWithAggregatesInput | users_goiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users_goi"> | string
    phone_number?: BigIntWithAggregatesFilter<"users_goi"> | bigint | number
    last_session_id?: StringNullableWithAggregatesFilter<"users_goi"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users_goi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users_goi"> | Date | string
  }

  export type users_spaWhereInput = {
    AND?: users_spaWhereInput | users_spaWhereInput[]
    OR?: users_spaWhereInput[]
    NOT?: users_spaWhereInput | users_spaWhereInput[]
    id?: StringFilter<"users_spa"> | string
    phone_number?: BigIntFilter<"users_spa"> | bigint | number
    last_session_id?: StringNullableFilter<"users_spa"> | string | null
    createdAt?: DateTimeFilter<"users_spa"> | Date | string
    updatedAt?: DateTimeFilter<"users_spa"> | Date | string
    budget_consults_spa?: Budget_consults_spaListRelationFilter
    cpf_consults_spa?: Cpf_consults_spaListRelationFilter
    quote_calculations_spa?: Quote_calculations_spaListRelationFilter
    sessions_spa?: Sessions_spaListRelationFilter
    threads_spa?: Threads_spaListRelationFilter
    tokens_generated_spa?: Tokens_generated_spaListRelationFilter
    trainings_links_spa?: Trainings_links_spaListRelationFilter
  }

  export type users_spaOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budget_consults_spa?: budget_consults_spaOrderByRelationAggregateInput
    cpf_consults_spa?: cpf_consults_spaOrderByRelationAggregateInput
    quote_calculations_spa?: quote_calculations_spaOrderByRelationAggregateInput
    sessions_spa?: sessions_spaOrderByRelationAggregateInput
    threads_spa?: threads_spaOrderByRelationAggregateInput
    tokens_generated_spa?: tokens_generated_spaOrderByRelationAggregateInput
    trainings_links_spa?: trainings_links_spaOrderByRelationAggregateInput
    _relevance?: users_spaOrderByRelevanceInput
  }

  export type users_spaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: users_spaWhereInput | users_spaWhereInput[]
    OR?: users_spaWhereInput[]
    NOT?: users_spaWhereInput | users_spaWhereInput[]
    phone_number?: BigIntFilter<"users_spa"> | bigint | number
    last_session_id?: StringNullableFilter<"users_spa"> | string | null
    createdAt?: DateTimeFilter<"users_spa"> | Date | string
    updatedAt?: DateTimeFilter<"users_spa"> | Date | string
    budget_consults_spa?: Budget_consults_spaListRelationFilter
    cpf_consults_spa?: Cpf_consults_spaListRelationFilter
    quote_calculations_spa?: Quote_calculations_spaListRelationFilter
    sessions_spa?: Sessions_spaListRelationFilter
    threads_spa?: Threads_spaListRelationFilter
    tokens_generated_spa?: Tokens_generated_spaListRelationFilter
    trainings_links_spa?: Trainings_links_spaListRelationFilter
  }, "id">

  export type users_spaOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: users_spaCountOrderByAggregateInput
    _avg?: users_spaAvgOrderByAggregateInput
    _max?: users_spaMaxOrderByAggregateInput
    _min?: users_spaMinOrderByAggregateInput
    _sum?: users_spaSumOrderByAggregateInput
  }

  export type users_spaScalarWhereWithAggregatesInput = {
    AND?: users_spaScalarWhereWithAggregatesInput | users_spaScalarWhereWithAggregatesInput[]
    OR?: users_spaScalarWhereWithAggregatesInput[]
    NOT?: users_spaScalarWhereWithAggregatesInput | users_spaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users_spa"> | string
    phone_number?: BigIntWithAggregatesFilter<"users_spa"> | bigint | number
    last_session_id?: StringNullableWithAggregatesFilter<"users_spa"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users_spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users_spa"> | Date | string
  }

  export type SequelizeMetaCreateInput = {
    name: string
  }

  export type SequelizeMetaUncheckedCreateInput = {
    name: string
  }

  export type SequelizeMetaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaCreateManyInput = {
    name: string
  }

  export type SequelizeMetaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type accommodation_quotationsCreateInput = {
    id?: bigint | number
    name: string
  }

  export type accommodation_quotationsUncheckedCreateInput = {
    id?: bigint | number
    name: string
  }

  export type accommodation_quotationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type accommodation_quotationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type accommodation_quotationsCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type accommodation_quotationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type accommodation_quotationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type attendantCreateInput = {
    id: string
    jid: string
    name: string
    password: string
    token?: string | null
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
    calls?: callsCreateNestedManyWithoutAttendantInput
  }

  export type attendantUncheckedCreateInput = {
    id: string
    jid: string
    name: string
    password: string
    token?: string | null
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
    calls?: callsUncheckedCreateNestedManyWithoutAttendantInput
  }

  export type attendantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calls?: callsUpdateManyWithoutAttendantNestedInput
  }

  export type attendantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calls?: callsUncheckedUpdateManyWithoutAttendantNestedInput
  }

  export type attendantCreateManyInput = {
    id: string
    jid: string
    name: string
    password: string
    token?: string | null
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendant_callsCreateInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
    attendants?: attendantsCreateNestedOneWithoutAttendant_callsInput
  }

  export type attendant_callsUncheckedCreateInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    attendantId?: string | null
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendant_callsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendants?: attendantsUpdateOneWithoutAttendant_callsNestedInput
  }

  export type attendant_callsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    attendantId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendant_callsCreateManyInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    attendantId?: string | null
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendant_callsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendant_callsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    attendantId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendantsCreateInput = {
    id: string
    jid: string
    name: string
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
    attendant_calls?: attendant_callsCreateNestedManyWithoutAttendantsInput
  }

  export type attendantsUncheckedCreateInput = {
    id: string
    jid: string
    name: string
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
    attendant_calls?: attendant_callsUncheckedCreateNestedManyWithoutAttendantsInput
  }

  export type attendantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendant_calls?: attendant_callsUpdateManyWithoutAttendantsNestedInput
  }

  export type attendantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendant_calls?: attendant_callsUncheckedUpdateManyWithoutAttendantsNestedInput
  }

  export type attendantsCreateManyInput = {
    id: string
    jid: string
    name: string
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_autCreateInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_aut: users_autCreateNestedOneWithoutBudget_consults_autInput
  }

  export type budget_consults_autUncheckedCreateInput = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_aut?: users_autUpdateOneRequiredWithoutBudget_consults_autNestedInput
  }

  export type budget_consults_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_autCreateManyInput = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_cltCreateInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_clt: users_cltCreateNestedOneWithoutBudget_consults_cltInput
  }

  export type budget_consults_cltUncheckedCreateInput = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_clt?: users_cltUpdateOneRequiredWithoutBudget_consults_cltNestedInput
  }

  export type budget_consults_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_cltCreateManyInput = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_goiCreateInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_goi: users_goiCreateNestedOneWithoutBudget_consults_goiInput
  }

  export type budget_consults_goiUncheckedCreateInput = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_goi?: users_goiUpdateOneRequiredWithoutBudget_consults_goiNestedInput
  }

  export type budget_consults_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_goiCreateManyInput = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_spaCreateInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_spa: users_spaCreateNestedOneWithoutBudget_consults_spaInput
  }

  export type budget_consults_spaUncheckedCreateInput = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_spa?: users_spaUpdateOneRequiredWithoutBudget_consults_spaNestedInput
  }

  export type budget_consults_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_spaCreateManyInput = {
    id: string
    budget_code: number
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type callsCreateInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
    attendant?: attendantCreateNestedOneWithoutCallsInput
  }

  export type callsUncheckedCreateInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    attendantId?: string | null
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type callsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendant?: attendantUpdateOneWithoutCallsNestedInput
  }

  export type callsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    attendantId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type callsCreateManyInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    attendantId?: string | null
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type callsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type callsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    attendantId?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cities_quotationsCreateInput = {
    id?: bigint | number
    name: string
  }

  export type cities_quotationsUncheckedCreateInput = {
    id?: bigint | number
    name: string
  }

  export type cities_quotationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type cities_quotationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type cities_quotationsCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type cities_quotationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type cities_quotationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type configs_bot_autCreateInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_autUncheckedCreateInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_autCreateManyInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_cltCreateInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_cltUncheckedCreateInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_cltCreateManyInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_goiCreateInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_goiUncheckedCreateInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_goiCreateManyInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_spaCreateInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_spaUncheckedCreateInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_spaCreateManyInput = {
    id: string
    tag: string
    is_actived: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configs_bot_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configs_bot_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    is_actived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coparticipation_type_quotationsCreateInput = {
    id?: bigint | number
    name: string
  }

  export type coparticipation_type_quotationsUncheckedCreateInput = {
    id?: bigint | number
    name: string
  }

  export type coparticipation_type_quotationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type coparticipation_type_quotationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type coparticipation_type_quotationsCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type coparticipation_type_quotationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type coparticipation_type_quotationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type cpf_consults_autCreateInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_aut: users_autCreateNestedOneWithoutCpf_consults_autInput
  }

  export type cpf_consults_autUncheckedCreateInput = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_aut?: users_autUpdateOneRequiredWithoutCpf_consults_autNestedInput
  }

  export type cpf_consults_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_autCreateManyInput = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_cltCreateInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_clt: users_cltCreateNestedOneWithoutCpf_consults_cltInput
  }

  export type cpf_consults_cltUncheckedCreateInput = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_clt?: users_cltUpdateOneRequiredWithoutCpf_consults_cltNestedInput
  }

  export type cpf_consults_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_cltCreateManyInput = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_goiCreateInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_goi: users_goiCreateNestedOneWithoutCpf_consults_goiInput
  }

  export type cpf_consults_goiUncheckedCreateInput = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_goi?: users_goiUpdateOneRequiredWithoutCpf_consults_goiNestedInput
  }

  export type cpf_consults_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_goiCreateManyInput = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_spaCreateInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_spa: users_spaCreateNestedOneWithoutCpf_consults_spaInput
  }

  export type cpf_consults_spaUncheckedCreateInput = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_spa?: users_spaUpdateOneRequiredWithoutCpf_consults_spaNestedInput
  }

  export type cpf_consults_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_spaCreateManyInput = {
    id: string
    cpf: string
    user_id: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type filesCreateInput = {
    id?: bigint | number
    name: string
    data: Uint8Array
    mimetype: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type filesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    data: Uint8Array
    mimetype: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type filesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    mimetype?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type filesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    mimetype?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type filesCreateManyInput = {
    id?: bigint | number
    name: string
    data: Uint8Array
    mimetype: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type filesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    mimetype?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type filesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: BytesFieldUpdateOperationsInput | Uint8Array
    mimetype?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type maintenance_commandsCreateInput = {
    id: string
    bot_type: string
    option: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type maintenance_commandsUncheckedCreateInput = {
    id: string
    bot_type: string
    option: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type maintenance_commandsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bot_type?: StringFieldUpdateOperationsInput | string
    option?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type maintenance_commandsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bot_type?: StringFieldUpdateOperationsInput | string
    option?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type maintenance_commandsCreateManyInput = {
    id: string
    bot_type: string
    option: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type maintenance_commandsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bot_type?: StringFieldUpdateOperationsInput | string
    option?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type maintenance_commandsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bot_type?: StringFieldUpdateOperationsInput | string
    option?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messages_logCreateInput = {
    id: string
    phone_number: bigint | number
    message: string
    is_attendant: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type messages_logUncheckedCreateInput = {
    id: string
    phone_number: bigint | number
    message: string
    is_attendant: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type messages_logUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    is_attendant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messages_logUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    is_attendant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messages_logCreateManyInput = {
    id: string
    phone_number: bigint | number
    message: string
    is_attendant: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type messages_logUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    is_attendant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messages_logUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    is_attendant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type modality_assistance_quotationsCreateInput = {
    id?: bigint | number
    name: string
  }

  export type modality_assistance_quotationsUncheckedCreateInput = {
    id?: bigint | number
    name: string
  }

  export type modality_assistance_quotationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type modality_assistance_quotationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type modality_assistance_quotationsCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type modality_assistance_quotationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type modality_assistance_quotationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type plan_group_quotationsCreateInput = {
    id?: bigint | number
    name: string
  }

  export type plan_group_quotationsUncheckedCreateInput = {
    id?: bigint | number
    name: string
  }

  export type plan_group_quotationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type plan_group_quotationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type plan_group_quotationsCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type plan_group_quotationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type plan_group_quotationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type plan_type_quotationsCreateInput = {
    id?: bigint | number
    name: string
  }

  export type plan_type_quotationsUncheckedCreateInput = {
    id?: bigint | number
    name: string
  }

  export type plan_type_quotationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type plan_type_quotationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type plan_type_quotationsCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type plan_type_quotationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type plan_type_quotationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type problems_cltCreateInput = {
    id: string
    user_id: string
    problem: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type problems_cltUncheckedCreateInput = {
    id: string
    user_id: string
    problem: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type problems_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type problems_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type problems_cltCreateManyInput = {
    id: string
    user_id: string
    problem: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type problems_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type problems_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationCreateInput = {
    id?: bigint | number
    plano_grupo: string
    estado: string
    coparticipacao_tipo: string
    segmentacao?: string | null
    acomodacao: string
    assistencia_modalidade: string
    codigo_interno?: string | null
    registro_ans?: string | null
    cidade: string
    validade_valores?: string | null
    tipo_plano: string
    preco_00_a_18_anos?: Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: Decimal | DecimalJsLike | number | string | null
    exames_simples?: Decimal | DecimalJsLike | number | string | null
    exames_complexos?: Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: Decimal | DecimalJsLike | number | string | null
    demais_terapias?: Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: number | null
    desconto_familiares?: string | null
    quantidade_de_familiares?: string | null
    campo_vigencia?: string | null
  }

  export type QuotationUncheckedCreateInput = {
    id?: bigint | number
    plano_grupo: string
    estado: string
    coparticipacao_tipo: string
    segmentacao?: string | null
    acomodacao: string
    assistencia_modalidade: string
    codigo_interno?: string | null
    registro_ans?: string | null
    cidade: string
    validade_valores?: string | null
    tipo_plano: string
    preco_00_a_18_anos?: Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: Decimal | DecimalJsLike | number | string | null
    exames_simples?: Decimal | DecimalJsLike | number | string | null
    exames_complexos?: Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: Decimal | DecimalJsLike | number | string | null
    demais_terapias?: Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: number | null
    desconto_familiares?: string | null
    quantidade_de_familiares?: string | null
    campo_vigencia?: string | null
  }

  export type QuotationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plano_grupo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    coparticipacao_tipo?: StringFieldUpdateOperationsInput | string
    segmentacao?: NullableStringFieldUpdateOperationsInput | string | null
    acomodacao?: StringFieldUpdateOperationsInput | string
    assistencia_modalidade?: StringFieldUpdateOperationsInput | string
    codigo_interno?: NullableStringFieldUpdateOperationsInput | string | null
    registro_ans?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    validade_valores?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_plano?: StringFieldUpdateOperationsInput | string
    preco_00_a_18_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exames_simples?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exames_complexos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demais_terapias?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: NullableIntFieldUpdateOperationsInput | number | null
    desconto_familiares?: NullableStringFieldUpdateOperationsInput | string | null
    quantidade_de_familiares?: NullableStringFieldUpdateOperationsInput | string | null
    campo_vigencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plano_grupo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    coparticipacao_tipo?: StringFieldUpdateOperationsInput | string
    segmentacao?: NullableStringFieldUpdateOperationsInput | string | null
    acomodacao?: StringFieldUpdateOperationsInput | string
    assistencia_modalidade?: StringFieldUpdateOperationsInput | string
    codigo_interno?: NullableStringFieldUpdateOperationsInput | string | null
    registro_ans?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    validade_valores?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_plano?: StringFieldUpdateOperationsInput | string
    preco_00_a_18_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exames_simples?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exames_complexos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demais_terapias?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: NullableIntFieldUpdateOperationsInput | number | null
    desconto_familiares?: NullableStringFieldUpdateOperationsInput | string | null
    quantidade_de_familiares?: NullableStringFieldUpdateOperationsInput | string | null
    campo_vigencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationCreateManyInput = {
    id?: bigint | number
    plano_grupo: string
    estado: string
    coparticipacao_tipo: string
    segmentacao?: string | null
    acomodacao: string
    assistencia_modalidade: string
    codigo_interno?: string | null
    registro_ans?: string | null
    cidade: string
    validade_valores?: string | null
    tipo_plano: string
    preco_00_a_18_anos?: Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: Decimal | DecimalJsLike | number | string | null
    exames_simples?: Decimal | DecimalJsLike | number | string | null
    exames_complexos?: Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: Decimal | DecimalJsLike | number | string | null
    demais_terapias?: Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: number | null
    desconto_familiares?: string | null
    quantidade_de_familiares?: string | null
    campo_vigencia?: string | null
  }

  export type QuotationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plano_grupo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    coparticipacao_tipo?: StringFieldUpdateOperationsInput | string
    segmentacao?: NullableStringFieldUpdateOperationsInput | string | null
    acomodacao?: StringFieldUpdateOperationsInput | string
    assistencia_modalidade?: StringFieldUpdateOperationsInput | string
    codigo_interno?: NullableStringFieldUpdateOperationsInput | string | null
    registro_ans?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    validade_valores?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_plano?: StringFieldUpdateOperationsInput | string
    preco_00_a_18_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exames_simples?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exames_complexos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demais_terapias?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: NullableIntFieldUpdateOperationsInput | number | null
    desconto_familiares?: NullableStringFieldUpdateOperationsInput | string | null
    quantidade_de_familiares?: NullableStringFieldUpdateOperationsInput | string | null
    campo_vigencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plano_grupo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    coparticipacao_tipo?: StringFieldUpdateOperationsInput | string
    segmentacao?: NullableStringFieldUpdateOperationsInput | string | null
    acomodacao?: StringFieldUpdateOperationsInput | string
    assistencia_modalidade?: StringFieldUpdateOperationsInput | string
    codigo_interno?: NullableStringFieldUpdateOperationsInput | string | null
    registro_ans?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    validade_valores?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_plano?: StringFieldUpdateOperationsInput | string
    preco_00_a_18_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_19_a_23_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_24_a_28_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_29_a_33_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_34_a_38_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_39_a_43_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_44_a_48_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_49_a_53_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_54_a_58_anos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_59_anos_ou_mais?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preco_todas_idades?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    consultas_eletivas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    consultas_urgencia?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exames_simples?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exames_complexos?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terapias_neurologicas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demais_terapias?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto_vidas?: NullableIntFieldUpdateOperationsInput | number | null
    desconto_familiares?: NullableStringFieldUpdateOperationsInput | string | null
    quantidade_de_familiares?: NullableStringFieldUpdateOperationsInput | string | null
    campo_vigencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quote_calculations_autCreateInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_aut: users_autCreateNestedOneWithoutQuote_calculations_autInput
  }

  export type quote_calculations_autUncheckedCreateInput = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_aut?: users_autUpdateOneRequiredWithoutQuote_calculations_autNestedInput
  }

  export type quote_calculations_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_autCreateManyInput = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_cltCreateInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_clt: users_cltCreateNestedOneWithoutQuote_calculations_cltInput
  }

  export type quote_calculations_cltUncheckedCreateInput = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_clt?: users_cltUpdateOneRequiredWithoutQuote_calculations_cltNestedInput
  }

  export type quote_calculations_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_cltCreateManyInput = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_goiCreateInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_goi: users_goiCreateNestedOneWithoutQuote_calculations_goiInput
  }

  export type quote_calculations_goiUncheckedCreateInput = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_goi?: users_goiUpdateOneRequiredWithoutQuote_calculations_goiNestedInput
  }

  export type quote_calculations_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_goiCreateManyInput = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_spaCreateInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_spa: users_spaCreateNestedOneWithoutQuote_calculations_spaInput
  }

  export type quote_calculations_spaUncheckedCreateInput = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_spa?: users_spaUpdateOneRequiredWithoutQuote_calculations_spaNestedInput
  }

  export type quote_calculations_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_spaCreateManyInput = {
    id: string
    user_id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type register_partners_autCreateInput = {
    id: string
    complete_name: string
    phone_number: string
    email: string
    birth_date: string
    city: string
    createdAt: Date | string
    updatedAt: Date | string
    obs?: string | null
  }

  export type register_partners_autUncheckedCreateInput = {
    id: string
    complete_name: string
    phone_number: string
    email: string
    birth_date: string
    city: string
    createdAt: Date | string
    updatedAt: Date | string
    obs?: string | null
  }

  export type register_partners_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    complete_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birth_date?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type register_partners_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    complete_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birth_date?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type register_partners_autCreateManyInput = {
    id: string
    complete_name: string
    phone_number: string
    email: string
    birth_date: string
    city: string
    createdAt: Date | string
    updatedAt: Date | string
    obs?: string | null
  }

  export type register_partners_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    complete_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birth_date?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type register_partners_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    complete_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birth_date?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type register_partners_spaCreateInput = {
    id: string
    complete_name: string
    phone_number: string
    email: string
    birth_date: string
    city: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type register_partners_spaUncheckedCreateInput = {
    id: string
    complete_name: string
    phone_number: string
    email: string
    birth_date: string
    city: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type register_partners_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    complete_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birth_date?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type register_partners_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    complete_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birth_date?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type register_partners_spaCreateManyInput = {
    id: string
    complete_name: string
    phone_number: string
    email: string
    birth_date: string
    city: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type register_partners_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    complete_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birth_date?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type register_partners_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    complete_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birth_date?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rh_callsCreateInput = {
    id: string
    jid: string
    name: string
    message: string
    createdAt: Date | string
    updatedAt: Date | string
    rh_numbers?: rh_numbersCreateNestedOneWithoutRh_callsInput
  }

  export type rh_callsUncheckedCreateInput = {
    id: string
    jid: string
    name: string
    message: string
    createdAt: Date | string
    updatedAt: Date | string
    rhNumberId?: string | null
  }

  export type rh_callsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rh_numbers?: rh_numbersUpdateOneWithoutRh_callsNestedInput
  }

  export type rh_callsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rhNumberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rh_callsCreateManyInput = {
    id: string
    jid: string
    name: string
    message: string
    createdAt: Date | string
    updatedAt: Date | string
    rhNumberId?: string | null
  }

  export type rh_callsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rh_callsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rhNumberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rh_numbersCreateInput = {
    id: string
    name: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
    rh_calls?: rh_callsCreateNestedManyWithoutRh_numbersInput
  }

  export type rh_numbersUncheckedCreateInput = {
    id: string
    name: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
    rh_calls?: rh_callsUncheckedCreateNestedManyWithoutRh_numbersInput
  }

  export type rh_numbersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rh_calls?: rh_callsUpdateManyWithoutRh_numbersNestedInput
  }

  export type rh_numbersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rh_calls?: rh_callsUncheckedUpdateManyWithoutRh_numbersNestedInput
  }

  export type rh_numbersCreateManyInput = {
    id: string
    name: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type rh_numbersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rh_numbersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type seller_codesCreateInput = {
    id: string
    code: number
    square: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type seller_codesUncheckedCreateInput = {
    id: string
    code: number
    square: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type seller_codesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    square?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type seller_codesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    square?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type seller_codesCreateManyInput = {
    id: string
    code: number
    square: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type seller_codesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    square?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type seller_codesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    square?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_autCreateInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_aut: users_autCreateNestedOneWithoutSessions_autInput
  }

  export type sessions_autUncheckedCreateInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_aut?: users_autUpdateOneRequiredWithoutSessions_autNestedInput
  }

  export type sessions_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_autCreateManyInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_cltCreateInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_clt: users_cltCreateNestedOneWithoutSessions_cltInput
  }

  export type sessions_cltUncheckedCreateInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_clt?: users_cltUpdateOneRequiredWithoutSessions_cltNestedInput
  }

  export type sessions_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_cltCreateManyInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_goiCreateInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_goi: users_goiCreateNestedOneWithoutSessions_goiInput
  }

  export type sessions_goiUncheckedCreateInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_goi?: users_goiUpdateOneRequiredWithoutSessions_goiNestedInput
  }

  export type sessions_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_goiCreateManyInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_spaCreateInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_spa: users_spaCreateNestedOneWithoutSessions_spaInput
  }

  export type sessions_spaUncheckedCreateInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_spa?: users_spaUpdateOneRequiredWithoutSessions_spaNestedInput
  }

  export type sessions_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_spaCreateManyInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    user_id: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supervisor_register_partnersCreateInput = {
    id: string
    phone_number?: string | null
    name?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type supervisor_register_partnersUncheckedCreateInput = {
    id: string
    phone_number?: string | null
    name?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type supervisor_register_partnersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supervisor_register_partnersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supervisor_register_partnersCreateManyInput = {
    id: string
    phone_number?: string | null
    name?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type supervisor_register_partnersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supervisor_register_partnersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type testers_autCreateInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_autUncheckedCreateInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_autCreateManyInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_cltCreateInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_cltUncheckedCreateInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_cltCreateManyInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_goiCreateInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_goiUncheckedCreateInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_goiCreateManyInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_spaCreateInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_spaUncheckedCreateInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_spaCreateManyInput = {
    id: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type testers_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testers_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_autCreateInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
    users_aut: users_autCreateNestedOneWithoutThreads_autInput
  }

  export type threads_autUncheckedCreateInput = {
    id: string
    user_id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_aut?: users_autUpdateOneRequiredWithoutThreads_autNestedInput
  }

  export type threads_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_autCreateManyInput = {
    id: string
    user_id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_cltCreateInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
    users_clt: users_cltCreateNestedOneWithoutThreads_cltInput
  }

  export type threads_cltUncheckedCreateInput = {
    id: string
    user_id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_clt?: users_cltUpdateOneRequiredWithoutThreads_cltNestedInput
  }

  export type threads_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_cltCreateManyInput = {
    id: string
    user_id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_goiCreateInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
    users_goi: users_goiCreateNestedOneWithoutThreads_goiInput
  }

  export type threads_goiUncheckedCreateInput = {
    id: string
    user_id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_goi?: users_goiUpdateOneRequiredWithoutThreads_goiNestedInput
  }

  export type threads_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_goiCreateManyInput = {
    id: string
    user_id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_spaCreateInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
    users_spa: users_spaCreateNestedOneWithoutThreads_spaInput
  }

  export type threads_spaUncheckedCreateInput = {
    id: string
    user_id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_spa?: users_spaUpdateOneRequiredWithoutThreads_spaNestedInput
  }

  export type threads_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_spaCreateManyInput = {
    id: string
    user_id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_autCreateInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_aut: users_autCreateNestedOneWithoutTokens_generated_autInput
  }

  export type tokens_generated_autUncheckedCreateInput = {
    id: string
    create_token_id?: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_aut?: users_autUpdateOneRequiredWithoutTokens_generated_autNestedInput
  }

  export type tokens_generated_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_autCreateManyInput = {
    id: string
    create_token_id?: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_cltCreateInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_clt: users_cltCreateNestedOneWithoutTokens_generated_cltInput
  }

  export type tokens_generated_cltUncheckedCreateInput = {
    id: string
    create_token_id?: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_clt?: users_cltUpdateOneRequiredWithoutTokens_generated_cltNestedInput
  }

  export type tokens_generated_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_cltCreateManyInput = {
    id: string
    create_token_id?: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_goiCreateInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_goi: users_goiCreateNestedOneWithoutTokens_generated_goiInput
  }

  export type tokens_generated_goiUncheckedCreateInput = {
    id: string
    create_token_id?: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_goi?: users_goiUpdateOneRequiredWithoutTokens_generated_goiNestedInput
  }

  export type tokens_generated_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_goiCreateManyInput = {
    id: string
    create_token_id?: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_spaCreateInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
    users_spa: users_spaCreateNestedOneWithoutTokens_generated_spaInput
  }

  export type tokens_generated_spaUncheckedCreateInput = {
    id: string
    create_token_id?: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_spa?: users_spaUpdateOneRequiredWithoutTokens_generated_spaNestedInput
  }

  export type tokens_generated_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_spaCreateManyInput = {
    id: string
    create_token_id?: string | null
    user_id: string
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_autCreateInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
    users_aut: users_autCreateNestedOneWithoutTrainings_links_autInput
  }

  export type trainings_links_autUncheckedCreateInput = {
    id: string
    user_id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_aut?: users_autUpdateOneRequiredWithoutTrainings_links_autNestedInput
  }

  export type trainings_links_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_autCreateManyInput = {
    id: string
    user_id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_cltCreateInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
    users_clt: users_cltCreateNestedOneWithoutTrainings_links_cltInput
  }

  export type trainings_links_cltUncheckedCreateInput = {
    id: string
    user_id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_clt?: users_cltUpdateOneRequiredWithoutTrainings_links_cltNestedInput
  }

  export type trainings_links_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_cltCreateManyInput = {
    id: string
    user_id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_goiCreateInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
    users_goi: users_goiCreateNestedOneWithoutTrainings_links_goiInput
  }

  export type trainings_links_goiUncheckedCreateInput = {
    id: string
    user_id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_goi?: users_goiUpdateOneRequiredWithoutTrainings_links_goiNestedInput
  }

  export type trainings_links_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_goiCreateManyInput = {
    id: string
    user_id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_spaCreateInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
    users_spa: users_spaCreateNestedOneWithoutTrainings_links_spaInput
  }

  export type trainings_links_spaUncheckedCreateInput = {
    id: string
    user_id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_spa?: users_spaUpdateOneRequiredWithoutTrainings_links_spaNestedInput
  }

  export type trainings_links_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_spaCreateManyInput = {
    id: string
    user_id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_autCreateInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUncheckedCreateInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autUncheckedCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autUncheckedCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autUncheckedCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autUncheckedCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autUncheckedCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUncheckedUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUncheckedUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUncheckedUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUncheckedUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUncheckedUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autCreateManyInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type users_autUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_autUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_cltCreateInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUncheckedCreateInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltUncheckedCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltCreateManyInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type users_cltUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_cltUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_goiCreateInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUncheckedCreateInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiUncheckedCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiCreateManyInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type users_goiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_goiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_spaCreateInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUncheckedCreateInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaUncheckedCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaCreateManyInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type users_spaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_spaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SequelizeMetaOrderByRelevanceInput = {
    fields: SequelizeMetaOrderByRelevanceFieldEnum | SequelizeMetaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SequelizeMetaCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SequelizeMetaMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SequelizeMetaMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type accommodation_quotationsOrderByRelevanceInput = {
    fields: accommodation_quotationsOrderByRelevanceFieldEnum | accommodation_quotationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accommodation_quotationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type accommodation_quotationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type accommodation_quotationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type accommodation_quotationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type accommodation_quotationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CallsListRelationFilter = {
    every?: callsWhereInput
    some?: callsWhereInput
    none?: callsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type callsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type attendantOrderByRelevanceInput = {
    fields: attendantOrderByRelevanceFieldEnum | attendantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type attendantCountOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    password?: SortOrder
    token?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type attendantMaxOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    password?: SortOrder
    token?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type attendantMinOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    password?: SortOrder
    token?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AttendantsNullableScalarRelationFilter = {
    is?: attendantsWhereInput | null
    isNot?: attendantsWhereInput | null
  }

  export type attendant_callsOrderByRelevanceInput = {
    fields: attendant_callsOrderByRelevanceFieldEnum | attendant_callsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type attendant_callsCountOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type attendant_callsMaxOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type attendant_callsMinOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Attendant_callsListRelationFilter = {
    every?: attendant_callsWhereInput
    some?: attendant_callsWhereInput
    none?: attendant_callsWhereInput
  }

  export type attendant_callsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type attendantsOrderByRelevanceInput = {
    fields: attendantsOrderByRelevanceFieldEnum | attendantsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type attendantsCountOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type attendantsMaxOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type attendantsMinOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type Users_autScalarRelationFilter = {
    is?: users_autWhereInput
    isNot?: users_autWhereInput
  }

  export type budget_consults_autOrderByRelevanceInput = {
    fields: budget_consults_autOrderByRelevanceFieldEnum | budget_consults_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type budget_consults_autCountOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_autAvgOrderByAggregateInput = {
    budget_code?: SortOrder
  }

  export type budget_consults_autMaxOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_autMinOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_autSumOrderByAggregateInput = {
    budget_code?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Users_cltScalarRelationFilter = {
    is?: users_cltWhereInput
    isNot?: users_cltWhereInput
  }

  export type budget_consults_cltOrderByRelevanceInput = {
    fields: budget_consults_cltOrderByRelevanceFieldEnum | budget_consults_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type budget_consults_cltCountOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_cltAvgOrderByAggregateInput = {
    budget_code?: SortOrder
  }

  export type budget_consults_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_cltMinOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_cltSumOrderByAggregateInput = {
    budget_code?: SortOrder
  }

  export type Users_goiScalarRelationFilter = {
    is?: users_goiWhereInput
    isNot?: users_goiWhereInput
  }

  export type budget_consults_goiOrderByRelevanceInput = {
    fields: budget_consults_goiOrderByRelevanceFieldEnum | budget_consults_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type budget_consults_goiCountOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_goiAvgOrderByAggregateInput = {
    budget_code?: SortOrder
  }

  export type budget_consults_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_goiMinOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_goiSumOrderByAggregateInput = {
    budget_code?: SortOrder
  }

  export type Users_spaScalarRelationFilter = {
    is?: users_spaWhereInput
    isNot?: users_spaWhereInput
  }

  export type budget_consults_spaOrderByRelevanceInput = {
    fields: budget_consults_spaOrderByRelevanceFieldEnum | budget_consults_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type budget_consults_spaCountOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_spaAvgOrderByAggregateInput = {
    budget_code?: SortOrder
  }

  export type budget_consults_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_spaMinOrderByAggregateInput = {
    id?: SortOrder
    budget_code?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type budget_consults_spaSumOrderByAggregateInput = {
    budget_code?: SortOrder
  }

  export type AttendantNullableScalarRelationFilter = {
    is?: attendantWhereInput | null
    isNot?: attendantWhereInput | null
  }

  export type callsOrderByRelevanceInput = {
    fields: callsOrderByRelevanceFieldEnum | callsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type callsCountOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type callsMaxOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type callsMinOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    mainProblem?: SortOrder
    detailsProblem?: SortOrder
    pushName?: SortOrder
    attendantId?: SortOrder
    isResolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cities_quotationsOrderByRelevanceInput = {
    fields: cities_quotationsOrderByRelevanceFieldEnum | cities_quotationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cities_quotationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type cities_quotationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cities_quotationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type cities_quotationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type cities_quotationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type configs_bot_autOrderByRelevanceInput = {
    fields: configs_bot_autOrderByRelevanceFieldEnum | configs_bot_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type configs_bot_autCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_autMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_autMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_cltOrderByRelevanceInput = {
    fields: configs_bot_cltOrderByRelevanceFieldEnum | configs_bot_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type configs_bot_cltCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_cltMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_goiOrderByRelevanceInput = {
    fields: configs_bot_goiOrderByRelevanceFieldEnum | configs_bot_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type configs_bot_goiCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_goiMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_spaOrderByRelevanceInput = {
    fields: configs_bot_spaOrderByRelevanceFieldEnum | configs_bot_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type configs_bot_spaCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configs_bot_spaMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    is_actived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type coparticipation_type_quotationsOrderByRelevanceInput = {
    fields: coparticipation_type_quotationsOrderByRelevanceFieldEnum | coparticipation_type_quotationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type coparticipation_type_quotationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type coparticipation_type_quotationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type coparticipation_type_quotationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type coparticipation_type_quotationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type coparticipation_type_quotationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cpf_consults_autOrderByRelevanceInput = {
    fields: cpf_consults_autOrderByRelevanceFieldEnum | cpf_consults_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cpf_consults_autCountOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_autMaxOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_autMinOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_cltOrderByRelevanceInput = {
    fields: cpf_consults_cltOrderByRelevanceFieldEnum | cpf_consults_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cpf_consults_cltCountOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_cltMinOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_goiOrderByRelevanceInput = {
    fields: cpf_consults_goiOrderByRelevanceFieldEnum | cpf_consults_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cpf_consults_goiCountOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_goiMinOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_spaOrderByRelevanceInput = {
    fields: cpf_consults_spaOrderByRelevanceFieldEnum | cpf_consults_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cpf_consults_spaCountOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cpf_consults_spaMinOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    user_id?: SortOrder
    is_error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type filesOrderByRelevanceInput = {
    fields: filesOrderByRelevanceFieldEnum | filesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type filesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    mimetype?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type filesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type filesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    mimetype?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type filesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    mimetype?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type filesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type maintenance_commandsOrderByRelevanceInput = {
    fields: maintenance_commandsOrderByRelevanceFieldEnum | maintenance_commandsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type maintenance_commandsCountOrderByAggregateInput = {
    id?: SortOrder
    bot_type?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type maintenance_commandsAvgOrderByAggregateInput = {
    option?: SortOrder
  }

  export type maintenance_commandsMaxOrderByAggregateInput = {
    id?: SortOrder
    bot_type?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type maintenance_commandsMinOrderByAggregateInput = {
    id?: SortOrder
    bot_type?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type maintenance_commandsSumOrderByAggregateInput = {
    option?: SortOrder
  }

  export type messages_logOrderByRelevanceInput = {
    fields: messages_logOrderByRelevanceFieldEnum | messages_logOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type messages_logCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    is_attendant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type messages_logAvgOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type messages_logMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    is_attendant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type messages_logMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    is_attendant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type messages_logSumOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type modality_assistance_quotationsOrderByRelevanceInput = {
    fields: modality_assistance_quotationsOrderByRelevanceFieldEnum | modality_assistance_quotationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type modality_assistance_quotationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type modality_assistance_quotationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type modality_assistance_quotationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type modality_assistance_quotationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type modality_assistance_quotationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plan_group_quotationsOrderByRelevanceInput = {
    fields: plan_group_quotationsOrderByRelevanceFieldEnum | plan_group_quotationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type plan_group_quotationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type plan_group_quotationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plan_group_quotationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type plan_group_quotationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type plan_group_quotationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plan_type_quotationsOrderByRelevanceInput = {
    fields: plan_type_quotationsOrderByRelevanceFieldEnum | plan_type_quotationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type plan_type_quotationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type plan_type_quotationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plan_type_quotationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type plan_type_quotationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type plan_type_quotationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type problems_cltOrderByRelevanceInput = {
    fields: problems_cltOrderByRelevanceFieldEnum | problems_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type problems_cltCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type problems_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type problems_cltMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type QuotationOrderByRelevanceInput = {
    fields: QuotationOrderByRelevanceFieldEnum | QuotationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QuotationCountOrderByAggregateInput = {
    id?: SortOrder
    plano_grupo?: SortOrder
    estado?: SortOrder
    coparticipacao_tipo?: SortOrder
    segmentacao?: SortOrder
    acomodacao?: SortOrder
    assistencia_modalidade?: SortOrder
    codigo_interno?: SortOrder
    registro_ans?: SortOrder
    cidade?: SortOrder
    validade_valores?: SortOrder
    tipo_plano?: SortOrder
    preco_00_a_18_anos?: SortOrder
    preco_19_a_23_anos?: SortOrder
    preco_24_a_28_anos?: SortOrder
    preco_29_a_33_anos?: SortOrder
    preco_34_a_38_anos?: SortOrder
    preco_39_a_43_anos?: SortOrder
    preco_44_a_48_anos?: SortOrder
    preco_49_a_53_anos?: SortOrder
    preco_54_a_58_anos?: SortOrder
    preco_59_anos_ou_mais?: SortOrder
    preco_todas_idades?: SortOrder
    consultas_eletivas?: SortOrder
    consultas_urgencia?: SortOrder
    exames_simples?: SortOrder
    exames_complexos?: SortOrder
    terapias_neurologicas?: SortOrder
    demais_terapias?: SortOrder
    desconto_vidas?: SortOrder
    desconto_familiares?: SortOrder
    quantidade_de_familiares?: SortOrder
    campo_vigencia?: SortOrder
  }

  export type QuotationAvgOrderByAggregateInput = {
    id?: SortOrder
    preco_00_a_18_anos?: SortOrder
    preco_19_a_23_anos?: SortOrder
    preco_24_a_28_anos?: SortOrder
    preco_29_a_33_anos?: SortOrder
    preco_34_a_38_anos?: SortOrder
    preco_39_a_43_anos?: SortOrder
    preco_44_a_48_anos?: SortOrder
    preco_49_a_53_anos?: SortOrder
    preco_54_a_58_anos?: SortOrder
    preco_59_anos_ou_mais?: SortOrder
    preco_todas_idades?: SortOrder
    consultas_eletivas?: SortOrder
    consultas_urgencia?: SortOrder
    exames_simples?: SortOrder
    exames_complexos?: SortOrder
    terapias_neurologicas?: SortOrder
    demais_terapias?: SortOrder
    desconto_vidas?: SortOrder
  }

  export type QuotationMaxOrderByAggregateInput = {
    id?: SortOrder
    plano_grupo?: SortOrder
    estado?: SortOrder
    coparticipacao_tipo?: SortOrder
    segmentacao?: SortOrder
    acomodacao?: SortOrder
    assistencia_modalidade?: SortOrder
    codigo_interno?: SortOrder
    registro_ans?: SortOrder
    cidade?: SortOrder
    validade_valores?: SortOrder
    tipo_plano?: SortOrder
    preco_00_a_18_anos?: SortOrder
    preco_19_a_23_anos?: SortOrder
    preco_24_a_28_anos?: SortOrder
    preco_29_a_33_anos?: SortOrder
    preco_34_a_38_anos?: SortOrder
    preco_39_a_43_anos?: SortOrder
    preco_44_a_48_anos?: SortOrder
    preco_49_a_53_anos?: SortOrder
    preco_54_a_58_anos?: SortOrder
    preco_59_anos_ou_mais?: SortOrder
    preco_todas_idades?: SortOrder
    consultas_eletivas?: SortOrder
    consultas_urgencia?: SortOrder
    exames_simples?: SortOrder
    exames_complexos?: SortOrder
    terapias_neurologicas?: SortOrder
    demais_terapias?: SortOrder
    desconto_vidas?: SortOrder
    desconto_familiares?: SortOrder
    quantidade_de_familiares?: SortOrder
    campo_vigencia?: SortOrder
  }

  export type QuotationMinOrderByAggregateInput = {
    id?: SortOrder
    plano_grupo?: SortOrder
    estado?: SortOrder
    coparticipacao_tipo?: SortOrder
    segmentacao?: SortOrder
    acomodacao?: SortOrder
    assistencia_modalidade?: SortOrder
    codigo_interno?: SortOrder
    registro_ans?: SortOrder
    cidade?: SortOrder
    validade_valores?: SortOrder
    tipo_plano?: SortOrder
    preco_00_a_18_anos?: SortOrder
    preco_19_a_23_anos?: SortOrder
    preco_24_a_28_anos?: SortOrder
    preco_29_a_33_anos?: SortOrder
    preco_34_a_38_anos?: SortOrder
    preco_39_a_43_anos?: SortOrder
    preco_44_a_48_anos?: SortOrder
    preco_49_a_53_anos?: SortOrder
    preco_54_a_58_anos?: SortOrder
    preco_59_anos_ou_mais?: SortOrder
    preco_todas_idades?: SortOrder
    consultas_eletivas?: SortOrder
    consultas_urgencia?: SortOrder
    exames_simples?: SortOrder
    exames_complexos?: SortOrder
    terapias_neurologicas?: SortOrder
    demais_terapias?: SortOrder
    desconto_vidas?: SortOrder
    desconto_familiares?: SortOrder
    quantidade_de_familiares?: SortOrder
    campo_vigencia?: SortOrder
  }

  export type QuotationSumOrderByAggregateInput = {
    id?: SortOrder
    preco_00_a_18_anos?: SortOrder
    preco_19_a_23_anos?: SortOrder
    preco_24_a_28_anos?: SortOrder
    preco_29_a_33_anos?: SortOrder
    preco_34_a_38_anos?: SortOrder
    preco_39_a_43_anos?: SortOrder
    preco_44_a_48_anos?: SortOrder
    preco_49_a_53_anos?: SortOrder
    preco_54_a_58_anos?: SortOrder
    preco_59_anos_ou_mais?: SortOrder
    preco_todas_idades?: SortOrder
    consultas_eletivas?: SortOrder
    consultas_urgencia?: SortOrder
    exames_simples?: SortOrder
    exames_complexos?: SortOrder
    terapias_neurologicas?: SortOrder
    demais_terapias?: SortOrder
    desconto_vidas?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type quote_calculations_autOrderByRelevanceInput = {
    fields: quote_calculations_autOrderByRelevanceFieldEnum | quote_calculations_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type quote_calculations_autCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_autMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_autMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_cltOrderByRelevanceInput = {
    fields: quote_calculations_cltOrderByRelevanceFieldEnum | quote_calculations_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type quote_calculations_cltCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_cltMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_goiOrderByRelevanceInput = {
    fields: quote_calculations_goiOrderByRelevanceFieldEnum | quote_calculations_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type quote_calculations_goiCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_goiMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_spaOrderByRelevanceInput = {
    fields: quote_calculations_spaOrderByRelevanceFieldEnum | quote_calculations_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type quote_calculations_spaCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quote_calculations_spaMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_name?: SortOrder
    consultant_name?: SortOrder
    ages?: SortOrder
    accommodation?: SortOrder
    plan_type?: SortOrder
    square?: SortOrder
    is_odonto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type register_partners_autOrderByRelevanceInput = {
    fields: register_partners_autOrderByRelevanceFieldEnum | register_partners_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type register_partners_autCountOrderByAggregateInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obs?: SortOrder
  }

  export type register_partners_autMaxOrderByAggregateInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obs?: SortOrder
  }

  export type register_partners_autMinOrderByAggregateInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obs?: SortOrder
  }

  export type register_partners_spaOrderByRelevanceInput = {
    fields: register_partners_spaOrderByRelevanceFieldEnum | register_partners_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type register_partners_spaCountOrderByAggregateInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type register_partners_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type register_partners_spaMinOrderByAggregateInput = {
    id?: SortOrder
    complete_name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    birth_date?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Rh_numbersNullableScalarRelationFilter = {
    is?: rh_numbersWhereInput | null
    isNot?: rh_numbersWhereInput | null
  }

  export type rh_callsOrderByRelevanceInput = {
    fields: rh_callsOrderByRelevanceFieldEnum | rh_callsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rh_callsCountOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rhNumberId?: SortOrder
  }

  export type rh_callsMaxOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rhNumberId?: SortOrder
  }

  export type rh_callsMinOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rhNumberId?: SortOrder
  }

  export type Rh_callsListRelationFilter = {
    every?: rh_callsWhereInput
    some?: rh_callsWhereInput
    none?: rh_callsWhereInput
  }

  export type rh_callsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rh_numbersOrderByRelevanceInput = {
    fields: rh_numbersOrderByRelevanceFieldEnum | rh_numbersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rh_numbersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rh_numbersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rh_numbersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type seller_codesOrderByRelevanceInput = {
    fields: seller_codesOrderByRelevanceFieldEnum | seller_codesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type seller_codesCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    square?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type seller_codesAvgOrderByAggregateInput = {
    code?: SortOrder
  }

  export type seller_codesMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    square?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type seller_codesMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    square?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type seller_codesSumOrderByAggregateInput = {
    code?: SortOrder
  }

  export type sessions_autOrderByRelevanceInput = {
    fields: sessions_autOrderByRelevanceFieldEnum | sessions_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessions_autCountOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_autAvgOrderByAggregateInput = {
    entrace_option?: SortOrder
  }

  export type sessions_autMaxOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_autMinOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_autSumOrderByAggregateInput = {
    entrace_option?: SortOrder
  }

  export type sessions_cltOrderByRelevanceInput = {
    fields: sessions_cltOrderByRelevanceFieldEnum | sessions_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessions_cltCountOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_cltAvgOrderByAggregateInput = {
    entrace_option?: SortOrder
  }

  export type sessions_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_cltMinOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_cltSumOrderByAggregateInput = {
    entrace_option?: SortOrder
  }

  export type sessions_goiOrderByRelevanceInput = {
    fields: sessions_goiOrderByRelevanceFieldEnum | sessions_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessions_goiCountOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_goiAvgOrderByAggregateInput = {
    entrace_option?: SortOrder
  }

  export type sessions_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_goiMinOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_goiSumOrderByAggregateInput = {
    entrace_option?: SortOrder
  }

  export type sessions_spaOrderByRelevanceInput = {
    fields: sessions_spaOrderByRelevanceFieldEnum | sessions_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessions_spaCountOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_spaAvgOrderByAggregateInput = {
    entrace_option?: SortOrder
  }

  export type sessions_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_spaMinOrderByAggregateInput = {
    id?: SortOrder
    entrace_option?: SortOrder
    is_finished?: SortOrder
    is_timeout?: SortOrder
    is_error?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessions_spaSumOrderByAggregateInput = {
    entrace_option?: SortOrder
  }

  export type supervisor_register_partnersOrderByRelevanceInput = {
    fields: supervisor_register_partnersOrderByRelevanceFieldEnum | supervisor_register_partnersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type supervisor_register_partnersCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supervisor_register_partnersMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type supervisor_register_partnersMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_autOrderByRelevanceInput = {
    fields: testers_autOrderByRelevanceFieldEnum | testers_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testers_autCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_autMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_autMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_cltOrderByRelevanceInput = {
    fields: testers_cltOrderByRelevanceFieldEnum | testers_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testers_cltCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_cltMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_goiOrderByRelevanceInput = {
    fields: testers_goiOrderByRelevanceFieldEnum | testers_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testers_goiCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_goiMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_spaOrderByRelevanceInput = {
    fields: testers_spaOrderByRelevanceFieldEnum | testers_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testers_spaCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type testers_spaMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_autOrderByRelevanceInput = {
    fields: threads_autOrderByRelevanceFieldEnum | threads_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type threads_autCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_autMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_autMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_cltOrderByRelevanceInput = {
    fields: threads_cltOrderByRelevanceFieldEnum | threads_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type threads_cltCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_cltMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_goiOrderByRelevanceInput = {
    fields: threads_goiOrderByRelevanceFieldEnum | threads_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type threads_goiCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_goiMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_spaOrderByRelevanceInput = {
    fields: threads_spaOrderByRelevanceFieldEnum | threads_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type threads_spaCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type threads_spaMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    thread?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_autOrderByRelevanceInput = {
    fields: tokens_generated_autOrderByRelevanceFieldEnum | tokens_generated_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tokens_generated_autCountOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_autMaxOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_autMinOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_cltOrderByRelevanceInput = {
    fields: tokens_generated_cltOrderByRelevanceFieldEnum | tokens_generated_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tokens_generated_cltCountOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_cltMinOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_goiOrderByRelevanceInput = {
    fields: tokens_generated_goiOrderByRelevanceFieldEnum | tokens_generated_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tokens_generated_goiCountOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_goiMinOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_spaOrderByRelevanceInput = {
    fields: tokens_generated_spaOrderByRelevanceFieldEnum | tokens_generated_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tokens_generated_spaCountOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokens_generated_spaMinOrderByAggregateInput = {
    id?: SortOrder
    create_token_id?: SortOrder
    user_id?: SortOrder
    is_expired?: SortOrder
    is_error?: SortOrder
    is_confirmed?: SortOrder
    is_closed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_autOrderByRelevanceInput = {
    fields: trainings_links_autOrderByRelevanceFieldEnum | trainings_links_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type trainings_links_autCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_autMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_autMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_cltOrderByRelevanceInput = {
    fields: trainings_links_cltOrderByRelevanceFieldEnum | trainings_links_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type trainings_links_cltCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_cltMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_goiOrderByRelevanceInput = {
    fields: trainings_links_goiOrderByRelevanceFieldEnum | trainings_links_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type trainings_links_goiCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_goiMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_spaOrderByRelevanceInput = {
    fields: trainings_links_spaOrderByRelevanceFieldEnum | trainings_links_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type trainings_links_spaCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trainings_links_spaMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Budget_consults_autListRelationFilter = {
    every?: budget_consults_autWhereInput
    some?: budget_consults_autWhereInput
    none?: budget_consults_autWhereInput
  }

  export type Cpf_consults_autListRelationFilter = {
    every?: cpf_consults_autWhereInput
    some?: cpf_consults_autWhereInput
    none?: cpf_consults_autWhereInput
  }

  export type Quote_calculations_autListRelationFilter = {
    every?: quote_calculations_autWhereInput
    some?: quote_calculations_autWhereInput
    none?: quote_calculations_autWhereInput
  }

  export type Sessions_autListRelationFilter = {
    every?: sessions_autWhereInput
    some?: sessions_autWhereInput
    none?: sessions_autWhereInput
  }

  export type Threads_autListRelationFilter = {
    every?: threads_autWhereInput
    some?: threads_autWhereInput
    none?: threads_autWhereInput
  }

  export type Tokens_generated_autListRelationFilter = {
    every?: tokens_generated_autWhereInput
    some?: tokens_generated_autWhereInput
    none?: tokens_generated_autWhereInput
  }

  export type Trainings_links_autListRelationFilter = {
    every?: trainings_links_autWhereInput
    some?: trainings_links_autWhereInput
    none?: trainings_links_autWhereInput
  }

  export type budget_consults_autOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cpf_consults_autOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quote_calculations_autOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessions_autOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type threads_autOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tokens_generated_autOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type trainings_links_autOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type users_autOrderByRelevanceInput = {
    fields: users_autOrderByRelevanceFieldEnum | users_autOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type users_autCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_autAvgOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type users_autMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_autMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_autSumOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type Budget_consults_cltListRelationFilter = {
    every?: budget_consults_cltWhereInput
    some?: budget_consults_cltWhereInput
    none?: budget_consults_cltWhereInput
  }

  export type Cpf_consults_cltListRelationFilter = {
    every?: cpf_consults_cltWhereInput
    some?: cpf_consults_cltWhereInput
    none?: cpf_consults_cltWhereInput
  }

  export type Quote_calculations_cltListRelationFilter = {
    every?: quote_calculations_cltWhereInput
    some?: quote_calculations_cltWhereInput
    none?: quote_calculations_cltWhereInput
  }

  export type Sessions_cltListRelationFilter = {
    every?: sessions_cltWhereInput
    some?: sessions_cltWhereInput
    none?: sessions_cltWhereInput
  }

  export type Threads_cltListRelationFilter = {
    every?: threads_cltWhereInput
    some?: threads_cltWhereInput
    none?: threads_cltWhereInput
  }

  export type Tokens_generated_cltListRelationFilter = {
    every?: tokens_generated_cltWhereInput
    some?: tokens_generated_cltWhereInput
    none?: tokens_generated_cltWhereInput
  }

  export type Trainings_links_cltListRelationFilter = {
    every?: trainings_links_cltWhereInput
    some?: trainings_links_cltWhereInput
    none?: trainings_links_cltWhereInput
  }

  export type budget_consults_cltOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cpf_consults_cltOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quote_calculations_cltOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessions_cltOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type threads_cltOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tokens_generated_cltOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type trainings_links_cltOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type users_cltOrderByRelevanceInput = {
    fields: users_cltOrderByRelevanceFieldEnum | users_cltOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type users_cltCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_cltAvgOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type users_cltMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_cltMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_cltSumOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type Budget_consults_goiListRelationFilter = {
    every?: budget_consults_goiWhereInput
    some?: budget_consults_goiWhereInput
    none?: budget_consults_goiWhereInput
  }

  export type Cpf_consults_goiListRelationFilter = {
    every?: cpf_consults_goiWhereInput
    some?: cpf_consults_goiWhereInput
    none?: cpf_consults_goiWhereInput
  }

  export type Quote_calculations_goiListRelationFilter = {
    every?: quote_calculations_goiWhereInput
    some?: quote_calculations_goiWhereInput
    none?: quote_calculations_goiWhereInput
  }

  export type Sessions_goiListRelationFilter = {
    every?: sessions_goiWhereInput
    some?: sessions_goiWhereInput
    none?: sessions_goiWhereInput
  }

  export type Threads_goiListRelationFilter = {
    every?: threads_goiWhereInput
    some?: threads_goiWhereInput
    none?: threads_goiWhereInput
  }

  export type Tokens_generated_goiListRelationFilter = {
    every?: tokens_generated_goiWhereInput
    some?: tokens_generated_goiWhereInput
    none?: tokens_generated_goiWhereInput
  }

  export type Trainings_links_goiListRelationFilter = {
    every?: trainings_links_goiWhereInput
    some?: trainings_links_goiWhereInput
    none?: trainings_links_goiWhereInput
  }

  export type budget_consults_goiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cpf_consults_goiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quote_calculations_goiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessions_goiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type threads_goiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tokens_generated_goiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type trainings_links_goiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type users_goiOrderByRelevanceInput = {
    fields: users_goiOrderByRelevanceFieldEnum | users_goiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type users_goiCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_goiAvgOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type users_goiMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_goiMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_goiSumOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type Budget_consults_spaListRelationFilter = {
    every?: budget_consults_spaWhereInput
    some?: budget_consults_spaWhereInput
    none?: budget_consults_spaWhereInput
  }

  export type Cpf_consults_spaListRelationFilter = {
    every?: cpf_consults_spaWhereInput
    some?: cpf_consults_spaWhereInput
    none?: cpf_consults_spaWhereInput
  }

  export type Quote_calculations_spaListRelationFilter = {
    every?: quote_calculations_spaWhereInput
    some?: quote_calculations_spaWhereInput
    none?: quote_calculations_spaWhereInput
  }

  export type Sessions_spaListRelationFilter = {
    every?: sessions_spaWhereInput
    some?: sessions_spaWhereInput
    none?: sessions_spaWhereInput
  }

  export type Threads_spaListRelationFilter = {
    every?: threads_spaWhereInput
    some?: threads_spaWhereInput
    none?: threads_spaWhereInput
  }

  export type Tokens_generated_spaListRelationFilter = {
    every?: tokens_generated_spaWhereInput
    some?: tokens_generated_spaWhereInput
    none?: tokens_generated_spaWhereInput
  }

  export type Trainings_links_spaListRelationFilter = {
    every?: trainings_links_spaWhereInput
    some?: trainings_links_spaWhereInput
    none?: trainings_links_spaWhereInput
  }

  export type budget_consults_spaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cpf_consults_spaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quote_calculations_spaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessions_spaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type threads_spaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tokens_generated_spaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type trainings_links_spaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type users_spaOrderByRelevanceInput = {
    fields: users_spaOrderByRelevanceFieldEnum | users_spaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type users_spaCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_spaAvgOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type users_spaMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_spaMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    last_session_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type users_spaSumOrderByAggregateInput = {
    phone_number?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type callsCreateNestedManyWithoutAttendantInput = {
    create?: XOR<callsCreateWithoutAttendantInput, callsUncheckedCreateWithoutAttendantInput> | callsCreateWithoutAttendantInput[] | callsUncheckedCreateWithoutAttendantInput[]
    connectOrCreate?: callsCreateOrConnectWithoutAttendantInput | callsCreateOrConnectWithoutAttendantInput[]
    createMany?: callsCreateManyAttendantInputEnvelope
    connect?: callsWhereUniqueInput | callsWhereUniqueInput[]
  }

  export type callsUncheckedCreateNestedManyWithoutAttendantInput = {
    create?: XOR<callsCreateWithoutAttendantInput, callsUncheckedCreateWithoutAttendantInput> | callsCreateWithoutAttendantInput[] | callsUncheckedCreateWithoutAttendantInput[]
    connectOrCreate?: callsCreateOrConnectWithoutAttendantInput | callsCreateOrConnectWithoutAttendantInput[]
    createMany?: callsCreateManyAttendantInputEnvelope
    connect?: callsWhereUniqueInput | callsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type callsUpdateManyWithoutAttendantNestedInput = {
    create?: XOR<callsCreateWithoutAttendantInput, callsUncheckedCreateWithoutAttendantInput> | callsCreateWithoutAttendantInput[] | callsUncheckedCreateWithoutAttendantInput[]
    connectOrCreate?: callsCreateOrConnectWithoutAttendantInput | callsCreateOrConnectWithoutAttendantInput[]
    upsert?: callsUpsertWithWhereUniqueWithoutAttendantInput | callsUpsertWithWhereUniqueWithoutAttendantInput[]
    createMany?: callsCreateManyAttendantInputEnvelope
    set?: callsWhereUniqueInput | callsWhereUniqueInput[]
    disconnect?: callsWhereUniqueInput | callsWhereUniqueInput[]
    delete?: callsWhereUniqueInput | callsWhereUniqueInput[]
    connect?: callsWhereUniqueInput | callsWhereUniqueInput[]
    update?: callsUpdateWithWhereUniqueWithoutAttendantInput | callsUpdateWithWhereUniqueWithoutAttendantInput[]
    updateMany?: callsUpdateManyWithWhereWithoutAttendantInput | callsUpdateManyWithWhereWithoutAttendantInput[]
    deleteMany?: callsScalarWhereInput | callsScalarWhereInput[]
  }

  export type callsUncheckedUpdateManyWithoutAttendantNestedInput = {
    create?: XOR<callsCreateWithoutAttendantInput, callsUncheckedCreateWithoutAttendantInput> | callsCreateWithoutAttendantInput[] | callsUncheckedCreateWithoutAttendantInput[]
    connectOrCreate?: callsCreateOrConnectWithoutAttendantInput | callsCreateOrConnectWithoutAttendantInput[]
    upsert?: callsUpsertWithWhereUniqueWithoutAttendantInput | callsUpsertWithWhereUniqueWithoutAttendantInput[]
    createMany?: callsCreateManyAttendantInputEnvelope
    set?: callsWhereUniqueInput | callsWhereUniqueInput[]
    disconnect?: callsWhereUniqueInput | callsWhereUniqueInput[]
    delete?: callsWhereUniqueInput | callsWhereUniqueInput[]
    connect?: callsWhereUniqueInput | callsWhereUniqueInput[]
    update?: callsUpdateWithWhereUniqueWithoutAttendantInput | callsUpdateWithWhereUniqueWithoutAttendantInput[]
    updateMany?: callsUpdateManyWithWhereWithoutAttendantInput | callsUpdateManyWithWhereWithoutAttendantInput[]
    deleteMany?: callsScalarWhereInput | callsScalarWhereInput[]
  }

  export type attendantsCreateNestedOneWithoutAttendant_callsInput = {
    create?: XOR<attendantsCreateWithoutAttendant_callsInput, attendantsUncheckedCreateWithoutAttendant_callsInput>
    connectOrCreate?: attendantsCreateOrConnectWithoutAttendant_callsInput
    connect?: attendantsWhereUniqueInput
  }

  export type attendantsUpdateOneWithoutAttendant_callsNestedInput = {
    create?: XOR<attendantsCreateWithoutAttendant_callsInput, attendantsUncheckedCreateWithoutAttendant_callsInput>
    connectOrCreate?: attendantsCreateOrConnectWithoutAttendant_callsInput
    upsert?: attendantsUpsertWithoutAttendant_callsInput
    disconnect?: attendantsWhereInput | boolean
    delete?: attendantsWhereInput | boolean
    connect?: attendantsWhereUniqueInput
    update?: XOR<XOR<attendantsUpdateToOneWithWhereWithoutAttendant_callsInput, attendantsUpdateWithoutAttendant_callsInput>, attendantsUncheckedUpdateWithoutAttendant_callsInput>
  }

  export type attendant_callsCreateNestedManyWithoutAttendantsInput = {
    create?: XOR<attendant_callsCreateWithoutAttendantsInput, attendant_callsUncheckedCreateWithoutAttendantsInput> | attendant_callsCreateWithoutAttendantsInput[] | attendant_callsUncheckedCreateWithoutAttendantsInput[]
    connectOrCreate?: attendant_callsCreateOrConnectWithoutAttendantsInput | attendant_callsCreateOrConnectWithoutAttendantsInput[]
    createMany?: attendant_callsCreateManyAttendantsInputEnvelope
    connect?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
  }

  export type attendant_callsUncheckedCreateNestedManyWithoutAttendantsInput = {
    create?: XOR<attendant_callsCreateWithoutAttendantsInput, attendant_callsUncheckedCreateWithoutAttendantsInput> | attendant_callsCreateWithoutAttendantsInput[] | attendant_callsUncheckedCreateWithoutAttendantsInput[]
    connectOrCreate?: attendant_callsCreateOrConnectWithoutAttendantsInput | attendant_callsCreateOrConnectWithoutAttendantsInput[]
    createMany?: attendant_callsCreateManyAttendantsInputEnvelope
    connect?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
  }

  export type attendant_callsUpdateManyWithoutAttendantsNestedInput = {
    create?: XOR<attendant_callsCreateWithoutAttendantsInput, attendant_callsUncheckedCreateWithoutAttendantsInput> | attendant_callsCreateWithoutAttendantsInput[] | attendant_callsUncheckedCreateWithoutAttendantsInput[]
    connectOrCreate?: attendant_callsCreateOrConnectWithoutAttendantsInput | attendant_callsCreateOrConnectWithoutAttendantsInput[]
    upsert?: attendant_callsUpsertWithWhereUniqueWithoutAttendantsInput | attendant_callsUpsertWithWhereUniqueWithoutAttendantsInput[]
    createMany?: attendant_callsCreateManyAttendantsInputEnvelope
    set?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
    disconnect?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
    delete?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
    connect?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
    update?: attendant_callsUpdateWithWhereUniqueWithoutAttendantsInput | attendant_callsUpdateWithWhereUniqueWithoutAttendantsInput[]
    updateMany?: attendant_callsUpdateManyWithWhereWithoutAttendantsInput | attendant_callsUpdateManyWithWhereWithoutAttendantsInput[]
    deleteMany?: attendant_callsScalarWhereInput | attendant_callsScalarWhereInput[]
  }

  export type attendant_callsUncheckedUpdateManyWithoutAttendantsNestedInput = {
    create?: XOR<attendant_callsCreateWithoutAttendantsInput, attendant_callsUncheckedCreateWithoutAttendantsInput> | attendant_callsCreateWithoutAttendantsInput[] | attendant_callsUncheckedCreateWithoutAttendantsInput[]
    connectOrCreate?: attendant_callsCreateOrConnectWithoutAttendantsInput | attendant_callsCreateOrConnectWithoutAttendantsInput[]
    upsert?: attendant_callsUpsertWithWhereUniqueWithoutAttendantsInput | attendant_callsUpsertWithWhereUniqueWithoutAttendantsInput[]
    createMany?: attendant_callsCreateManyAttendantsInputEnvelope
    set?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
    disconnect?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
    delete?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
    connect?: attendant_callsWhereUniqueInput | attendant_callsWhereUniqueInput[]
    update?: attendant_callsUpdateWithWhereUniqueWithoutAttendantsInput | attendant_callsUpdateWithWhereUniqueWithoutAttendantsInput[]
    updateMany?: attendant_callsUpdateManyWithWhereWithoutAttendantsInput | attendant_callsUpdateManyWithWhereWithoutAttendantsInput[]
    deleteMany?: attendant_callsScalarWhereInput | attendant_callsScalarWhereInput[]
  }

  export type users_autCreateNestedOneWithoutBudget_consults_autInput = {
    create?: XOR<users_autCreateWithoutBudget_consults_autInput, users_autUncheckedCreateWithoutBudget_consults_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutBudget_consults_autInput
    connect?: users_autWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type users_autUpdateOneRequiredWithoutBudget_consults_autNestedInput = {
    create?: XOR<users_autCreateWithoutBudget_consults_autInput, users_autUncheckedCreateWithoutBudget_consults_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutBudget_consults_autInput
    upsert?: users_autUpsertWithoutBudget_consults_autInput
    connect?: users_autWhereUniqueInput
    update?: XOR<XOR<users_autUpdateToOneWithWhereWithoutBudget_consults_autInput, users_autUpdateWithoutBudget_consults_autInput>, users_autUncheckedUpdateWithoutBudget_consults_autInput>
  }

  export type users_cltCreateNestedOneWithoutBudget_consults_cltInput = {
    create?: XOR<users_cltCreateWithoutBudget_consults_cltInput, users_cltUncheckedCreateWithoutBudget_consults_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutBudget_consults_cltInput
    connect?: users_cltWhereUniqueInput
  }

  export type users_cltUpdateOneRequiredWithoutBudget_consults_cltNestedInput = {
    create?: XOR<users_cltCreateWithoutBudget_consults_cltInput, users_cltUncheckedCreateWithoutBudget_consults_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutBudget_consults_cltInput
    upsert?: users_cltUpsertWithoutBudget_consults_cltInput
    connect?: users_cltWhereUniqueInput
    update?: XOR<XOR<users_cltUpdateToOneWithWhereWithoutBudget_consults_cltInput, users_cltUpdateWithoutBudget_consults_cltInput>, users_cltUncheckedUpdateWithoutBudget_consults_cltInput>
  }

  export type users_goiCreateNestedOneWithoutBudget_consults_goiInput = {
    create?: XOR<users_goiCreateWithoutBudget_consults_goiInput, users_goiUncheckedCreateWithoutBudget_consults_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutBudget_consults_goiInput
    connect?: users_goiWhereUniqueInput
  }

  export type users_goiUpdateOneRequiredWithoutBudget_consults_goiNestedInput = {
    create?: XOR<users_goiCreateWithoutBudget_consults_goiInput, users_goiUncheckedCreateWithoutBudget_consults_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutBudget_consults_goiInput
    upsert?: users_goiUpsertWithoutBudget_consults_goiInput
    connect?: users_goiWhereUniqueInput
    update?: XOR<XOR<users_goiUpdateToOneWithWhereWithoutBudget_consults_goiInput, users_goiUpdateWithoutBudget_consults_goiInput>, users_goiUncheckedUpdateWithoutBudget_consults_goiInput>
  }

  export type users_spaCreateNestedOneWithoutBudget_consults_spaInput = {
    create?: XOR<users_spaCreateWithoutBudget_consults_spaInput, users_spaUncheckedCreateWithoutBudget_consults_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutBudget_consults_spaInput
    connect?: users_spaWhereUniqueInput
  }

  export type users_spaUpdateOneRequiredWithoutBudget_consults_spaNestedInput = {
    create?: XOR<users_spaCreateWithoutBudget_consults_spaInput, users_spaUncheckedCreateWithoutBudget_consults_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutBudget_consults_spaInput
    upsert?: users_spaUpsertWithoutBudget_consults_spaInput
    connect?: users_spaWhereUniqueInput
    update?: XOR<XOR<users_spaUpdateToOneWithWhereWithoutBudget_consults_spaInput, users_spaUpdateWithoutBudget_consults_spaInput>, users_spaUncheckedUpdateWithoutBudget_consults_spaInput>
  }

  export type attendantCreateNestedOneWithoutCallsInput = {
    create?: XOR<attendantCreateWithoutCallsInput, attendantUncheckedCreateWithoutCallsInput>
    connectOrCreate?: attendantCreateOrConnectWithoutCallsInput
    connect?: attendantWhereUniqueInput
  }

  export type attendantUpdateOneWithoutCallsNestedInput = {
    create?: XOR<attendantCreateWithoutCallsInput, attendantUncheckedCreateWithoutCallsInput>
    connectOrCreate?: attendantCreateOrConnectWithoutCallsInput
    upsert?: attendantUpsertWithoutCallsInput
    disconnect?: attendantWhereInput | boolean
    delete?: attendantWhereInput | boolean
    connect?: attendantWhereUniqueInput
    update?: XOR<XOR<attendantUpdateToOneWithWhereWithoutCallsInput, attendantUpdateWithoutCallsInput>, attendantUncheckedUpdateWithoutCallsInput>
  }

  export type users_autCreateNestedOneWithoutCpf_consults_autInput = {
    create?: XOR<users_autCreateWithoutCpf_consults_autInput, users_autUncheckedCreateWithoutCpf_consults_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutCpf_consults_autInput
    connect?: users_autWhereUniqueInput
  }

  export type users_autUpdateOneRequiredWithoutCpf_consults_autNestedInput = {
    create?: XOR<users_autCreateWithoutCpf_consults_autInput, users_autUncheckedCreateWithoutCpf_consults_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutCpf_consults_autInput
    upsert?: users_autUpsertWithoutCpf_consults_autInput
    connect?: users_autWhereUniqueInput
    update?: XOR<XOR<users_autUpdateToOneWithWhereWithoutCpf_consults_autInput, users_autUpdateWithoutCpf_consults_autInput>, users_autUncheckedUpdateWithoutCpf_consults_autInput>
  }

  export type users_cltCreateNestedOneWithoutCpf_consults_cltInput = {
    create?: XOR<users_cltCreateWithoutCpf_consults_cltInput, users_cltUncheckedCreateWithoutCpf_consults_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutCpf_consults_cltInput
    connect?: users_cltWhereUniqueInput
  }

  export type users_cltUpdateOneRequiredWithoutCpf_consults_cltNestedInput = {
    create?: XOR<users_cltCreateWithoutCpf_consults_cltInput, users_cltUncheckedCreateWithoutCpf_consults_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutCpf_consults_cltInput
    upsert?: users_cltUpsertWithoutCpf_consults_cltInput
    connect?: users_cltWhereUniqueInput
    update?: XOR<XOR<users_cltUpdateToOneWithWhereWithoutCpf_consults_cltInput, users_cltUpdateWithoutCpf_consults_cltInput>, users_cltUncheckedUpdateWithoutCpf_consults_cltInput>
  }

  export type users_goiCreateNestedOneWithoutCpf_consults_goiInput = {
    create?: XOR<users_goiCreateWithoutCpf_consults_goiInput, users_goiUncheckedCreateWithoutCpf_consults_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutCpf_consults_goiInput
    connect?: users_goiWhereUniqueInput
  }

  export type users_goiUpdateOneRequiredWithoutCpf_consults_goiNestedInput = {
    create?: XOR<users_goiCreateWithoutCpf_consults_goiInput, users_goiUncheckedCreateWithoutCpf_consults_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutCpf_consults_goiInput
    upsert?: users_goiUpsertWithoutCpf_consults_goiInput
    connect?: users_goiWhereUniqueInput
    update?: XOR<XOR<users_goiUpdateToOneWithWhereWithoutCpf_consults_goiInput, users_goiUpdateWithoutCpf_consults_goiInput>, users_goiUncheckedUpdateWithoutCpf_consults_goiInput>
  }

  export type users_spaCreateNestedOneWithoutCpf_consults_spaInput = {
    create?: XOR<users_spaCreateWithoutCpf_consults_spaInput, users_spaUncheckedCreateWithoutCpf_consults_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutCpf_consults_spaInput
    connect?: users_spaWhereUniqueInput
  }

  export type users_spaUpdateOneRequiredWithoutCpf_consults_spaNestedInput = {
    create?: XOR<users_spaCreateWithoutCpf_consults_spaInput, users_spaUncheckedCreateWithoutCpf_consults_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutCpf_consults_spaInput
    upsert?: users_spaUpsertWithoutCpf_consults_spaInput
    connect?: users_spaWhereUniqueInput
    update?: XOR<XOR<users_spaUpdateToOneWithWhereWithoutCpf_consults_spaInput, users_spaUpdateWithoutCpf_consults_spaInput>, users_spaUncheckedUpdateWithoutCpf_consults_spaInput>
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type users_autCreateNestedOneWithoutQuote_calculations_autInput = {
    create?: XOR<users_autCreateWithoutQuote_calculations_autInput, users_autUncheckedCreateWithoutQuote_calculations_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutQuote_calculations_autInput
    connect?: users_autWhereUniqueInput
  }

  export type users_autUpdateOneRequiredWithoutQuote_calculations_autNestedInput = {
    create?: XOR<users_autCreateWithoutQuote_calculations_autInput, users_autUncheckedCreateWithoutQuote_calculations_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutQuote_calculations_autInput
    upsert?: users_autUpsertWithoutQuote_calculations_autInput
    connect?: users_autWhereUniqueInput
    update?: XOR<XOR<users_autUpdateToOneWithWhereWithoutQuote_calculations_autInput, users_autUpdateWithoutQuote_calculations_autInput>, users_autUncheckedUpdateWithoutQuote_calculations_autInput>
  }

  export type users_cltCreateNestedOneWithoutQuote_calculations_cltInput = {
    create?: XOR<users_cltCreateWithoutQuote_calculations_cltInput, users_cltUncheckedCreateWithoutQuote_calculations_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutQuote_calculations_cltInput
    connect?: users_cltWhereUniqueInput
  }

  export type users_cltUpdateOneRequiredWithoutQuote_calculations_cltNestedInput = {
    create?: XOR<users_cltCreateWithoutQuote_calculations_cltInput, users_cltUncheckedCreateWithoutQuote_calculations_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutQuote_calculations_cltInput
    upsert?: users_cltUpsertWithoutQuote_calculations_cltInput
    connect?: users_cltWhereUniqueInput
    update?: XOR<XOR<users_cltUpdateToOneWithWhereWithoutQuote_calculations_cltInput, users_cltUpdateWithoutQuote_calculations_cltInput>, users_cltUncheckedUpdateWithoutQuote_calculations_cltInput>
  }

  export type users_goiCreateNestedOneWithoutQuote_calculations_goiInput = {
    create?: XOR<users_goiCreateWithoutQuote_calculations_goiInput, users_goiUncheckedCreateWithoutQuote_calculations_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutQuote_calculations_goiInput
    connect?: users_goiWhereUniqueInput
  }

  export type users_goiUpdateOneRequiredWithoutQuote_calculations_goiNestedInput = {
    create?: XOR<users_goiCreateWithoutQuote_calculations_goiInput, users_goiUncheckedCreateWithoutQuote_calculations_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutQuote_calculations_goiInput
    upsert?: users_goiUpsertWithoutQuote_calculations_goiInput
    connect?: users_goiWhereUniqueInput
    update?: XOR<XOR<users_goiUpdateToOneWithWhereWithoutQuote_calculations_goiInput, users_goiUpdateWithoutQuote_calculations_goiInput>, users_goiUncheckedUpdateWithoutQuote_calculations_goiInput>
  }

  export type users_spaCreateNestedOneWithoutQuote_calculations_spaInput = {
    create?: XOR<users_spaCreateWithoutQuote_calculations_spaInput, users_spaUncheckedCreateWithoutQuote_calculations_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutQuote_calculations_spaInput
    connect?: users_spaWhereUniqueInput
  }

  export type users_spaUpdateOneRequiredWithoutQuote_calculations_spaNestedInput = {
    create?: XOR<users_spaCreateWithoutQuote_calculations_spaInput, users_spaUncheckedCreateWithoutQuote_calculations_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutQuote_calculations_spaInput
    upsert?: users_spaUpsertWithoutQuote_calculations_spaInput
    connect?: users_spaWhereUniqueInput
    update?: XOR<XOR<users_spaUpdateToOneWithWhereWithoutQuote_calculations_spaInput, users_spaUpdateWithoutQuote_calculations_spaInput>, users_spaUncheckedUpdateWithoutQuote_calculations_spaInput>
  }

  export type rh_numbersCreateNestedOneWithoutRh_callsInput = {
    create?: XOR<rh_numbersCreateWithoutRh_callsInput, rh_numbersUncheckedCreateWithoutRh_callsInput>
    connectOrCreate?: rh_numbersCreateOrConnectWithoutRh_callsInput
    connect?: rh_numbersWhereUniqueInput
  }

  export type rh_numbersUpdateOneWithoutRh_callsNestedInput = {
    create?: XOR<rh_numbersCreateWithoutRh_callsInput, rh_numbersUncheckedCreateWithoutRh_callsInput>
    connectOrCreate?: rh_numbersCreateOrConnectWithoutRh_callsInput
    upsert?: rh_numbersUpsertWithoutRh_callsInput
    disconnect?: rh_numbersWhereInput | boolean
    delete?: rh_numbersWhereInput | boolean
    connect?: rh_numbersWhereUniqueInput
    update?: XOR<XOR<rh_numbersUpdateToOneWithWhereWithoutRh_callsInput, rh_numbersUpdateWithoutRh_callsInput>, rh_numbersUncheckedUpdateWithoutRh_callsInput>
  }

  export type rh_callsCreateNestedManyWithoutRh_numbersInput = {
    create?: XOR<rh_callsCreateWithoutRh_numbersInput, rh_callsUncheckedCreateWithoutRh_numbersInput> | rh_callsCreateWithoutRh_numbersInput[] | rh_callsUncheckedCreateWithoutRh_numbersInput[]
    connectOrCreate?: rh_callsCreateOrConnectWithoutRh_numbersInput | rh_callsCreateOrConnectWithoutRh_numbersInput[]
    createMany?: rh_callsCreateManyRh_numbersInputEnvelope
    connect?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
  }

  export type rh_callsUncheckedCreateNestedManyWithoutRh_numbersInput = {
    create?: XOR<rh_callsCreateWithoutRh_numbersInput, rh_callsUncheckedCreateWithoutRh_numbersInput> | rh_callsCreateWithoutRh_numbersInput[] | rh_callsUncheckedCreateWithoutRh_numbersInput[]
    connectOrCreate?: rh_callsCreateOrConnectWithoutRh_numbersInput | rh_callsCreateOrConnectWithoutRh_numbersInput[]
    createMany?: rh_callsCreateManyRh_numbersInputEnvelope
    connect?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
  }

  export type rh_callsUpdateManyWithoutRh_numbersNestedInput = {
    create?: XOR<rh_callsCreateWithoutRh_numbersInput, rh_callsUncheckedCreateWithoutRh_numbersInput> | rh_callsCreateWithoutRh_numbersInput[] | rh_callsUncheckedCreateWithoutRh_numbersInput[]
    connectOrCreate?: rh_callsCreateOrConnectWithoutRh_numbersInput | rh_callsCreateOrConnectWithoutRh_numbersInput[]
    upsert?: rh_callsUpsertWithWhereUniqueWithoutRh_numbersInput | rh_callsUpsertWithWhereUniqueWithoutRh_numbersInput[]
    createMany?: rh_callsCreateManyRh_numbersInputEnvelope
    set?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
    disconnect?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
    delete?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
    connect?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
    update?: rh_callsUpdateWithWhereUniqueWithoutRh_numbersInput | rh_callsUpdateWithWhereUniqueWithoutRh_numbersInput[]
    updateMany?: rh_callsUpdateManyWithWhereWithoutRh_numbersInput | rh_callsUpdateManyWithWhereWithoutRh_numbersInput[]
    deleteMany?: rh_callsScalarWhereInput | rh_callsScalarWhereInput[]
  }

  export type rh_callsUncheckedUpdateManyWithoutRh_numbersNestedInput = {
    create?: XOR<rh_callsCreateWithoutRh_numbersInput, rh_callsUncheckedCreateWithoutRh_numbersInput> | rh_callsCreateWithoutRh_numbersInput[] | rh_callsUncheckedCreateWithoutRh_numbersInput[]
    connectOrCreate?: rh_callsCreateOrConnectWithoutRh_numbersInput | rh_callsCreateOrConnectWithoutRh_numbersInput[]
    upsert?: rh_callsUpsertWithWhereUniqueWithoutRh_numbersInput | rh_callsUpsertWithWhereUniqueWithoutRh_numbersInput[]
    createMany?: rh_callsCreateManyRh_numbersInputEnvelope
    set?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
    disconnect?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
    delete?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
    connect?: rh_callsWhereUniqueInput | rh_callsWhereUniqueInput[]
    update?: rh_callsUpdateWithWhereUniqueWithoutRh_numbersInput | rh_callsUpdateWithWhereUniqueWithoutRh_numbersInput[]
    updateMany?: rh_callsUpdateManyWithWhereWithoutRh_numbersInput | rh_callsUpdateManyWithWhereWithoutRh_numbersInput[]
    deleteMany?: rh_callsScalarWhereInput | rh_callsScalarWhereInput[]
  }

  export type users_autCreateNestedOneWithoutSessions_autInput = {
    create?: XOR<users_autCreateWithoutSessions_autInput, users_autUncheckedCreateWithoutSessions_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutSessions_autInput
    connect?: users_autWhereUniqueInput
  }

  export type users_autUpdateOneRequiredWithoutSessions_autNestedInput = {
    create?: XOR<users_autCreateWithoutSessions_autInput, users_autUncheckedCreateWithoutSessions_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutSessions_autInput
    upsert?: users_autUpsertWithoutSessions_autInput
    connect?: users_autWhereUniqueInput
    update?: XOR<XOR<users_autUpdateToOneWithWhereWithoutSessions_autInput, users_autUpdateWithoutSessions_autInput>, users_autUncheckedUpdateWithoutSessions_autInput>
  }

  export type users_cltCreateNestedOneWithoutSessions_cltInput = {
    create?: XOR<users_cltCreateWithoutSessions_cltInput, users_cltUncheckedCreateWithoutSessions_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutSessions_cltInput
    connect?: users_cltWhereUniqueInput
  }

  export type users_cltUpdateOneRequiredWithoutSessions_cltNestedInput = {
    create?: XOR<users_cltCreateWithoutSessions_cltInput, users_cltUncheckedCreateWithoutSessions_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutSessions_cltInput
    upsert?: users_cltUpsertWithoutSessions_cltInput
    connect?: users_cltWhereUniqueInput
    update?: XOR<XOR<users_cltUpdateToOneWithWhereWithoutSessions_cltInput, users_cltUpdateWithoutSessions_cltInput>, users_cltUncheckedUpdateWithoutSessions_cltInput>
  }

  export type users_goiCreateNestedOneWithoutSessions_goiInput = {
    create?: XOR<users_goiCreateWithoutSessions_goiInput, users_goiUncheckedCreateWithoutSessions_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutSessions_goiInput
    connect?: users_goiWhereUniqueInput
  }

  export type users_goiUpdateOneRequiredWithoutSessions_goiNestedInput = {
    create?: XOR<users_goiCreateWithoutSessions_goiInput, users_goiUncheckedCreateWithoutSessions_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutSessions_goiInput
    upsert?: users_goiUpsertWithoutSessions_goiInput
    connect?: users_goiWhereUniqueInput
    update?: XOR<XOR<users_goiUpdateToOneWithWhereWithoutSessions_goiInput, users_goiUpdateWithoutSessions_goiInput>, users_goiUncheckedUpdateWithoutSessions_goiInput>
  }

  export type users_spaCreateNestedOneWithoutSessions_spaInput = {
    create?: XOR<users_spaCreateWithoutSessions_spaInput, users_spaUncheckedCreateWithoutSessions_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutSessions_spaInput
    connect?: users_spaWhereUniqueInput
  }

  export type users_spaUpdateOneRequiredWithoutSessions_spaNestedInput = {
    create?: XOR<users_spaCreateWithoutSessions_spaInput, users_spaUncheckedCreateWithoutSessions_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutSessions_spaInput
    upsert?: users_spaUpsertWithoutSessions_spaInput
    connect?: users_spaWhereUniqueInput
    update?: XOR<XOR<users_spaUpdateToOneWithWhereWithoutSessions_spaInput, users_spaUpdateWithoutSessions_spaInput>, users_spaUncheckedUpdateWithoutSessions_spaInput>
  }

  export type users_autCreateNestedOneWithoutThreads_autInput = {
    create?: XOR<users_autCreateWithoutThreads_autInput, users_autUncheckedCreateWithoutThreads_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutThreads_autInput
    connect?: users_autWhereUniqueInput
  }

  export type users_autUpdateOneRequiredWithoutThreads_autNestedInput = {
    create?: XOR<users_autCreateWithoutThreads_autInput, users_autUncheckedCreateWithoutThreads_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutThreads_autInput
    upsert?: users_autUpsertWithoutThreads_autInput
    connect?: users_autWhereUniqueInput
    update?: XOR<XOR<users_autUpdateToOneWithWhereWithoutThreads_autInput, users_autUpdateWithoutThreads_autInput>, users_autUncheckedUpdateWithoutThreads_autInput>
  }

  export type users_cltCreateNestedOneWithoutThreads_cltInput = {
    create?: XOR<users_cltCreateWithoutThreads_cltInput, users_cltUncheckedCreateWithoutThreads_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutThreads_cltInput
    connect?: users_cltWhereUniqueInput
  }

  export type users_cltUpdateOneRequiredWithoutThreads_cltNestedInput = {
    create?: XOR<users_cltCreateWithoutThreads_cltInput, users_cltUncheckedCreateWithoutThreads_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutThreads_cltInput
    upsert?: users_cltUpsertWithoutThreads_cltInput
    connect?: users_cltWhereUniqueInput
    update?: XOR<XOR<users_cltUpdateToOneWithWhereWithoutThreads_cltInput, users_cltUpdateWithoutThreads_cltInput>, users_cltUncheckedUpdateWithoutThreads_cltInput>
  }

  export type users_goiCreateNestedOneWithoutThreads_goiInput = {
    create?: XOR<users_goiCreateWithoutThreads_goiInput, users_goiUncheckedCreateWithoutThreads_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutThreads_goiInput
    connect?: users_goiWhereUniqueInput
  }

  export type users_goiUpdateOneRequiredWithoutThreads_goiNestedInput = {
    create?: XOR<users_goiCreateWithoutThreads_goiInput, users_goiUncheckedCreateWithoutThreads_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutThreads_goiInput
    upsert?: users_goiUpsertWithoutThreads_goiInput
    connect?: users_goiWhereUniqueInput
    update?: XOR<XOR<users_goiUpdateToOneWithWhereWithoutThreads_goiInput, users_goiUpdateWithoutThreads_goiInput>, users_goiUncheckedUpdateWithoutThreads_goiInput>
  }

  export type users_spaCreateNestedOneWithoutThreads_spaInput = {
    create?: XOR<users_spaCreateWithoutThreads_spaInput, users_spaUncheckedCreateWithoutThreads_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutThreads_spaInput
    connect?: users_spaWhereUniqueInput
  }

  export type users_spaUpdateOneRequiredWithoutThreads_spaNestedInput = {
    create?: XOR<users_spaCreateWithoutThreads_spaInput, users_spaUncheckedCreateWithoutThreads_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutThreads_spaInput
    upsert?: users_spaUpsertWithoutThreads_spaInput
    connect?: users_spaWhereUniqueInput
    update?: XOR<XOR<users_spaUpdateToOneWithWhereWithoutThreads_spaInput, users_spaUpdateWithoutThreads_spaInput>, users_spaUncheckedUpdateWithoutThreads_spaInput>
  }

  export type users_autCreateNestedOneWithoutTokens_generated_autInput = {
    create?: XOR<users_autCreateWithoutTokens_generated_autInput, users_autUncheckedCreateWithoutTokens_generated_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutTokens_generated_autInput
    connect?: users_autWhereUniqueInput
  }

  export type users_autUpdateOneRequiredWithoutTokens_generated_autNestedInput = {
    create?: XOR<users_autCreateWithoutTokens_generated_autInput, users_autUncheckedCreateWithoutTokens_generated_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutTokens_generated_autInput
    upsert?: users_autUpsertWithoutTokens_generated_autInput
    connect?: users_autWhereUniqueInput
    update?: XOR<XOR<users_autUpdateToOneWithWhereWithoutTokens_generated_autInput, users_autUpdateWithoutTokens_generated_autInput>, users_autUncheckedUpdateWithoutTokens_generated_autInput>
  }

  export type users_cltCreateNestedOneWithoutTokens_generated_cltInput = {
    create?: XOR<users_cltCreateWithoutTokens_generated_cltInput, users_cltUncheckedCreateWithoutTokens_generated_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutTokens_generated_cltInput
    connect?: users_cltWhereUniqueInput
  }

  export type users_cltUpdateOneRequiredWithoutTokens_generated_cltNestedInput = {
    create?: XOR<users_cltCreateWithoutTokens_generated_cltInput, users_cltUncheckedCreateWithoutTokens_generated_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutTokens_generated_cltInput
    upsert?: users_cltUpsertWithoutTokens_generated_cltInput
    connect?: users_cltWhereUniqueInput
    update?: XOR<XOR<users_cltUpdateToOneWithWhereWithoutTokens_generated_cltInput, users_cltUpdateWithoutTokens_generated_cltInput>, users_cltUncheckedUpdateWithoutTokens_generated_cltInput>
  }

  export type users_goiCreateNestedOneWithoutTokens_generated_goiInput = {
    create?: XOR<users_goiCreateWithoutTokens_generated_goiInput, users_goiUncheckedCreateWithoutTokens_generated_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutTokens_generated_goiInput
    connect?: users_goiWhereUniqueInput
  }

  export type users_goiUpdateOneRequiredWithoutTokens_generated_goiNestedInput = {
    create?: XOR<users_goiCreateWithoutTokens_generated_goiInput, users_goiUncheckedCreateWithoutTokens_generated_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutTokens_generated_goiInput
    upsert?: users_goiUpsertWithoutTokens_generated_goiInput
    connect?: users_goiWhereUniqueInput
    update?: XOR<XOR<users_goiUpdateToOneWithWhereWithoutTokens_generated_goiInput, users_goiUpdateWithoutTokens_generated_goiInput>, users_goiUncheckedUpdateWithoutTokens_generated_goiInput>
  }

  export type users_spaCreateNestedOneWithoutTokens_generated_spaInput = {
    create?: XOR<users_spaCreateWithoutTokens_generated_spaInput, users_spaUncheckedCreateWithoutTokens_generated_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutTokens_generated_spaInput
    connect?: users_spaWhereUniqueInput
  }

  export type users_spaUpdateOneRequiredWithoutTokens_generated_spaNestedInput = {
    create?: XOR<users_spaCreateWithoutTokens_generated_spaInput, users_spaUncheckedCreateWithoutTokens_generated_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutTokens_generated_spaInput
    upsert?: users_spaUpsertWithoutTokens_generated_spaInput
    connect?: users_spaWhereUniqueInput
    update?: XOR<XOR<users_spaUpdateToOneWithWhereWithoutTokens_generated_spaInput, users_spaUpdateWithoutTokens_generated_spaInput>, users_spaUncheckedUpdateWithoutTokens_generated_spaInput>
  }

  export type users_autCreateNestedOneWithoutTrainings_links_autInput = {
    create?: XOR<users_autCreateWithoutTrainings_links_autInput, users_autUncheckedCreateWithoutTrainings_links_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutTrainings_links_autInput
    connect?: users_autWhereUniqueInput
  }

  export type users_autUpdateOneRequiredWithoutTrainings_links_autNestedInput = {
    create?: XOR<users_autCreateWithoutTrainings_links_autInput, users_autUncheckedCreateWithoutTrainings_links_autInput>
    connectOrCreate?: users_autCreateOrConnectWithoutTrainings_links_autInput
    upsert?: users_autUpsertWithoutTrainings_links_autInput
    connect?: users_autWhereUniqueInput
    update?: XOR<XOR<users_autUpdateToOneWithWhereWithoutTrainings_links_autInput, users_autUpdateWithoutTrainings_links_autInput>, users_autUncheckedUpdateWithoutTrainings_links_autInput>
  }

  export type users_cltCreateNestedOneWithoutTrainings_links_cltInput = {
    create?: XOR<users_cltCreateWithoutTrainings_links_cltInput, users_cltUncheckedCreateWithoutTrainings_links_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutTrainings_links_cltInput
    connect?: users_cltWhereUniqueInput
  }

  export type users_cltUpdateOneRequiredWithoutTrainings_links_cltNestedInput = {
    create?: XOR<users_cltCreateWithoutTrainings_links_cltInput, users_cltUncheckedCreateWithoutTrainings_links_cltInput>
    connectOrCreate?: users_cltCreateOrConnectWithoutTrainings_links_cltInput
    upsert?: users_cltUpsertWithoutTrainings_links_cltInput
    connect?: users_cltWhereUniqueInput
    update?: XOR<XOR<users_cltUpdateToOneWithWhereWithoutTrainings_links_cltInput, users_cltUpdateWithoutTrainings_links_cltInput>, users_cltUncheckedUpdateWithoutTrainings_links_cltInput>
  }

  export type users_goiCreateNestedOneWithoutTrainings_links_goiInput = {
    create?: XOR<users_goiCreateWithoutTrainings_links_goiInput, users_goiUncheckedCreateWithoutTrainings_links_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutTrainings_links_goiInput
    connect?: users_goiWhereUniqueInput
  }

  export type users_goiUpdateOneRequiredWithoutTrainings_links_goiNestedInput = {
    create?: XOR<users_goiCreateWithoutTrainings_links_goiInput, users_goiUncheckedCreateWithoutTrainings_links_goiInput>
    connectOrCreate?: users_goiCreateOrConnectWithoutTrainings_links_goiInput
    upsert?: users_goiUpsertWithoutTrainings_links_goiInput
    connect?: users_goiWhereUniqueInput
    update?: XOR<XOR<users_goiUpdateToOneWithWhereWithoutTrainings_links_goiInput, users_goiUpdateWithoutTrainings_links_goiInput>, users_goiUncheckedUpdateWithoutTrainings_links_goiInput>
  }

  export type users_spaCreateNestedOneWithoutTrainings_links_spaInput = {
    create?: XOR<users_spaCreateWithoutTrainings_links_spaInput, users_spaUncheckedCreateWithoutTrainings_links_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutTrainings_links_spaInput
    connect?: users_spaWhereUniqueInput
  }

  export type users_spaUpdateOneRequiredWithoutTrainings_links_spaNestedInput = {
    create?: XOR<users_spaCreateWithoutTrainings_links_spaInput, users_spaUncheckedCreateWithoutTrainings_links_spaInput>
    connectOrCreate?: users_spaCreateOrConnectWithoutTrainings_links_spaInput
    upsert?: users_spaUpsertWithoutTrainings_links_spaInput
    connect?: users_spaWhereUniqueInput
    update?: XOR<XOR<users_spaUpdateToOneWithWhereWithoutTrainings_links_spaInput, users_spaUpdateWithoutTrainings_links_spaInput>, users_spaUncheckedUpdateWithoutTrainings_links_spaInput>
  }

  export type budget_consults_autCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<budget_consults_autCreateWithoutUsers_autInput, budget_consults_autUncheckedCreateWithoutUsers_autInput> | budget_consults_autCreateWithoutUsers_autInput[] | budget_consults_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: budget_consults_autCreateOrConnectWithoutUsers_autInput | budget_consults_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: budget_consults_autCreateManyUsers_autInputEnvelope
    connect?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
  }

  export type cpf_consults_autCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<cpf_consults_autCreateWithoutUsers_autInput, cpf_consults_autUncheckedCreateWithoutUsers_autInput> | cpf_consults_autCreateWithoutUsers_autInput[] | cpf_consults_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: cpf_consults_autCreateOrConnectWithoutUsers_autInput | cpf_consults_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: cpf_consults_autCreateManyUsers_autInputEnvelope
    connect?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
  }

  export type quote_calculations_autCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<quote_calculations_autCreateWithoutUsers_autInput, quote_calculations_autUncheckedCreateWithoutUsers_autInput> | quote_calculations_autCreateWithoutUsers_autInput[] | quote_calculations_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: quote_calculations_autCreateOrConnectWithoutUsers_autInput | quote_calculations_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: quote_calculations_autCreateManyUsers_autInputEnvelope
    connect?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
  }

  export type sessions_autCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<sessions_autCreateWithoutUsers_autInput, sessions_autUncheckedCreateWithoutUsers_autInput> | sessions_autCreateWithoutUsers_autInput[] | sessions_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: sessions_autCreateOrConnectWithoutUsers_autInput | sessions_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: sessions_autCreateManyUsers_autInputEnvelope
    connect?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
  }

  export type threads_autCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<threads_autCreateWithoutUsers_autInput, threads_autUncheckedCreateWithoutUsers_autInput> | threads_autCreateWithoutUsers_autInput[] | threads_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: threads_autCreateOrConnectWithoutUsers_autInput | threads_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: threads_autCreateManyUsers_autInputEnvelope
    connect?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
  }

  export type tokens_generated_autCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<tokens_generated_autCreateWithoutUsers_autInput, tokens_generated_autUncheckedCreateWithoutUsers_autInput> | tokens_generated_autCreateWithoutUsers_autInput[] | tokens_generated_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: tokens_generated_autCreateOrConnectWithoutUsers_autInput | tokens_generated_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: tokens_generated_autCreateManyUsers_autInputEnvelope
    connect?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
  }

  export type trainings_links_autCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<trainings_links_autCreateWithoutUsers_autInput, trainings_links_autUncheckedCreateWithoutUsers_autInput> | trainings_links_autCreateWithoutUsers_autInput[] | trainings_links_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: trainings_links_autCreateOrConnectWithoutUsers_autInput | trainings_links_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: trainings_links_autCreateManyUsers_autInputEnvelope
    connect?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
  }

  export type budget_consults_autUncheckedCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<budget_consults_autCreateWithoutUsers_autInput, budget_consults_autUncheckedCreateWithoutUsers_autInput> | budget_consults_autCreateWithoutUsers_autInput[] | budget_consults_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: budget_consults_autCreateOrConnectWithoutUsers_autInput | budget_consults_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: budget_consults_autCreateManyUsers_autInputEnvelope
    connect?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
  }

  export type cpf_consults_autUncheckedCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<cpf_consults_autCreateWithoutUsers_autInput, cpf_consults_autUncheckedCreateWithoutUsers_autInput> | cpf_consults_autCreateWithoutUsers_autInput[] | cpf_consults_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: cpf_consults_autCreateOrConnectWithoutUsers_autInput | cpf_consults_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: cpf_consults_autCreateManyUsers_autInputEnvelope
    connect?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
  }

  export type quote_calculations_autUncheckedCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<quote_calculations_autCreateWithoutUsers_autInput, quote_calculations_autUncheckedCreateWithoutUsers_autInput> | quote_calculations_autCreateWithoutUsers_autInput[] | quote_calculations_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: quote_calculations_autCreateOrConnectWithoutUsers_autInput | quote_calculations_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: quote_calculations_autCreateManyUsers_autInputEnvelope
    connect?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
  }

  export type sessions_autUncheckedCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<sessions_autCreateWithoutUsers_autInput, sessions_autUncheckedCreateWithoutUsers_autInput> | sessions_autCreateWithoutUsers_autInput[] | sessions_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: sessions_autCreateOrConnectWithoutUsers_autInput | sessions_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: sessions_autCreateManyUsers_autInputEnvelope
    connect?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
  }

  export type threads_autUncheckedCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<threads_autCreateWithoutUsers_autInput, threads_autUncheckedCreateWithoutUsers_autInput> | threads_autCreateWithoutUsers_autInput[] | threads_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: threads_autCreateOrConnectWithoutUsers_autInput | threads_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: threads_autCreateManyUsers_autInputEnvelope
    connect?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
  }

  export type tokens_generated_autUncheckedCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<tokens_generated_autCreateWithoutUsers_autInput, tokens_generated_autUncheckedCreateWithoutUsers_autInput> | tokens_generated_autCreateWithoutUsers_autInput[] | tokens_generated_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: tokens_generated_autCreateOrConnectWithoutUsers_autInput | tokens_generated_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: tokens_generated_autCreateManyUsers_autInputEnvelope
    connect?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
  }

  export type trainings_links_autUncheckedCreateNestedManyWithoutUsers_autInput = {
    create?: XOR<trainings_links_autCreateWithoutUsers_autInput, trainings_links_autUncheckedCreateWithoutUsers_autInput> | trainings_links_autCreateWithoutUsers_autInput[] | trainings_links_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: trainings_links_autCreateOrConnectWithoutUsers_autInput | trainings_links_autCreateOrConnectWithoutUsers_autInput[]
    createMany?: trainings_links_autCreateManyUsers_autInputEnvelope
    connect?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
  }

  export type budget_consults_autUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<budget_consults_autCreateWithoutUsers_autInput, budget_consults_autUncheckedCreateWithoutUsers_autInput> | budget_consults_autCreateWithoutUsers_autInput[] | budget_consults_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: budget_consults_autCreateOrConnectWithoutUsers_autInput | budget_consults_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: budget_consults_autUpsertWithWhereUniqueWithoutUsers_autInput | budget_consults_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: budget_consults_autCreateManyUsers_autInputEnvelope
    set?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
    disconnect?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
    delete?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
    connect?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
    update?: budget_consults_autUpdateWithWhereUniqueWithoutUsers_autInput | budget_consults_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: budget_consults_autUpdateManyWithWhereWithoutUsers_autInput | budget_consults_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: budget_consults_autScalarWhereInput | budget_consults_autScalarWhereInput[]
  }

  export type cpf_consults_autUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<cpf_consults_autCreateWithoutUsers_autInput, cpf_consults_autUncheckedCreateWithoutUsers_autInput> | cpf_consults_autCreateWithoutUsers_autInput[] | cpf_consults_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: cpf_consults_autCreateOrConnectWithoutUsers_autInput | cpf_consults_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: cpf_consults_autUpsertWithWhereUniqueWithoutUsers_autInput | cpf_consults_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: cpf_consults_autCreateManyUsers_autInputEnvelope
    set?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
    disconnect?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
    delete?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
    connect?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
    update?: cpf_consults_autUpdateWithWhereUniqueWithoutUsers_autInput | cpf_consults_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: cpf_consults_autUpdateManyWithWhereWithoutUsers_autInput | cpf_consults_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: cpf_consults_autScalarWhereInput | cpf_consults_autScalarWhereInput[]
  }

  export type quote_calculations_autUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<quote_calculations_autCreateWithoutUsers_autInput, quote_calculations_autUncheckedCreateWithoutUsers_autInput> | quote_calculations_autCreateWithoutUsers_autInput[] | quote_calculations_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: quote_calculations_autCreateOrConnectWithoutUsers_autInput | quote_calculations_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: quote_calculations_autUpsertWithWhereUniqueWithoutUsers_autInput | quote_calculations_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: quote_calculations_autCreateManyUsers_autInputEnvelope
    set?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
    disconnect?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
    delete?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
    connect?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
    update?: quote_calculations_autUpdateWithWhereUniqueWithoutUsers_autInput | quote_calculations_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: quote_calculations_autUpdateManyWithWhereWithoutUsers_autInput | quote_calculations_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: quote_calculations_autScalarWhereInput | quote_calculations_autScalarWhereInput[]
  }

  export type sessions_autUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<sessions_autCreateWithoutUsers_autInput, sessions_autUncheckedCreateWithoutUsers_autInput> | sessions_autCreateWithoutUsers_autInput[] | sessions_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: sessions_autCreateOrConnectWithoutUsers_autInput | sessions_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: sessions_autUpsertWithWhereUniqueWithoutUsers_autInput | sessions_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: sessions_autCreateManyUsers_autInputEnvelope
    set?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
    disconnect?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
    delete?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
    connect?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
    update?: sessions_autUpdateWithWhereUniqueWithoutUsers_autInput | sessions_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: sessions_autUpdateManyWithWhereWithoutUsers_autInput | sessions_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: sessions_autScalarWhereInput | sessions_autScalarWhereInput[]
  }

  export type threads_autUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<threads_autCreateWithoutUsers_autInput, threads_autUncheckedCreateWithoutUsers_autInput> | threads_autCreateWithoutUsers_autInput[] | threads_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: threads_autCreateOrConnectWithoutUsers_autInput | threads_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: threads_autUpsertWithWhereUniqueWithoutUsers_autInput | threads_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: threads_autCreateManyUsers_autInputEnvelope
    set?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
    disconnect?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
    delete?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
    connect?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
    update?: threads_autUpdateWithWhereUniqueWithoutUsers_autInput | threads_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: threads_autUpdateManyWithWhereWithoutUsers_autInput | threads_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: threads_autScalarWhereInput | threads_autScalarWhereInput[]
  }

  export type tokens_generated_autUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<tokens_generated_autCreateWithoutUsers_autInput, tokens_generated_autUncheckedCreateWithoutUsers_autInput> | tokens_generated_autCreateWithoutUsers_autInput[] | tokens_generated_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: tokens_generated_autCreateOrConnectWithoutUsers_autInput | tokens_generated_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: tokens_generated_autUpsertWithWhereUniqueWithoutUsers_autInput | tokens_generated_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: tokens_generated_autCreateManyUsers_autInputEnvelope
    set?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
    disconnect?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
    delete?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
    connect?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
    update?: tokens_generated_autUpdateWithWhereUniqueWithoutUsers_autInput | tokens_generated_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: tokens_generated_autUpdateManyWithWhereWithoutUsers_autInput | tokens_generated_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: tokens_generated_autScalarWhereInput | tokens_generated_autScalarWhereInput[]
  }

  export type trainings_links_autUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<trainings_links_autCreateWithoutUsers_autInput, trainings_links_autUncheckedCreateWithoutUsers_autInput> | trainings_links_autCreateWithoutUsers_autInput[] | trainings_links_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: trainings_links_autCreateOrConnectWithoutUsers_autInput | trainings_links_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: trainings_links_autUpsertWithWhereUniqueWithoutUsers_autInput | trainings_links_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: trainings_links_autCreateManyUsers_autInputEnvelope
    set?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
    disconnect?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
    delete?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
    connect?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
    update?: trainings_links_autUpdateWithWhereUniqueWithoutUsers_autInput | trainings_links_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: trainings_links_autUpdateManyWithWhereWithoutUsers_autInput | trainings_links_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: trainings_links_autScalarWhereInput | trainings_links_autScalarWhereInput[]
  }

  export type budget_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<budget_consults_autCreateWithoutUsers_autInput, budget_consults_autUncheckedCreateWithoutUsers_autInput> | budget_consults_autCreateWithoutUsers_autInput[] | budget_consults_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: budget_consults_autCreateOrConnectWithoutUsers_autInput | budget_consults_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: budget_consults_autUpsertWithWhereUniqueWithoutUsers_autInput | budget_consults_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: budget_consults_autCreateManyUsers_autInputEnvelope
    set?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
    disconnect?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
    delete?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
    connect?: budget_consults_autWhereUniqueInput | budget_consults_autWhereUniqueInput[]
    update?: budget_consults_autUpdateWithWhereUniqueWithoutUsers_autInput | budget_consults_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: budget_consults_autUpdateManyWithWhereWithoutUsers_autInput | budget_consults_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: budget_consults_autScalarWhereInput | budget_consults_autScalarWhereInput[]
  }

  export type cpf_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<cpf_consults_autCreateWithoutUsers_autInput, cpf_consults_autUncheckedCreateWithoutUsers_autInput> | cpf_consults_autCreateWithoutUsers_autInput[] | cpf_consults_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: cpf_consults_autCreateOrConnectWithoutUsers_autInput | cpf_consults_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: cpf_consults_autUpsertWithWhereUniqueWithoutUsers_autInput | cpf_consults_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: cpf_consults_autCreateManyUsers_autInputEnvelope
    set?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
    disconnect?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
    delete?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
    connect?: cpf_consults_autWhereUniqueInput | cpf_consults_autWhereUniqueInput[]
    update?: cpf_consults_autUpdateWithWhereUniqueWithoutUsers_autInput | cpf_consults_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: cpf_consults_autUpdateManyWithWhereWithoutUsers_autInput | cpf_consults_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: cpf_consults_autScalarWhereInput | cpf_consults_autScalarWhereInput[]
  }

  export type quote_calculations_autUncheckedUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<quote_calculations_autCreateWithoutUsers_autInput, quote_calculations_autUncheckedCreateWithoutUsers_autInput> | quote_calculations_autCreateWithoutUsers_autInput[] | quote_calculations_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: quote_calculations_autCreateOrConnectWithoutUsers_autInput | quote_calculations_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: quote_calculations_autUpsertWithWhereUniqueWithoutUsers_autInput | quote_calculations_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: quote_calculations_autCreateManyUsers_autInputEnvelope
    set?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
    disconnect?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
    delete?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
    connect?: quote_calculations_autWhereUniqueInput | quote_calculations_autWhereUniqueInput[]
    update?: quote_calculations_autUpdateWithWhereUniqueWithoutUsers_autInput | quote_calculations_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: quote_calculations_autUpdateManyWithWhereWithoutUsers_autInput | quote_calculations_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: quote_calculations_autScalarWhereInput | quote_calculations_autScalarWhereInput[]
  }

  export type sessions_autUncheckedUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<sessions_autCreateWithoutUsers_autInput, sessions_autUncheckedCreateWithoutUsers_autInput> | sessions_autCreateWithoutUsers_autInput[] | sessions_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: sessions_autCreateOrConnectWithoutUsers_autInput | sessions_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: sessions_autUpsertWithWhereUniqueWithoutUsers_autInput | sessions_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: sessions_autCreateManyUsers_autInputEnvelope
    set?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
    disconnect?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
    delete?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
    connect?: sessions_autWhereUniqueInput | sessions_autWhereUniqueInput[]
    update?: sessions_autUpdateWithWhereUniqueWithoutUsers_autInput | sessions_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: sessions_autUpdateManyWithWhereWithoutUsers_autInput | sessions_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: sessions_autScalarWhereInput | sessions_autScalarWhereInput[]
  }

  export type threads_autUncheckedUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<threads_autCreateWithoutUsers_autInput, threads_autUncheckedCreateWithoutUsers_autInput> | threads_autCreateWithoutUsers_autInput[] | threads_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: threads_autCreateOrConnectWithoutUsers_autInput | threads_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: threads_autUpsertWithWhereUniqueWithoutUsers_autInput | threads_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: threads_autCreateManyUsers_autInputEnvelope
    set?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
    disconnect?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
    delete?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
    connect?: threads_autWhereUniqueInput | threads_autWhereUniqueInput[]
    update?: threads_autUpdateWithWhereUniqueWithoutUsers_autInput | threads_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: threads_autUpdateManyWithWhereWithoutUsers_autInput | threads_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: threads_autScalarWhereInput | threads_autScalarWhereInput[]
  }

  export type tokens_generated_autUncheckedUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<tokens_generated_autCreateWithoutUsers_autInput, tokens_generated_autUncheckedCreateWithoutUsers_autInput> | tokens_generated_autCreateWithoutUsers_autInput[] | tokens_generated_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: tokens_generated_autCreateOrConnectWithoutUsers_autInput | tokens_generated_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: tokens_generated_autUpsertWithWhereUniqueWithoutUsers_autInput | tokens_generated_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: tokens_generated_autCreateManyUsers_autInputEnvelope
    set?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
    disconnect?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
    delete?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
    connect?: tokens_generated_autWhereUniqueInput | tokens_generated_autWhereUniqueInput[]
    update?: tokens_generated_autUpdateWithWhereUniqueWithoutUsers_autInput | tokens_generated_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: tokens_generated_autUpdateManyWithWhereWithoutUsers_autInput | tokens_generated_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: tokens_generated_autScalarWhereInput | tokens_generated_autScalarWhereInput[]
  }

  export type trainings_links_autUncheckedUpdateManyWithoutUsers_autNestedInput = {
    create?: XOR<trainings_links_autCreateWithoutUsers_autInput, trainings_links_autUncheckedCreateWithoutUsers_autInput> | trainings_links_autCreateWithoutUsers_autInput[] | trainings_links_autUncheckedCreateWithoutUsers_autInput[]
    connectOrCreate?: trainings_links_autCreateOrConnectWithoutUsers_autInput | trainings_links_autCreateOrConnectWithoutUsers_autInput[]
    upsert?: trainings_links_autUpsertWithWhereUniqueWithoutUsers_autInput | trainings_links_autUpsertWithWhereUniqueWithoutUsers_autInput[]
    createMany?: trainings_links_autCreateManyUsers_autInputEnvelope
    set?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
    disconnect?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
    delete?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
    connect?: trainings_links_autWhereUniqueInput | trainings_links_autWhereUniqueInput[]
    update?: trainings_links_autUpdateWithWhereUniqueWithoutUsers_autInput | trainings_links_autUpdateWithWhereUniqueWithoutUsers_autInput[]
    updateMany?: trainings_links_autUpdateManyWithWhereWithoutUsers_autInput | trainings_links_autUpdateManyWithWhereWithoutUsers_autInput[]
    deleteMany?: trainings_links_autScalarWhereInput | trainings_links_autScalarWhereInput[]
  }

  export type budget_consults_cltCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<budget_consults_cltCreateWithoutUsers_cltInput, budget_consults_cltUncheckedCreateWithoutUsers_cltInput> | budget_consults_cltCreateWithoutUsers_cltInput[] | budget_consults_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: budget_consults_cltCreateOrConnectWithoutUsers_cltInput | budget_consults_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: budget_consults_cltCreateManyUsers_cltInputEnvelope
    connect?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
  }

  export type cpf_consults_cltCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<cpf_consults_cltCreateWithoutUsers_cltInput, cpf_consults_cltUncheckedCreateWithoutUsers_cltInput> | cpf_consults_cltCreateWithoutUsers_cltInput[] | cpf_consults_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: cpf_consults_cltCreateOrConnectWithoutUsers_cltInput | cpf_consults_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: cpf_consults_cltCreateManyUsers_cltInputEnvelope
    connect?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
  }

  export type quote_calculations_cltCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<quote_calculations_cltCreateWithoutUsers_cltInput, quote_calculations_cltUncheckedCreateWithoutUsers_cltInput> | quote_calculations_cltCreateWithoutUsers_cltInput[] | quote_calculations_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: quote_calculations_cltCreateOrConnectWithoutUsers_cltInput | quote_calculations_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: quote_calculations_cltCreateManyUsers_cltInputEnvelope
    connect?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
  }

  export type sessions_cltCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<sessions_cltCreateWithoutUsers_cltInput, sessions_cltUncheckedCreateWithoutUsers_cltInput> | sessions_cltCreateWithoutUsers_cltInput[] | sessions_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: sessions_cltCreateOrConnectWithoutUsers_cltInput | sessions_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: sessions_cltCreateManyUsers_cltInputEnvelope
    connect?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
  }

  export type threads_cltCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<threads_cltCreateWithoutUsers_cltInput, threads_cltUncheckedCreateWithoutUsers_cltInput> | threads_cltCreateWithoutUsers_cltInput[] | threads_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: threads_cltCreateOrConnectWithoutUsers_cltInput | threads_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: threads_cltCreateManyUsers_cltInputEnvelope
    connect?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
  }

  export type tokens_generated_cltCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<tokens_generated_cltCreateWithoutUsers_cltInput, tokens_generated_cltUncheckedCreateWithoutUsers_cltInput> | tokens_generated_cltCreateWithoutUsers_cltInput[] | tokens_generated_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: tokens_generated_cltCreateOrConnectWithoutUsers_cltInput | tokens_generated_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: tokens_generated_cltCreateManyUsers_cltInputEnvelope
    connect?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
  }

  export type trainings_links_cltCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<trainings_links_cltCreateWithoutUsers_cltInput, trainings_links_cltUncheckedCreateWithoutUsers_cltInput> | trainings_links_cltCreateWithoutUsers_cltInput[] | trainings_links_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: trainings_links_cltCreateOrConnectWithoutUsers_cltInput | trainings_links_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: trainings_links_cltCreateManyUsers_cltInputEnvelope
    connect?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
  }

  export type budget_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<budget_consults_cltCreateWithoutUsers_cltInput, budget_consults_cltUncheckedCreateWithoutUsers_cltInput> | budget_consults_cltCreateWithoutUsers_cltInput[] | budget_consults_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: budget_consults_cltCreateOrConnectWithoutUsers_cltInput | budget_consults_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: budget_consults_cltCreateManyUsers_cltInputEnvelope
    connect?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
  }

  export type cpf_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<cpf_consults_cltCreateWithoutUsers_cltInput, cpf_consults_cltUncheckedCreateWithoutUsers_cltInput> | cpf_consults_cltCreateWithoutUsers_cltInput[] | cpf_consults_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: cpf_consults_cltCreateOrConnectWithoutUsers_cltInput | cpf_consults_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: cpf_consults_cltCreateManyUsers_cltInputEnvelope
    connect?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
  }

  export type quote_calculations_cltUncheckedCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<quote_calculations_cltCreateWithoutUsers_cltInput, quote_calculations_cltUncheckedCreateWithoutUsers_cltInput> | quote_calculations_cltCreateWithoutUsers_cltInput[] | quote_calculations_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: quote_calculations_cltCreateOrConnectWithoutUsers_cltInput | quote_calculations_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: quote_calculations_cltCreateManyUsers_cltInputEnvelope
    connect?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
  }

  export type sessions_cltUncheckedCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<sessions_cltCreateWithoutUsers_cltInput, sessions_cltUncheckedCreateWithoutUsers_cltInput> | sessions_cltCreateWithoutUsers_cltInput[] | sessions_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: sessions_cltCreateOrConnectWithoutUsers_cltInput | sessions_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: sessions_cltCreateManyUsers_cltInputEnvelope
    connect?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
  }

  export type threads_cltUncheckedCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<threads_cltCreateWithoutUsers_cltInput, threads_cltUncheckedCreateWithoutUsers_cltInput> | threads_cltCreateWithoutUsers_cltInput[] | threads_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: threads_cltCreateOrConnectWithoutUsers_cltInput | threads_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: threads_cltCreateManyUsers_cltInputEnvelope
    connect?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
  }

  export type tokens_generated_cltUncheckedCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<tokens_generated_cltCreateWithoutUsers_cltInput, tokens_generated_cltUncheckedCreateWithoutUsers_cltInput> | tokens_generated_cltCreateWithoutUsers_cltInput[] | tokens_generated_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: tokens_generated_cltCreateOrConnectWithoutUsers_cltInput | tokens_generated_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: tokens_generated_cltCreateManyUsers_cltInputEnvelope
    connect?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
  }

  export type trainings_links_cltUncheckedCreateNestedManyWithoutUsers_cltInput = {
    create?: XOR<trainings_links_cltCreateWithoutUsers_cltInput, trainings_links_cltUncheckedCreateWithoutUsers_cltInput> | trainings_links_cltCreateWithoutUsers_cltInput[] | trainings_links_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: trainings_links_cltCreateOrConnectWithoutUsers_cltInput | trainings_links_cltCreateOrConnectWithoutUsers_cltInput[]
    createMany?: trainings_links_cltCreateManyUsers_cltInputEnvelope
    connect?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
  }

  export type budget_consults_cltUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<budget_consults_cltCreateWithoutUsers_cltInput, budget_consults_cltUncheckedCreateWithoutUsers_cltInput> | budget_consults_cltCreateWithoutUsers_cltInput[] | budget_consults_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: budget_consults_cltCreateOrConnectWithoutUsers_cltInput | budget_consults_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: budget_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput | budget_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: budget_consults_cltCreateManyUsers_cltInputEnvelope
    set?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
    disconnect?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
    delete?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
    connect?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
    update?: budget_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput | budget_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: budget_consults_cltUpdateManyWithWhereWithoutUsers_cltInput | budget_consults_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: budget_consults_cltScalarWhereInput | budget_consults_cltScalarWhereInput[]
  }

  export type cpf_consults_cltUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<cpf_consults_cltCreateWithoutUsers_cltInput, cpf_consults_cltUncheckedCreateWithoutUsers_cltInput> | cpf_consults_cltCreateWithoutUsers_cltInput[] | cpf_consults_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: cpf_consults_cltCreateOrConnectWithoutUsers_cltInput | cpf_consults_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: cpf_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput | cpf_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: cpf_consults_cltCreateManyUsers_cltInputEnvelope
    set?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
    disconnect?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
    delete?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
    connect?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
    update?: cpf_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput | cpf_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: cpf_consults_cltUpdateManyWithWhereWithoutUsers_cltInput | cpf_consults_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: cpf_consults_cltScalarWhereInput | cpf_consults_cltScalarWhereInput[]
  }

  export type quote_calculations_cltUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<quote_calculations_cltCreateWithoutUsers_cltInput, quote_calculations_cltUncheckedCreateWithoutUsers_cltInput> | quote_calculations_cltCreateWithoutUsers_cltInput[] | quote_calculations_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: quote_calculations_cltCreateOrConnectWithoutUsers_cltInput | quote_calculations_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: quote_calculations_cltUpsertWithWhereUniqueWithoutUsers_cltInput | quote_calculations_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: quote_calculations_cltCreateManyUsers_cltInputEnvelope
    set?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
    disconnect?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
    delete?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
    connect?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
    update?: quote_calculations_cltUpdateWithWhereUniqueWithoutUsers_cltInput | quote_calculations_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: quote_calculations_cltUpdateManyWithWhereWithoutUsers_cltInput | quote_calculations_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: quote_calculations_cltScalarWhereInput | quote_calculations_cltScalarWhereInput[]
  }

  export type sessions_cltUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<sessions_cltCreateWithoutUsers_cltInput, sessions_cltUncheckedCreateWithoutUsers_cltInput> | sessions_cltCreateWithoutUsers_cltInput[] | sessions_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: sessions_cltCreateOrConnectWithoutUsers_cltInput | sessions_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: sessions_cltUpsertWithWhereUniqueWithoutUsers_cltInput | sessions_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: sessions_cltCreateManyUsers_cltInputEnvelope
    set?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
    disconnect?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
    delete?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
    connect?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
    update?: sessions_cltUpdateWithWhereUniqueWithoutUsers_cltInput | sessions_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: sessions_cltUpdateManyWithWhereWithoutUsers_cltInput | sessions_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: sessions_cltScalarWhereInput | sessions_cltScalarWhereInput[]
  }

  export type threads_cltUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<threads_cltCreateWithoutUsers_cltInput, threads_cltUncheckedCreateWithoutUsers_cltInput> | threads_cltCreateWithoutUsers_cltInput[] | threads_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: threads_cltCreateOrConnectWithoutUsers_cltInput | threads_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: threads_cltUpsertWithWhereUniqueWithoutUsers_cltInput | threads_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: threads_cltCreateManyUsers_cltInputEnvelope
    set?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
    disconnect?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
    delete?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
    connect?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
    update?: threads_cltUpdateWithWhereUniqueWithoutUsers_cltInput | threads_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: threads_cltUpdateManyWithWhereWithoutUsers_cltInput | threads_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: threads_cltScalarWhereInput | threads_cltScalarWhereInput[]
  }

  export type tokens_generated_cltUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<tokens_generated_cltCreateWithoutUsers_cltInput, tokens_generated_cltUncheckedCreateWithoutUsers_cltInput> | tokens_generated_cltCreateWithoutUsers_cltInput[] | tokens_generated_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: tokens_generated_cltCreateOrConnectWithoutUsers_cltInput | tokens_generated_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: tokens_generated_cltUpsertWithWhereUniqueWithoutUsers_cltInput | tokens_generated_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: tokens_generated_cltCreateManyUsers_cltInputEnvelope
    set?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
    disconnect?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
    delete?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
    connect?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
    update?: tokens_generated_cltUpdateWithWhereUniqueWithoutUsers_cltInput | tokens_generated_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: tokens_generated_cltUpdateManyWithWhereWithoutUsers_cltInput | tokens_generated_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: tokens_generated_cltScalarWhereInput | tokens_generated_cltScalarWhereInput[]
  }

  export type trainings_links_cltUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<trainings_links_cltCreateWithoutUsers_cltInput, trainings_links_cltUncheckedCreateWithoutUsers_cltInput> | trainings_links_cltCreateWithoutUsers_cltInput[] | trainings_links_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: trainings_links_cltCreateOrConnectWithoutUsers_cltInput | trainings_links_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: trainings_links_cltUpsertWithWhereUniqueWithoutUsers_cltInput | trainings_links_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: trainings_links_cltCreateManyUsers_cltInputEnvelope
    set?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
    disconnect?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
    delete?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
    connect?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
    update?: trainings_links_cltUpdateWithWhereUniqueWithoutUsers_cltInput | trainings_links_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: trainings_links_cltUpdateManyWithWhereWithoutUsers_cltInput | trainings_links_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: trainings_links_cltScalarWhereInput | trainings_links_cltScalarWhereInput[]
  }

  export type budget_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<budget_consults_cltCreateWithoutUsers_cltInput, budget_consults_cltUncheckedCreateWithoutUsers_cltInput> | budget_consults_cltCreateWithoutUsers_cltInput[] | budget_consults_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: budget_consults_cltCreateOrConnectWithoutUsers_cltInput | budget_consults_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: budget_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput | budget_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: budget_consults_cltCreateManyUsers_cltInputEnvelope
    set?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
    disconnect?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
    delete?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
    connect?: budget_consults_cltWhereUniqueInput | budget_consults_cltWhereUniqueInput[]
    update?: budget_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput | budget_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: budget_consults_cltUpdateManyWithWhereWithoutUsers_cltInput | budget_consults_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: budget_consults_cltScalarWhereInput | budget_consults_cltScalarWhereInput[]
  }

  export type cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<cpf_consults_cltCreateWithoutUsers_cltInput, cpf_consults_cltUncheckedCreateWithoutUsers_cltInput> | cpf_consults_cltCreateWithoutUsers_cltInput[] | cpf_consults_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: cpf_consults_cltCreateOrConnectWithoutUsers_cltInput | cpf_consults_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: cpf_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput | cpf_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: cpf_consults_cltCreateManyUsers_cltInputEnvelope
    set?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
    disconnect?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
    delete?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
    connect?: cpf_consults_cltWhereUniqueInput | cpf_consults_cltWhereUniqueInput[]
    update?: cpf_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput | cpf_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: cpf_consults_cltUpdateManyWithWhereWithoutUsers_cltInput | cpf_consults_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: cpf_consults_cltScalarWhereInput | cpf_consults_cltScalarWhereInput[]
  }

  export type quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<quote_calculations_cltCreateWithoutUsers_cltInput, quote_calculations_cltUncheckedCreateWithoutUsers_cltInput> | quote_calculations_cltCreateWithoutUsers_cltInput[] | quote_calculations_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: quote_calculations_cltCreateOrConnectWithoutUsers_cltInput | quote_calculations_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: quote_calculations_cltUpsertWithWhereUniqueWithoutUsers_cltInput | quote_calculations_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: quote_calculations_cltCreateManyUsers_cltInputEnvelope
    set?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
    disconnect?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
    delete?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
    connect?: quote_calculations_cltWhereUniqueInput | quote_calculations_cltWhereUniqueInput[]
    update?: quote_calculations_cltUpdateWithWhereUniqueWithoutUsers_cltInput | quote_calculations_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: quote_calculations_cltUpdateManyWithWhereWithoutUsers_cltInput | quote_calculations_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: quote_calculations_cltScalarWhereInput | quote_calculations_cltScalarWhereInput[]
  }

  export type sessions_cltUncheckedUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<sessions_cltCreateWithoutUsers_cltInput, sessions_cltUncheckedCreateWithoutUsers_cltInput> | sessions_cltCreateWithoutUsers_cltInput[] | sessions_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: sessions_cltCreateOrConnectWithoutUsers_cltInput | sessions_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: sessions_cltUpsertWithWhereUniqueWithoutUsers_cltInput | sessions_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: sessions_cltCreateManyUsers_cltInputEnvelope
    set?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
    disconnect?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
    delete?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
    connect?: sessions_cltWhereUniqueInput | sessions_cltWhereUniqueInput[]
    update?: sessions_cltUpdateWithWhereUniqueWithoutUsers_cltInput | sessions_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: sessions_cltUpdateManyWithWhereWithoutUsers_cltInput | sessions_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: sessions_cltScalarWhereInput | sessions_cltScalarWhereInput[]
  }

  export type threads_cltUncheckedUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<threads_cltCreateWithoutUsers_cltInput, threads_cltUncheckedCreateWithoutUsers_cltInput> | threads_cltCreateWithoutUsers_cltInput[] | threads_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: threads_cltCreateOrConnectWithoutUsers_cltInput | threads_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: threads_cltUpsertWithWhereUniqueWithoutUsers_cltInput | threads_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: threads_cltCreateManyUsers_cltInputEnvelope
    set?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
    disconnect?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
    delete?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
    connect?: threads_cltWhereUniqueInput | threads_cltWhereUniqueInput[]
    update?: threads_cltUpdateWithWhereUniqueWithoutUsers_cltInput | threads_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: threads_cltUpdateManyWithWhereWithoutUsers_cltInput | threads_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: threads_cltScalarWhereInput | threads_cltScalarWhereInput[]
  }

  export type tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<tokens_generated_cltCreateWithoutUsers_cltInput, tokens_generated_cltUncheckedCreateWithoutUsers_cltInput> | tokens_generated_cltCreateWithoutUsers_cltInput[] | tokens_generated_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: tokens_generated_cltCreateOrConnectWithoutUsers_cltInput | tokens_generated_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: tokens_generated_cltUpsertWithWhereUniqueWithoutUsers_cltInput | tokens_generated_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: tokens_generated_cltCreateManyUsers_cltInputEnvelope
    set?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
    disconnect?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
    delete?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
    connect?: tokens_generated_cltWhereUniqueInput | tokens_generated_cltWhereUniqueInput[]
    update?: tokens_generated_cltUpdateWithWhereUniqueWithoutUsers_cltInput | tokens_generated_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: tokens_generated_cltUpdateManyWithWhereWithoutUsers_cltInput | tokens_generated_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: tokens_generated_cltScalarWhereInput | tokens_generated_cltScalarWhereInput[]
  }

  export type trainings_links_cltUncheckedUpdateManyWithoutUsers_cltNestedInput = {
    create?: XOR<trainings_links_cltCreateWithoutUsers_cltInput, trainings_links_cltUncheckedCreateWithoutUsers_cltInput> | trainings_links_cltCreateWithoutUsers_cltInput[] | trainings_links_cltUncheckedCreateWithoutUsers_cltInput[]
    connectOrCreate?: trainings_links_cltCreateOrConnectWithoutUsers_cltInput | trainings_links_cltCreateOrConnectWithoutUsers_cltInput[]
    upsert?: trainings_links_cltUpsertWithWhereUniqueWithoutUsers_cltInput | trainings_links_cltUpsertWithWhereUniqueWithoutUsers_cltInput[]
    createMany?: trainings_links_cltCreateManyUsers_cltInputEnvelope
    set?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
    disconnect?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
    delete?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
    connect?: trainings_links_cltWhereUniqueInput | trainings_links_cltWhereUniqueInput[]
    update?: trainings_links_cltUpdateWithWhereUniqueWithoutUsers_cltInput | trainings_links_cltUpdateWithWhereUniqueWithoutUsers_cltInput[]
    updateMany?: trainings_links_cltUpdateManyWithWhereWithoutUsers_cltInput | trainings_links_cltUpdateManyWithWhereWithoutUsers_cltInput[]
    deleteMany?: trainings_links_cltScalarWhereInput | trainings_links_cltScalarWhereInput[]
  }

  export type budget_consults_goiCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<budget_consults_goiCreateWithoutUsers_goiInput, budget_consults_goiUncheckedCreateWithoutUsers_goiInput> | budget_consults_goiCreateWithoutUsers_goiInput[] | budget_consults_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: budget_consults_goiCreateOrConnectWithoutUsers_goiInput | budget_consults_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: budget_consults_goiCreateManyUsers_goiInputEnvelope
    connect?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
  }

  export type cpf_consults_goiCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<cpf_consults_goiCreateWithoutUsers_goiInput, cpf_consults_goiUncheckedCreateWithoutUsers_goiInput> | cpf_consults_goiCreateWithoutUsers_goiInput[] | cpf_consults_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: cpf_consults_goiCreateOrConnectWithoutUsers_goiInput | cpf_consults_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: cpf_consults_goiCreateManyUsers_goiInputEnvelope
    connect?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
  }

  export type quote_calculations_goiCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<quote_calculations_goiCreateWithoutUsers_goiInput, quote_calculations_goiUncheckedCreateWithoutUsers_goiInput> | quote_calculations_goiCreateWithoutUsers_goiInput[] | quote_calculations_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: quote_calculations_goiCreateOrConnectWithoutUsers_goiInput | quote_calculations_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: quote_calculations_goiCreateManyUsers_goiInputEnvelope
    connect?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
  }

  export type sessions_goiCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<sessions_goiCreateWithoutUsers_goiInput, sessions_goiUncheckedCreateWithoutUsers_goiInput> | sessions_goiCreateWithoutUsers_goiInput[] | sessions_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: sessions_goiCreateOrConnectWithoutUsers_goiInput | sessions_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: sessions_goiCreateManyUsers_goiInputEnvelope
    connect?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
  }

  export type threads_goiCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<threads_goiCreateWithoutUsers_goiInput, threads_goiUncheckedCreateWithoutUsers_goiInput> | threads_goiCreateWithoutUsers_goiInput[] | threads_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: threads_goiCreateOrConnectWithoutUsers_goiInput | threads_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: threads_goiCreateManyUsers_goiInputEnvelope
    connect?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
  }

  export type tokens_generated_goiCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<tokens_generated_goiCreateWithoutUsers_goiInput, tokens_generated_goiUncheckedCreateWithoutUsers_goiInput> | tokens_generated_goiCreateWithoutUsers_goiInput[] | tokens_generated_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: tokens_generated_goiCreateOrConnectWithoutUsers_goiInput | tokens_generated_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: tokens_generated_goiCreateManyUsers_goiInputEnvelope
    connect?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
  }

  export type trainings_links_goiCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<trainings_links_goiCreateWithoutUsers_goiInput, trainings_links_goiUncheckedCreateWithoutUsers_goiInput> | trainings_links_goiCreateWithoutUsers_goiInput[] | trainings_links_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: trainings_links_goiCreateOrConnectWithoutUsers_goiInput | trainings_links_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: trainings_links_goiCreateManyUsers_goiInputEnvelope
    connect?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
  }

  export type budget_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<budget_consults_goiCreateWithoutUsers_goiInput, budget_consults_goiUncheckedCreateWithoutUsers_goiInput> | budget_consults_goiCreateWithoutUsers_goiInput[] | budget_consults_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: budget_consults_goiCreateOrConnectWithoutUsers_goiInput | budget_consults_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: budget_consults_goiCreateManyUsers_goiInputEnvelope
    connect?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
  }

  export type cpf_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<cpf_consults_goiCreateWithoutUsers_goiInput, cpf_consults_goiUncheckedCreateWithoutUsers_goiInput> | cpf_consults_goiCreateWithoutUsers_goiInput[] | cpf_consults_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: cpf_consults_goiCreateOrConnectWithoutUsers_goiInput | cpf_consults_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: cpf_consults_goiCreateManyUsers_goiInputEnvelope
    connect?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
  }

  export type quote_calculations_goiUncheckedCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<quote_calculations_goiCreateWithoutUsers_goiInput, quote_calculations_goiUncheckedCreateWithoutUsers_goiInput> | quote_calculations_goiCreateWithoutUsers_goiInput[] | quote_calculations_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: quote_calculations_goiCreateOrConnectWithoutUsers_goiInput | quote_calculations_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: quote_calculations_goiCreateManyUsers_goiInputEnvelope
    connect?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
  }

  export type sessions_goiUncheckedCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<sessions_goiCreateWithoutUsers_goiInput, sessions_goiUncheckedCreateWithoutUsers_goiInput> | sessions_goiCreateWithoutUsers_goiInput[] | sessions_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: sessions_goiCreateOrConnectWithoutUsers_goiInput | sessions_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: sessions_goiCreateManyUsers_goiInputEnvelope
    connect?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
  }

  export type threads_goiUncheckedCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<threads_goiCreateWithoutUsers_goiInput, threads_goiUncheckedCreateWithoutUsers_goiInput> | threads_goiCreateWithoutUsers_goiInput[] | threads_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: threads_goiCreateOrConnectWithoutUsers_goiInput | threads_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: threads_goiCreateManyUsers_goiInputEnvelope
    connect?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
  }

  export type tokens_generated_goiUncheckedCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<tokens_generated_goiCreateWithoutUsers_goiInput, tokens_generated_goiUncheckedCreateWithoutUsers_goiInput> | tokens_generated_goiCreateWithoutUsers_goiInput[] | tokens_generated_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: tokens_generated_goiCreateOrConnectWithoutUsers_goiInput | tokens_generated_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: tokens_generated_goiCreateManyUsers_goiInputEnvelope
    connect?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
  }

  export type trainings_links_goiUncheckedCreateNestedManyWithoutUsers_goiInput = {
    create?: XOR<trainings_links_goiCreateWithoutUsers_goiInput, trainings_links_goiUncheckedCreateWithoutUsers_goiInput> | trainings_links_goiCreateWithoutUsers_goiInput[] | trainings_links_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: trainings_links_goiCreateOrConnectWithoutUsers_goiInput | trainings_links_goiCreateOrConnectWithoutUsers_goiInput[]
    createMany?: trainings_links_goiCreateManyUsers_goiInputEnvelope
    connect?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
  }

  export type budget_consults_goiUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<budget_consults_goiCreateWithoutUsers_goiInput, budget_consults_goiUncheckedCreateWithoutUsers_goiInput> | budget_consults_goiCreateWithoutUsers_goiInput[] | budget_consults_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: budget_consults_goiCreateOrConnectWithoutUsers_goiInput | budget_consults_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: budget_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput | budget_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: budget_consults_goiCreateManyUsers_goiInputEnvelope
    set?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
    disconnect?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
    delete?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
    connect?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
    update?: budget_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput | budget_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: budget_consults_goiUpdateManyWithWhereWithoutUsers_goiInput | budget_consults_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: budget_consults_goiScalarWhereInput | budget_consults_goiScalarWhereInput[]
  }

  export type cpf_consults_goiUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<cpf_consults_goiCreateWithoutUsers_goiInput, cpf_consults_goiUncheckedCreateWithoutUsers_goiInput> | cpf_consults_goiCreateWithoutUsers_goiInput[] | cpf_consults_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: cpf_consults_goiCreateOrConnectWithoutUsers_goiInput | cpf_consults_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: cpf_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput | cpf_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: cpf_consults_goiCreateManyUsers_goiInputEnvelope
    set?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
    disconnect?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
    delete?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
    connect?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
    update?: cpf_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput | cpf_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: cpf_consults_goiUpdateManyWithWhereWithoutUsers_goiInput | cpf_consults_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: cpf_consults_goiScalarWhereInput | cpf_consults_goiScalarWhereInput[]
  }

  export type quote_calculations_goiUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<quote_calculations_goiCreateWithoutUsers_goiInput, quote_calculations_goiUncheckedCreateWithoutUsers_goiInput> | quote_calculations_goiCreateWithoutUsers_goiInput[] | quote_calculations_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: quote_calculations_goiCreateOrConnectWithoutUsers_goiInput | quote_calculations_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: quote_calculations_goiUpsertWithWhereUniqueWithoutUsers_goiInput | quote_calculations_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: quote_calculations_goiCreateManyUsers_goiInputEnvelope
    set?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
    disconnect?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
    delete?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
    connect?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
    update?: quote_calculations_goiUpdateWithWhereUniqueWithoutUsers_goiInput | quote_calculations_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: quote_calculations_goiUpdateManyWithWhereWithoutUsers_goiInput | quote_calculations_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: quote_calculations_goiScalarWhereInput | quote_calculations_goiScalarWhereInput[]
  }

  export type sessions_goiUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<sessions_goiCreateWithoutUsers_goiInput, sessions_goiUncheckedCreateWithoutUsers_goiInput> | sessions_goiCreateWithoutUsers_goiInput[] | sessions_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: sessions_goiCreateOrConnectWithoutUsers_goiInput | sessions_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: sessions_goiUpsertWithWhereUniqueWithoutUsers_goiInput | sessions_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: sessions_goiCreateManyUsers_goiInputEnvelope
    set?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
    disconnect?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
    delete?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
    connect?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
    update?: sessions_goiUpdateWithWhereUniqueWithoutUsers_goiInput | sessions_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: sessions_goiUpdateManyWithWhereWithoutUsers_goiInput | sessions_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: sessions_goiScalarWhereInput | sessions_goiScalarWhereInput[]
  }

  export type threads_goiUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<threads_goiCreateWithoutUsers_goiInput, threads_goiUncheckedCreateWithoutUsers_goiInput> | threads_goiCreateWithoutUsers_goiInput[] | threads_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: threads_goiCreateOrConnectWithoutUsers_goiInput | threads_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: threads_goiUpsertWithWhereUniqueWithoutUsers_goiInput | threads_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: threads_goiCreateManyUsers_goiInputEnvelope
    set?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
    disconnect?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
    delete?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
    connect?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
    update?: threads_goiUpdateWithWhereUniqueWithoutUsers_goiInput | threads_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: threads_goiUpdateManyWithWhereWithoutUsers_goiInput | threads_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: threads_goiScalarWhereInput | threads_goiScalarWhereInput[]
  }

  export type tokens_generated_goiUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<tokens_generated_goiCreateWithoutUsers_goiInput, tokens_generated_goiUncheckedCreateWithoutUsers_goiInput> | tokens_generated_goiCreateWithoutUsers_goiInput[] | tokens_generated_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: tokens_generated_goiCreateOrConnectWithoutUsers_goiInput | tokens_generated_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: tokens_generated_goiUpsertWithWhereUniqueWithoutUsers_goiInput | tokens_generated_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: tokens_generated_goiCreateManyUsers_goiInputEnvelope
    set?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
    disconnect?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
    delete?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
    connect?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
    update?: tokens_generated_goiUpdateWithWhereUniqueWithoutUsers_goiInput | tokens_generated_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: tokens_generated_goiUpdateManyWithWhereWithoutUsers_goiInput | tokens_generated_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: tokens_generated_goiScalarWhereInput | tokens_generated_goiScalarWhereInput[]
  }

  export type trainings_links_goiUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<trainings_links_goiCreateWithoutUsers_goiInput, trainings_links_goiUncheckedCreateWithoutUsers_goiInput> | trainings_links_goiCreateWithoutUsers_goiInput[] | trainings_links_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: trainings_links_goiCreateOrConnectWithoutUsers_goiInput | trainings_links_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: trainings_links_goiUpsertWithWhereUniqueWithoutUsers_goiInput | trainings_links_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: trainings_links_goiCreateManyUsers_goiInputEnvelope
    set?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
    disconnect?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
    delete?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
    connect?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
    update?: trainings_links_goiUpdateWithWhereUniqueWithoutUsers_goiInput | trainings_links_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: trainings_links_goiUpdateManyWithWhereWithoutUsers_goiInput | trainings_links_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: trainings_links_goiScalarWhereInput | trainings_links_goiScalarWhereInput[]
  }

  export type budget_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<budget_consults_goiCreateWithoutUsers_goiInput, budget_consults_goiUncheckedCreateWithoutUsers_goiInput> | budget_consults_goiCreateWithoutUsers_goiInput[] | budget_consults_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: budget_consults_goiCreateOrConnectWithoutUsers_goiInput | budget_consults_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: budget_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput | budget_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: budget_consults_goiCreateManyUsers_goiInputEnvelope
    set?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
    disconnect?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
    delete?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
    connect?: budget_consults_goiWhereUniqueInput | budget_consults_goiWhereUniqueInput[]
    update?: budget_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput | budget_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: budget_consults_goiUpdateManyWithWhereWithoutUsers_goiInput | budget_consults_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: budget_consults_goiScalarWhereInput | budget_consults_goiScalarWhereInput[]
  }

  export type cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<cpf_consults_goiCreateWithoutUsers_goiInput, cpf_consults_goiUncheckedCreateWithoutUsers_goiInput> | cpf_consults_goiCreateWithoutUsers_goiInput[] | cpf_consults_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: cpf_consults_goiCreateOrConnectWithoutUsers_goiInput | cpf_consults_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: cpf_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput | cpf_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: cpf_consults_goiCreateManyUsers_goiInputEnvelope
    set?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
    disconnect?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
    delete?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
    connect?: cpf_consults_goiWhereUniqueInput | cpf_consults_goiWhereUniqueInput[]
    update?: cpf_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput | cpf_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: cpf_consults_goiUpdateManyWithWhereWithoutUsers_goiInput | cpf_consults_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: cpf_consults_goiScalarWhereInput | cpf_consults_goiScalarWhereInput[]
  }

  export type quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<quote_calculations_goiCreateWithoutUsers_goiInput, quote_calculations_goiUncheckedCreateWithoutUsers_goiInput> | quote_calculations_goiCreateWithoutUsers_goiInput[] | quote_calculations_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: quote_calculations_goiCreateOrConnectWithoutUsers_goiInput | quote_calculations_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: quote_calculations_goiUpsertWithWhereUniqueWithoutUsers_goiInput | quote_calculations_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: quote_calculations_goiCreateManyUsers_goiInputEnvelope
    set?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
    disconnect?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
    delete?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
    connect?: quote_calculations_goiWhereUniqueInput | quote_calculations_goiWhereUniqueInput[]
    update?: quote_calculations_goiUpdateWithWhereUniqueWithoutUsers_goiInput | quote_calculations_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: quote_calculations_goiUpdateManyWithWhereWithoutUsers_goiInput | quote_calculations_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: quote_calculations_goiScalarWhereInput | quote_calculations_goiScalarWhereInput[]
  }

  export type sessions_goiUncheckedUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<sessions_goiCreateWithoutUsers_goiInput, sessions_goiUncheckedCreateWithoutUsers_goiInput> | sessions_goiCreateWithoutUsers_goiInput[] | sessions_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: sessions_goiCreateOrConnectWithoutUsers_goiInput | sessions_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: sessions_goiUpsertWithWhereUniqueWithoutUsers_goiInput | sessions_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: sessions_goiCreateManyUsers_goiInputEnvelope
    set?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
    disconnect?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
    delete?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
    connect?: sessions_goiWhereUniqueInput | sessions_goiWhereUniqueInput[]
    update?: sessions_goiUpdateWithWhereUniqueWithoutUsers_goiInput | sessions_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: sessions_goiUpdateManyWithWhereWithoutUsers_goiInput | sessions_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: sessions_goiScalarWhereInput | sessions_goiScalarWhereInput[]
  }

  export type threads_goiUncheckedUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<threads_goiCreateWithoutUsers_goiInput, threads_goiUncheckedCreateWithoutUsers_goiInput> | threads_goiCreateWithoutUsers_goiInput[] | threads_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: threads_goiCreateOrConnectWithoutUsers_goiInput | threads_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: threads_goiUpsertWithWhereUniqueWithoutUsers_goiInput | threads_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: threads_goiCreateManyUsers_goiInputEnvelope
    set?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
    disconnect?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
    delete?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
    connect?: threads_goiWhereUniqueInput | threads_goiWhereUniqueInput[]
    update?: threads_goiUpdateWithWhereUniqueWithoutUsers_goiInput | threads_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: threads_goiUpdateManyWithWhereWithoutUsers_goiInput | threads_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: threads_goiScalarWhereInput | threads_goiScalarWhereInput[]
  }

  export type tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<tokens_generated_goiCreateWithoutUsers_goiInput, tokens_generated_goiUncheckedCreateWithoutUsers_goiInput> | tokens_generated_goiCreateWithoutUsers_goiInput[] | tokens_generated_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: tokens_generated_goiCreateOrConnectWithoutUsers_goiInput | tokens_generated_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: tokens_generated_goiUpsertWithWhereUniqueWithoutUsers_goiInput | tokens_generated_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: tokens_generated_goiCreateManyUsers_goiInputEnvelope
    set?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
    disconnect?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
    delete?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
    connect?: tokens_generated_goiWhereUniqueInput | tokens_generated_goiWhereUniqueInput[]
    update?: tokens_generated_goiUpdateWithWhereUniqueWithoutUsers_goiInput | tokens_generated_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: tokens_generated_goiUpdateManyWithWhereWithoutUsers_goiInput | tokens_generated_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: tokens_generated_goiScalarWhereInput | tokens_generated_goiScalarWhereInput[]
  }

  export type trainings_links_goiUncheckedUpdateManyWithoutUsers_goiNestedInput = {
    create?: XOR<trainings_links_goiCreateWithoutUsers_goiInput, trainings_links_goiUncheckedCreateWithoutUsers_goiInput> | trainings_links_goiCreateWithoutUsers_goiInput[] | trainings_links_goiUncheckedCreateWithoutUsers_goiInput[]
    connectOrCreate?: trainings_links_goiCreateOrConnectWithoutUsers_goiInput | trainings_links_goiCreateOrConnectWithoutUsers_goiInput[]
    upsert?: trainings_links_goiUpsertWithWhereUniqueWithoutUsers_goiInput | trainings_links_goiUpsertWithWhereUniqueWithoutUsers_goiInput[]
    createMany?: trainings_links_goiCreateManyUsers_goiInputEnvelope
    set?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
    disconnect?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
    delete?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
    connect?: trainings_links_goiWhereUniqueInput | trainings_links_goiWhereUniqueInput[]
    update?: trainings_links_goiUpdateWithWhereUniqueWithoutUsers_goiInput | trainings_links_goiUpdateWithWhereUniqueWithoutUsers_goiInput[]
    updateMany?: trainings_links_goiUpdateManyWithWhereWithoutUsers_goiInput | trainings_links_goiUpdateManyWithWhereWithoutUsers_goiInput[]
    deleteMany?: trainings_links_goiScalarWhereInput | trainings_links_goiScalarWhereInput[]
  }

  export type budget_consults_spaCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<budget_consults_spaCreateWithoutUsers_spaInput, budget_consults_spaUncheckedCreateWithoutUsers_spaInput> | budget_consults_spaCreateWithoutUsers_spaInput[] | budget_consults_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: budget_consults_spaCreateOrConnectWithoutUsers_spaInput | budget_consults_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: budget_consults_spaCreateManyUsers_spaInputEnvelope
    connect?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
  }

  export type cpf_consults_spaCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<cpf_consults_spaCreateWithoutUsers_spaInput, cpf_consults_spaUncheckedCreateWithoutUsers_spaInput> | cpf_consults_spaCreateWithoutUsers_spaInput[] | cpf_consults_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: cpf_consults_spaCreateOrConnectWithoutUsers_spaInput | cpf_consults_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: cpf_consults_spaCreateManyUsers_spaInputEnvelope
    connect?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
  }

  export type quote_calculations_spaCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<quote_calculations_spaCreateWithoutUsers_spaInput, quote_calculations_spaUncheckedCreateWithoutUsers_spaInput> | quote_calculations_spaCreateWithoutUsers_spaInput[] | quote_calculations_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: quote_calculations_spaCreateOrConnectWithoutUsers_spaInput | quote_calculations_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: quote_calculations_spaCreateManyUsers_spaInputEnvelope
    connect?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
  }

  export type sessions_spaCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<sessions_spaCreateWithoutUsers_spaInput, sessions_spaUncheckedCreateWithoutUsers_spaInput> | sessions_spaCreateWithoutUsers_spaInput[] | sessions_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: sessions_spaCreateOrConnectWithoutUsers_spaInput | sessions_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: sessions_spaCreateManyUsers_spaInputEnvelope
    connect?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
  }

  export type threads_spaCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<threads_spaCreateWithoutUsers_spaInput, threads_spaUncheckedCreateWithoutUsers_spaInput> | threads_spaCreateWithoutUsers_spaInput[] | threads_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: threads_spaCreateOrConnectWithoutUsers_spaInput | threads_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: threads_spaCreateManyUsers_spaInputEnvelope
    connect?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
  }

  export type tokens_generated_spaCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<tokens_generated_spaCreateWithoutUsers_spaInput, tokens_generated_spaUncheckedCreateWithoutUsers_spaInput> | tokens_generated_spaCreateWithoutUsers_spaInput[] | tokens_generated_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: tokens_generated_spaCreateOrConnectWithoutUsers_spaInput | tokens_generated_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: tokens_generated_spaCreateManyUsers_spaInputEnvelope
    connect?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
  }

  export type trainings_links_spaCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<trainings_links_spaCreateWithoutUsers_spaInput, trainings_links_spaUncheckedCreateWithoutUsers_spaInput> | trainings_links_spaCreateWithoutUsers_spaInput[] | trainings_links_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: trainings_links_spaCreateOrConnectWithoutUsers_spaInput | trainings_links_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: trainings_links_spaCreateManyUsers_spaInputEnvelope
    connect?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
  }

  export type budget_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<budget_consults_spaCreateWithoutUsers_spaInput, budget_consults_spaUncheckedCreateWithoutUsers_spaInput> | budget_consults_spaCreateWithoutUsers_spaInput[] | budget_consults_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: budget_consults_spaCreateOrConnectWithoutUsers_spaInput | budget_consults_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: budget_consults_spaCreateManyUsers_spaInputEnvelope
    connect?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
  }

  export type cpf_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<cpf_consults_spaCreateWithoutUsers_spaInput, cpf_consults_spaUncheckedCreateWithoutUsers_spaInput> | cpf_consults_spaCreateWithoutUsers_spaInput[] | cpf_consults_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: cpf_consults_spaCreateOrConnectWithoutUsers_spaInput | cpf_consults_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: cpf_consults_spaCreateManyUsers_spaInputEnvelope
    connect?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
  }

  export type quote_calculations_spaUncheckedCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<quote_calculations_spaCreateWithoutUsers_spaInput, quote_calculations_spaUncheckedCreateWithoutUsers_spaInput> | quote_calculations_spaCreateWithoutUsers_spaInput[] | quote_calculations_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: quote_calculations_spaCreateOrConnectWithoutUsers_spaInput | quote_calculations_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: quote_calculations_spaCreateManyUsers_spaInputEnvelope
    connect?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
  }

  export type sessions_spaUncheckedCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<sessions_spaCreateWithoutUsers_spaInput, sessions_spaUncheckedCreateWithoutUsers_spaInput> | sessions_spaCreateWithoutUsers_spaInput[] | sessions_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: sessions_spaCreateOrConnectWithoutUsers_spaInput | sessions_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: sessions_spaCreateManyUsers_spaInputEnvelope
    connect?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
  }

  export type threads_spaUncheckedCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<threads_spaCreateWithoutUsers_spaInput, threads_spaUncheckedCreateWithoutUsers_spaInput> | threads_spaCreateWithoutUsers_spaInput[] | threads_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: threads_spaCreateOrConnectWithoutUsers_spaInput | threads_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: threads_spaCreateManyUsers_spaInputEnvelope
    connect?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
  }

  export type tokens_generated_spaUncheckedCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<tokens_generated_spaCreateWithoutUsers_spaInput, tokens_generated_spaUncheckedCreateWithoutUsers_spaInput> | tokens_generated_spaCreateWithoutUsers_spaInput[] | tokens_generated_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: tokens_generated_spaCreateOrConnectWithoutUsers_spaInput | tokens_generated_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: tokens_generated_spaCreateManyUsers_spaInputEnvelope
    connect?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
  }

  export type trainings_links_spaUncheckedCreateNestedManyWithoutUsers_spaInput = {
    create?: XOR<trainings_links_spaCreateWithoutUsers_spaInput, trainings_links_spaUncheckedCreateWithoutUsers_spaInput> | trainings_links_spaCreateWithoutUsers_spaInput[] | trainings_links_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: trainings_links_spaCreateOrConnectWithoutUsers_spaInput | trainings_links_spaCreateOrConnectWithoutUsers_spaInput[]
    createMany?: trainings_links_spaCreateManyUsers_spaInputEnvelope
    connect?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
  }

  export type budget_consults_spaUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<budget_consults_spaCreateWithoutUsers_spaInput, budget_consults_spaUncheckedCreateWithoutUsers_spaInput> | budget_consults_spaCreateWithoutUsers_spaInput[] | budget_consults_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: budget_consults_spaCreateOrConnectWithoutUsers_spaInput | budget_consults_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: budget_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput | budget_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: budget_consults_spaCreateManyUsers_spaInputEnvelope
    set?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
    disconnect?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
    delete?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
    connect?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
    update?: budget_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput | budget_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: budget_consults_spaUpdateManyWithWhereWithoutUsers_spaInput | budget_consults_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: budget_consults_spaScalarWhereInput | budget_consults_spaScalarWhereInput[]
  }

  export type cpf_consults_spaUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<cpf_consults_spaCreateWithoutUsers_spaInput, cpf_consults_spaUncheckedCreateWithoutUsers_spaInput> | cpf_consults_spaCreateWithoutUsers_spaInput[] | cpf_consults_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: cpf_consults_spaCreateOrConnectWithoutUsers_spaInput | cpf_consults_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: cpf_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput | cpf_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: cpf_consults_spaCreateManyUsers_spaInputEnvelope
    set?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
    disconnect?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
    delete?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
    connect?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
    update?: cpf_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput | cpf_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: cpf_consults_spaUpdateManyWithWhereWithoutUsers_spaInput | cpf_consults_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: cpf_consults_spaScalarWhereInput | cpf_consults_spaScalarWhereInput[]
  }

  export type quote_calculations_spaUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<quote_calculations_spaCreateWithoutUsers_spaInput, quote_calculations_spaUncheckedCreateWithoutUsers_spaInput> | quote_calculations_spaCreateWithoutUsers_spaInput[] | quote_calculations_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: quote_calculations_spaCreateOrConnectWithoutUsers_spaInput | quote_calculations_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: quote_calculations_spaUpsertWithWhereUniqueWithoutUsers_spaInput | quote_calculations_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: quote_calculations_spaCreateManyUsers_spaInputEnvelope
    set?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
    disconnect?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
    delete?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
    connect?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
    update?: quote_calculations_spaUpdateWithWhereUniqueWithoutUsers_spaInput | quote_calculations_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: quote_calculations_spaUpdateManyWithWhereWithoutUsers_spaInput | quote_calculations_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: quote_calculations_spaScalarWhereInput | quote_calculations_spaScalarWhereInput[]
  }

  export type sessions_spaUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<sessions_spaCreateWithoutUsers_spaInput, sessions_spaUncheckedCreateWithoutUsers_spaInput> | sessions_spaCreateWithoutUsers_spaInput[] | sessions_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: sessions_spaCreateOrConnectWithoutUsers_spaInput | sessions_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: sessions_spaUpsertWithWhereUniqueWithoutUsers_spaInput | sessions_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: sessions_spaCreateManyUsers_spaInputEnvelope
    set?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
    disconnect?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
    delete?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
    connect?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
    update?: sessions_spaUpdateWithWhereUniqueWithoutUsers_spaInput | sessions_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: sessions_spaUpdateManyWithWhereWithoutUsers_spaInput | sessions_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: sessions_spaScalarWhereInput | sessions_spaScalarWhereInput[]
  }

  export type threads_spaUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<threads_spaCreateWithoutUsers_spaInput, threads_spaUncheckedCreateWithoutUsers_spaInput> | threads_spaCreateWithoutUsers_spaInput[] | threads_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: threads_spaCreateOrConnectWithoutUsers_spaInput | threads_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: threads_spaUpsertWithWhereUniqueWithoutUsers_spaInput | threads_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: threads_spaCreateManyUsers_spaInputEnvelope
    set?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
    disconnect?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
    delete?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
    connect?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
    update?: threads_spaUpdateWithWhereUniqueWithoutUsers_spaInput | threads_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: threads_spaUpdateManyWithWhereWithoutUsers_spaInput | threads_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: threads_spaScalarWhereInput | threads_spaScalarWhereInput[]
  }

  export type tokens_generated_spaUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<tokens_generated_spaCreateWithoutUsers_spaInput, tokens_generated_spaUncheckedCreateWithoutUsers_spaInput> | tokens_generated_spaCreateWithoutUsers_spaInput[] | tokens_generated_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: tokens_generated_spaCreateOrConnectWithoutUsers_spaInput | tokens_generated_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: tokens_generated_spaUpsertWithWhereUniqueWithoutUsers_spaInput | tokens_generated_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: tokens_generated_spaCreateManyUsers_spaInputEnvelope
    set?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
    disconnect?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
    delete?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
    connect?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
    update?: tokens_generated_spaUpdateWithWhereUniqueWithoutUsers_spaInput | tokens_generated_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: tokens_generated_spaUpdateManyWithWhereWithoutUsers_spaInput | tokens_generated_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: tokens_generated_spaScalarWhereInput | tokens_generated_spaScalarWhereInput[]
  }

  export type trainings_links_spaUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<trainings_links_spaCreateWithoutUsers_spaInput, trainings_links_spaUncheckedCreateWithoutUsers_spaInput> | trainings_links_spaCreateWithoutUsers_spaInput[] | trainings_links_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: trainings_links_spaCreateOrConnectWithoutUsers_spaInput | trainings_links_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: trainings_links_spaUpsertWithWhereUniqueWithoutUsers_spaInput | trainings_links_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: trainings_links_spaCreateManyUsers_spaInputEnvelope
    set?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
    disconnect?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
    delete?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
    connect?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
    update?: trainings_links_spaUpdateWithWhereUniqueWithoutUsers_spaInput | trainings_links_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: trainings_links_spaUpdateManyWithWhereWithoutUsers_spaInput | trainings_links_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: trainings_links_spaScalarWhereInput | trainings_links_spaScalarWhereInput[]
  }

  export type budget_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<budget_consults_spaCreateWithoutUsers_spaInput, budget_consults_spaUncheckedCreateWithoutUsers_spaInput> | budget_consults_spaCreateWithoutUsers_spaInput[] | budget_consults_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: budget_consults_spaCreateOrConnectWithoutUsers_spaInput | budget_consults_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: budget_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput | budget_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: budget_consults_spaCreateManyUsers_spaInputEnvelope
    set?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
    disconnect?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
    delete?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
    connect?: budget_consults_spaWhereUniqueInput | budget_consults_spaWhereUniqueInput[]
    update?: budget_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput | budget_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: budget_consults_spaUpdateManyWithWhereWithoutUsers_spaInput | budget_consults_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: budget_consults_spaScalarWhereInput | budget_consults_spaScalarWhereInput[]
  }

  export type cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<cpf_consults_spaCreateWithoutUsers_spaInput, cpf_consults_spaUncheckedCreateWithoutUsers_spaInput> | cpf_consults_spaCreateWithoutUsers_spaInput[] | cpf_consults_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: cpf_consults_spaCreateOrConnectWithoutUsers_spaInput | cpf_consults_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: cpf_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput | cpf_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: cpf_consults_spaCreateManyUsers_spaInputEnvelope
    set?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
    disconnect?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
    delete?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
    connect?: cpf_consults_spaWhereUniqueInput | cpf_consults_spaWhereUniqueInput[]
    update?: cpf_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput | cpf_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: cpf_consults_spaUpdateManyWithWhereWithoutUsers_spaInput | cpf_consults_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: cpf_consults_spaScalarWhereInput | cpf_consults_spaScalarWhereInput[]
  }

  export type quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<quote_calculations_spaCreateWithoutUsers_spaInput, quote_calculations_spaUncheckedCreateWithoutUsers_spaInput> | quote_calculations_spaCreateWithoutUsers_spaInput[] | quote_calculations_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: quote_calculations_spaCreateOrConnectWithoutUsers_spaInput | quote_calculations_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: quote_calculations_spaUpsertWithWhereUniqueWithoutUsers_spaInput | quote_calculations_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: quote_calculations_spaCreateManyUsers_spaInputEnvelope
    set?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
    disconnect?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
    delete?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
    connect?: quote_calculations_spaWhereUniqueInput | quote_calculations_spaWhereUniqueInput[]
    update?: quote_calculations_spaUpdateWithWhereUniqueWithoutUsers_spaInput | quote_calculations_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: quote_calculations_spaUpdateManyWithWhereWithoutUsers_spaInput | quote_calculations_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: quote_calculations_spaScalarWhereInput | quote_calculations_spaScalarWhereInput[]
  }

  export type sessions_spaUncheckedUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<sessions_spaCreateWithoutUsers_spaInput, sessions_spaUncheckedCreateWithoutUsers_spaInput> | sessions_spaCreateWithoutUsers_spaInput[] | sessions_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: sessions_spaCreateOrConnectWithoutUsers_spaInput | sessions_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: sessions_spaUpsertWithWhereUniqueWithoutUsers_spaInput | sessions_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: sessions_spaCreateManyUsers_spaInputEnvelope
    set?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
    disconnect?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
    delete?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
    connect?: sessions_spaWhereUniqueInput | sessions_spaWhereUniqueInput[]
    update?: sessions_spaUpdateWithWhereUniqueWithoutUsers_spaInput | sessions_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: sessions_spaUpdateManyWithWhereWithoutUsers_spaInput | sessions_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: sessions_spaScalarWhereInput | sessions_spaScalarWhereInput[]
  }

  export type threads_spaUncheckedUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<threads_spaCreateWithoutUsers_spaInput, threads_spaUncheckedCreateWithoutUsers_spaInput> | threads_spaCreateWithoutUsers_spaInput[] | threads_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: threads_spaCreateOrConnectWithoutUsers_spaInput | threads_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: threads_spaUpsertWithWhereUniqueWithoutUsers_spaInput | threads_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: threads_spaCreateManyUsers_spaInputEnvelope
    set?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
    disconnect?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
    delete?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
    connect?: threads_spaWhereUniqueInput | threads_spaWhereUniqueInput[]
    update?: threads_spaUpdateWithWhereUniqueWithoutUsers_spaInput | threads_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: threads_spaUpdateManyWithWhereWithoutUsers_spaInput | threads_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: threads_spaScalarWhereInput | threads_spaScalarWhereInput[]
  }

  export type tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<tokens_generated_spaCreateWithoutUsers_spaInput, tokens_generated_spaUncheckedCreateWithoutUsers_spaInput> | tokens_generated_spaCreateWithoutUsers_spaInput[] | tokens_generated_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: tokens_generated_spaCreateOrConnectWithoutUsers_spaInput | tokens_generated_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: tokens_generated_spaUpsertWithWhereUniqueWithoutUsers_spaInput | tokens_generated_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: tokens_generated_spaCreateManyUsers_spaInputEnvelope
    set?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
    disconnect?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
    delete?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
    connect?: tokens_generated_spaWhereUniqueInput | tokens_generated_spaWhereUniqueInput[]
    update?: tokens_generated_spaUpdateWithWhereUniqueWithoutUsers_spaInput | tokens_generated_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: tokens_generated_spaUpdateManyWithWhereWithoutUsers_spaInput | tokens_generated_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: tokens_generated_spaScalarWhereInput | tokens_generated_spaScalarWhereInput[]
  }

  export type trainings_links_spaUncheckedUpdateManyWithoutUsers_spaNestedInput = {
    create?: XOR<trainings_links_spaCreateWithoutUsers_spaInput, trainings_links_spaUncheckedCreateWithoutUsers_spaInput> | trainings_links_spaCreateWithoutUsers_spaInput[] | trainings_links_spaUncheckedCreateWithoutUsers_spaInput[]
    connectOrCreate?: trainings_links_spaCreateOrConnectWithoutUsers_spaInput | trainings_links_spaCreateOrConnectWithoutUsers_spaInput[]
    upsert?: trainings_links_spaUpsertWithWhereUniqueWithoutUsers_spaInput | trainings_links_spaUpsertWithWhereUniqueWithoutUsers_spaInput[]
    createMany?: trainings_links_spaCreateManyUsers_spaInputEnvelope
    set?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
    disconnect?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
    delete?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
    connect?: trainings_links_spaWhereUniqueInput | trainings_links_spaWhereUniqueInput[]
    update?: trainings_links_spaUpdateWithWhereUniqueWithoutUsers_spaInput | trainings_links_spaUpdateWithWhereUniqueWithoutUsers_spaInput[]
    updateMany?: trainings_links_spaUpdateManyWithWhereWithoutUsers_spaInput | trainings_links_spaUpdateManyWithWhereWithoutUsers_spaInput[]
    deleteMany?: trainings_links_spaScalarWhereInput | trainings_links_spaScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type callsCreateWithoutAttendantInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type callsUncheckedCreateWithoutAttendantInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type callsCreateOrConnectWithoutAttendantInput = {
    where: callsWhereUniqueInput
    create: XOR<callsCreateWithoutAttendantInput, callsUncheckedCreateWithoutAttendantInput>
  }

  export type callsCreateManyAttendantInputEnvelope = {
    data: callsCreateManyAttendantInput | callsCreateManyAttendantInput[]
    skipDuplicates?: boolean
  }

  export type callsUpsertWithWhereUniqueWithoutAttendantInput = {
    where: callsWhereUniqueInput
    update: XOR<callsUpdateWithoutAttendantInput, callsUncheckedUpdateWithoutAttendantInput>
    create: XOR<callsCreateWithoutAttendantInput, callsUncheckedCreateWithoutAttendantInput>
  }

  export type callsUpdateWithWhereUniqueWithoutAttendantInput = {
    where: callsWhereUniqueInput
    data: XOR<callsUpdateWithoutAttendantInput, callsUncheckedUpdateWithoutAttendantInput>
  }

  export type callsUpdateManyWithWhereWithoutAttendantInput = {
    where: callsScalarWhereInput
    data: XOR<callsUpdateManyMutationInput, callsUncheckedUpdateManyWithoutAttendantInput>
  }

  export type callsScalarWhereInput = {
    AND?: callsScalarWhereInput | callsScalarWhereInput[]
    OR?: callsScalarWhereInput[]
    NOT?: callsScalarWhereInput | callsScalarWhereInput[]
    id?: StringFilter<"calls"> | string
    jid?: StringFilter<"calls"> | string
    mainProblem?: StringFilter<"calls"> | string
    detailsProblem?: StringFilter<"calls"> | string
    pushName?: StringFilter<"calls"> | string
    attendantId?: StringNullableFilter<"calls"> | string | null
    isResolved?: BoolFilter<"calls"> | boolean
    createdAt?: DateTimeFilter<"calls"> | Date | string
    updatedAt?: DateTimeFilter<"calls"> | Date | string
  }

  export type attendantsCreateWithoutAttendant_callsInput = {
    id: string
    jid: string
    name: string
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendantsUncheckedCreateWithoutAttendant_callsInput = {
    id: string
    jid: string
    name: string
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendantsCreateOrConnectWithoutAttendant_callsInput = {
    where: attendantsWhereUniqueInput
    create: XOR<attendantsCreateWithoutAttendant_callsInput, attendantsUncheckedCreateWithoutAttendant_callsInput>
  }

  export type attendantsUpsertWithoutAttendant_callsInput = {
    update: XOR<attendantsUpdateWithoutAttendant_callsInput, attendantsUncheckedUpdateWithoutAttendant_callsInput>
    create: XOR<attendantsCreateWithoutAttendant_callsInput, attendantsUncheckedCreateWithoutAttendant_callsInput>
    where?: attendantsWhereInput
  }

  export type attendantsUpdateToOneWithWhereWithoutAttendant_callsInput = {
    where?: attendantsWhereInput
    data: XOR<attendantsUpdateWithoutAttendant_callsInput, attendantsUncheckedUpdateWithoutAttendant_callsInput>
  }

  export type attendantsUpdateWithoutAttendant_callsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendantsUncheckedUpdateWithoutAttendant_callsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendant_callsCreateWithoutAttendantsInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendant_callsUncheckedCreateWithoutAttendantsInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendant_callsCreateOrConnectWithoutAttendantsInput = {
    where: attendant_callsWhereUniqueInput
    create: XOR<attendant_callsCreateWithoutAttendantsInput, attendant_callsUncheckedCreateWithoutAttendantsInput>
  }

  export type attendant_callsCreateManyAttendantsInputEnvelope = {
    data: attendant_callsCreateManyAttendantsInput | attendant_callsCreateManyAttendantsInput[]
    skipDuplicates?: boolean
  }

  export type attendant_callsUpsertWithWhereUniqueWithoutAttendantsInput = {
    where: attendant_callsWhereUniqueInput
    update: XOR<attendant_callsUpdateWithoutAttendantsInput, attendant_callsUncheckedUpdateWithoutAttendantsInput>
    create: XOR<attendant_callsCreateWithoutAttendantsInput, attendant_callsUncheckedCreateWithoutAttendantsInput>
  }

  export type attendant_callsUpdateWithWhereUniqueWithoutAttendantsInput = {
    where: attendant_callsWhereUniqueInput
    data: XOR<attendant_callsUpdateWithoutAttendantsInput, attendant_callsUncheckedUpdateWithoutAttendantsInput>
  }

  export type attendant_callsUpdateManyWithWhereWithoutAttendantsInput = {
    where: attendant_callsScalarWhereInput
    data: XOR<attendant_callsUpdateManyMutationInput, attendant_callsUncheckedUpdateManyWithoutAttendantsInput>
  }

  export type attendant_callsScalarWhereInput = {
    AND?: attendant_callsScalarWhereInput | attendant_callsScalarWhereInput[]
    OR?: attendant_callsScalarWhereInput[]
    NOT?: attendant_callsScalarWhereInput | attendant_callsScalarWhereInput[]
    id?: StringFilter<"attendant_calls"> | string
    jid?: StringFilter<"attendant_calls"> | string
    mainProblem?: StringFilter<"attendant_calls"> | string
    detailsProblem?: StringFilter<"attendant_calls"> | string
    pushName?: StringFilter<"attendant_calls"> | string
    attendantId?: StringNullableFilter<"attendant_calls"> | string | null
    isResolved?: BoolFilter<"attendant_calls"> | boolean
    createdAt?: DateTimeFilter<"attendant_calls"> | Date | string
    updatedAt?: DateTimeFilter<"attendant_calls"> | Date | string
  }

  export type users_autCreateWithoutBudget_consults_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf_consults_aut?: cpf_consults_autCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUncheckedCreateWithoutBudget_consults_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf_consults_aut?: cpf_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autUncheckedCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autUncheckedCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autUncheckedCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autUncheckedCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autUncheckedCreateNestedManyWithoutUsers_autInput
  }

  export type users_autCreateOrConnectWithoutBudget_consults_autInput = {
    where: users_autWhereUniqueInput
    create: XOR<users_autCreateWithoutBudget_consults_autInput, users_autUncheckedCreateWithoutBudget_consults_autInput>
  }

  export type users_autUpsertWithoutBudget_consults_autInput = {
    update: XOR<users_autUpdateWithoutBudget_consults_autInput, users_autUncheckedUpdateWithoutBudget_consults_autInput>
    create: XOR<users_autCreateWithoutBudget_consults_autInput, users_autUncheckedCreateWithoutBudget_consults_autInput>
    where?: users_autWhereInput
  }

  export type users_autUpdateToOneWithWhereWithoutBudget_consults_autInput = {
    where?: users_autWhereInput
    data: XOR<users_autUpdateWithoutBudget_consults_autInput, users_autUncheckedUpdateWithoutBudget_consults_autInput>
  }

  export type users_autUpdateWithoutBudget_consults_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf_consults_aut?: cpf_consults_autUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autUncheckedUpdateWithoutBudget_consults_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf_consults_aut?: cpf_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUncheckedUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUncheckedUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUncheckedUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUncheckedUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUncheckedUpdateManyWithoutUsers_autNestedInput
  }

  export type users_cltCreateWithoutBudget_consults_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf_consults_clt?: cpf_consults_cltCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUncheckedCreateWithoutBudget_consults_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf_consults_clt?: cpf_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltUncheckedCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltCreateOrConnectWithoutBudget_consults_cltInput = {
    where: users_cltWhereUniqueInput
    create: XOR<users_cltCreateWithoutBudget_consults_cltInput, users_cltUncheckedCreateWithoutBudget_consults_cltInput>
  }

  export type users_cltUpsertWithoutBudget_consults_cltInput = {
    update: XOR<users_cltUpdateWithoutBudget_consults_cltInput, users_cltUncheckedUpdateWithoutBudget_consults_cltInput>
    create: XOR<users_cltCreateWithoutBudget_consults_cltInput, users_cltUncheckedCreateWithoutBudget_consults_cltInput>
    where?: users_cltWhereInput
  }

  export type users_cltUpdateToOneWithWhereWithoutBudget_consults_cltInput = {
    where?: users_cltWhereInput
    data: XOR<users_cltUpdateWithoutBudget_consults_cltInput, users_cltUncheckedUpdateWithoutBudget_consults_cltInput>
  }

  export type users_cltUpdateWithoutBudget_consults_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf_consults_clt?: cpf_consults_cltUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltUncheckedUpdateWithoutBudget_consults_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf_consults_clt?: cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_goiCreateWithoutBudget_consults_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf_consults_goi?: cpf_consults_goiCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUncheckedCreateWithoutBudget_consults_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf_consults_goi?: cpf_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiUncheckedCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiCreateOrConnectWithoutBudget_consults_goiInput = {
    where: users_goiWhereUniqueInput
    create: XOR<users_goiCreateWithoutBudget_consults_goiInput, users_goiUncheckedCreateWithoutBudget_consults_goiInput>
  }

  export type users_goiUpsertWithoutBudget_consults_goiInput = {
    update: XOR<users_goiUpdateWithoutBudget_consults_goiInput, users_goiUncheckedUpdateWithoutBudget_consults_goiInput>
    create: XOR<users_goiCreateWithoutBudget_consults_goiInput, users_goiUncheckedCreateWithoutBudget_consults_goiInput>
    where?: users_goiWhereInput
  }

  export type users_goiUpdateToOneWithWhereWithoutBudget_consults_goiInput = {
    where?: users_goiWhereInput
    data: XOR<users_goiUpdateWithoutBudget_consults_goiInput, users_goiUncheckedUpdateWithoutBudget_consults_goiInput>
  }

  export type users_goiUpdateWithoutBudget_consults_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf_consults_goi?: cpf_consults_goiUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiUncheckedUpdateWithoutBudget_consults_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf_consults_goi?: cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_spaCreateWithoutBudget_consults_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf_consults_spa?: cpf_consults_spaCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUncheckedCreateWithoutBudget_consults_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf_consults_spa?: cpf_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaUncheckedCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaCreateOrConnectWithoutBudget_consults_spaInput = {
    where: users_spaWhereUniqueInput
    create: XOR<users_spaCreateWithoutBudget_consults_spaInput, users_spaUncheckedCreateWithoutBudget_consults_spaInput>
  }

  export type users_spaUpsertWithoutBudget_consults_spaInput = {
    update: XOR<users_spaUpdateWithoutBudget_consults_spaInput, users_spaUncheckedUpdateWithoutBudget_consults_spaInput>
    create: XOR<users_spaCreateWithoutBudget_consults_spaInput, users_spaUncheckedCreateWithoutBudget_consults_spaInput>
    where?: users_spaWhereInput
  }

  export type users_spaUpdateToOneWithWhereWithoutBudget_consults_spaInput = {
    where?: users_spaWhereInput
    data: XOR<users_spaUpdateWithoutBudget_consults_spaInput, users_spaUncheckedUpdateWithoutBudget_consults_spaInput>
  }

  export type users_spaUpdateWithoutBudget_consults_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf_consults_spa?: cpf_consults_spaUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaUncheckedUpdateWithoutBudget_consults_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf_consults_spa?: cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
  }

  export type attendantCreateWithoutCallsInput = {
    id: string
    jid: string
    name: string
    password: string
    token?: string | null
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendantUncheckedCreateWithoutCallsInput = {
    id: string
    jid: string
    name: string
    password: string
    token?: string | null
    isAdmin: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendantCreateOrConnectWithoutCallsInput = {
    where: attendantWhereUniqueInput
    create: XOR<attendantCreateWithoutCallsInput, attendantUncheckedCreateWithoutCallsInput>
  }

  export type attendantUpsertWithoutCallsInput = {
    update: XOR<attendantUpdateWithoutCallsInput, attendantUncheckedUpdateWithoutCallsInput>
    create: XOR<attendantCreateWithoutCallsInput, attendantUncheckedCreateWithoutCallsInput>
    where?: attendantWhereInput
  }

  export type attendantUpdateToOneWithWhereWithoutCallsInput = {
    where?: attendantWhereInput
    data: XOR<attendantUpdateWithoutCallsInput, attendantUncheckedUpdateWithoutCallsInput>
  }

  export type attendantUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendantUncheckedUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_autCreateWithoutCpf_consults_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUncheckedCreateWithoutCpf_consults_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autUncheckedCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autUncheckedCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autUncheckedCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autUncheckedCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autUncheckedCreateNestedManyWithoutUsers_autInput
  }

  export type users_autCreateOrConnectWithoutCpf_consults_autInput = {
    where: users_autWhereUniqueInput
    create: XOR<users_autCreateWithoutCpf_consults_autInput, users_autUncheckedCreateWithoutCpf_consults_autInput>
  }

  export type users_autUpsertWithoutCpf_consults_autInput = {
    update: XOR<users_autUpdateWithoutCpf_consults_autInput, users_autUncheckedUpdateWithoutCpf_consults_autInput>
    create: XOR<users_autCreateWithoutCpf_consults_autInput, users_autUncheckedCreateWithoutCpf_consults_autInput>
    where?: users_autWhereInput
  }

  export type users_autUpdateToOneWithWhereWithoutCpf_consults_autInput = {
    where?: users_autWhereInput
    data: XOR<users_autUpdateWithoutCpf_consults_autInput, users_autUncheckedUpdateWithoutCpf_consults_autInput>
  }

  export type users_autUpdateWithoutCpf_consults_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autUncheckedUpdateWithoutCpf_consults_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUncheckedUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUncheckedUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUncheckedUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUncheckedUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUncheckedUpdateManyWithoutUsers_autNestedInput
  }

  export type users_cltCreateWithoutCpf_consults_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUncheckedCreateWithoutCpf_consults_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltUncheckedCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltCreateOrConnectWithoutCpf_consults_cltInput = {
    where: users_cltWhereUniqueInput
    create: XOR<users_cltCreateWithoutCpf_consults_cltInput, users_cltUncheckedCreateWithoutCpf_consults_cltInput>
  }

  export type users_cltUpsertWithoutCpf_consults_cltInput = {
    update: XOR<users_cltUpdateWithoutCpf_consults_cltInput, users_cltUncheckedUpdateWithoutCpf_consults_cltInput>
    create: XOR<users_cltCreateWithoutCpf_consults_cltInput, users_cltUncheckedCreateWithoutCpf_consults_cltInput>
    where?: users_cltWhereInput
  }

  export type users_cltUpdateToOneWithWhereWithoutCpf_consults_cltInput = {
    where?: users_cltWhereInput
    data: XOR<users_cltUpdateWithoutCpf_consults_cltInput, users_cltUncheckedUpdateWithoutCpf_consults_cltInput>
  }

  export type users_cltUpdateWithoutCpf_consults_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltUncheckedUpdateWithoutCpf_consults_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_goiCreateWithoutCpf_consults_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUncheckedCreateWithoutCpf_consults_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiUncheckedCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiCreateOrConnectWithoutCpf_consults_goiInput = {
    where: users_goiWhereUniqueInput
    create: XOR<users_goiCreateWithoutCpf_consults_goiInput, users_goiUncheckedCreateWithoutCpf_consults_goiInput>
  }

  export type users_goiUpsertWithoutCpf_consults_goiInput = {
    update: XOR<users_goiUpdateWithoutCpf_consults_goiInput, users_goiUncheckedUpdateWithoutCpf_consults_goiInput>
    create: XOR<users_goiCreateWithoutCpf_consults_goiInput, users_goiUncheckedCreateWithoutCpf_consults_goiInput>
    where?: users_goiWhereInput
  }

  export type users_goiUpdateToOneWithWhereWithoutCpf_consults_goiInput = {
    where?: users_goiWhereInput
    data: XOR<users_goiUpdateWithoutCpf_consults_goiInput, users_goiUncheckedUpdateWithoutCpf_consults_goiInput>
  }

  export type users_goiUpdateWithoutCpf_consults_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiUncheckedUpdateWithoutCpf_consults_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_spaCreateWithoutCpf_consults_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUncheckedCreateWithoutCpf_consults_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaUncheckedCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaCreateOrConnectWithoutCpf_consults_spaInput = {
    where: users_spaWhereUniqueInput
    create: XOR<users_spaCreateWithoutCpf_consults_spaInput, users_spaUncheckedCreateWithoutCpf_consults_spaInput>
  }

  export type users_spaUpsertWithoutCpf_consults_spaInput = {
    update: XOR<users_spaUpdateWithoutCpf_consults_spaInput, users_spaUncheckedUpdateWithoutCpf_consults_spaInput>
    create: XOR<users_spaCreateWithoutCpf_consults_spaInput, users_spaUncheckedCreateWithoutCpf_consults_spaInput>
    where?: users_spaWhereInput
  }

  export type users_spaUpdateToOneWithWhereWithoutCpf_consults_spaInput = {
    where?: users_spaWhereInput
    data: XOR<users_spaUpdateWithoutCpf_consults_spaInput, users_spaUncheckedUpdateWithoutCpf_consults_spaInput>
  }

  export type users_spaUpdateWithoutCpf_consults_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaUncheckedUpdateWithoutCpf_consults_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_autCreateWithoutQuote_calculations_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUncheckedCreateWithoutQuote_calculations_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autUncheckedCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autUncheckedCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autUncheckedCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autUncheckedCreateNestedManyWithoutUsers_autInput
  }

  export type users_autCreateOrConnectWithoutQuote_calculations_autInput = {
    where: users_autWhereUniqueInput
    create: XOR<users_autCreateWithoutQuote_calculations_autInput, users_autUncheckedCreateWithoutQuote_calculations_autInput>
  }

  export type users_autUpsertWithoutQuote_calculations_autInput = {
    update: XOR<users_autUpdateWithoutQuote_calculations_autInput, users_autUncheckedUpdateWithoutQuote_calculations_autInput>
    create: XOR<users_autCreateWithoutQuote_calculations_autInput, users_autUncheckedCreateWithoutQuote_calculations_autInput>
    where?: users_autWhereInput
  }

  export type users_autUpdateToOneWithWhereWithoutQuote_calculations_autInput = {
    where?: users_autWhereInput
    data: XOR<users_autUpdateWithoutQuote_calculations_autInput, users_autUncheckedUpdateWithoutQuote_calculations_autInput>
  }

  export type users_autUpdateWithoutQuote_calculations_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autUncheckedUpdateWithoutQuote_calculations_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUncheckedUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUncheckedUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUncheckedUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUncheckedUpdateManyWithoutUsers_autNestedInput
  }

  export type users_cltCreateWithoutQuote_calculations_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUncheckedCreateWithoutQuote_calculations_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltUncheckedCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltCreateOrConnectWithoutQuote_calculations_cltInput = {
    where: users_cltWhereUniqueInput
    create: XOR<users_cltCreateWithoutQuote_calculations_cltInput, users_cltUncheckedCreateWithoutQuote_calculations_cltInput>
  }

  export type users_cltUpsertWithoutQuote_calculations_cltInput = {
    update: XOR<users_cltUpdateWithoutQuote_calculations_cltInput, users_cltUncheckedUpdateWithoutQuote_calculations_cltInput>
    create: XOR<users_cltCreateWithoutQuote_calculations_cltInput, users_cltUncheckedCreateWithoutQuote_calculations_cltInput>
    where?: users_cltWhereInput
  }

  export type users_cltUpdateToOneWithWhereWithoutQuote_calculations_cltInput = {
    where?: users_cltWhereInput
    data: XOR<users_cltUpdateWithoutQuote_calculations_cltInput, users_cltUncheckedUpdateWithoutQuote_calculations_cltInput>
  }

  export type users_cltUpdateWithoutQuote_calculations_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltUncheckedUpdateWithoutQuote_calculations_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_goiCreateWithoutQuote_calculations_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUncheckedCreateWithoutQuote_calculations_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiUncheckedCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiCreateOrConnectWithoutQuote_calculations_goiInput = {
    where: users_goiWhereUniqueInput
    create: XOR<users_goiCreateWithoutQuote_calculations_goiInput, users_goiUncheckedCreateWithoutQuote_calculations_goiInput>
  }

  export type users_goiUpsertWithoutQuote_calculations_goiInput = {
    update: XOR<users_goiUpdateWithoutQuote_calculations_goiInput, users_goiUncheckedUpdateWithoutQuote_calculations_goiInput>
    create: XOR<users_goiCreateWithoutQuote_calculations_goiInput, users_goiUncheckedCreateWithoutQuote_calculations_goiInput>
    where?: users_goiWhereInput
  }

  export type users_goiUpdateToOneWithWhereWithoutQuote_calculations_goiInput = {
    where?: users_goiWhereInput
    data: XOR<users_goiUpdateWithoutQuote_calculations_goiInput, users_goiUncheckedUpdateWithoutQuote_calculations_goiInput>
  }

  export type users_goiUpdateWithoutQuote_calculations_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiUncheckedUpdateWithoutQuote_calculations_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_spaCreateWithoutQuote_calculations_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUncheckedCreateWithoutQuote_calculations_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaUncheckedCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaCreateOrConnectWithoutQuote_calculations_spaInput = {
    where: users_spaWhereUniqueInput
    create: XOR<users_spaCreateWithoutQuote_calculations_spaInput, users_spaUncheckedCreateWithoutQuote_calculations_spaInput>
  }

  export type users_spaUpsertWithoutQuote_calculations_spaInput = {
    update: XOR<users_spaUpdateWithoutQuote_calculations_spaInput, users_spaUncheckedUpdateWithoutQuote_calculations_spaInput>
    create: XOR<users_spaCreateWithoutQuote_calculations_spaInput, users_spaUncheckedCreateWithoutQuote_calculations_spaInput>
    where?: users_spaWhereInput
  }

  export type users_spaUpdateToOneWithWhereWithoutQuote_calculations_spaInput = {
    where?: users_spaWhereInput
    data: XOR<users_spaUpdateWithoutQuote_calculations_spaInput, users_spaUncheckedUpdateWithoutQuote_calculations_spaInput>
  }

  export type users_spaUpdateWithoutQuote_calculations_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaUncheckedUpdateWithoutQuote_calculations_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
  }

  export type rh_numbersCreateWithoutRh_callsInput = {
    id: string
    name: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type rh_numbersUncheckedCreateWithoutRh_callsInput = {
    id: string
    name: string
    phone_number: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type rh_numbersCreateOrConnectWithoutRh_callsInput = {
    where: rh_numbersWhereUniqueInput
    create: XOR<rh_numbersCreateWithoutRh_callsInput, rh_numbersUncheckedCreateWithoutRh_callsInput>
  }

  export type rh_numbersUpsertWithoutRh_callsInput = {
    update: XOR<rh_numbersUpdateWithoutRh_callsInput, rh_numbersUncheckedUpdateWithoutRh_callsInput>
    create: XOR<rh_numbersCreateWithoutRh_callsInput, rh_numbersUncheckedCreateWithoutRh_callsInput>
    where?: rh_numbersWhereInput
  }

  export type rh_numbersUpdateToOneWithWhereWithoutRh_callsInput = {
    where?: rh_numbersWhereInput
    data: XOR<rh_numbersUpdateWithoutRh_callsInput, rh_numbersUncheckedUpdateWithoutRh_callsInput>
  }

  export type rh_numbersUpdateWithoutRh_callsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rh_numbersUncheckedUpdateWithoutRh_callsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rh_callsCreateWithoutRh_numbersInput = {
    id: string
    jid: string
    name: string
    message: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type rh_callsUncheckedCreateWithoutRh_numbersInput = {
    id: string
    jid: string
    name: string
    message: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type rh_callsCreateOrConnectWithoutRh_numbersInput = {
    where: rh_callsWhereUniqueInput
    create: XOR<rh_callsCreateWithoutRh_numbersInput, rh_callsUncheckedCreateWithoutRh_numbersInput>
  }

  export type rh_callsCreateManyRh_numbersInputEnvelope = {
    data: rh_callsCreateManyRh_numbersInput | rh_callsCreateManyRh_numbersInput[]
    skipDuplicates?: boolean
  }

  export type rh_callsUpsertWithWhereUniqueWithoutRh_numbersInput = {
    where: rh_callsWhereUniqueInput
    update: XOR<rh_callsUpdateWithoutRh_numbersInput, rh_callsUncheckedUpdateWithoutRh_numbersInput>
    create: XOR<rh_callsCreateWithoutRh_numbersInput, rh_callsUncheckedCreateWithoutRh_numbersInput>
  }

  export type rh_callsUpdateWithWhereUniqueWithoutRh_numbersInput = {
    where: rh_callsWhereUniqueInput
    data: XOR<rh_callsUpdateWithoutRh_numbersInput, rh_callsUncheckedUpdateWithoutRh_numbersInput>
  }

  export type rh_callsUpdateManyWithWhereWithoutRh_numbersInput = {
    where: rh_callsScalarWhereInput
    data: XOR<rh_callsUpdateManyMutationInput, rh_callsUncheckedUpdateManyWithoutRh_numbersInput>
  }

  export type rh_callsScalarWhereInput = {
    AND?: rh_callsScalarWhereInput | rh_callsScalarWhereInput[]
    OR?: rh_callsScalarWhereInput[]
    NOT?: rh_callsScalarWhereInput | rh_callsScalarWhereInput[]
    id?: StringFilter<"rh_calls"> | string
    jid?: StringFilter<"rh_calls"> | string
    name?: StringFilter<"rh_calls"> | string
    message?: StringFilter<"rh_calls"> | string
    createdAt?: DateTimeFilter<"rh_calls"> | Date | string
    updatedAt?: DateTimeFilter<"rh_calls"> | Date | string
    rhNumberId?: StringNullableFilter<"rh_calls"> | string | null
  }

  export type users_autCreateWithoutSessions_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUncheckedCreateWithoutSessions_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autUncheckedCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autUncheckedCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autUncheckedCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autUncheckedCreateNestedManyWithoutUsers_autInput
  }

  export type users_autCreateOrConnectWithoutSessions_autInput = {
    where: users_autWhereUniqueInput
    create: XOR<users_autCreateWithoutSessions_autInput, users_autUncheckedCreateWithoutSessions_autInput>
  }

  export type users_autUpsertWithoutSessions_autInput = {
    update: XOR<users_autUpdateWithoutSessions_autInput, users_autUncheckedUpdateWithoutSessions_autInput>
    create: XOR<users_autCreateWithoutSessions_autInput, users_autUncheckedCreateWithoutSessions_autInput>
    where?: users_autWhereInput
  }

  export type users_autUpdateToOneWithWhereWithoutSessions_autInput = {
    where?: users_autWhereInput
    data: XOR<users_autUpdateWithoutSessions_autInput, users_autUncheckedUpdateWithoutSessions_autInput>
  }

  export type users_autUpdateWithoutSessions_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autUncheckedUpdateWithoutSessions_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUncheckedUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUncheckedUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUncheckedUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUncheckedUpdateManyWithoutUsers_autNestedInput
  }

  export type users_cltCreateWithoutSessions_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUncheckedCreateWithoutSessions_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltUncheckedCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltCreateOrConnectWithoutSessions_cltInput = {
    where: users_cltWhereUniqueInput
    create: XOR<users_cltCreateWithoutSessions_cltInput, users_cltUncheckedCreateWithoutSessions_cltInput>
  }

  export type users_cltUpsertWithoutSessions_cltInput = {
    update: XOR<users_cltUpdateWithoutSessions_cltInput, users_cltUncheckedUpdateWithoutSessions_cltInput>
    create: XOR<users_cltCreateWithoutSessions_cltInput, users_cltUncheckedCreateWithoutSessions_cltInput>
    where?: users_cltWhereInput
  }

  export type users_cltUpdateToOneWithWhereWithoutSessions_cltInput = {
    where?: users_cltWhereInput
    data: XOR<users_cltUpdateWithoutSessions_cltInput, users_cltUncheckedUpdateWithoutSessions_cltInput>
  }

  export type users_cltUpdateWithoutSessions_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltUncheckedUpdateWithoutSessions_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_goiCreateWithoutSessions_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUncheckedCreateWithoutSessions_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiUncheckedCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiCreateOrConnectWithoutSessions_goiInput = {
    where: users_goiWhereUniqueInput
    create: XOR<users_goiCreateWithoutSessions_goiInput, users_goiUncheckedCreateWithoutSessions_goiInput>
  }

  export type users_goiUpsertWithoutSessions_goiInput = {
    update: XOR<users_goiUpdateWithoutSessions_goiInput, users_goiUncheckedUpdateWithoutSessions_goiInput>
    create: XOR<users_goiCreateWithoutSessions_goiInput, users_goiUncheckedCreateWithoutSessions_goiInput>
    where?: users_goiWhereInput
  }

  export type users_goiUpdateToOneWithWhereWithoutSessions_goiInput = {
    where?: users_goiWhereInput
    data: XOR<users_goiUpdateWithoutSessions_goiInput, users_goiUncheckedUpdateWithoutSessions_goiInput>
  }

  export type users_goiUpdateWithoutSessions_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiUncheckedUpdateWithoutSessions_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_spaCreateWithoutSessions_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUncheckedCreateWithoutSessions_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaUncheckedCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaCreateOrConnectWithoutSessions_spaInput = {
    where: users_spaWhereUniqueInput
    create: XOR<users_spaCreateWithoutSessions_spaInput, users_spaUncheckedCreateWithoutSessions_spaInput>
  }

  export type users_spaUpsertWithoutSessions_spaInput = {
    update: XOR<users_spaUpdateWithoutSessions_spaInput, users_spaUncheckedUpdateWithoutSessions_spaInput>
    create: XOR<users_spaCreateWithoutSessions_spaInput, users_spaUncheckedCreateWithoutSessions_spaInput>
    where?: users_spaWhereInput
  }

  export type users_spaUpdateToOneWithWhereWithoutSessions_spaInput = {
    where?: users_spaWhereInput
    data: XOR<users_spaUpdateWithoutSessions_spaInput, users_spaUncheckedUpdateWithoutSessions_spaInput>
  }

  export type users_spaUpdateWithoutSessions_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaUncheckedUpdateWithoutSessions_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_autCreateWithoutThreads_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUncheckedCreateWithoutThreads_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autUncheckedCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autUncheckedCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autUncheckedCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autUncheckedCreateNestedManyWithoutUsers_autInput
  }

  export type users_autCreateOrConnectWithoutThreads_autInput = {
    where: users_autWhereUniqueInput
    create: XOR<users_autCreateWithoutThreads_autInput, users_autUncheckedCreateWithoutThreads_autInput>
  }

  export type users_autUpsertWithoutThreads_autInput = {
    update: XOR<users_autUpdateWithoutThreads_autInput, users_autUncheckedUpdateWithoutThreads_autInput>
    create: XOR<users_autCreateWithoutThreads_autInput, users_autUncheckedCreateWithoutThreads_autInput>
    where?: users_autWhereInput
  }

  export type users_autUpdateToOneWithWhereWithoutThreads_autInput = {
    where?: users_autWhereInput
    data: XOR<users_autUpdateWithoutThreads_autInput, users_autUncheckedUpdateWithoutThreads_autInput>
  }

  export type users_autUpdateWithoutThreads_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autUncheckedUpdateWithoutThreads_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUncheckedUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUncheckedUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUncheckedUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUncheckedUpdateManyWithoutUsers_autNestedInput
  }

  export type users_cltCreateWithoutThreads_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUncheckedCreateWithoutThreads_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltUncheckedCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltCreateOrConnectWithoutThreads_cltInput = {
    where: users_cltWhereUniqueInput
    create: XOR<users_cltCreateWithoutThreads_cltInput, users_cltUncheckedCreateWithoutThreads_cltInput>
  }

  export type users_cltUpsertWithoutThreads_cltInput = {
    update: XOR<users_cltUpdateWithoutThreads_cltInput, users_cltUncheckedUpdateWithoutThreads_cltInput>
    create: XOR<users_cltCreateWithoutThreads_cltInput, users_cltUncheckedCreateWithoutThreads_cltInput>
    where?: users_cltWhereInput
  }

  export type users_cltUpdateToOneWithWhereWithoutThreads_cltInput = {
    where?: users_cltWhereInput
    data: XOR<users_cltUpdateWithoutThreads_cltInput, users_cltUncheckedUpdateWithoutThreads_cltInput>
  }

  export type users_cltUpdateWithoutThreads_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltUncheckedUpdateWithoutThreads_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_goiCreateWithoutThreads_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUncheckedCreateWithoutThreads_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiUncheckedCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiCreateOrConnectWithoutThreads_goiInput = {
    where: users_goiWhereUniqueInput
    create: XOR<users_goiCreateWithoutThreads_goiInput, users_goiUncheckedCreateWithoutThreads_goiInput>
  }

  export type users_goiUpsertWithoutThreads_goiInput = {
    update: XOR<users_goiUpdateWithoutThreads_goiInput, users_goiUncheckedUpdateWithoutThreads_goiInput>
    create: XOR<users_goiCreateWithoutThreads_goiInput, users_goiUncheckedCreateWithoutThreads_goiInput>
    where?: users_goiWhereInput
  }

  export type users_goiUpdateToOneWithWhereWithoutThreads_goiInput = {
    where?: users_goiWhereInput
    data: XOR<users_goiUpdateWithoutThreads_goiInput, users_goiUncheckedUpdateWithoutThreads_goiInput>
  }

  export type users_goiUpdateWithoutThreads_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiUncheckedUpdateWithoutThreads_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_spaCreateWithoutThreads_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUncheckedCreateWithoutThreads_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaUncheckedCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaCreateOrConnectWithoutThreads_spaInput = {
    where: users_spaWhereUniqueInput
    create: XOR<users_spaCreateWithoutThreads_spaInput, users_spaUncheckedCreateWithoutThreads_spaInput>
  }

  export type users_spaUpsertWithoutThreads_spaInput = {
    update: XOR<users_spaUpdateWithoutThreads_spaInput, users_spaUncheckedUpdateWithoutThreads_spaInput>
    create: XOR<users_spaCreateWithoutThreads_spaInput, users_spaUncheckedCreateWithoutThreads_spaInput>
    where?: users_spaWhereInput
  }

  export type users_spaUpdateToOneWithWhereWithoutThreads_spaInput = {
    where?: users_spaWhereInput
    data: XOR<users_spaUpdateWithoutThreads_spaInput, users_spaUncheckedUpdateWithoutThreads_spaInput>
  }

  export type users_spaUpdateWithoutThreads_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaUncheckedUpdateWithoutThreads_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_autCreateWithoutTokens_generated_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUncheckedCreateWithoutTokens_generated_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autUncheckedCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autUncheckedCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autUncheckedCreateNestedManyWithoutUsers_autInput
    trainings_links_aut?: trainings_links_autUncheckedCreateNestedManyWithoutUsers_autInput
  }

  export type users_autCreateOrConnectWithoutTokens_generated_autInput = {
    where: users_autWhereUniqueInput
    create: XOR<users_autCreateWithoutTokens_generated_autInput, users_autUncheckedCreateWithoutTokens_generated_autInput>
  }

  export type users_autUpsertWithoutTokens_generated_autInput = {
    update: XOR<users_autUpdateWithoutTokens_generated_autInput, users_autUncheckedUpdateWithoutTokens_generated_autInput>
    create: XOR<users_autCreateWithoutTokens_generated_autInput, users_autUncheckedCreateWithoutTokens_generated_autInput>
    where?: users_autWhereInput
  }

  export type users_autUpdateToOneWithWhereWithoutTokens_generated_autInput = {
    where?: users_autWhereInput
    data: XOR<users_autUpdateWithoutTokens_generated_autInput, users_autUncheckedUpdateWithoutTokens_generated_autInput>
  }

  export type users_autUpdateWithoutTokens_generated_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autUncheckedUpdateWithoutTokens_generated_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUncheckedUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUncheckedUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUncheckedUpdateManyWithoutUsers_autNestedInput
    trainings_links_aut?: trainings_links_autUncheckedUpdateManyWithoutUsers_autNestedInput
  }

  export type users_cltCreateWithoutTokens_generated_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUncheckedCreateWithoutTokens_generated_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    trainings_links_clt?: trainings_links_cltUncheckedCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltCreateOrConnectWithoutTokens_generated_cltInput = {
    where: users_cltWhereUniqueInput
    create: XOR<users_cltCreateWithoutTokens_generated_cltInput, users_cltUncheckedCreateWithoutTokens_generated_cltInput>
  }

  export type users_cltUpsertWithoutTokens_generated_cltInput = {
    update: XOR<users_cltUpdateWithoutTokens_generated_cltInput, users_cltUncheckedUpdateWithoutTokens_generated_cltInput>
    create: XOR<users_cltCreateWithoutTokens_generated_cltInput, users_cltUncheckedCreateWithoutTokens_generated_cltInput>
    where?: users_cltWhereInput
  }

  export type users_cltUpdateToOneWithWhereWithoutTokens_generated_cltInput = {
    where?: users_cltWhereInput
    data: XOR<users_cltUpdateWithoutTokens_generated_cltInput, users_cltUncheckedUpdateWithoutTokens_generated_cltInput>
  }

  export type users_cltUpdateWithoutTokens_generated_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltUncheckedUpdateWithoutTokens_generated_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    trainings_links_clt?: trainings_links_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_goiCreateWithoutTokens_generated_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUncheckedCreateWithoutTokens_generated_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    trainings_links_goi?: trainings_links_goiUncheckedCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiCreateOrConnectWithoutTokens_generated_goiInput = {
    where: users_goiWhereUniqueInput
    create: XOR<users_goiCreateWithoutTokens_generated_goiInput, users_goiUncheckedCreateWithoutTokens_generated_goiInput>
  }

  export type users_goiUpsertWithoutTokens_generated_goiInput = {
    update: XOR<users_goiUpdateWithoutTokens_generated_goiInput, users_goiUncheckedUpdateWithoutTokens_generated_goiInput>
    create: XOR<users_goiCreateWithoutTokens_generated_goiInput, users_goiUncheckedCreateWithoutTokens_generated_goiInput>
    where?: users_goiWhereInput
  }

  export type users_goiUpdateToOneWithWhereWithoutTokens_generated_goiInput = {
    where?: users_goiWhereInput
    data: XOR<users_goiUpdateWithoutTokens_generated_goiInput, users_goiUncheckedUpdateWithoutTokens_generated_goiInput>
  }

  export type users_goiUpdateWithoutTokens_generated_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiUncheckedUpdateWithoutTokens_generated_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    trainings_links_goi?: trainings_links_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_spaCreateWithoutTokens_generated_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUncheckedCreateWithoutTokens_generated_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    trainings_links_spa?: trainings_links_spaUncheckedCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaCreateOrConnectWithoutTokens_generated_spaInput = {
    where: users_spaWhereUniqueInput
    create: XOR<users_spaCreateWithoutTokens_generated_spaInput, users_spaUncheckedCreateWithoutTokens_generated_spaInput>
  }

  export type users_spaUpsertWithoutTokens_generated_spaInput = {
    update: XOR<users_spaUpdateWithoutTokens_generated_spaInput, users_spaUncheckedUpdateWithoutTokens_generated_spaInput>
    create: XOR<users_spaCreateWithoutTokens_generated_spaInput, users_spaUncheckedCreateWithoutTokens_generated_spaInput>
    where?: users_spaWhereInput
  }

  export type users_spaUpdateToOneWithWhereWithoutTokens_generated_spaInput = {
    where?: users_spaWhereInput
    data: XOR<users_spaUpdateWithoutTokens_generated_spaInput, users_spaUncheckedUpdateWithoutTokens_generated_spaInput>
  }

  export type users_spaUpdateWithoutTokens_generated_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaUncheckedUpdateWithoutTokens_generated_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    trainings_links_spa?: trainings_links_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_autCreateWithoutTrainings_links_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autCreateNestedManyWithoutUsers_autInput
  }

  export type users_autUncheckedCreateWithoutTrainings_links_autInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_aut?: budget_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    cpf_consults_aut?: cpf_consults_autUncheckedCreateNestedManyWithoutUsers_autInput
    quote_calculations_aut?: quote_calculations_autUncheckedCreateNestedManyWithoutUsers_autInput
    sessions_aut?: sessions_autUncheckedCreateNestedManyWithoutUsers_autInput
    threads_aut?: threads_autUncheckedCreateNestedManyWithoutUsers_autInput
    tokens_generated_aut?: tokens_generated_autUncheckedCreateNestedManyWithoutUsers_autInput
  }

  export type users_autCreateOrConnectWithoutTrainings_links_autInput = {
    where: users_autWhereUniqueInput
    create: XOR<users_autCreateWithoutTrainings_links_autInput, users_autUncheckedCreateWithoutTrainings_links_autInput>
  }

  export type users_autUpsertWithoutTrainings_links_autInput = {
    update: XOR<users_autUpdateWithoutTrainings_links_autInput, users_autUncheckedUpdateWithoutTrainings_links_autInput>
    create: XOR<users_autCreateWithoutTrainings_links_autInput, users_autUncheckedCreateWithoutTrainings_links_autInput>
    where?: users_autWhereInput
  }

  export type users_autUpdateToOneWithWhereWithoutTrainings_links_autInput = {
    where?: users_autWhereInput
    data: XOR<users_autUpdateWithoutTrainings_links_autInput, users_autUncheckedUpdateWithoutTrainings_links_autInput>
  }

  export type users_autUpdateWithoutTrainings_links_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUpdateManyWithoutUsers_autNestedInput
  }

  export type users_autUncheckedUpdateWithoutTrainings_links_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_aut?: budget_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    cpf_consults_aut?: cpf_consults_autUncheckedUpdateManyWithoutUsers_autNestedInput
    quote_calculations_aut?: quote_calculations_autUncheckedUpdateManyWithoutUsers_autNestedInput
    sessions_aut?: sessions_autUncheckedUpdateManyWithoutUsers_autNestedInput
    threads_aut?: threads_autUncheckedUpdateManyWithoutUsers_autNestedInput
    tokens_generated_aut?: tokens_generated_autUncheckedUpdateManyWithoutUsers_autNestedInput
  }

  export type users_cltCreateWithoutTrainings_links_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltUncheckedCreateWithoutTrainings_links_cltInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_clt?: budget_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    cpf_consults_clt?: cpf_consults_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    quote_calculations_clt?: quote_calculations_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    sessions_clt?: sessions_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    threads_clt?: threads_cltUncheckedCreateNestedManyWithoutUsers_cltInput
    tokens_generated_clt?: tokens_generated_cltUncheckedCreateNestedManyWithoutUsers_cltInput
  }

  export type users_cltCreateOrConnectWithoutTrainings_links_cltInput = {
    where: users_cltWhereUniqueInput
    create: XOR<users_cltCreateWithoutTrainings_links_cltInput, users_cltUncheckedCreateWithoutTrainings_links_cltInput>
  }

  export type users_cltUpsertWithoutTrainings_links_cltInput = {
    update: XOR<users_cltUpdateWithoutTrainings_links_cltInput, users_cltUncheckedUpdateWithoutTrainings_links_cltInput>
    create: XOR<users_cltCreateWithoutTrainings_links_cltInput, users_cltUncheckedCreateWithoutTrainings_links_cltInput>
    where?: users_cltWhereInput
  }

  export type users_cltUpdateToOneWithWhereWithoutTrainings_links_cltInput = {
    where?: users_cltWhereInput
    data: XOR<users_cltUpdateWithoutTrainings_links_cltInput, users_cltUncheckedUpdateWithoutTrainings_links_cltInput>
  }

  export type users_cltUpdateWithoutTrainings_links_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_cltUncheckedUpdateWithoutTrainings_links_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_clt?: budget_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    cpf_consults_clt?: cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    quote_calculations_clt?: quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    sessions_clt?: sessions_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    threads_clt?: threads_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
    tokens_generated_clt?: tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltNestedInput
  }

  export type users_goiCreateWithoutTrainings_links_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiUncheckedCreateWithoutTrainings_links_goiInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_goi?: budget_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    cpf_consults_goi?: cpf_consults_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    quote_calculations_goi?: quote_calculations_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    sessions_goi?: sessions_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    threads_goi?: threads_goiUncheckedCreateNestedManyWithoutUsers_goiInput
    tokens_generated_goi?: tokens_generated_goiUncheckedCreateNestedManyWithoutUsers_goiInput
  }

  export type users_goiCreateOrConnectWithoutTrainings_links_goiInput = {
    where: users_goiWhereUniqueInput
    create: XOR<users_goiCreateWithoutTrainings_links_goiInput, users_goiUncheckedCreateWithoutTrainings_links_goiInput>
  }

  export type users_goiUpsertWithoutTrainings_links_goiInput = {
    update: XOR<users_goiUpdateWithoutTrainings_links_goiInput, users_goiUncheckedUpdateWithoutTrainings_links_goiInput>
    create: XOR<users_goiCreateWithoutTrainings_links_goiInput, users_goiUncheckedCreateWithoutTrainings_links_goiInput>
    where?: users_goiWhereInput
  }

  export type users_goiUpdateToOneWithWhereWithoutTrainings_links_goiInput = {
    where?: users_goiWhereInput
    data: XOR<users_goiUpdateWithoutTrainings_links_goiInput, users_goiUncheckedUpdateWithoutTrainings_links_goiInput>
  }

  export type users_goiUpdateWithoutTrainings_links_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_goiUncheckedUpdateWithoutTrainings_links_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_goi?: budget_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    cpf_consults_goi?: cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    quote_calculations_goi?: quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    sessions_goi?: sessions_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    threads_goi?: threads_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
    tokens_generated_goi?: tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiNestedInput
  }

  export type users_spaCreateWithoutTrainings_links_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaUncheckedCreateWithoutTrainings_links_spaInput = {
    id: string
    phone_number: bigint | number
    last_session_id?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    budget_consults_spa?: budget_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    cpf_consults_spa?: cpf_consults_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    quote_calculations_spa?: quote_calculations_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    sessions_spa?: sessions_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    threads_spa?: threads_spaUncheckedCreateNestedManyWithoutUsers_spaInput
    tokens_generated_spa?: tokens_generated_spaUncheckedCreateNestedManyWithoutUsers_spaInput
  }

  export type users_spaCreateOrConnectWithoutTrainings_links_spaInput = {
    where: users_spaWhereUniqueInput
    create: XOR<users_spaCreateWithoutTrainings_links_spaInput, users_spaUncheckedCreateWithoutTrainings_links_spaInput>
  }

  export type users_spaUpsertWithoutTrainings_links_spaInput = {
    update: XOR<users_spaUpdateWithoutTrainings_links_spaInput, users_spaUncheckedUpdateWithoutTrainings_links_spaInput>
    create: XOR<users_spaCreateWithoutTrainings_links_spaInput, users_spaUncheckedCreateWithoutTrainings_links_spaInput>
    where?: users_spaWhereInput
  }

  export type users_spaUpdateToOneWithWhereWithoutTrainings_links_spaInput = {
    where?: users_spaWhereInput
    data: XOR<users_spaUpdateWithoutTrainings_links_spaInput, users_spaUncheckedUpdateWithoutTrainings_links_spaInput>
  }

  export type users_spaUpdateWithoutTrainings_links_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUpdateManyWithoutUsers_spaNestedInput
  }

  export type users_spaUncheckedUpdateWithoutTrainings_links_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: BigIntFieldUpdateOperationsInput | bigint | number
    last_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_consults_spa?: budget_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    cpf_consults_spa?: cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    quote_calculations_spa?: quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    sessions_spa?: sessions_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    threads_spa?: threads_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
    tokens_generated_spa?: tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaNestedInput
  }

  export type budget_consults_autCreateWithoutUsers_autInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_autUncheckedCreateWithoutUsers_autInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_autCreateOrConnectWithoutUsers_autInput = {
    where: budget_consults_autWhereUniqueInput
    create: XOR<budget_consults_autCreateWithoutUsers_autInput, budget_consults_autUncheckedCreateWithoutUsers_autInput>
  }

  export type budget_consults_autCreateManyUsers_autInputEnvelope = {
    data: budget_consults_autCreateManyUsers_autInput | budget_consults_autCreateManyUsers_autInput[]
    skipDuplicates?: boolean
  }

  export type cpf_consults_autCreateWithoutUsers_autInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_autUncheckedCreateWithoutUsers_autInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_autCreateOrConnectWithoutUsers_autInput = {
    where: cpf_consults_autWhereUniqueInput
    create: XOR<cpf_consults_autCreateWithoutUsers_autInput, cpf_consults_autUncheckedCreateWithoutUsers_autInput>
  }

  export type cpf_consults_autCreateManyUsers_autInputEnvelope = {
    data: cpf_consults_autCreateManyUsers_autInput | cpf_consults_autCreateManyUsers_autInput[]
    skipDuplicates?: boolean
  }

  export type quote_calculations_autCreateWithoutUsers_autInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_autUncheckedCreateWithoutUsers_autInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_autCreateOrConnectWithoutUsers_autInput = {
    where: quote_calculations_autWhereUniqueInput
    create: XOR<quote_calculations_autCreateWithoutUsers_autInput, quote_calculations_autUncheckedCreateWithoutUsers_autInput>
  }

  export type quote_calculations_autCreateManyUsers_autInputEnvelope = {
    data: quote_calculations_autCreateManyUsers_autInput | quote_calculations_autCreateManyUsers_autInput[]
    skipDuplicates?: boolean
  }

  export type sessions_autCreateWithoutUsers_autInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_autUncheckedCreateWithoutUsers_autInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_autCreateOrConnectWithoutUsers_autInput = {
    where: sessions_autWhereUniqueInput
    create: XOR<sessions_autCreateWithoutUsers_autInput, sessions_autUncheckedCreateWithoutUsers_autInput>
  }

  export type sessions_autCreateManyUsers_autInputEnvelope = {
    data: sessions_autCreateManyUsers_autInput | sessions_autCreateManyUsers_autInput[]
    skipDuplicates?: boolean
  }

  export type threads_autCreateWithoutUsers_autInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_autUncheckedCreateWithoutUsers_autInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_autCreateOrConnectWithoutUsers_autInput = {
    where: threads_autWhereUniqueInput
    create: XOR<threads_autCreateWithoutUsers_autInput, threads_autUncheckedCreateWithoutUsers_autInput>
  }

  export type threads_autCreateManyUsers_autInputEnvelope = {
    data: threads_autCreateManyUsers_autInput | threads_autCreateManyUsers_autInput[]
    skipDuplicates?: boolean
  }

  export type tokens_generated_autCreateWithoutUsers_autInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_autUncheckedCreateWithoutUsers_autInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_autCreateOrConnectWithoutUsers_autInput = {
    where: tokens_generated_autWhereUniqueInput
    create: XOR<tokens_generated_autCreateWithoutUsers_autInput, tokens_generated_autUncheckedCreateWithoutUsers_autInput>
  }

  export type tokens_generated_autCreateManyUsers_autInputEnvelope = {
    data: tokens_generated_autCreateManyUsers_autInput | tokens_generated_autCreateManyUsers_autInput[]
    skipDuplicates?: boolean
  }

  export type trainings_links_autCreateWithoutUsers_autInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_autUncheckedCreateWithoutUsers_autInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_autCreateOrConnectWithoutUsers_autInput = {
    where: trainings_links_autWhereUniqueInput
    create: XOR<trainings_links_autCreateWithoutUsers_autInput, trainings_links_autUncheckedCreateWithoutUsers_autInput>
  }

  export type trainings_links_autCreateManyUsers_autInputEnvelope = {
    data: trainings_links_autCreateManyUsers_autInput | trainings_links_autCreateManyUsers_autInput[]
    skipDuplicates?: boolean
  }

  export type budget_consults_autUpsertWithWhereUniqueWithoutUsers_autInput = {
    where: budget_consults_autWhereUniqueInput
    update: XOR<budget_consults_autUpdateWithoutUsers_autInput, budget_consults_autUncheckedUpdateWithoutUsers_autInput>
    create: XOR<budget_consults_autCreateWithoutUsers_autInput, budget_consults_autUncheckedCreateWithoutUsers_autInput>
  }

  export type budget_consults_autUpdateWithWhereUniqueWithoutUsers_autInput = {
    where: budget_consults_autWhereUniqueInput
    data: XOR<budget_consults_autUpdateWithoutUsers_autInput, budget_consults_autUncheckedUpdateWithoutUsers_autInput>
  }

  export type budget_consults_autUpdateManyWithWhereWithoutUsers_autInput = {
    where: budget_consults_autScalarWhereInput
    data: XOR<budget_consults_autUpdateManyMutationInput, budget_consults_autUncheckedUpdateManyWithoutUsers_autInput>
  }

  export type budget_consults_autScalarWhereInput = {
    AND?: budget_consults_autScalarWhereInput | budget_consults_autScalarWhereInput[]
    OR?: budget_consults_autScalarWhereInput[]
    NOT?: budget_consults_autScalarWhereInput | budget_consults_autScalarWhereInput[]
    id?: StringFilter<"budget_consults_aut"> | string
    budget_code?: IntFilter<"budget_consults_aut"> | number
    is_error?: BoolFilter<"budget_consults_aut"> | boolean
    user_id?: StringFilter<"budget_consults_aut"> | string
    createdAt?: DateTimeFilter<"budget_consults_aut"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_aut"> | Date | string
  }

  export type cpf_consults_autUpsertWithWhereUniqueWithoutUsers_autInput = {
    where: cpf_consults_autWhereUniqueInput
    update: XOR<cpf_consults_autUpdateWithoutUsers_autInput, cpf_consults_autUncheckedUpdateWithoutUsers_autInput>
    create: XOR<cpf_consults_autCreateWithoutUsers_autInput, cpf_consults_autUncheckedCreateWithoutUsers_autInput>
  }

  export type cpf_consults_autUpdateWithWhereUniqueWithoutUsers_autInput = {
    where: cpf_consults_autWhereUniqueInput
    data: XOR<cpf_consults_autUpdateWithoutUsers_autInput, cpf_consults_autUncheckedUpdateWithoutUsers_autInput>
  }

  export type cpf_consults_autUpdateManyWithWhereWithoutUsers_autInput = {
    where: cpf_consults_autScalarWhereInput
    data: XOR<cpf_consults_autUpdateManyMutationInput, cpf_consults_autUncheckedUpdateManyWithoutUsers_autInput>
  }

  export type cpf_consults_autScalarWhereInput = {
    AND?: cpf_consults_autScalarWhereInput | cpf_consults_autScalarWhereInput[]
    OR?: cpf_consults_autScalarWhereInput[]
    NOT?: cpf_consults_autScalarWhereInput | cpf_consults_autScalarWhereInput[]
    id?: StringFilter<"cpf_consults_aut"> | string
    cpf?: StringFilter<"cpf_consults_aut"> | string
    user_id?: StringFilter<"cpf_consults_aut"> | string
    is_error?: BoolFilter<"cpf_consults_aut"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_aut"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_aut"> | Date | string
  }

  export type quote_calculations_autUpsertWithWhereUniqueWithoutUsers_autInput = {
    where: quote_calculations_autWhereUniqueInput
    update: XOR<quote_calculations_autUpdateWithoutUsers_autInput, quote_calculations_autUncheckedUpdateWithoutUsers_autInput>
    create: XOR<quote_calculations_autCreateWithoutUsers_autInput, quote_calculations_autUncheckedCreateWithoutUsers_autInput>
  }

  export type quote_calculations_autUpdateWithWhereUniqueWithoutUsers_autInput = {
    where: quote_calculations_autWhereUniqueInput
    data: XOR<quote_calculations_autUpdateWithoutUsers_autInput, quote_calculations_autUncheckedUpdateWithoutUsers_autInput>
  }

  export type quote_calculations_autUpdateManyWithWhereWithoutUsers_autInput = {
    where: quote_calculations_autScalarWhereInput
    data: XOR<quote_calculations_autUpdateManyMutationInput, quote_calculations_autUncheckedUpdateManyWithoutUsers_autInput>
  }

  export type quote_calculations_autScalarWhereInput = {
    AND?: quote_calculations_autScalarWhereInput | quote_calculations_autScalarWhereInput[]
    OR?: quote_calculations_autScalarWhereInput[]
    NOT?: quote_calculations_autScalarWhereInput | quote_calculations_autScalarWhereInput[]
    id?: StringFilter<"quote_calculations_aut"> | string
    user_id?: StringFilter<"quote_calculations_aut"> | string
    client_name?: StringFilter<"quote_calculations_aut"> | string
    consultant_name?: StringFilter<"quote_calculations_aut"> | string
    ages?: StringFilter<"quote_calculations_aut"> | string
    accommodation?: StringFilter<"quote_calculations_aut"> | string
    plan_type?: StringFilter<"quote_calculations_aut"> | string
    square?: StringFilter<"quote_calculations_aut"> | string
    is_odonto?: BoolFilter<"quote_calculations_aut"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_aut"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_aut"> | Date | string
  }

  export type sessions_autUpsertWithWhereUniqueWithoutUsers_autInput = {
    where: sessions_autWhereUniqueInput
    update: XOR<sessions_autUpdateWithoutUsers_autInput, sessions_autUncheckedUpdateWithoutUsers_autInput>
    create: XOR<sessions_autCreateWithoutUsers_autInput, sessions_autUncheckedCreateWithoutUsers_autInput>
  }

  export type sessions_autUpdateWithWhereUniqueWithoutUsers_autInput = {
    where: sessions_autWhereUniqueInput
    data: XOR<sessions_autUpdateWithoutUsers_autInput, sessions_autUncheckedUpdateWithoutUsers_autInput>
  }

  export type sessions_autUpdateManyWithWhereWithoutUsers_autInput = {
    where: sessions_autScalarWhereInput
    data: XOR<sessions_autUpdateManyMutationInput, sessions_autUncheckedUpdateManyWithoutUsers_autInput>
  }

  export type sessions_autScalarWhereInput = {
    AND?: sessions_autScalarWhereInput | sessions_autScalarWhereInput[]
    OR?: sessions_autScalarWhereInput[]
    NOT?: sessions_autScalarWhereInput | sessions_autScalarWhereInput[]
    id?: StringFilter<"sessions_aut"> | string
    entrace_option?: IntNullableFilter<"sessions_aut"> | number | null
    is_finished?: BoolFilter<"sessions_aut"> | boolean
    is_timeout?: BoolFilter<"sessions_aut"> | boolean
    is_error?: BoolFilter<"sessions_aut"> | boolean
    user_id?: StringFilter<"sessions_aut"> | string
    createdAt?: DateTimeFilter<"sessions_aut"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_aut"> | Date | string
  }

  export type threads_autUpsertWithWhereUniqueWithoutUsers_autInput = {
    where: threads_autWhereUniqueInput
    update: XOR<threads_autUpdateWithoutUsers_autInput, threads_autUncheckedUpdateWithoutUsers_autInput>
    create: XOR<threads_autCreateWithoutUsers_autInput, threads_autUncheckedCreateWithoutUsers_autInput>
  }

  export type threads_autUpdateWithWhereUniqueWithoutUsers_autInput = {
    where: threads_autWhereUniqueInput
    data: XOR<threads_autUpdateWithoutUsers_autInput, threads_autUncheckedUpdateWithoutUsers_autInput>
  }

  export type threads_autUpdateManyWithWhereWithoutUsers_autInput = {
    where: threads_autScalarWhereInput
    data: XOR<threads_autUpdateManyMutationInput, threads_autUncheckedUpdateManyWithoutUsers_autInput>
  }

  export type threads_autScalarWhereInput = {
    AND?: threads_autScalarWhereInput | threads_autScalarWhereInput[]
    OR?: threads_autScalarWhereInput[]
    NOT?: threads_autScalarWhereInput | threads_autScalarWhereInput[]
    id?: StringFilter<"threads_aut"> | string
    user_id?: StringFilter<"threads_aut"> | string
    thread?: StringFilter<"threads_aut"> | string
    createdAt?: DateTimeFilter<"threads_aut"> | Date | string
    updatedAt?: DateTimeFilter<"threads_aut"> | Date | string
  }

  export type tokens_generated_autUpsertWithWhereUniqueWithoutUsers_autInput = {
    where: tokens_generated_autWhereUniqueInput
    update: XOR<tokens_generated_autUpdateWithoutUsers_autInput, tokens_generated_autUncheckedUpdateWithoutUsers_autInput>
    create: XOR<tokens_generated_autCreateWithoutUsers_autInput, tokens_generated_autUncheckedCreateWithoutUsers_autInput>
  }

  export type tokens_generated_autUpdateWithWhereUniqueWithoutUsers_autInput = {
    where: tokens_generated_autWhereUniqueInput
    data: XOR<tokens_generated_autUpdateWithoutUsers_autInput, tokens_generated_autUncheckedUpdateWithoutUsers_autInput>
  }

  export type tokens_generated_autUpdateManyWithWhereWithoutUsers_autInput = {
    where: tokens_generated_autScalarWhereInput
    data: XOR<tokens_generated_autUpdateManyMutationInput, tokens_generated_autUncheckedUpdateManyWithoutUsers_autInput>
  }

  export type tokens_generated_autScalarWhereInput = {
    AND?: tokens_generated_autScalarWhereInput | tokens_generated_autScalarWhereInput[]
    OR?: tokens_generated_autScalarWhereInput[]
    NOT?: tokens_generated_autScalarWhereInput | tokens_generated_autScalarWhereInput[]
    id?: StringFilter<"tokens_generated_aut"> | string
    create_token_id?: StringNullableFilter<"tokens_generated_aut"> | string | null
    user_id?: StringFilter<"tokens_generated_aut"> | string
    is_expired?: BoolFilter<"tokens_generated_aut"> | boolean
    is_error?: BoolFilter<"tokens_generated_aut"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_aut"> | boolean
    is_closed?: BoolFilter<"tokens_generated_aut"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_aut"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_aut"> | Date | string
  }

  export type trainings_links_autUpsertWithWhereUniqueWithoutUsers_autInput = {
    where: trainings_links_autWhereUniqueInput
    update: XOR<trainings_links_autUpdateWithoutUsers_autInput, trainings_links_autUncheckedUpdateWithoutUsers_autInput>
    create: XOR<trainings_links_autCreateWithoutUsers_autInput, trainings_links_autUncheckedCreateWithoutUsers_autInput>
  }

  export type trainings_links_autUpdateWithWhereUniqueWithoutUsers_autInput = {
    where: trainings_links_autWhereUniqueInput
    data: XOR<trainings_links_autUpdateWithoutUsers_autInput, trainings_links_autUncheckedUpdateWithoutUsers_autInput>
  }

  export type trainings_links_autUpdateManyWithWhereWithoutUsers_autInput = {
    where: trainings_links_autScalarWhereInput
    data: XOR<trainings_links_autUpdateManyMutationInput, trainings_links_autUncheckedUpdateManyWithoutUsers_autInput>
  }

  export type trainings_links_autScalarWhereInput = {
    AND?: trainings_links_autScalarWhereInput | trainings_links_autScalarWhereInput[]
    OR?: trainings_links_autScalarWhereInput[]
    NOT?: trainings_links_autScalarWhereInput | trainings_links_autScalarWhereInput[]
    id?: StringFilter<"trainings_links_aut"> | string
    user_id?: StringFilter<"trainings_links_aut"> | string
    training?: StringFilter<"trainings_links_aut"> | string
    createdAt?: DateTimeFilter<"trainings_links_aut"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_aut"> | Date | string
  }

  export type budget_consults_cltCreateWithoutUsers_cltInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_cltUncheckedCreateWithoutUsers_cltInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_cltCreateOrConnectWithoutUsers_cltInput = {
    where: budget_consults_cltWhereUniqueInput
    create: XOR<budget_consults_cltCreateWithoutUsers_cltInput, budget_consults_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type budget_consults_cltCreateManyUsers_cltInputEnvelope = {
    data: budget_consults_cltCreateManyUsers_cltInput | budget_consults_cltCreateManyUsers_cltInput[]
    skipDuplicates?: boolean
  }

  export type cpf_consults_cltCreateWithoutUsers_cltInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_cltUncheckedCreateWithoutUsers_cltInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_cltCreateOrConnectWithoutUsers_cltInput = {
    where: cpf_consults_cltWhereUniqueInput
    create: XOR<cpf_consults_cltCreateWithoutUsers_cltInput, cpf_consults_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type cpf_consults_cltCreateManyUsers_cltInputEnvelope = {
    data: cpf_consults_cltCreateManyUsers_cltInput | cpf_consults_cltCreateManyUsers_cltInput[]
    skipDuplicates?: boolean
  }

  export type quote_calculations_cltCreateWithoutUsers_cltInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_cltUncheckedCreateWithoutUsers_cltInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_cltCreateOrConnectWithoutUsers_cltInput = {
    where: quote_calculations_cltWhereUniqueInput
    create: XOR<quote_calculations_cltCreateWithoutUsers_cltInput, quote_calculations_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type quote_calculations_cltCreateManyUsers_cltInputEnvelope = {
    data: quote_calculations_cltCreateManyUsers_cltInput | quote_calculations_cltCreateManyUsers_cltInput[]
    skipDuplicates?: boolean
  }

  export type sessions_cltCreateWithoutUsers_cltInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_cltUncheckedCreateWithoutUsers_cltInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_cltCreateOrConnectWithoutUsers_cltInput = {
    where: sessions_cltWhereUniqueInput
    create: XOR<sessions_cltCreateWithoutUsers_cltInput, sessions_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type sessions_cltCreateManyUsers_cltInputEnvelope = {
    data: sessions_cltCreateManyUsers_cltInput | sessions_cltCreateManyUsers_cltInput[]
    skipDuplicates?: boolean
  }

  export type threads_cltCreateWithoutUsers_cltInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_cltUncheckedCreateWithoutUsers_cltInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_cltCreateOrConnectWithoutUsers_cltInput = {
    where: threads_cltWhereUniqueInput
    create: XOR<threads_cltCreateWithoutUsers_cltInput, threads_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type threads_cltCreateManyUsers_cltInputEnvelope = {
    data: threads_cltCreateManyUsers_cltInput | threads_cltCreateManyUsers_cltInput[]
    skipDuplicates?: boolean
  }

  export type tokens_generated_cltCreateWithoutUsers_cltInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_cltUncheckedCreateWithoutUsers_cltInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_cltCreateOrConnectWithoutUsers_cltInput = {
    where: tokens_generated_cltWhereUniqueInput
    create: XOR<tokens_generated_cltCreateWithoutUsers_cltInput, tokens_generated_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type tokens_generated_cltCreateManyUsers_cltInputEnvelope = {
    data: tokens_generated_cltCreateManyUsers_cltInput | tokens_generated_cltCreateManyUsers_cltInput[]
    skipDuplicates?: boolean
  }

  export type trainings_links_cltCreateWithoutUsers_cltInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_cltUncheckedCreateWithoutUsers_cltInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_cltCreateOrConnectWithoutUsers_cltInput = {
    where: trainings_links_cltWhereUniqueInput
    create: XOR<trainings_links_cltCreateWithoutUsers_cltInput, trainings_links_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type trainings_links_cltCreateManyUsers_cltInputEnvelope = {
    data: trainings_links_cltCreateManyUsers_cltInput | trainings_links_cltCreateManyUsers_cltInput[]
    skipDuplicates?: boolean
  }

  export type budget_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput = {
    where: budget_consults_cltWhereUniqueInput
    update: XOR<budget_consults_cltUpdateWithoutUsers_cltInput, budget_consults_cltUncheckedUpdateWithoutUsers_cltInput>
    create: XOR<budget_consults_cltCreateWithoutUsers_cltInput, budget_consults_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type budget_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput = {
    where: budget_consults_cltWhereUniqueInput
    data: XOR<budget_consults_cltUpdateWithoutUsers_cltInput, budget_consults_cltUncheckedUpdateWithoutUsers_cltInput>
  }

  export type budget_consults_cltUpdateManyWithWhereWithoutUsers_cltInput = {
    where: budget_consults_cltScalarWhereInput
    data: XOR<budget_consults_cltUpdateManyMutationInput, budget_consults_cltUncheckedUpdateManyWithoutUsers_cltInput>
  }

  export type budget_consults_cltScalarWhereInput = {
    AND?: budget_consults_cltScalarWhereInput | budget_consults_cltScalarWhereInput[]
    OR?: budget_consults_cltScalarWhereInput[]
    NOT?: budget_consults_cltScalarWhereInput | budget_consults_cltScalarWhereInput[]
    id?: StringFilter<"budget_consults_clt"> | string
    budget_code?: IntFilter<"budget_consults_clt"> | number
    is_error?: BoolFilter<"budget_consults_clt"> | boolean
    user_id?: StringFilter<"budget_consults_clt"> | string
    createdAt?: DateTimeFilter<"budget_consults_clt"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_clt"> | Date | string
  }

  export type cpf_consults_cltUpsertWithWhereUniqueWithoutUsers_cltInput = {
    where: cpf_consults_cltWhereUniqueInput
    update: XOR<cpf_consults_cltUpdateWithoutUsers_cltInput, cpf_consults_cltUncheckedUpdateWithoutUsers_cltInput>
    create: XOR<cpf_consults_cltCreateWithoutUsers_cltInput, cpf_consults_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type cpf_consults_cltUpdateWithWhereUniqueWithoutUsers_cltInput = {
    where: cpf_consults_cltWhereUniqueInput
    data: XOR<cpf_consults_cltUpdateWithoutUsers_cltInput, cpf_consults_cltUncheckedUpdateWithoutUsers_cltInput>
  }

  export type cpf_consults_cltUpdateManyWithWhereWithoutUsers_cltInput = {
    where: cpf_consults_cltScalarWhereInput
    data: XOR<cpf_consults_cltUpdateManyMutationInput, cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltInput>
  }

  export type cpf_consults_cltScalarWhereInput = {
    AND?: cpf_consults_cltScalarWhereInput | cpf_consults_cltScalarWhereInput[]
    OR?: cpf_consults_cltScalarWhereInput[]
    NOT?: cpf_consults_cltScalarWhereInput | cpf_consults_cltScalarWhereInput[]
    id?: StringFilter<"cpf_consults_clt"> | string
    cpf?: StringFilter<"cpf_consults_clt"> | string
    user_id?: StringFilter<"cpf_consults_clt"> | string
    is_error?: BoolFilter<"cpf_consults_clt"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_clt"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_clt"> | Date | string
  }

  export type quote_calculations_cltUpsertWithWhereUniqueWithoutUsers_cltInput = {
    where: quote_calculations_cltWhereUniqueInput
    update: XOR<quote_calculations_cltUpdateWithoutUsers_cltInput, quote_calculations_cltUncheckedUpdateWithoutUsers_cltInput>
    create: XOR<quote_calculations_cltCreateWithoutUsers_cltInput, quote_calculations_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type quote_calculations_cltUpdateWithWhereUniqueWithoutUsers_cltInput = {
    where: quote_calculations_cltWhereUniqueInput
    data: XOR<quote_calculations_cltUpdateWithoutUsers_cltInput, quote_calculations_cltUncheckedUpdateWithoutUsers_cltInput>
  }

  export type quote_calculations_cltUpdateManyWithWhereWithoutUsers_cltInput = {
    where: quote_calculations_cltScalarWhereInput
    data: XOR<quote_calculations_cltUpdateManyMutationInput, quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltInput>
  }

  export type quote_calculations_cltScalarWhereInput = {
    AND?: quote_calculations_cltScalarWhereInput | quote_calculations_cltScalarWhereInput[]
    OR?: quote_calculations_cltScalarWhereInput[]
    NOT?: quote_calculations_cltScalarWhereInput | quote_calculations_cltScalarWhereInput[]
    id?: StringFilter<"quote_calculations_clt"> | string
    user_id?: StringFilter<"quote_calculations_clt"> | string
    client_name?: StringFilter<"quote_calculations_clt"> | string
    consultant_name?: StringFilter<"quote_calculations_clt"> | string
    ages?: StringFilter<"quote_calculations_clt"> | string
    accommodation?: StringFilter<"quote_calculations_clt"> | string
    plan_type?: StringFilter<"quote_calculations_clt"> | string
    square?: StringFilter<"quote_calculations_clt"> | string
    is_odonto?: BoolFilter<"quote_calculations_clt"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_clt"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_clt"> | Date | string
  }

  export type sessions_cltUpsertWithWhereUniqueWithoutUsers_cltInput = {
    where: sessions_cltWhereUniqueInput
    update: XOR<sessions_cltUpdateWithoutUsers_cltInput, sessions_cltUncheckedUpdateWithoutUsers_cltInput>
    create: XOR<sessions_cltCreateWithoutUsers_cltInput, sessions_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type sessions_cltUpdateWithWhereUniqueWithoutUsers_cltInput = {
    where: sessions_cltWhereUniqueInput
    data: XOR<sessions_cltUpdateWithoutUsers_cltInput, sessions_cltUncheckedUpdateWithoutUsers_cltInput>
  }

  export type sessions_cltUpdateManyWithWhereWithoutUsers_cltInput = {
    where: sessions_cltScalarWhereInput
    data: XOR<sessions_cltUpdateManyMutationInput, sessions_cltUncheckedUpdateManyWithoutUsers_cltInput>
  }

  export type sessions_cltScalarWhereInput = {
    AND?: sessions_cltScalarWhereInput | sessions_cltScalarWhereInput[]
    OR?: sessions_cltScalarWhereInput[]
    NOT?: sessions_cltScalarWhereInput | sessions_cltScalarWhereInput[]
    id?: StringFilter<"sessions_clt"> | string
    entrace_option?: IntNullableFilter<"sessions_clt"> | number | null
    is_finished?: BoolFilter<"sessions_clt"> | boolean
    is_timeout?: BoolFilter<"sessions_clt"> | boolean
    is_error?: BoolFilter<"sessions_clt"> | boolean
    user_id?: StringFilter<"sessions_clt"> | string
    createdAt?: DateTimeFilter<"sessions_clt"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_clt"> | Date | string
  }

  export type threads_cltUpsertWithWhereUniqueWithoutUsers_cltInput = {
    where: threads_cltWhereUniqueInput
    update: XOR<threads_cltUpdateWithoutUsers_cltInput, threads_cltUncheckedUpdateWithoutUsers_cltInput>
    create: XOR<threads_cltCreateWithoutUsers_cltInput, threads_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type threads_cltUpdateWithWhereUniqueWithoutUsers_cltInput = {
    where: threads_cltWhereUniqueInput
    data: XOR<threads_cltUpdateWithoutUsers_cltInput, threads_cltUncheckedUpdateWithoutUsers_cltInput>
  }

  export type threads_cltUpdateManyWithWhereWithoutUsers_cltInput = {
    where: threads_cltScalarWhereInput
    data: XOR<threads_cltUpdateManyMutationInput, threads_cltUncheckedUpdateManyWithoutUsers_cltInput>
  }

  export type threads_cltScalarWhereInput = {
    AND?: threads_cltScalarWhereInput | threads_cltScalarWhereInput[]
    OR?: threads_cltScalarWhereInput[]
    NOT?: threads_cltScalarWhereInput | threads_cltScalarWhereInput[]
    id?: StringFilter<"threads_clt"> | string
    user_id?: StringFilter<"threads_clt"> | string
    thread?: StringFilter<"threads_clt"> | string
    createdAt?: DateTimeFilter<"threads_clt"> | Date | string
    updatedAt?: DateTimeFilter<"threads_clt"> | Date | string
  }

  export type tokens_generated_cltUpsertWithWhereUniqueWithoutUsers_cltInput = {
    where: tokens_generated_cltWhereUniqueInput
    update: XOR<tokens_generated_cltUpdateWithoutUsers_cltInput, tokens_generated_cltUncheckedUpdateWithoutUsers_cltInput>
    create: XOR<tokens_generated_cltCreateWithoutUsers_cltInput, tokens_generated_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type tokens_generated_cltUpdateWithWhereUniqueWithoutUsers_cltInput = {
    where: tokens_generated_cltWhereUniqueInput
    data: XOR<tokens_generated_cltUpdateWithoutUsers_cltInput, tokens_generated_cltUncheckedUpdateWithoutUsers_cltInput>
  }

  export type tokens_generated_cltUpdateManyWithWhereWithoutUsers_cltInput = {
    where: tokens_generated_cltScalarWhereInput
    data: XOR<tokens_generated_cltUpdateManyMutationInput, tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltInput>
  }

  export type tokens_generated_cltScalarWhereInput = {
    AND?: tokens_generated_cltScalarWhereInput | tokens_generated_cltScalarWhereInput[]
    OR?: tokens_generated_cltScalarWhereInput[]
    NOT?: tokens_generated_cltScalarWhereInput | tokens_generated_cltScalarWhereInput[]
    id?: StringFilter<"tokens_generated_clt"> | string
    create_token_id?: StringNullableFilter<"tokens_generated_clt"> | string | null
    user_id?: StringFilter<"tokens_generated_clt"> | string
    is_expired?: BoolFilter<"tokens_generated_clt"> | boolean
    is_error?: BoolFilter<"tokens_generated_clt"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_clt"> | boolean
    is_closed?: BoolFilter<"tokens_generated_clt"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_clt"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_clt"> | Date | string
  }

  export type trainings_links_cltUpsertWithWhereUniqueWithoutUsers_cltInput = {
    where: trainings_links_cltWhereUniqueInput
    update: XOR<trainings_links_cltUpdateWithoutUsers_cltInput, trainings_links_cltUncheckedUpdateWithoutUsers_cltInput>
    create: XOR<trainings_links_cltCreateWithoutUsers_cltInput, trainings_links_cltUncheckedCreateWithoutUsers_cltInput>
  }

  export type trainings_links_cltUpdateWithWhereUniqueWithoutUsers_cltInput = {
    where: trainings_links_cltWhereUniqueInput
    data: XOR<trainings_links_cltUpdateWithoutUsers_cltInput, trainings_links_cltUncheckedUpdateWithoutUsers_cltInput>
  }

  export type trainings_links_cltUpdateManyWithWhereWithoutUsers_cltInput = {
    where: trainings_links_cltScalarWhereInput
    data: XOR<trainings_links_cltUpdateManyMutationInput, trainings_links_cltUncheckedUpdateManyWithoutUsers_cltInput>
  }

  export type trainings_links_cltScalarWhereInput = {
    AND?: trainings_links_cltScalarWhereInput | trainings_links_cltScalarWhereInput[]
    OR?: trainings_links_cltScalarWhereInput[]
    NOT?: trainings_links_cltScalarWhereInput | trainings_links_cltScalarWhereInput[]
    id?: StringFilter<"trainings_links_clt"> | string
    user_id?: StringFilter<"trainings_links_clt"> | string
    training?: StringFilter<"trainings_links_clt"> | string
    createdAt?: DateTimeFilter<"trainings_links_clt"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_clt"> | Date | string
  }

  export type budget_consults_goiCreateWithoutUsers_goiInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_goiUncheckedCreateWithoutUsers_goiInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_goiCreateOrConnectWithoutUsers_goiInput = {
    where: budget_consults_goiWhereUniqueInput
    create: XOR<budget_consults_goiCreateWithoutUsers_goiInput, budget_consults_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type budget_consults_goiCreateManyUsers_goiInputEnvelope = {
    data: budget_consults_goiCreateManyUsers_goiInput | budget_consults_goiCreateManyUsers_goiInput[]
    skipDuplicates?: boolean
  }

  export type cpf_consults_goiCreateWithoutUsers_goiInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_goiUncheckedCreateWithoutUsers_goiInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_goiCreateOrConnectWithoutUsers_goiInput = {
    where: cpf_consults_goiWhereUniqueInput
    create: XOR<cpf_consults_goiCreateWithoutUsers_goiInput, cpf_consults_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type cpf_consults_goiCreateManyUsers_goiInputEnvelope = {
    data: cpf_consults_goiCreateManyUsers_goiInput | cpf_consults_goiCreateManyUsers_goiInput[]
    skipDuplicates?: boolean
  }

  export type quote_calculations_goiCreateWithoutUsers_goiInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_goiUncheckedCreateWithoutUsers_goiInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_goiCreateOrConnectWithoutUsers_goiInput = {
    where: quote_calculations_goiWhereUniqueInput
    create: XOR<quote_calculations_goiCreateWithoutUsers_goiInput, quote_calculations_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type quote_calculations_goiCreateManyUsers_goiInputEnvelope = {
    data: quote_calculations_goiCreateManyUsers_goiInput | quote_calculations_goiCreateManyUsers_goiInput[]
    skipDuplicates?: boolean
  }

  export type sessions_goiCreateWithoutUsers_goiInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_goiUncheckedCreateWithoutUsers_goiInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_goiCreateOrConnectWithoutUsers_goiInput = {
    where: sessions_goiWhereUniqueInput
    create: XOR<sessions_goiCreateWithoutUsers_goiInput, sessions_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type sessions_goiCreateManyUsers_goiInputEnvelope = {
    data: sessions_goiCreateManyUsers_goiInput | sessions_goiCreateManyUsers_goiInput[]
    skipDuplicates?: boolean
  }

  export type threads_goiCreateWithoutUsers_goiInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_goiUncheckedCreateWithoutUsers_goiInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_goiCreateOrConnectWithoutUsers_goiInput = {
    where: threads_goiWhereUniqueInput
    create: XOR<threads_goiCreateWithoutUsers_goiInput, threads_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type threads_goiCreateManyUsers_goiInputEnvelope = {
    data: threads_goiCreateManyUsers_goiInput | threads_goiCreateManyUsers_goiInput[]
    skipDuplicates?: boolean
  }

  export type tokens_generated_goiCreateWithoutUsers_goiInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_goiUncheckedCreateWithoutUsers_goiInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_goiCreateOrConnectWithoutUsers_goiInput = {
    where: tokens_generated_goiWhereUniqueInput
    create: XOR<tokens_generated_goiCreateWithoutUsers_goiInput, tokens_generated_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type tokens_generated_goiCreateManyUsers_goiInputEnvelope = {
    data: tokens_generated_goiCreateManyUsers_goiInput | tokens_generated_goiCreateManyUsers_goiInput[]
    skipDuplicates?: boolean
  }

  export type trainings_links_goiCreateWithoutUsers_goiInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_goiUncheckedCreateWithoutUsers_goiInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_goiCreateOrConnectWithoutUsers_goiInput = {
    where: trainings_links_goiWhereUniqueInput
    create: XOR<trainings_links_goiCreateWithoutUsers_goiInput, trainings_links_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type trainings_links_goiCreateManyUsers_goiInputEnvelope = {
    data: trainings_links_goiCreateManyUsers_goiInput | trainings_links_goiCreateManyUsers_goiInput[]
    skipDuplicates?: boolean
  }

  export type budget_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput = {
    where: budget_consults_goiWhereUniqueInput
    update: XOR<budget_consults_goiUpdateWithoutUsers_goiInput, budget_consults_goiUncheckedUpdateWithoutUsers_goiInput>
    create: XOR<budget_consults_goiCreateWithoutUsers_goiInput, budget_consults_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type budget_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput = {
    where: budget_consults_goiWhereUniqueInput
    data: XOR<budget_consults_goiUpdateWithoutUsers_goiInput, budget_consults_goiUncheckedUpdateWithoutUsers_goiInput>
  }

  export type budget_consults_goiUpdateManyWithWhereWithoutUsers_goiInput = {
    where: budget_consults_goiScalarWhereInput
    data: XOR<budget_consults_goiUpdateManyMutationInput, budget_consults_goiUncheckedUpdateManyWithoutUsers_goiInput>
  }

  export type budget_consults_goiScalarWhereInput = {
    AND?: budget_consults_goiScalarWhereInput | budget_consults_goiScalarWhereInput[]
    OR?: budget_consults_goiScalarWhereInput[]
    NOT?: budget_consults_goiScalarWhereInput | budget_consults_goiScalarWhereInput[]
    id?: StringFilter<"budget_consults_goi"> | string
    budget_code?: IntFilter<"budget_consults_goi"> | number
    is_error?: BoolFilter<"budget_consults_goi"> | boolean
    user_id?: StringFilter<"budget_consults_goi"> | string
    createdAt?: DateTimeFilter<"budget_consults_goi"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_goi"> | Date | string
  }

  export type cpf_consults_goiUpsertWithWhereUniqueWithoutUsers_goiInput = {
    where: cpf_consults_goiWhereUniqueInput
    update: XOR<cpf_consults_goiUpdateWithoutUsers_goiInput, cpf_consults_goiUncheckedUpdateWithoutUsers_goiInput>
    create: XOR<cpf_consults_goiCreateWithoutUsers_goiInput, cpf_consults_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type cpf_consults_goiUpdateWithWhereUniqueWithoutUsers_goiInput = {
    where: cpf_consults_goiWhereUniqueInput
    data: XOR<cpf_consults_goiUpdateWithoutUsers_goiInput, cpf_consults_goiUncheckedUpdateWithoutUsers_goiInput>
  }

  export type cpf_consults_goiUpdateManyWithWhereWithoutUsers_goiInput = {
    where: cpf_consults_goiScalarWhereInput
    data: XOR<cpf_consults_goiUpdateManyMutationInput, cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiInput>
  }

  export type cpf_consults_goiScalarWhereInput = {
    AND?: cpf_consults_goiScalarWhereInput | cpf_consults_goiScalarWhereInput[]
    OR?: cpf_consults_goiScalarWhereInput[]
    NOT?: cpf_consults_goiScalarWhereInput | cpf_consults_goiScalarWhereInput[]
    id?: StringFilter<"cpf_consults_goi"> | string
    cpf?: StringFilter<"cpf_consults_goi"> | string
    user_id?: StringFilter<"cpf_consults_goi"> | string
    is_error?: BoolFilter<"cpf_consults_goi"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_goi"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_goi"> | Date | string
  }

  export type quote_calculations_goiUpsertWithWhereUniqueWithoutUsers_goiInput = {
    where: quote_calculations_goiWhereUniqueInput
    update: XOR<quote_calculations_goiUpdateWithoutUsers_goiInput, quote_calculations_goiUncheckedUpdateWithoutUsers_goiInput>
    create: XOR<quote_calculations_goiCreateWithoutUsers_goiInput, quote_calculations_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type quote_calculations_goiUpdateWithWhereUniqueWithoutUsers_goiInput = {
    where: quote_calculations_goiWhereUniqueInput
    data: XOR<quote_calculations_goiUpdateWithoutUsers_goiInput, quote_calculations_goiUncheckedUpdateWithoutUsers_goiInput>
  }

  export type quote_calculations_goiUpdateManyWithWhereWithoutUsers_goiInput = {
    where: quote_calculations_goiScalarWhereInput
    data: XOR<quote_calculations_goiUpdateManyMutationInput, quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiInput>
  }

  export type quote_calculations_goiScalarWhereInput = {
    AND?: quote_calculations_goiScalarWhereInput | quote_calculations_goiScalarWhereInput[]
    OR?: quote_calculations_goiScalarWhereInput[]
    NOT?: quote_calculations_goiScalarWhereInput | quote_calculations_goiScalarWhereInput[]
    id?: StringFilter<"quote_calculations_goi"> | string
    user_id?: StringFilter<"quote_calculations_goi"> | string
    client_name?: StringFilter<"quote_calculations_goi"> | string
    consultant_name?: StringFilter<"quote_calculations_goi"> | string
    ages?: StringFilter<"quote_calculations_goi"> | string
    accommodation?: StringFilter<"quote_calculations_goi"> | string
    plan_type?: StringFilter<"quote_calculations_goi"> | string
    square?: StringFilter<"quote_calculations_goi"> | string
    is_odonto?: BoolFilter<"quote_calculations_goi"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_goi"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_goi"> | Date | string
  }

  export type sessions_goiUpsertWithWhereUniqueWithoutUsers_goiInput = {
    where: sessions_goiWhereUniqueInput
    update: XOR<sessions_goiUpdateWithoutUsers_goiInput, sessions_goiUncheckedUpdateWithoutUsers_goiInput>
    create: XOR<sessions_goiCreateWithoutUsers_goiInput, sessions_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type sessions_goiUpdateWithWhereUniqueWithoutUsers_goiInput = {
    where: sessions_goiWhereUniqueInput
    data: XOR<sessions_goiUpdateWithoutUsers_goiInput, sessions_goiUncheckedUpdateWithoutUsers_goiInput>
  }

  export type sessions_goiUpdateManyWithWhereWithoutUsers_goiInput = {
    where: sessions_goiScalarWhereInput
    data: XOR<sessions_goiUpdateManyMutationInput, sessions_goiUncheckedUpdateManyWithoutUsers_goiInput>
  }

  export type sessions_goiScalarWhereInput = {
    AND?: sessions_goiScalarWhereInput | sessions_goiScalarWhereInput[]
    OR?: sessions_goiScalarWhereInput[]
    NOT?: sessions_goiScalarWhereInput | sessions_goiScalarWhereInput[]
    id?: StringFilter<"sessions_goi"> | string
    entrace_option?: IntNullableFilter<"sessions_goi"> | number | null
    is_finished?: BoolFilter<"sessions_goi"> | boolean
    is_timeout?: BoolFilter<"sessions_goi"> | boolean
    is_error?: BoolFilter<"sessions_goi"> | boolean
    user_id?: StringFilter<"sessions_goi"> | string
    createdAt?: DateTimeFilter<"sessions_goi"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_goi"> | Date | string
  }

  export type threads_goiUpsertWithWhereUniqueWithoutUsers_goiInput = {
    where: threads_goiWhereUniqueInput
    update: XOR<threads_goiUpdateWithoutUsers_goiInput, threads_goiUncheckedUpdateWithoutUsers_goiInput>
    create: XOR<threads_goiCreateWithoutUsers_goiInput, threads_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type threads_goiUpdateWithWhereUniqueWithoutUsers_goiInput = {
    where: threads_goiWhereUniqueInput
    data: XOR<threads_goiUpdateWithoutUsers_goiInput, threads_goiUncheckedUpdateWithoutUsers_goiInput>
  }

  export type threads_goiUpdateManyWithWhereWithoutUsers_goiInput = {
    where: threads_goiScalarWhereInput
    data: XOR<threads_goiUpdateManyMutationInput, threads_goiUncheckedUpdateManyWithoutUsers_goiInput>
  }

  export type threads_goiScalarWhereInput = {
    AND?: threads_goiScalarWhereInput | threads_goiScalarWhereInput[]
    OR?: threads_goiScalarWhereInput[]
    NOT?: threads_goiScalarWhereInput | threads_goiScalarWhereInput[]
    id?: StringFilter<"threads_goi"> | string
    user_id?: StringFilter<"threads_goi"> | string
    thread?: StringFilter<"threads_goi"> | string
    createdAt?: DateTimeFilter<"threads_goi"> | Date | string
    updatedAt?: DateTimeFilter<"threads_goi"> | Date | string
  }

  export type tokens_generated_goiUpsertWithWhereUniqueWithoutUsers_goiInput = {
    where: tokens_generated_goiWhereUniqueInput
    update: XOR<tokens_generated_goiUpdateWithoutUsers_goiInput, tokens_generated_goiUncheckedUpdateWithoutUsers_goiInput>
    create: XOR<tokens_generated_goiCreateWithoutUsers_goiInput, tokens_generated_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type tokens_generated_goiUpdateWithWhereUniqueWithoutUsers_goiInput = {
    where: tokens_generated_goiWhereUniqueInput
    data: XOR<tokens_generated_goiUpdateWithoutUsers_goiInput, tokens_generated_goiUncheckedUpdateWithoutUsers_goiInput>
  }

  export type tokens_generated_goiUpdateManyWithWhereWithoutUsers_goiInput = {
    where: tokens_generated_goiScalarWhereInput
    data: XOR<tokens_generated_goiUpdateManyMutationInput, tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiInput>
  }

  export type tokens_generated_goiScalarWhereInput = {
    AND?: tokens_generated_goiScalarWhereInput | tokens_generated_goiScalarWhereInput[]
    OR?: tokens_generated_goiScalarWhereInput[]
    NOT?: tokens_generated_goiScalarWhereInput | tokens_generated_goiScalarWhereInput[]
    id?: StringFilter<"tokens_generated_goi"> | string
    create_token_id?: StringNullableFilter<"tokens_generated_goi"> | string | null
    user_id?: StringFilter<"tokens_generated_goi"> | string
    is_expired?: BoolFilter<"tokens_generated_goi"> | boolean
    is_error?: BoolFilter<"tokens_generated_goi"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_goi"> | boolean
    is_closed?: BoolFilter<"tokens_generated_goi"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_goi"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_goi"> | Date | string
  }

  export type trainings_links_goiUpsertWithWhereUniqueWithoutUsers_goiInput = {
    where: trainings_links_goiWhereUniqueInput
    update: XOR<trainings_links_goiUpdateWithoutUsers_goiInput, trainings_links_goiUncheckedUpdateWithoutUsers_goiInput>
    create: XOR<trainings_links_goiCreateWithoutUsers_goiInput, trainings_links_goiUncheckedCreateWithoutUsers_goiInput>
  }

  export type trainings_links_goiUpdateWithWhereUniqueWithoutUsers_goiInput = {
    where: trainings_links_goiWhereUniqueInput
    data: XOR<trainings_links_goiUpdateWithoutUsers_goiInput, trainings_links_goiUncheckedUpdateWithoutUsers_goiInput>
  }

  export type trainings_links_goiUpdateManyWithWhereWithoutUsers_goiInput = {
    where: trainings_links_goiScalarWhereInput
    data: XOR<trainings_links_goiUpdateManyMutationInput, trainings_links_goiUncheckedUpdateManyWithoutUsers_goiInput>
  }

  export type trainings_links_goiScalarWhereInput = {
    AND?: trainings_links_goiScalarWhereInput | trainings_links_goiScalarWhereInput[]
    OR?: trainings_links_goiScalarWhereInput[]
    NOT?: trainings_links_goiScalarWhereInput | trainings_links_goiScalarWhereInput[]
    id?: StringFilter<"trainings_links_goi"> | string
    user_id?: StringFilter<"trainings_links_goi"> | string
    training?: StringFilter<"trainings_links_goi"> | string
    createdAt?: DateTimeFilter<"trainings_links_goi"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_goi"> | Date | string
  }

  export type budget_consults_spaCreateWithoutUsers_spaInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_spaUncheckedCreateWithoutUsers_spaInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_spaCreateOrConnectWithoutUsers_spaInput = {
    where: budget_consults_spaWhereUniqueInput
    create: XOR<budget_consults_spaCreateWithoutUsers_spaInput, budget_consults_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type budget_consults_spaCreateManyUsers_spaInputEnvelope = {
    data: budget_consults_spaCreateManyUsers_spaInput | budget_consults_spaCreateManyUsers_spaInput[]
    skipDuplicates?: boolean
  }

  export type cpf_consults_spaCreateWithoutUsers_spaInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_spaUncheckedCreateWithoutUsers_spaInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_spaCreateOrConnectWithoutUsers_spaInput = {
    where: cpf_consults_spaWhereUniqueInput
    create: XOR<cpf_consults_spaCreateWithoutUsers_spaInput, cpf_consults_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type cpf_consults_spaCreateManyUsers_spaInputEnvelope = {
    data: cpf_consults_spaCreateManyUsers_spaInput | cpf_consults_spaCreateManyUsers_spaInput[]
    skipDuplicates?: boolean
  }

  export type quote_calculations_spaCreateWithoutUsers_spaInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_spaUncheckedCreateWithoutUsers_spaInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_spaCreateOrConnectWithoutUsers_spaInput = {
    where: quote_calculations_spaWhereUniqueInput
    create: XOR<quote_calculations_spaCreateWithoutUsers_spaInput, quote_calculations_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type quote_calculations_spaCreateManyUsers_spaInputEnvelope = {
    data: quote_calculations_spaCreateManyUsers_spaInput | quote_calculations_spaCreateManyUsers_spaInput[]
    skipDuplicates?: boolean
  }

  export type sessions_spaCreateWithoutUsers_spaInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_spaUncheckedCreateWithoutUsers_spaInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_spaCreateOrConnectWithoutUsers_spaInput = {
    where: sessions_spaWhereUniqueInput
    create: XOR<sessions_spaCreateWithoutUsers_spaInput, sessions_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type sessions_spaCreateManyUsers_spaInputEnvelope = {
    data: sessions_spaCreateManyUsers_spaInput | sessions_spaCreateManyUsers_spaInput[]
    skipDuplicates?: boolean
  }

  export type threads_spaCreateWithoutUsers_spaInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_spaUncheckedCreateWithoutUsers_spaInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_spaCreateOrConnectWithoutUsers_spaInput = {
    where: threads_spaWhereUniqueInput
    create: XOR<threads_spaCreateWithoutUsers_spaInput, threads_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type threads_spaCreateManyUsers_spaInputEnvelope = {
    data: threads_spaCreateManyUsers_spaInput | threads_spaCreateManyUsers_spaInput[]
    skipDuplicates?: boolean
  }

  export type tokens_generated_spaCreateWithoutUsers_spaInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_spaUncheckedCreateWithoutUsers_spaInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_spaCreateOrConnectWithoutUsers_spaInput = {
    where: tokens_generated_spaWhereUniqueInput
    create: XOR<tokens_generated_spaCreateWithoutUsers_spaInput, tokens_generated_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type tokens_generated_spaCreateManyUsers_spaInputEnvelope = {
    data: tokens_generated_spaCreateManyUsers_spaInput | tokens_generated_spaCreateManyUsers_spaInput[]
    skipDuplicates?: boolean
  }

  export type trainings_links_spaCreateWithoutUsers_spaInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_spaUncheckedCreateWithoutUsers_spaInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_spaCreateOrConnectWithoutUsers_spaInput = {
    where: trainings_links_spaWhereUniqueInput
    create: XOR<trainings_links_spaCreateWithoutUsers_spaInput, trainings_links_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type trainings_links_spaCreateManyUsers_spaInputEnvelope = {
    data: trainings_links_spaCreateManyUsers_spaInput | trainings_links_spaCreateManyUsers_spaInput[]
    skipDuplicates?: boolean
  }

  export type budget_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput = {
    where: budget_consults_spaWhereUniqueInput
    update: XOR<budget_consults_spaUpdateWithoutUsers_spaInput, budget_consults_spaUncheckedUpdateWithoutUsers_spaInput>
    create: XOR<budget_consults_spaCreateWithoutUsers_spaInput, budget_consults_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type budget_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput = {
    where: budget_consults_spaWhereUniqueInput
    data: XOR<budget_consults_spaUpdateWithoutUsers_spaInput, budget_consults_spaUncheckedUpdateWithoutUsers_spaInput>
  }

  export type budget_consults_spaUpdateManyWithWhereWithoutUsers_spaInput = {
    where: budget_consults_spaScalarWhereInput
    data: XOR<budget_consults_spaUpdateManyMutationInput, budget_consults_spaUncheckedUpdateManyWithoutUsers_spaInput>
  }

  export type budget_consults_spaScalarWhereInput = {
    AND?: budget_consults_spaScalarWhereInput | budget_consults_spaScalarWhereInput[]
    OR?: budget_consults_spaScalarWhereInput[]
    NOT?: budget_consults_spaScalarWhereInput | budget_consults_spaScalarWhereInput[]
    id?: StringFilter<"budget_consults_spa"> | string
    budget_code?: IntFilter<"budget_consults_spa"> | number
    is_error?: BoolFilter<"budget_consults_spa"> | boolean
    user_id?: StringFilter<"budget_consults_spa"> | string
    createdAt?: DateTimeFilter<"budget_consults_spa"> | Date | string
    updatedAt?: DateTimeFilter<"budget_consults_spa"> | Date | string
  }

  export type cpf_consults_spaUpsertWithWhereUniqueWithoutUsers_spaInput = {
    where: cpf_consults_spaWhereUniqueInput
    update: XOR<cpf_consults_spaUpdateWithoutUsers_spaInput, cpf_consults_spaUncheckedUpdateWithoutUsers_spaInput>
    create: XOR<cpf_consults_spaCreateWithoutUsers_spaInput, cpf_consults_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type cpf_consults_spaUpdateWithWhereUniqueWithoutUsers_spaInput = {
    where: cpf_consults_spaWhereUniqueInput
    data: XOR<cpf_consults_spaUpdateWithoutUsers_spaInput, cpf_consults_spaUncheckedUpdateWithoutUsers_spaInput>
  }

  export type cpf_consults_spaUpdateManyWithWhereWithoutUsers_spaInput = {
    where: cpf_consults_spaScalarWhereInput
    data: XOR<cpf_consults_spaUpdateManyMutationInput, cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaInput>
  }

  export type cpf_consults_spaScalarWhereInput = {
    AND?: cpf_consults_spaScalarWhereInput | cpf_consults_spaScalarWhereInput[]
    OR?: cpf_consults_spaScalarWhereInput[]
    NOT?: cpf_consults_spaScalarWhereInput | cpf_consults_spaScalarWhereInput[]
    id?: StringFilter<"cpf_consults_spa"> | string
    cpf?: StringFilter<"cpf_consults_spa"> | string
    user_id?: StringFilter<"cpf_consults_spa"> | string
    is_error?: BoolFilter<"cpf_consults_spa"> | boolean
    createdAt?: DateTimeFilter<"cpf_consults_spa"> | Date | string
    updatedAt?: DateTimeFilter<"cpf_consults_spa"> | Date | string
  }

  export type quote_calculations_spaUpsertWithWhereUniqueWithoutUsers_spaInput = {
    where: quote_calculations_spaWhereUniqueInput
    update: XOR<quote_calculations_spaUpdateWithoutUsers_spaInput, quote_calculations_spaUncheckedUpdateWithoutUsers_spaInput>
    create: XOR<quote_calculations_spaCreateWithoutUsers_spaInput, quote_calculations_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type quote_calculations_spaUpdateWithWhereUniqueWithoutUsers_spaInput = {
    where: quote_calculations_spaWhereUniqueInput
    data: XOR<quote_calculations_spaUpdateWithoutUsers_spaInput, quote_calculations_spaUncheckedUpdateWithoutUsers_spaInput>
  }

  export type quote_calculations_spaUpdateManyWithWhereWithoutUsers_spaInput = {
    where: quote_calculations_spaScalarWhereInput
    data: XOR<quote_calculations_spaUpdateManyMutationInput, quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaInput>
  }

  export type quote_calculations_spaScalarWhereInput = {
    AND?: quote_calculations_spaScalarWhereInput | quote_calculations_spaScalarWhereInput[]
    OR?: quote_calculations_spaScalarWhereInput[]
    NOT?: quote_calculations_spaScalarWhereInput | quote_calculations_spaScalarWhereInput[]
    id?: StringFilter<"quote_calculations_spa"> | string
    user_id?: StringFilter<"quote_calculations_spa"> | string
    client_name?: StringFilter<"quote_calculations_spa"> | string
    consultant_name?: StringFilter<"quote_calculations_spa"> | string
    ages?: StringFilter<"quote_calculations_spa"> | string
    accommodation?: StringFilter<"quote_calculations_spa"> | string
    plan_type?: StringFilter<"quote_calculations_spa"> | string
    square?: StringFilter<"quote_calculations_spa"> | string
    is_odonto?: BoolFilter<"quote_calculations_spa"> | boolean
    createdAt?: DateTimeFilter<"quote_calculations_spa"> | Date | string
    updatedAt?: DateTimeFilter<"quote_calculations_spa"> | Date | string
  }

  export type sessions_spaUpsertWithWhereUniqueWithoutUsers_spaInput = {
    where: sessions_spaWhereUniqueInput
    update: XOR<sessions_spaUpdateWithoutUsers_spaInput, sessions_spaUncheckedUpdateWithoutUsers_spaInput>
    create: XOR<sessions_spaCreateWithoutUsers_spaInput, sessions_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type sessions_spaUpdateWithWhereUniqueWithoutUsers_spaInput = {
    where: sessions_spaWhereUniqueInput
    data: XOR<sessions_spaUpdateWithoutUsers_spaInput, sessions_spaUncheckedUpdateWithoutUsers_spaInput>
  }

  export type sessions_spaUpdateManyWithWhereWithoutUsers_spaInput = {
    where: sessions_spaScalarWhereInput
    data: XOR<sessions_spaUpdateManyMutationInput, sessions_spaUncheckedUpdateManyWithoutUsers_spaInput>
  }

  export type sessions_spaScalarWhereInput = {
    AND?: sessions_spaScalarWhereInput | sessions_spaScalarWhereInput[]
    OR?: sessions_spaScalarWhereInput[]
    NOT?: sessions_spaScalarWhereInput | sessions_spaScalarWhereInput[]
    id?: StringFilter<"sessions_spa"> | string
    entrace_option?: IntNullableFilter<"sessions_spa"> | number | null
    is_finished?: BoolFilter<"sessions_spa"> | boolean
    is_timeout?: BoolFilter<"sessions_spa"> | boolean
    is_error?: BoolFilter<"sessions_spa"> | boolean
    user_id?: StringFilter<"sessions_spa"> | string
    createdAt?: DateTimeFilter<"sessions_spa"> | Date | string
    updatedAt?: DateTimeFilter<"sessions_spa"> | Date | string
  }

  export type threads_spaUpsertWithWhereUniqueWithoutUsers_spaInput = {
    where: threads_spaWhereUniqueInput
    update: XOR<threads_spaUpdateWithoutUsers_spaInput, threads_spaUncheckedUpdateWithoutUsers_spaInput>
    create: XOR<threads_spaCreateWithoutUsers_spaInput, threads_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type threads_spaUpdateWithWhereUniqueWithoutUsers_spaInput = {
    where: threads_spaWhereUniqueInput
    data: XOR<threads_spaUpdateWithoutUsers_spaInput, threads_spaUncheckedUpdateWithoutUsers_spaInput>
  }

  export type threads_spaUpdateManyWithWhereWithoutUsers_spaInput = {
    where: threads_spaScalarWhereInput
    data: XOR<threads_spaUpdateManyMutationInput, threads_spaUncheckedUpdateManyWithoutUsers_spaInput>
  }

  export type threads_spaScalarWhereInput = {
    AND?: threads_spaScalarWhereInput | threads_spaScalarWhereInput[]
    OR?: threads_spaScalarWhereInput[]
    NOT?: threads_spaScalarWhereInput | threads_spaScalarWhereInput[]
    id?: StringFilter<"threads_spa"> | string
    user_id?: StringFilter<"threads_spa"> | string
    thread?: StringFilter<"threads_spa"> | string
    createdAt?: DateTimeFilter<"threads_spa"> | Date | string
    updatedAt?: DateTimeFilter<"threads_spa"> | Date | string
  }

  export type tokens_generated_spaUpsertWithWhereUniqueWithoutUsers_spaInput = {
    where: tokens_generated_spaWhereUniqueInput
    update: XOR<tokens_generated_spaUpdateWithoutUsers_spaInput, tokens_generated_spaUncheckedUpdateWithoutUsers_spaInput>
    create: XOR<tokens_generated_spaCreateWithoutUsers_spaInput, tokens_generated_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type tokens_generated_spaUpdateWithWhereUniqueWithoutUsers_spaInput = {
    where: tokens_generated_spaWhereUniqueInput
    data: XOR<tokens_generated_spaUpdateWithoutUsers_spaInput, tokens_generated_spaUncheckedUpdateWithoutUsers_spaInput>
  }

  export type tokens_generated_spaUpdateManyWithWhereWithoutUsers_spaInput = {
    where: tokens_generated_spaScalarWhereInput
    data: XOR<tokens_generated_spaUpdateManyMutationInput, tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaInput>
  }

  export type tokens_generated_spaScalarWhereInput = {
    AND?: tokens_generated_spaScalarWhereInput | tokens_generated_spaScalarWhereInput[]
    OR?: tokens_generated_spaScalarWhereInput[]
    NOT?: tokens_generated_spaScalarWhereInput | tokens_generated_spaScalarWhereInput[]
    id?: StringFilter<"tokens_generated_spa"> | string
    create_token_id?: StringNullableFilter<"tokens_generated_spa"> | string | null
    user_id?: StringFilter<"tokens_generated_spa"> | string
    is_expired?: BoolFilter<"tokens_generated_spa"> | boolean
    is_error?: BoolFilter<"tokens_generated_spa"> | boolean
    is_confirmed?: BoolFilter<"tokens_generated_spa"> | boolean
    is_closed?: BoolFilter<"tokens_generated_spa"> | boolean
    createdAt?: DateTimeFilter<"tokens_generated_spa"> | Date | string
    updatedAt?: DateTimeFilter<"tokens_generated_spa"> | Date | string
  }

  export type trainings_links_spaUpsertWithWhereUniqueWithoutUsers_spaInput = {
    where: trainings_links_spaWhereUniqueInput
    update: XOR<trainings_links_spaUpdateWithoutUsers_spaInput, trainings_links_spaUncheckedUpdateWithoutUsers_spaInput>
    create: XOR<trainings_links_spaCreateWithoutUsers_spaInput, trainings_links_spaUncheckedCreateWithoutUsers_spaInput>
  }

  export type trainings_links_spaUpdateWithWhereUniqueWithoutUsers_spaInput = {
    where: trainings_links_spaWhereUniqueInput
    data: XOR<trainings_links_spaUpdateWithoutUsers_spaInput, trainings_links_spaUncheckedUpdateWithoutUsers_spaInput>
  }

  export type trainings_links_spaUpdateManyWithWhereWithoutUsers_spaInput = {
    where: trainings_links_spaScalarWhereInput
    data: XOR<trainings_links_spaUpdateManyMutationInput, trainings_links_spaUncheckedUpdateManyWithoutUsers_spaInput>
  }

  export type trainings_links_spaScalarWhereInput = {
    AND?: trainings_links_spaScalarWhereInput | trainings_links_spaScalarWhereInput[]
    OR?: trainings_links_spaScalarWhereInput[]
    NOT?: trainings_links_spaScalarWhereInput | trainings_links_spaScalarWhereInput[]
    id?: StringFilter<"trainings_links_spa"> | string
    user_id?: StringFilter<"trainings_links_spa"> | string
    training?: StringFilter<"trainings_links_spa"> | string
    createdAt?: DateTimeFilter<"trainings_links_spa"> | Date | string
    updatedAt?: DateTimeFilter<"trainings_links_spa"> | Date | string
  }

  export type callsCreateManyAttendantInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type callsUpdateWithoutAttendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type callsUncheckedUpdateWithoutAttendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type callsUncheckedUpdateManyWithoutAttendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendant_callsCreateManyAttendantsInput = {
    id: string
    jid: string
    mainProblem: string
    detailsProblem: string
    pushName: string
    isResolved: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type attendant_callsUpdateWithoutAttendantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendant_callsUncheckedUpdateWithoutAttendantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendant_callsUncheckedUpdateManyWithoutAttendantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailsProblem?: StringFieldUpdateOperationsInput | string
    pushName?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rh_callsCreateManyRh_numbersInput = {
    id: string
    jid: string
    name: string
    message: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type rh_callsUpdateWithoutRh_numbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rh_callsUncheckedUpdateWithoutRh_numbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rh_callsUncheckedUpdateManyWithoutRh_numbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_autCreateManyUsers_autInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_autCreateManyUsers_autInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_autCreateManyUsers_autInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_autCreateManyUsers_autInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_autCreateManyUsers_autInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_autCreateManyUsers_autInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_autCreateManyUsers_autInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_autUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_autUncheckedUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_autUncheckedUpdateManyWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_autUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_autUncheckedUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_autUncheckedUpdateManyWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_autUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_autUncheckedUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_autUncheckedUpdateManyWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_autUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_autUncheckedUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_autUncheckedUpdateManyWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_autUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_autUncheckedUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_autUncheckedUpdateManyWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_autUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_autUncheckedUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_autUncheckedUpdateManyWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_autUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_autUncheckedUpdateWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_autUncheckedUpdateManyWithoutUsers_autInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_cltCreateManyUsers_cltInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_cltCreateManyUsers_cltInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_cltCreateManyUsers_cltInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_cltCreateManyUsers_cltInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_cltCreateManyUsers_cltInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_cltCreateManyUsers_cltInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_cltCreateManyUsers_cltInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_cltUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_cltUncheckedUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_cltUncheckedUpdateManyWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_cltUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_cltUncheckedUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_cltUncheckedUpdateManyWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_cltUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_cltUncheckedUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_cltUncheckedUpdateManyWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_cltUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_cltUncheckedUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_cltUncheckedUpdateManyWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_cltUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_cltUncheckedUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_cltUncheckedUpdateManyWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_cltUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_cltUncheckedUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_cltUncheckedUpdateManyWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_cltUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_cltUncheckedUpdateWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_cltUncheckedUpdateManyWithoutUsers_cltInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_goiCreateManyUsers_goiInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_goiCreateManyUsers_goiInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_goiCreateManyUsers_goiInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_goiCreateManyUsers_goiInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_goiCreateManyUsers_goiInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_goiCreateManyUsers_goiInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_goiCreateManyUsers_goiInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_goiUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_goiUncheckedUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_goiUncheckedUpdateManyWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_goiUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_goiUncheckedUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_goiUncheckedUpdateManyWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_goiUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_goiUncheckedUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_goiUncheckedUpdateManyWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_goiUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_goiUncheckedUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_goiUncheckedUpdateManyWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_goiUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_goiUncheckedUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_goiUncheckedUpdateManyWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_goiUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_goiUncheckedUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_goiUncheckedUpdateManyWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_goiUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_goiUncheckedUpdateWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_goiUncheckedUpdateManyWithoutUsers_goiInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_spaCreateManyUsers_spaInput = {
    id: string
    budget_code: number
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type cpf_consults_spaCreateManyUsers_spaInput = {
    id: string
    cpf: string
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type quote_calculations_spaCreateManyUsers_spaInput = {
    id: string
    client_name: string
    consultant_name: string
    ages: string
    accommodation: string
    plan_type: string
    square: string
    is_odonto: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type sessions_spaCreateManyUsers_spaInput = {
    id: string
    entrace_option?: number | null
    is_finished: boolean
    is_timeout: boolean
    is_error: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type threads_spaCreateManyUsers_spaInput = {
    id: string
    thread: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokens_generated_spaCreateManyUsers_spaInput = {
    id: string
    create_token_id?: string | null
    is_expired: boolean
    is_error: boolean
    is_confirmed: boolean
    is_closed: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trainings_links_spaCreateManyUsers_spaInput = {
    id: string
    training: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type budget_consults_spaUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_spaUncheckedUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_consults_spaUncheckedUpdateManyWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_code?: IntFieldUpdateOperationsInput | number
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_spaUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_spaUncheckedUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cpf_consults_spaUncheckedUpdateManyWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_spaUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_spaUncheckedUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quote_calculations_spaUncheckedUpdateManyWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_name?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    ages?: StringFieldUpdateOperationsInput | string
    accommodation?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    square?: StringFieldUpdateOperationsInput | string
    is_odonto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_spaUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_spaUncheckedUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessions_spaUncheckedUpdateManyWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    entrace_option?: NullableIntFieldUpdateOperationsInput | number | null
    is_finished?: BoolFieldUpdateOperationsInput | boolean
    is_timeout?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_spaUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_spaUncheckedUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type threads_spaUncheckedUpdateManyWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    thread?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_spaUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_spaUncheckedUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokens_generated_spaUncheckedUpdateManyWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    create_token_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_expired?: BoolFieldUpdateOperationsInput | boolean
    is_error?: BoolFieldUpdateOperationsInput | boolean
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_closed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_spaUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_spaUncheckedUpdateWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trainings_links_spaUncheckedUpdateManyWithoutUsers_spaInput = {
    id?: StringFieldUpdateOperationsInput | string
    training?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}